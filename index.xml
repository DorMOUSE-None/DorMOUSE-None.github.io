<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Utop&#39;s Blog</title>
    <link>https://www.ffutop.com/</link>
    <description>Recent content on Utop&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cmn-Hans-CN</language>
    <lastBuildDate>Sat, 25 Jul 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://www.ffutop.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>URI不规范编码解决方案</title>
      <link>https://www.ffutop.com/posts/2020-07-25-non-standard-uri/</link>
      <pubDate>Sat, 25 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.ffutop.com/posts/2020-07-25-non-standard-uri/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://tools.ietf.org/rfc/rfc7230.txt&#34;&gt;RFC 7230&lt;/a&gt; 与 &lt;a href=&#34;https://tools.ietf.org/rfc/rfc3986.txt&#34;&gt;RFC 3986&lt;/a&gt; 定义了 HTTP/1.1 标准并对 URI 的编解码问题作出了规范。但是，文本形式的规范和最终落地的标准之间总是存在着差距。标准中共 82 个字符无需编码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789:/?#@!$&amp;amp;&#39;()*+,;_-.~
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于需要编码的字符，百分号编码方案要求 ASCII 字符表示成两个 16 进制值并添加前缀 &lt;code&gt;%&lt;/code&gt;；对于非 ASCII 字符, 需要转换为 UTF-8 字节序, 然后每个字节按照上述方式表示成两个 16 进制值并添加前缀 &lt;code&gt;%&lt;/code&gt;。比如 &lt;code&gt;|&lt;/code&gt; 将被表示为 &lt;code&gt;%7C&lt;/code&gt; 或 &lt;code&gt;%7c&lt;/code&gt;（大小写无关）；&lt;code&gt;啊&lt;/code&gt; 将被表示为 &lt;code&gt;%E5%95%8A&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;最近因为 Tomcat 版本升级，遭遇了非标到标准实现的过渡，新版本 Tomcat 严格执行 RFC 规范直接将非标准的 URI 请求强制拒绝。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-plain&#34; data-lang=&#34;plain&#34;&gt;2020-07-15 16:02:12,931  INFO 1 --- [http-nio-8080-exec-7] o.a.c.h.Http11Processor                  : Error parsing HTTP request header
 Note: further occurrences of HTTP request parsing errors will be logged at DEBUG level.
java.lang.IllegalArgumentException: Invalid character found in the request target. The valid characters are defined in RFC 7230 and RFC 3986
        at org.apache.coyote.http11.Http11InputBuffer.parseRequestLine(Http11InputBuffer.java:468) ~[tomcat-embed-core-9.0.22.jar!/:9.0.22]
        at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:294) [tomcat-embed-core-9.0.22.jar!/:9.0.22]
        at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) [tomcat-embed-core-9.0.22.jar!/:9.0.22]
        at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:853) [tomcat-embed-core-9.0.22.jar!/:9.0.22]
        at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1587) [tomcat-embed-core-9.0.22.jar!/:9.0.22]
        at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.22.jar!/:9.0.22]
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [?:1.8.0_161]
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [?:1.8.0_161]
        at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.22.jar!/:9.0.22]
        at java.lang.Thread.run(Thread.java:748) [?:1.8.0_161]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>纠缠不清的 OAuth vs OpenId</title>
      <link>https://www.ffutop.com/posts/2020-07-17-oauth-and-openid/</link>
      <pubDate>Fri, 17 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.ffutop.com/posts/2020-07-17-oauth-and-openid/</guid>
      <description>认证: 完成对用户身份的确认，验证当前自称为某种身份的用户，确实是所声称的用户 授权: 一般指对特定身份的用户授予访问数字化资源的权限 OAuth 2.0 是一个关</description>
    </item>
    
    <item>
      <title>Dubbo Telnet 调试</title>
      <link>https://www.ffutop.com/posts/2020-06-17-dubbo-telnet/</link>
      <pubDate>Wed, 17 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.ffutop.com/posts/2020-06-17-dubbo-telnet/</guid>
      <description>&lt;p&gt;始于 Dubbo 2.0.6 的 Telnet Command 是一个令人兴奋的特性，极大地降低了服务化测试的成本，但是，&lt;a href=&#34;http://dubbo.apache.org/zh-cn/docs/user/references/telnet.html&#34;&gt;寥寥数行的可怜文档&lt;/a&gt;无形地为使用增加了成本。此前虽然一直在使用 Telnet Command，但基本上是浅尝辄止，字符集的问题、重载方法的错误筛选等，都让我不得不对这个特性敬而远之，无法作为高频的生产力工具。最近，频繁出现的调试需求让我不得不尝试接受并熟悉 Dubbo Telnet Command。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;本文只针对 invoke 命令，基于 Dubbo 版本 2.6.7&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Dubbo Telnet Command &lt;code&gt;invoke&lt;/code&gt; 命令的一般格式为 &lt;code&gt;invoke &amp;lt;全限定名&amp;gt;.&amp;lt;方法名&amp;gt;(&amp;lt;参数&amp;gt;,...,&amp;lt;参数&amp;gt;)&lt;/code&gt;。其中参数需要能被 JSON 解析，即提取命令中的 &lt;code&gt;&amp;lt;参数&amp;gt;,...,&amp;lt;参数&amp;gt;&lt;/code&gt; 部分，并包装上 &lt;code&gt;[]&lt;/code&gt; 构成 &lt;code&gt;[&amp;lt;参数&amp;gt;,...,&amp;lt;参数&amp;gt;]&lt;/code&gt; ，需要保证这个串是一个合法的 JSON Array。&lt;/p&gt;
&lt;p&gt;本文提供的示例均可在 &lt;a href=&#34;https://github.com/ffutop/dubbo-telnet-playground&#34;&gt;dubbo-telnet-playground&lt;/a&gt; 中找到。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>URI 与资源定义</title>
      <link>https://www.ffutop.com/posts/2020-05-23-uri/</link>
      <pubDate>Sat, 23 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.ffutop.com/posts/2020-05-23-uri/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;URI syntax:
&lt;code&gt;&amp;lt;scheme&amp;gt;:&amp;lt;scheme-specific-part&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;generic URI syntax:
&lt;code&gt;&amp;lt;scheme&amp;gt;://&amp;lt;authority&amp;gt;&amp;lt;path&amp;gt;?&amp;lt;query&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此前对 URI、URL 的定义一知半解，网上充斥着大量文档试图描述 URI、URL、URN 的区别。其中一种经典的观点是：URI 是 URN、URL 的超集。其中 URN 被用来描述资源的名称(身份ID)，而 URL 被用来描述查找该资源的方法。这个表述确实没有问题，但对于理解 URx 无法提供切实的帮助。最近阅读了 &lt;a href=&#34;https://tools.ietf.org/html/rfc3305&#34;&gt;RFC 3305&lt;/a&gt;、&lt;a href=&#34;https://tools.ietf.org/html/rfc3986&#34;&gt;RFC 3986&lt;/a&gt;、&lt;a href=&#34;https://tools.ietf.org/html/rfc7595&#34;&gt;RFC 7595&lt;/a&gt; 等资料，本文将聊聊个人对 URI 的见解，以及借此回顾此前参与的公司权限系统的设计。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>HTTP Large Header Fields Problem</title>
      <link>https://www.ffutop.com/posts/2020-04-11-large-http-header/</link>
      <pubDate>Sat, 11 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.ffutop.com/posts/2020-04-11-large-http-header/</guid>
      <description>&lt;p&gt;&lt;em&gt;首次遇到请求头过大的问题，做个记录。特别是在本次处理陷入了误区，做了太多无谓的猜测&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;请求头过大导致响应错误码 400 (Bad Request)、414 (URI Too Long)、431 (Request Header Fields Too Large) 的情况不多，不过原因和解决方案都是比较清晰的。客户端请求的请求头过大导致超出了服务器支持的缓冲区。如果客户端可控，控制请求头的大小；否则，适当调大服务器配置的缓冲区大小。&lt;/p&gt;
&lt;p&gt;最近生产上碰到了这个问题，颇费了一番功夫。接手问题时得到了几个错误的信息，干扰到了处理的全过程。甚至为此去重读了 NGINX Directive &lt;code&gt;client_header_buffer_size&lt;/code&gt; 和 &lt;code&gt;large_client_header_buffers&lt;/code&gt; 在 1.8.1 版本的实现。&lt;/p&gt;
&lt;p&gt;最原始的问题是：NGINX 接收到了大请求头(4.5k)的请求，最终响应了错误码 400 Bad Request 。&lt;/p&gt;
&lt;p&gt;真实的背景因素包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请求链路 NGINX -&amp;gt; k8s nginx ingress -&amp;gt; k8s pods (Tomcat)&lt;/li&gt;
&lt;li&gt;NGINX &lt;code&gt;large_client_header_buffers&lt;/code&gt; 使用了默认配置 &lt;code&gt;4 8k&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;Tomcat maxHttpHeaderSize 使用了默认配置 (default 8192)&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Idempotent Pattern</title>
      <link>https://www.ffutop.com/posts/2020-03-26-idempotent/</link>
      <pubDate>Thu, 26 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.ffutop.com/posts/2020-03-26-idempotent/</guid>
      <description>&lt;p&gt;&lt;!-- raw HTML omitted --&gt;“同样是 KV-Server ，为什么基于 Raft Algorithm 的 KV-Server 需要对客户端操作实现幂等，而 Redis 却不需要？” 此前在实现基于 Raft 的容错 Key/Value Service 时，为了能够实现幂等的 &lt;code&gt;Put(key, value)&lt;/code&gt;、&lt;code&gt;Append(key, arg)&lt;/code&gt; 操作，可谓是费尽心思。但同为提供键值服务的 Redis ，怎么从来没见被要求幂等呢？&lt;/p&gt;
&lt;p&gt;基于这个问题，本篇将整理并总结个人的结论。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>基于DNS的数据库切换·事故</title>
      <link>https://www.ffutop.com/posts/2020-02-28-db-transfer-based-on-dns/</link>
      <pubDate>Fri, 28 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.ffutop.com/posts/2020-02-28-db-transfer-based-on-dns/</guid>
      <description>&lt;p&gt;我们生产环境上所有的应用都是通过域名来访问 MySQL、Redis 等基础服务。按说域名相较于 IP，凭空多了个 DNS 解析动作，是一个劣化的方案。但好处在于，一旦需要切换基础服务，将带来巨大的利好。可是，任何忽视DNS Record TTL的切换方案，都将伴随着巨大的风险。甚至，成为否定该利好的佐证。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>分布式共识·Raft Algorithm</title>
      <link>https://www.ffutop.com/posts/2020-02-17-raft/</link>
      <pubDate>Mon, 17 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.ffutop.com/posts/2020-02-17-raft/</guid>
      <description>&lt;h2 id=&#34;分布式系统与共识&#34;&gt;分布式系统与共识&lt;/h2&gt;
&lt;p&gt;分布式系统是一组透过网络相互连接通信与传递信息的计算机，协同来完成一件任务的系统。任务可能是大规模计算，可能是冗余存储。按此分类，又有分布式计算系统和分布式存储系统。&lt;/p&gt;
&lt;p&gt;典型的分布式计算系统/框架有 MapReduce、Spark；分布式存储系统有 GFS 等。虽然有此划分，但分布式计算几乎必然地涉及到存储的需求。存储为计算提供支持，计算促进存储的发展。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img.ffutop.com/3885C079-B4ED-4B0E-AD86-60AB8D4D4792.png&#34; alt=&#34;分布式系统分类&#34;&gt;&lt;/p&gt;
&lt;p&gt;计算是无状态的，存储是有状态的。在分布式的存储下，为了让计算机各自维护的状态协商达成一致，就必然地需要共识算法的支持。Wait a minute. 计算机间的协商需要共识算法？&lt;/p&gt;
&lt;p&gt;计算机间的协作可以划分为中心化与去中心化两大类。中心化的方案自然是有一个权威的 Master 来协调所有的计算机的任务，但前提是这个 Master 必须可靠，即依赖一个单点就必须要对它的可用性进行担保；去中心化的方案，计算机间都是平等的，如何就一个问题达成共识，就是面对的核心问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 id=&#34;共识与一致性&#34;&gt;共识与一致性&lt;/h3&gt;
&lt;p&gt;共识(Consensus)：机器之间就一个值/命令等达成共同的认识，一般是面向输入，处理并维护这个值（状态）&lt;/p&gt;
&lt;p&gt;一致性(Consistency)：一致性表述为机器对外提供服务时的表现。向机器 A 或机器 B 读取同一数据，两者的返回值是相同的。当然，也有不同的弱化版本，允许一些特定条件下的不一致&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 2014 年之前，Paxos [1] 几乎是解决共识问题的唯一选择。但难懂是一个致命的问题，并且难以工程化也是重大的缺陷。Raft 的出现无疑是一道曙光，熟读，实践，豁然开朗。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Goroutine 与调度</title>
      <link>https://www.ffutop.com/posts/2020-01-27-go-routine/</link>
      <pubDate>Mon, 27 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.ffutop.com/posts/2020-01-27-go-routine/</guid>
      <description>&lt;p&gt;虽然我们在日常沟通中把 Goroutine 和线程、协程之类的执行流概念混杂着沟通，但 Go 语言一直坚持 &amp;ldquo;Goroutine&amp;rdquo;。 宣称这一名词的产生是由于线程、协程、进程等无法准确表达其概念。本篇将就这一声明进行探究，Goroutine 与线程、协程究竟有何不同。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Calico 网络通信解析</title>
      <link>https://www.ffutop.com/posts/2019-12-24-how-calico-works/</link>
      <pubDate>Tue, 24 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.ffutop.com/posts/2019-12-24-how-calico-works/</guid>
      <description>&lt;p&gt;在 Kubernetes 集群中，Calico 区别于 Flannel 的最显著特征，就是其宣称可以不借助隧道技术，是建立在纯三层协议上的解决方案。也就是说，Calico 通过建立一些路由信息，就构建了单节点/多节点网络命名空间隔离下的通信网络。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>