<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Utop&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://DorMOUSE-None.github.io/"/>
  <updated>2019-07-08T00:32:50.668Z</updated>
  <id>https://DorMOUSE-None.github.io/</id>
  
  <author>
    <name>Utop</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JNI 引发的堆外内存泄露</title>
    <link href="https://DorMOUSE-None.github.io/2019-07-06-JNI_PROBLEM/"/>
    <id>https://DorMOUSE-None.github.io/2019-07-06-JNI_PROBLEM/</id>
    <published>2019-07-05T16:00:00.000Z</published>
    <updated>2019-07-08T00:32:50.668Z</updated>
    
    <content type="html"><![CDATA[<p>本以为写写异构代码也不算一件难事。毕竟做 Java 开发，日常也写些 C 代码，无论如何也不至于到棘手到地步。哪曾想，JNI 开发不难，但问题颇多。</p><p>为了排查一个 JNI 的堆外内存泄露问题，简直是绞尽脑汁而不得其门。最后查找的问题原因也特别简单，但凡认真学习了 JNI 开发都能够避免。</p><p>问题代码类似于下列代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Main.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_Main_sayHi</span> <span class="params">(JNIEnv *env, jobject jobj, jstring jstr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *str = (*env)-&gt;GetStringUTFChars(env, jstr, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> len = (*env)-&gt;GetStringUTFLength(env, jstr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... some code omitted </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="问题表现"><a href="#问题表现" class="headerlink" title="问题表现"></a>问题表现</h2><p>最初的表现很明显，2核4G的机器，2GB的 Java 堆，最终物理内存不够用，导致 Java 进程被强制杀掉。几乎毫无疑问，就是 Java 堆外内存引发的问题。不过遗憾的是，物理内存不够用，没有留下足够多的堆栈详情。另外找了一台快要把内存打满的机器，打印信息。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ pmap -x 27765 | sort -n -k3 | tail -n 50</span><br><span class="line">00007f460c9ac000   55632   23896   23896 rw---   [ anon ]</span><br><span class="line">00007f45d0000000   38980   38980   38980 rw---   [ anon ]</span><br><span class="line">00007f45dc000000   45980   39512   39512 rw---   [ anon ]</span><br><span class="line">00007f45e0000000   46120   39652   39652 rw---   [ anon ]</span><br><span class="line">00007f45d4000000   42160   41744   41744 rw---   [ anon ]</span><br><span class="line">00007f45c8000000   45992   45992   45992 rw---   [ anon ]</span><br><span class="line">00007f4610000000   48896   48872   48872 rwx--   [ anon ]</span><br><span class="line">00007f45f8000000   51084   51084   51084 rw---   [ anon ]</span><br><span class="line">00007f4600000000   52328   52328   52328 rw---   [ anon ]</span><br><span class="line">00007f4608000000   58332   55452   55452 rw---   [ anon ]</span><br><span class="line">00000000014f8000   57036   56908   56908 rw---   [ anon ]</span><br><span class="line">00007f45d8000000   63760   57292   57292 rw---   [ anon ]</span><br><span class="line">00007f45e8000000   58488   58488   58488 rw---   [ anon ]</span><br><span class="line">00007f4604000000   59912   59912   59912 rw---   [ anon ]</span><br><span class="line">00007f45fc000000   60080   60080   60080 rw---   [ anon ]</span><br><span class="line">00007f45e4000000   64460   64452   64452 rw---   [ anon ]</span><br><span class="line">00007f45f4000000   65072   65072   65072 rw---   [ anon ]</span><br><span class="line">00007f4620000000   65536   65536   65536 rw---   [ anon ]</span><br><span class="line">0000000080000000 2105600 2008240 2008240 rw---   [ anon ]   <span class="comment"># 2GB 的 Java 堆</span></span><br><span class="line">total kB         4885820 3040036 3030476</span><br></pre></td></tr></table></figure><p>比较多的内存块都在 64M 左右大小。确实也很明显，就是申请的内存没有得到释放。</p><h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><p>C 不似 Java，没有 Garbage Collection 。所有申请的内存都必须主动进行释放。唯一的问题就是 <code>GetStringUTFChars</code> 得到的内存是否会被 JVM 统一管理。</p><p>结果当然是不会，虽然是 Java 与 C 衔接的胶水代码，但这部分得到的内存需要自行管理。不过，JNI 也提供了函数来进行释放。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* from src/share/vm/prims/jni.cpp */</span></span><br><span class="line">JNI_ENTRY(<span class="keyword">const</span> <span class="keyword">char</span>*, jni_GetStringUTFChars(JNIEnv *env, jstring <span class="built_in">string</span>, jboolean *isCopy))</span><br><span class="line">  JNIWrapper(<span class="string">"GetStringUTFChars"</span>);</span><br><span class="line">  <span class="keyword">char</span>* result = <span class="literal">NULL</span>;</span><br><span class="line">  oop java_string = JNIHandles::resolve_non_null(<span class="built_in">string</span>);</span><br><span class="line">  <span class="keyword">if</span> (java_lang_String::value(java_string) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> length = java_lang_String::utf8_length(java_string);</span><br><span class="line">    <span class="comment">/* 申请堆内存 */</span></span><br><span class="line">    result = AllocateHeap(length + <span class="number">1</span>, mtInternal, <span class="number">0</span>, AllocFailStrategy::RETURN_NULL);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      java_lang_String::as_utf8_string(java_string, result, (<span class="keyword">int</span>) length + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (isCopy != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *isCopy = JNI_TRUE;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">JNI_END</span><br><span class="line"></span><br><span class="line"><span class="comment">/* from src/share/vm/memory/allocation.inline.hpp */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span>* <span class="title">AllocateHeap</span><span class="params">(<span class="keyword">size_t</span> size, MEMFLAGS flags,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> NativeCallStack&amp; <span class="built_in">stack</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 申请内存</span></span><br><span class="line">    <span class="keyword">char</span>* p = (<span class="keyword">char</span>*) os::<span class="built_in">malloc</span>(size, flags, <span class="built_in">stack</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></span><br><span class="line">    <span class="keyword">if</span> (PrintMallocFree) trace_heap_malloc(size, <span class="string">"AllocateHeap"</span>, p);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> &amp;&amp; alloc_failmode == AllocFailStrategy::EXIT_OOM) &#123;</span><br><span class="line">        vm_exit_out_of_memory(size, OOM_MALLOC_ERROR, <span class="string">"AllocateHeap"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* from src/share/vm/prims/jni.cpp */</span></span><br><span class="line">JNI_LEAF(<span class="keyword">void</span>, jni_ReleaseStringUTFChars(JNIEnv *env, jstring str, <span class="keyword">const</span> <span class="keyword">char</span> *chars))</span><br><span class="line">  JNIWrapper(<span class="string">"ReleaseStringUTFChars"</span>);</span><br><span class="line">  <span class="keyword">if</span> (chars != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    FreeHeap((<span class="keyword">char</span>*) chars);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line">JNI_END</span><br><span class="line"></span><br><span class="line"><span class="comment">/* from src/share/vm/memory/allocation.inline.hpp */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FreeHeap</span><span class="params">(<span class="keyword">void</span>* p, MEMFLAGS memflags = mtInternal)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></span><br><span class="line">    <span class="keyword">if</span> (PrintMallocFree) trace_heap_free(p);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    os::<span class="built_in">free</span>(p, memflags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从名称就可以看出来，<code>GetStringUTFChars</code> 和 <code>ReleaseStringUTFChars</code> 是相对的方法。而且默认走的都是 Glibc 的 <code>malloc</code> 和 <code>free</code> 。 </p><h2 id="问题验证"><a href="#问题验证" class="headerlink" title="问题验证"></a>问题验证</h2><p>为了验证问题的原因和最终的现象，整了一段代码来测试效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.load(<span class="string">"/root/jni/Main.so"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String value = <span class="string">"AAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHH"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">(String value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Main main = <span class="keyword">new</span> Main();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++) &#123;</span><br><span class="line">                <span class="keyword">char</span> c1 = (<span class="keyword">char</span>) (<span class="string">'A'</span> + Math.random() * <span class="number">26</span>);</span><br><span class="line">                <span class="keyword">char</span> c2 = (<span class="keyword">char</span>) (<span class="string">'a'</span> + Math.random() * <span class="number">26</span>);</span><br><span class="line">                main.sayHi(value + c1 + c2);</span><br><span class="line">            &#125;</span><br><span class="line">            System.gc();</span><br><span class="line">            <span class="keyword">int</span> val = System.in.read();</span><br><span class="line">            <span class="keyword">if</span> (val == <span class="string">'1'</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Main.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_Main_sayHi</span> <span class="params">(JNIEnv *env, jobject jobj, jstring jstr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *str = (*env)-&gt;GetStringUTFChars(env, jstr, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> len = (*env)-&gt;GetStringUTFLength(env, jstr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, str);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SUCCESS</span></span><br><span class="line">    (*env)-&gt;ReleaseStringUTFChars(env, jstr, str);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/DorMOUSE-None/Repo/master/jni-memory-leak.zip" target="_blank" rel="noopener">测试用的源代码</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ java Main</span><br><span class="line">$ pmap -x 22690 | sort -n -k3</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line">00007f0d44000000   65536   65500   65500 rw---   [ anon ]</span><br><span class="line">00007f0d04000000  131072  131068  131068 rw---   [ anon ]</span><br><span class="line">00007f0cc4000000  131072  131072  131072 rw---   [ anon ]</span><br><span class="line">00007f0ccc000000  131072  131072  131072 rw---   [ anon ]</span><br><span class="line">00007f0cd4000000  131072  131072  131072 rw---   [ anon ]</span><br><span class="line">00007f0cdc000000  131072  131072  131072 rw---   [ anon ]</span><br><span class="line">00007f0ce4000000  131072  131072  131072 rw---   [ anon ]</span><br><span class="line">00007f0cec000000  131072  131072  131072 rw---   [ anon ]</span><br><span class="line">00007f0cf4000000  131072  131072  131072 rw---   [ anon ]</span><br><span class="line">00007f0cfc000000  131072  131072  131072 rw---   [ anon ]</span><br><span class="line">total kB         3822700 1293952 1276900</span><br></pre></td></tr></table></figure><p>确实引起了内存的增长，而将内存 dump 下了之后，也看到了大量字符串。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ PID=23756; grep rw-p /proc/<span class="variable">$&#123;PID&#125;</span>/maps | sed -n <span class="string">'s/^\([0-9a-f]*\)-\([0-9a-f]*\) .*$/\1 \2/p'</span> | <span class="keyword">while</span> <span class="built_in">read</span> start stop;  \</span><br><span class="line"><span class="keyword">do</span> \</span><br><span class="line">    gdb --batch --pid <span class="variable">$&#123;PID&#125;</span> -ex <span class="string">"dump memory <span class="variable">$&#123;PID&#125;</span>-<span class="variable">$start</span>-<span class="variable">$stop</span>.dump 0x<span class="variable">$start</span> 0x<span class="variable">$stop</span>"</span>;  \</span><br><span class="line"><span class="keyword">done</span> </span><br><span class="line">$ strings 23756-7f6f6c000000-7f6f70000000.dump| grep <span class="string">'AAAA'</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line">AAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHVn</span><br><span class="line">AAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHXp</span><br><span class="line">AAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHFn</span><br></pre></td></tr></table></figure><p>待到添加上 <code>ReleaseStringUTFChars</code> ，申请到内存得到释放，确实解决了这个问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>定位问题确实看起来不难，但这种异构代码，真正难点在于定位问题。这期间走了不少的弯路，也无法确定究竟是对是错。毕竟问题的原因多种多样：</p><ol><li>可能是 Java 代码用了诸如 Zip 等容易出现堆外内存泄露的方法</li><li>不当使用 JNI （就像是上文描述的问题）</li><li>再有就是第三方 C 库使用不当，或者其本身存在 BUG。</li></ol><p>这是第一次排查异构代码的问题，颇多难以分辨，无法做定论之事。</p><p>再就是 C 的平台相关性实在是太过于严重了，加之本就不太熟悉，搞个编译新的库文件就好一番折腾。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本以为写写异构代码也不算一件难事。毕竟做 Java 开发，日常也写些 C 代码，无论如何也不至于到棘手到地步。哪曾想，JNI 开发不难，但问题颇多。&lt;/p&gt;
&lt;p&gt;为了排查一个 JNI 的堆外内存泄露问题，简直是绞尽脑汁而不得其门。最后查找的问题原因也特别简单，但凡认真学习了 JNI 开发都能够避免。&lt;/p&gt;
&lt;p&gt;问题代码类似于下列代码：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&quot;Main.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;JNIEXPORT &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; JNICALL &lt;span class=&quot;title&quot;&gt;Java_Main_sayHi&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(JNIEnv *env, jobject jobj, jstring jstr)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *str = (*env)-&amp;gt;GetStringUTFChars(env, jstr, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; len = (*env)-&amp;gt;GetStringUTFLength(env, jstr);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ... some code omitted &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="JNI" scheme="https://DorMOUSE-None.github.io/tags/JNI/"/>
    
      <category term="memory leak" scheme="https://DorMOUSE-None.github.io/tags/memory-leak/"/>
    
  </entry>
  
  <entry>
    <title>理解 Linux Kernel (12) - Linux 容器化技术</title>
    <link href="https://DorMOUSE-None.github.io/2019-06-18-understand-Kernel-12/"/>
    <id>https://DorMOUSE-None.github.io/2019-06-18-understand-Kernel-12/</id>
    <published>2019-06-17T16:00:00.000Z</published>
    <updated>2019-06-18T01:52:51.327Z</updated>
    
    <content type="html"><![CDATA[<p>由于工作上的一些调整，目前开始接触容器化技术了。容器化技术相对于虚拟机的最大区别，在于其只是在操作系统上做了资源隔离和控制，而虚拟机则会基于原有的操作系统，模拟一整套硬件设备接口，运行一个新的操作系统及相关的 Lib 库。</p><p><img src="http://img.ffutop.com/9FD2522D-BBEB-443A-8267-26F1EC77BA87.png" alt="Containerd VS VM"></p><p><small><center>Copied From docker.com</center></small></p><p>如何实现容器化，显然需要从操作系统层面进行支撑。这其中涉及到的核心技术，就包括命名空间(namespace)和控制组(Control Group, cgroup)，前者用来对资源进行隔离，后者用来对资源加以限制。</p><blockquote><p>本文所有涉及的内核代码基于版本 3.10.1 ；所有命令执行结果基于 Ubuntu 18.04 </p></blockquote><a id="more"></a><h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><p>命名空间用来对资源进行隔离，每类资源都有一种命名空间，比如 <code>ipc_namespace</code> 用来对 IPC 资源进行隔离，<code>pid_namespace</code> 用来对可见的进程id进行隔离。</p><p>首先确定一下命名空间与任务之间的关系。用户与操作系统的任何交互，都是基于任务开始的，内核也是基于任务进行的调度。（关于“任务”与“进程、线程”之间的关系，详见<a href="https://www.ffutop.com/2019-04-10-understand-Kernel-10/" target="_blank" rel="noopener">Context of Execution</a>。下文不区分”进程、线程”，统一使用内核概念——任务）</p><p>每个任务都维护一个该任务所属的命名空间集合（其中包括该任务所属的 UTS 命名空间，IPC 命名空间等）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> &#123;</span></span><br><span class="line">    <span class="keyword">atomic_t</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uts_namespace</span> *<span class="title">uts_ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ipc_ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> *<span class="title">mnt_ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> *<span class="title">pid_ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net</span>      *<span class="title">net_ns</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// ... something omitted </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> <span class="title">nsproxy</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想要查看现有的一些任务所属的命名空间，可以使用命令 <code>ls -l /proc/[PID]/ns</code> 。如果两个任务的某类命名空间 inode 编号一致，则说明两任务处于同一命名空间之下。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ls -l /proc/20/ns</span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 15 08:38 ipc -&gt; <span class="string">'ipc:[4026531839]'</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 15 08:38 mnt -&gt; <span class="string">'mnt:[4026531840]'</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 15 08:38 net -&gt; <span class="string">'net:[4026531993]'</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 15 08:38 pid -&gt; <span class="string">'pid:[4026531836]'</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 Jun 15 08:38 uts -&gt; <span class="string">'uts:[4026531838]'</span></span><br></pre></td></tr></table></figure><h3 id="建立新的命名空间"><a href="#建立新的命名空间" class="headerlink" title="建立新的命名空间"></a>建立新的命名空间</h3><p>最常见的创建新命名空间的方式是：在 clone 新任务的同时，携带诸如 <code>CLONE_NEWNS</code>, <code>CLONE_NEWPID</code> 之类的标志，系统调用 <code>clone</code> 将根据这些标志将新的任务 <code>task</code> 与新的命名空间进行关联。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct task_struct *<span class="title">copy_process</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ... something omitted</span></span><br><span class="line">    retval = copy_namespaces(clone_flags, p)</span><br><span class="line">    <span class="comment">// ... something omitted </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> copy_namespaces(<span class="keyword">unsigned</span> <span class="keyword">long</span> flags, struct task_struct *tsk)</span><br><span class="line">&#123;</span><br><span class="line">    struct nsproxy *old_ns = tsk-&gt;nsproxy;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span> = <span class="title">task_cred_xxx</span>(<span class="title">tsk</span>, <span class="title">user_ns</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> *<span class="title">new_ns</span>;</span></span><br><span class="line">    <span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!old_ns)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为 old_ns 添加一个引用计数</span></span><br><span class="line">    get_nsproxy(old_ns);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不存在创建新的 CLONE_NEWxx 标志，意味着不需要创建新的命名空间</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC |</span><br><span class="line">                CLONE_NEWPID | CLONE_NEWNET)))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有 CAP_SYS_ADMIN 允许创建新的命名空间</span></span><br><span class="line">    <span class="keyword">if</span> (!ns_capable(user_ns, CAP_SYS_ADMIN)) &#123;</span><br><span class="line">        err = -EPERM;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CLONE_NEWIPC 与 CLONE_SYSVSEM 是互斥的标志位，需要保证不同时出现</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; CLONE_NEWIPC) &amp;&amp; (flags &amp; CLONE_SYSVSEM)) &#123;</span><br><span class="line">        err = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新的命名空间</span></span><br><span class="line">    new_ns = create_new_namespaces(flags, tsk, user_ns, tsk-&gt;fs);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(new_ns)) &#123;</span><br><span class="line">        err = PTR_ERR(new_ns);</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新的命名空间绑定到新的任务上</span></span><br><span class="line">    tsk-&gt;nsproxy = new_ns;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    put_nsproxy(old_ns);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct nsproxy *<span class="title">create_new_namespaces</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">    struct task_struct *tsk, struct user_namespace *user_ns,</span></span></span><br><span class="line"><span class="function"><span class="params">    struct fs_struct *new_fs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> *<span class="title">new_nsp</span>;</span></span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为新的 nsproxy 数据结构申请内存</span></span><br><span class="line">    new_nsp = create_nsproxy();</span><br><span class="line">    <span class="keyword">if</span> (!new_nsp)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 对每类命名空间，逐一执行拷贝的动作。</span></span><br><span class="line"><span class="comment">     * 当然，如果 flags 未配置 CLONE_NEWxx，该命名空间直接引用老的命名空间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    new_nsp-&gt;mnt_ns = copy_mnt_ns(flags, tsk-&gt;nsproxy-&gt;mnt_ns, user_ns, new_fs);</span><br><span class="line">    <span class="comment">// something omitted ...</span></span><br><span class="line"></span><br><span class="line">    new_nsp-&gt;uts_ns = copy_utsname(flags, user_ns, tsk-&gt;nsproxy-&gt;uts_ns);</span><br><span class="line">    <span class="comment">// something omitted ...</span></span><br><span class="line"></span><br><span class="line">    new_nsp-&gt;ipc_ns = copy_ipcs(flags, user_ns, tsk-&gt;nsproxy-&gt;ipc_ns);</span><br><span class="line">    <span class="comment">// something omitted ...</span></span><br><span class="line"></span><br><span class="line">    new_nsp-&gt;pid_ns = copy_pid_ns(flags, user_ns, tsk-&gt;nsproxy-&gt;pid_ns);</span><br><span class="line">    <span class="comment">// something omitted ...</span></span><br><span class="line"></span><br><span class="line">    new_nsp-&gt;net_ns = copy_net_ns(flags, user_ns, tsk-&gt;nsproxy-&gt;net_ns);</span><br><span class="line">    <span class="comment">// something omitted ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_nsp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mnt_namespace</code> 在对应的标志位为 <code>CLONE_NEWNS</code>，这是个历史遗留问题，早期认为只有文件系统需要命名空间，所以直接把 <code>NS</code> 赋予了 <code>mnt_namespace</code> 作为标志。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct mnt_namespace *<span class="title">copy_mnt_ns</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> flags, struct mnt_namespace *ns,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct user_namespace *user_ns, struct fs_struct *new_fs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> *<span class="title">new_ns</span>;</span></span><br><span class="line"></span><br><span class="line">    BUG_ON(!ns);</span><br><span class="line">    <span class="comment">// 为 ns 添加一个引用计数</span></span><br><span class="line">    get_mnt_ns(ns);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 CLONE_NEWNS 没有置位，直接返回老的 mnt 命名空间</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; CLONE_NEWNS))</span><br><span class="line">        <span class="keyword">return</span> ns;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按原来的 ns 拷贝一份新的 mnt_namespace</span></span><br><span class="line">    new_ns = dup_mnt_ns(ns, user_ns, new_fs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放对 ns 的引用</span></span><br><span class="line">    put_mnt_ns(ns);</span><br><span class="line">    <span class="keyword">return</span> new_ns;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.ffutop.com/B5647B7D-4928-448F-88CA-D07A4039107A.png" alt=""></p><p>其它命名空间的操作类似，都是依据相关的 clone flag 决定是拷贝一份新的命名空间，或者是继续使用老的命名空间。而通过拷贝新的命名空间，相关的资源维护也就变得独立于原有的命名空间，从而达到资源隔离的目的。</p><p>完成命名空间的拷贝之后，之后的操作显得相当平凡，不管是用原来的命名空间，还是新的命名空间，总之都已经绑定到 <code>struct task_struct-&gt;nsproxy</code> 上，只需要普通的使用就可以了。</p><h3 id="使用命名空间"><a href="#使用命名空间" class="headerlink" title="使用命名空间"></a>使用命名空间</h3><p>以 PID 命名空间为例，现在需要为新的任务分配一个新的任务id，调用链开始于 <code>clone -&gt; do_fork -&gt; copy_process -&gt; alloc_pid</code>。</p><p><img src="http://img.ffutop.com/748138AC-65B2-489B-86F2-94FFD7A64592.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct task_struct *<span class="title">copy_process</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ... something omitted</span></span><br><span class="line"></span><br><span class="line">    retval = copy_namespaces(clone_flags, p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... something omitted </span></span><br><span class="line"></span><br><span class="line">    pid = alloc_pid(p-&gt;nsproxy-&gt;pid_ns);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... something omitted </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct pid *<span class="title">alloc_pid</span><span class="params">(struct pid_namespace *ns)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pid</span>;</span></span><br><span class="line">    <span class="keyword">enum</span> pid_type type;</span><br><span class="line">    <span class="keyword">int</span> i, nr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> *<span class="title">tmp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">upid</span> *<span class="title">upid</span>;</span></span><br><span class="line"></span><br><span class="line">    pid = kmem_cache_alloc(ns-&gt;pid_cachep, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!pid)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    tmp = ns;</span><br><span class="line">    pid-&gt;level = ns-&gt;level;</span><br><span class="line">    <span class="comment">// PID 需要在每层PID命名空间获得一个唯一的 number (known as upid.nr)</span></span><br><span class="line">    <span class="keyword">for</span> (i = ns-&gt;level; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 从 pidmap 中取出一个可用的 id</span></span><br><span class="line"><span class="comment">         * 这里的 pidmap 是个位图，主要是为了提高效率而使用。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        nr = alloc_pidmap(tmp);</span><br><span class="line">        <span class="keyword">if</span> (nr &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> out_free;</span><br><span class="line"></span><br><span class="line">        pid-&gt;numbers[i].nr = nr;</span><br><span class="line">        pid-&gt;numbers[i].ns = tmp;</span><br><span class="line">        tmp = tmp-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(is_child_reaper(pid))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pid_ns_prepare_proc(ns))</span><br><span class="line">            <span class="keyword">goto</span> out_free;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    get_pid_ns(ns);</span><br><span class="line">    atomic_set(&amp;pid-&gt;count, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (type = <span class="number">0</span>; type &lt; PIDTYPE_MAX; ++type)</span><br><span class="line">        INIT_HLIST_HEAD(&amp;pid-&gt;tasks[type]);</span><br><span class="line"></span><br><span class="line">    upid = pid-&gt;numbers + ns-&gt;level;</span><br><span class="line">    spin_lock_irq(&amp;pidmap_lock);</span><br><span class="line">    <span class="keyword">if</span> (!(ns-&gt;nr_hashed &amp; PIDNS_HASH_ADDING))</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    <span class="keyword">for</span> ( ; upid &gt;= pid-&gt;numbers; --upid) &#123;</span><br><span class="line">        hlist_add_head_rcu(&amp;upid-&gt;pid_chain,</span><br><span class="line">            &amp;pid_hash[pid_hashfn(upid-&gt;nr, upid-&gt;ns)]);</span><br><span class="line">        upid-&gt;ns-&gt;nr_hashed++;</span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock_irq(&amp;pidmap_lock);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">    spin_unlock_irq(&amp;pidmap_lock);</span><br><span class="line">out_free:</span><br><span class="line">    <span class="keyword">while</span> (++i &lt;= ns-&gt;level)</span><br><span class="line">        free_pidmap(pid-&gt;numbers + i);</span><br><span class="line"></span><br><span class="line">    kmem_cache_free(ns-&gt;pid_cachep, pid);</span><br><span class="line">    pid = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，并不是所有的命名空间都建立起了父子节点的层级关联。此处只是以 PID 作为一个简单的示例。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* fns.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> errExit(msg)    do &#123; perror(msg); exit(EXIT_FAILURE); &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">childFunc</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    execv(<span class="string">"/bin/bash"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE (1024 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *<span class="built_in">stack</span>;</span><br><span class="line">    <span class="keyword">char</span> *stackTop;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为子任务申请栈内存 */</span></span><br><span class="line">    <span class="built_in">stack</span> = <span class="built_in">malloc</span>(STACK_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span>)</span><br><span class="line">        errExit(<span class="string">"malloc"</span>);</span><br><span class="line">    stackTop = <span class="built_in">stack</span> + STACK_SIZE;</span><br><span class="line"></span><br><span class="line">    pid = clone(childFunc, stackTop, CLONE_NEWUTS | CLONE_NEWNS | CLONE_NEWPID | CLONE_NEWIPC | SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">"clone"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"clone() returned %ld\n"</span>, (<span class="keyword">long</span>) pid);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">"waitpid"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child has terminated\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译命令 <code>gcc -o fns fns.c -w</code></p><p>执行指令 <code>./fns</code> 将进入一个新的 bash，此时的 UTS、VFS、PID、IPC 命名空间都是全新的。所有基于这些命名空间而存在的概念将不会对 root 命名空间产生影响。</p><h2 id="Control-Group"><a href="#Control-Group" class="headerlink" title="Control Group"></a>Control Group</h2><p>对命名空间有了初步的概念之后，再看看 Control Group —— 用来限制任务能够使用的资源上限，当然，还可以调整进程优先级、进行资源统计、实现进程控制等。</p><p>cgroup 主要存在四大概念：</p><ol><li><p><strong>task</strong>，任务调度的基本单位，用户认知的进程/线程(<a href="https://www.ffutop.com/2019-04-10-understand-Kernel-10/" target="_blank" rel="noopener">详见 执行的上下文</a>)</p></li><li><p><strong>subsystem</strong>，子系统，Control Group 可以进行资源控制，每类可进行控制的资源作为一种子系统而存在。</p></li><li><p><strong>cgroup</strong>，控制组，在划分后在各个子系统下，分别都有控制组来对现有的任务(task)进行划分，每个任务在单个子系统中只能从属于一个控制组，每个任务可以从属于多个不同的子系统。</p></li><li><p><strong>hierarchy</strong>，层级树，每个子系统下，会有多个不同的控制组，它们共同维护起来树形的结构。在没有特别配置的情况下，每个子控制组将继承父控制组的限制。</p></li></ol><p><img src="http://img.ffutop.com/3527AE73-94CD-4F49-8ECD-2EB7163A545D.png" alt=""></p><h3 id="Cgroup-组织结构"><a href="#Cgroup-组织结构" class="headerlink" title="Cgroup 组织结构"></a>Cgroup 组织结构</h3><p><img src="http://img.ffutop.com/6344FE65-3A6D-42DF-9A42-046D38EA3F69.png" alt=""></p><p>一个任务从属于一个控制组集合中(例如属于<code>cpu</code>子系统控制组-1，<code>mem</code>子系统控制组-3…)。将不同子系统控制组整合起来的数据结构就是 <code>css_set</code>(cgroup subsys state set)。一个控制组集合可以维护多个任务(通过列表的形式链接)。</p><p><img src="http://img.ffutop.com/7C9A5B57-8A2A-47DF-B7CA-EA9BEAAFCF86.png" alt=""></p><p><code>css_set</code> 控制组集合中维护了一个 css 列表，每个 <code>cgroup_subsys_state</code> 执行一个 <code>cgroup</code> 结构（包含某一子系统控制组的所有信息）。通过这样的方式，任务就和一系列的子系统控制组联系起来了。</p><p><img src="http://img.ffutop.com/B454475C-D06A-4B48-B273-66AB96091CE9.png" alt=""></p><p>反向的，通过 cgroup 结构查找所有处于其控制下的任务。这里的 <code>cgroup</code> 与 <code>css_set</code> 是一个多对多的关系。一个 <code>css_set</code> 整合了多个 <code>cgroup</code> ，一个 <code>cgroup</code> 可以被多个 <code>css_set</code> 利用。<code>cg_cgroup_link</code> 就是一个处于中间的关联结构。（多对多的关系可以参考数据库建表，两个实体表 A, B 间需要通过第三张表 C 来描述 (A-id, B-id) 的关系）。</p><p><img src="http://img.ffutop.com/F97AEA47-8FBF-4D0D-A16F-D421816CF889.png" alt=""></p><p>最后来看看 <code>cgroup_subsys_state</code> 结构，各个子系统结构的第一个参数都是 <code>cgroup_subsys_state_css</code>，通过内核的 <code>container_of</code> 函数，<code>subsys[]</code> 的每个元素都可以分别被认知为 <code>cpuset</code> , <code>mem_cgroup</code> 等。</p><p>这里还能看到一个现象，<code>css_set</code> 和 <code>cgroup</code> 都维护了 <code>cgroup_subsys_state</code> 的数组，这是为了加速访问而实现的。<code>cgroup</code> 作为调整参数的控制结构，通过实现 VFS 的接口对用户暴露读写等操作。而作为 Cgroup 的被控制对象的 <code>task</code> 也需要频繁地对其所受的资源限制进行检查。由于 <code>task</code> 没有与 <code>cgroup</code> 作直接关联，是一种多对多的关系，因此额外维护了一份 <code>subsys[]</code> ，来加速频繁的读操作。</p><h3 id="Cgroup-实现资源控制的方式"><a href="#Cgroup-实现资源控制的方式" class="headerlink" title="Cgroup 实现资源控制的方式"></a>Cgroup 实现资源控制的方式</h3><p>Cgroup 归根结底是需要实现对任务的资源控制。</p><p>首先是新任务如何与 Cgroup 挂钩。</p><ol><li>在系统启动阶段，<code>init/main.c</code> 中的代码初始化了 root cgroup ，并初始化第一个 <code>css_set</code> 挂载到创始任务上</li><li>此后，所有任务的产生和终结，将调用 <code>cgroup_fork</code> 和 <code>cgroup_exit</code> 实现任务与 <code>css_set</code> 的互操作；</li><li>在任务运行过程中，将任务从子系统的一个 cgroup 移动到另一个 cgroup，将使用 <code>attach</code> 和 <code>detach</code> 进行操作。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct task_struct *<span class="title">copy_process</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_start,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_size,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> __user *child_tidptr,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct pid *pid,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> trace)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// something omitted ...</span></span><br><span class="line">    cgroup_fork(p);</span><br><span class="line">    <span class="comment">// something omitted ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cgroup_fork</span><span class="params">(struct task_struct *child)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    task_lock(current);</span><br><span class="line">    <span class="comment">// 直接引用当前任务（即父任务）的 cgroups 指针</span></span><br><span class="line">    <span class="comment">// 这里的 cgroups 变量类型是 *css_set </span></span><br><span class="line">    child-&gt;cgroups = current-&gt;cgroups;</span><br><span class="line">    <span class="comment">// 添加一个引用计数</span></span><br><span class="line">    get_css_set(child-&gt;cgroups);</span><br><span class="line">    task_unlock(current);</span><br><span class="line">    INIT_LIST_HEAD(&amp;child-&gt;cg_list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="演示：限制-CPU-密集型任务的-CPU-资源使用量"><a href="#演示：限制-CPU-密集型任务的-CPU-资源使用量" class="headerlink" title="演示：限制 CPU 密集型任务的 CPU 资源使用量"></a>演示：限制 CPU 密集型任务的 CPU 资源使用量</h3><p>演示程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* calc.c */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">0</span>;<span class="number">1</span>;i++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后后台执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="comment"># 编译</span></span><br><span class="line">$ cc calc.c -o calc</span><br><span class="line">$ <span class="comment"># 后台执行 </span></span><br><span class="line">$ ./calc &amp;</span><br><span class="line">[1] 25828</span><br><span class="line">$ <span class="comment"># 观察 CPU 使用量</span></span><br><span class="line">$ top</span><br></pre></td></tr></table></figure><p>任务 <code>calc</code> 的 CPU 使用率基本上达到了 100% 左右。现在要将它限制到 50% 。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="comment"># 找到 cgroup 虚拟文件系统的挂载路径</span></span><br><span class="line">$ mount | grep cgroup</span><br><span class="line">tmpfs on /sys/fs/cgroup <span class="built_in">type</span> tmpfs (ro,nosuid,nodev,noexec,mode=755)</span><br><span class="line">cgroup on /sys/fs/cgroup/unified <span class="built_in">type</span> cgroup2 (rw,nosuid,nodev,noexec,relatime)</span><br><span class="line">cgroup on /sys/fs/cgroup/systemd <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name=systemd)</span><br><span class="line">cgroup on /sys/fs/cgroup/cpu,cpuacct <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,cpu,cpuacct)</span><br><span class="line">cgroup on /sys/fs/cgroup/memory <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,memory)</span><br><span class="line">cgroup on /sys/fs/cgroup/blkio <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,blkio)</span><br><span class="line">cgroup on /sys/fs/cgroup/hugetlb <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb)</span><br><span class="line">cgroup on /sys/fs/cgroup/cpuset <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)</span><br><span class="line">cgroup on /sys/fs/cgroup/pids <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,pids)</span><br><span class="line">cgroup on /sys/fs/cgroup/devices <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,devices)</span><br><span class="line">cgroup on /sys/fs/cgroup/net_cls,net_prio <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,net_cls,net_prio)</span><br><span class="line">cgroup on /sys/fs/cgroup/rdma <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,rdma)</span><br><span class="line">cgroup on /sys/fs/cgroup/freezer <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,freezer)</span><br><span class="line">cgroup on /sys/fs/cgroup/perf_event <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,perf_event)</span><br><span class="line"></span><br><span class="line">$ <span class="comment"># 在 /sys/fs/cgroup/cpu,cpuacct/ 目录挂载的就是 cgroup cpu 子系统和 cpuacct 子系统</span></span><br><span class="line">$ <span class="built_in">cd</span> /sys/fs/cgroup/cpu,cpuacct/</span><br><span class="line">$ <span class="comment"># 创建一个新的 cgroup ，继承父 cgroup 的所有参数，但可以被修改。</span></span><br><span class="line">$ <span class="comment"># Cgroup 实现了虚拟文件系统的接口，可以像操作文件一样修改内核 Cgroup 的各个参数</span></span><br><span class="line">$ mkdir ff </span><br><span class="line">$ <span class="comment"># 将 calc 任务加入的 ff cgroup 的管理下</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"25828"</span> &gt; tasks</span><br></pre></td></tr></table></figure><p>这样就把 calc 任务从一个 cgroup 转移到另一个 cgroup 的控制之下。不过，到目前为止，calc 任务仍然保持 CPU 100% 占用。毕竟这个 cgroup 的配置继承自父 cgroup ，都没有做任何限制。如何做限制呢？</p><p><code>cpu.cfs_period_us</code> 和 <code>cpu.cfs_quota_us</code> 分别被用来描述完全公平调度器每微秒的周期数和每微秒使用的周期数</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat cpu.cfs_period_us</span><br><span class="line">100000</span><br><span class="line">$ cat cpu.cfs_quota_us</span><br><span class="line">-1</span><br></pre></td></tr></table></figure><p>目前使用中的 <code>cpu.cfs_quota_us</code> 是 -1，代码没有逻辑上限。为了将 calc 任务的 CPU 使用率调整到 50% ，修改 <code>cpu.cfs_quota_us</code> ，使其恰好为 <code>cpu.cfs_period_us</code> 的一半就可以了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"50000"</span> &gt; cpu.cfs_period_us</span><br></pre></td></tr></table></figure><p>OK，再检查 calc 任务，结果就基本稳定在 50% 的使用率。而 CPU 没有其它的高使用率负载。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过命名空间和控制组的配合，就基本达成了容器化的初级要求——资源隔离、资源限额。当然，关于网络相关的仍然存在疑问。</p><p>在控制组的使用中，突然回忆起以前的一个问题——如何编程实现一个任务的 CPU 使用率恰好是 X%？虽然通过编程合理计算指令执行时间也能实现，但用 Cgroup 来似乎更为简单。不过，这两者的控制层面已经有了很大的不同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于工作上的一些调整，目前开始接触容器化技术了。容器化技术相对于虚拟机的最大区别，在于其只是在操作系统上做了资源隔离和控制，而虚拟机则会基于原有的操作系统，模拟一整套硬件设备接口，运行一个新的操作系统及相关的 Lib 库。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.ffutop.com/9FD2522D-BBEB-443A-8267-26F1EC77BA87.png&quot; alt=&quot;Containerd VS VM&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;&lt;center&gt;Copied From docker.com&lt;/center&gt;&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;如何实现容器化，显然需要从操作系统层面进行支撑。这其中涉及到的核心技术，就包括命名空间(namespace)和控制组(Control Group, cgroup)，前者用来对资源进行隔离，后者用来对资源加以限制。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文所有涉及的内核代码基于版本 3.10.1 ；所有命令执行结果基于 Ubuntu 18.04 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://DorMOUSE-None.github.io/tags/Linux/"/>
    
      <category term="Kernel" scheme="https://DorMOUSE-None.github.io/tags/Kernel/"/>
    
      <category term="LXC" scheme="https://DorMOUSE-None.github.io/tags/LXC/"/>
    
  </entry>
  
  <entry>
    <title>跟踪内核函数的工具—— Ftrace</title>
    <link href="https://DorMOUSE-None.github.io/2019-06-02-ftrace/"/>
    <id>https://DorMOUSE-None.github.io/2019-06-02-ftrace/</id>
    <published>2019-06-01T16:00:00.000Z</published>
    <updated>2019-06-02T01:03:47.103Z</updated>
    
    <content type="html"><![CDATA[<p>前两天仿照 <code>strings</code> 工具写了个打印进程运行时堆栈可打印字符的工具 <a href="https://github.com/DorMOUSE-None/ff-proc-utils/blob/master/ffstrings.c" target="_blank" rel="noopener">ffstrings</a> 。结果没几天就被告知在 CentOS 上跑不通(uid: root, errno: EPERM):&lt; </p><p>在反复调试无果之后，希望得到一种可以跟踪内核执行流的工具。功夫不负有心人，在内核文档中找到了—— <code>ftrace</code> 。</p><blockquote><p>Ftrace 是位于内核内部的跟踪器，可以用来调试和分析发生在用户空间（内核空间）之外的延迟和性能问题。</p><p>虽然 Ftrace 是一款函数跟踪器，但也支持基于其它目的的跟踪，例如：跟踪上下文切换、跟踪高优先级任务的执行时间等等。另外还可以通过插件的方式自定义更多的跟踪。</p></blockquote><p>当然，目前仅仅是做简单的介绍。毕竟最初的目的是为了确认 <code>ffstrings</code> 出现 <code>EPERM</code> 的原因。</p><a id="more"></a><h2 id="启用-Ftrace"><a href="#启用-Ftrace" class="headerlink" title="启用 Ftrace"></a>启用 Ftrace</h2><p><code>Ftrace</code> 自版本 2.6.28 开始加入内核。首先要做的就是确保内核已经集成了 <code>Ftrace</code> 。当然，目前的内核版本都已经到 5.X 了，而且云服务器的普及，相信已经没有太多还在使用7、8年前 Linux 发行版的机器了吧 :) </p><p><code>Ftrace</code> 使用 debugfs 文件系统以文件的形式来维护控制项和跟踪器输出。一般来说，这个文件系统将挂载在 <code>/sys/kernel/debug</code> 目录下。如果没有找到，那就主动先挂载上 debugfs 文件系统：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t debugfs nodev /sys/kernel/debug</span><br></pre></td></tr></table></figure><p>挂载文件系统之后，可以检查下 <code>/sys/kernel/debug/tracing</code> 目录，这里就是 <code>Ftrace</code> 全部的可配置项和输出。</p><p>几个重要的文件包括：</p><ul><li><code>current_tracer</code>, 配置当前跟踪器进行哪些项目的跟踪</li><li><code>available_tracers</code>, 当前内核支持的所有跟踪项目</li><li><code>tracing_on</code>, 开启/关闭跟踪器 (0 表示关闭, 1 表示开启)</li><li><code>trace</code>, 用户可读的跟踪结果文件</li><li><code>trace_pipe</code>, 与 <code>trace</code> 文件静态呈现的形式相对，里面的数据只能消费一次</li><li><code>trace_options</code>, 配置输出文件的格式</li><li><code>tracing_max_latency</code>, 记录最大延时</li><li><code>buffer_size_kb</code>, 用于设置单个CPU使用的跟踪器缓存大小。跟踪器缓存使用环形缓存，老的缓存会在空间不足时被新缓存覆盖</li><li><code>tracing_cpumask</code>, 用来配置需要监控的CPU</li><li><code>set_ftrace_filter</code>, 显示指定跟踪特定的函数</li><li><code>set_ftrace_notrace</code>, 与 <code>set_ftrace_filter</code> 功能恰好相反</li><li><code>set_ftrace_pid</code>, 只跟踪特定的任务</li><li><code>set_graph_function</code>, 设置要清晰显示调用关系的函数，以 C 语言缩进式地呈现</li><li><code>available_filter_functions</code>, 显示目前可以跟踪的所有内核函数</li></ul><h2 id="使用-Ftrace"><a href="#使用-Ftrace" class="headerlink" title="使用 Ftrace"></a>使用 Ftrace</h2><p>配置 <code>current_tracer</code> ，跟踪内核所有函数的调用</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="keyword">function</span> &gt; current_tracer</span><br></pre></td></tr></table></figure><p>配置 <code>tracing_enabled</code>，开启跟踪器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> 1 &gt; tracing_on</span><br></pre></td></tr></table></figure><p>查看 <code>trace</code> 文件中记录的跟踪器输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ head -15 trace</span><br><span class="line"><span class="comment"># tracer: function</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#                              _-----=&gt; irqs-off</span></span><br><span class="line"><span class="comment">#                             / _----=&gt; need-resched</span></span><br><span class="line"><span class="comment">#                            | / _---=&gt; hardirq/softirq</span></span><br><span class="line"><span class="comment">#                            || / _--=&gt; preempt-depth</span></span><br><span class="line"><span class="comment">#                            ||| /     delay</span></span><br><span class="line"><span class="comment">#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span></span><br><span class="line"><span class="comment">#              | |       |   ||||       |         |</span></span><br><span class="line">             zsh-23126 [000] d... 5252243.233084: do_syscall_64 &lt;-entry_SYSCALL_64_after_hwframe</span><br><span class="line">             zsh-23126 [000] .... 5252243.233084: SyS_rt_sigprocmask &lt;-do_syscall_64</span><br><span class="line">             zsh-23126 [000] .... 5252243.233084: sigprocmask &lt;-SyS_rt_sigprocmask</span><br><span class="line">             zsh-23126 [000] .... 5252243.233084: __set_current_blocked &lt;-sigprocmask</span><br><span class="line">             zsh-23126 [000] .... 5252243.233084: _raw_spin_lock_irq &lt;-__set_current_blocked</span><br><span class="line">             zsh-23126 [000] d... 5252243.233085: __set_task_blocked &lt;-__set_current_blocked</span><br></pre></td></tr></table></figure><p>OK，如果觉得这个结果并不直观，可以重新配置 <code>current_tracer</code>，使用 <code>function_graph</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> function_graph &gt; current_tracer</span><br><span class="line">$ head -15 trace</span><br><span class="line"><span class="comment"># tracer: function_graph</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># CPU  DURATION                  FUNCTION CALLS</span></span><br><span class="line"><span class="comment"># |     |   |                     |   |   |   |</span></span><br><span class="line"> 0)               |      <span class="function">__fdget_pos</span>() &#123;</span><br><span class="line"> 0)   0.072 us    |        __fget_light();</span><br><span class="line"> 0)   0.377 us    |      &#125;</span><br><span class="line"> 0)               |      <span class="function"><span class="title">vfs_read</span></span>() &#123;</span><br><span class="line"> 0)               |        <span class="function"><span class="title">rw_verify_area</span></span>() &#123;</span><br><span class="line"> 0)               |          <span class="function"><span class="title">security_file_permission</span></span>() &#123;</span><br><span class="line"> 0)               |            <span class="function"><span class="title">apparmor_file_permission</span></span>() &#123;</span><br><span class="line"> 0)               |              <span class="function"><span class="title">common_file_perm</span></span>() &#123;</span><br><span class="line"> 0)   0.079 us    |                aa_file_perm();</span><br><span class="line"> 0)   0.480 us    |              &#125;</span><br><span class="line"> 0)   0.877 us    |            &#125;</span><br></pre></td></tr></table></figure><h2 id="跟踪应用程序的系统调用"><a href="#跟踪应用程序的系统调用" class="headerlink" title="跟踪应用程序的系统调用"></a>跟踪应用程序的系统调用</h2><p>虽然 <code>strace</code> 就可以打印出任务的每个系统调用，但是，它所能完成的仅仅只是对每个系统调用及结果进行记录，而无法看到系统调用内部究竟发生了什么。而 ftrace 可以很好的完成这一点。当然，这需要一点点编码量。</p><p>回到最初的命题，执行 <code>ffstrings</code> 过程中，抛出了 <code>EPERM</code> 错误码。首先使用 <code>strace</code> 进行定位，究竟是哪个系统调用出了问题</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ strace ./ffstrings &lt;PID&gt;</span><br><span class="line"><span class="comment"># ... omitted output</span></span><br><span class="line"><span class="built_in">read</span>(4, 0x7f9ac2970000, 1024)           = -1 EPERM (Operation not permitted)</span><br><span class="line"><span class="comment"># ... omitted output</span></span><br></pre></td></tr></table></figure><p>修改应用程序代码，添加两个新的函数 (<code>trace_on</code>, <code>trace_off</code>)。</p><p><em>Hint: 这段代码的健壮性并不好，请各位多担待</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> trace_fd = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> marker_fd = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">char</span> *debugfs = <span class="string">"/sys/kernel/debug"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trace_on</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> path[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(path, debugfs);  <span class="comment">/* BEWARE buffer overflow */</span></span><br><span class="line"><span class="built_in">strcat</span>(path,<span class="string">"/tracing/tracing_on"</span>);</span><br><span class="line">trace_fd = open(path, O_WRONLY);</span><br><span class="line"><span class="keyword">if</span> (trace_fd &gt;= <span class="number">0</span>)</span><br><span class="line">write(trace_fd, <span class="string">"1"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(path, debugfs);</span><br><span class="line"><span class="built_in">strcat</span>(path,<span class="string">"/tracing/trace_marker"</span>);</span><br><span class="line">marker_fd = open(path, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (marker_fd &gt;= <span class="number">0</span>)</span><br><span class="line">    write(marker_fd, <span class="string">"In critical area\n"</span>, <span class="number">17</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trace_off</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (marker_fd &gt;= <span class="number">0</span>)</span><br><span class="line">    write(marker_fd, <span class="string">"Out critical area\n"</span>, <span class="number">17</span>);</span><br><span class="line">    write(trace_fd, <span class="string">"0"</span>, <span class="number">1</span>);</span><br><span class="line">    close(trace_fd);</span><br><span class="line">    close(marker_fd);</span><br><span class="line">    trace_fd = <span class="number">-1</span>;</span><br><span class="line">    marker_fd = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在问题代码前后执行这两个新的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">trace_on();</span><br><span class="line"><span class="keyword">char</span> c = getc(mem);</span><br><span class="line">trace_off();</span><br></pre></td></tr></table></figure><p>再去从 <code>trace</code> 文件中取一下执行结果（局部结果）</p><p><img src="http://img.ffutop.com/669F0256-7612-48E5-9069-292D4E687660.png" alt=""></p><p>到此为止，就可以简单的实现对内核函数的跟踪。</p><p>不过，这仅仅只能看到内核函数调用，具体的调用关系，还是得拿到相应版本的内核代码仔细研读研读。毕竟，内核代码的改动也是相当频繁的，不同版本调用关系会出现很大的变化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天仿照 &lt;code&gt;strings&lt;/code&gt; 工具写了个打印进程运行时堆栈可打印字符的工具 &lt;a href=&quot;https://github.com/DorMOUSE-None/ff-proc-utils/blob/master/ffstrings.c&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ffstrings&lt;/a&gt; 。结果没几天就被告知在 CentOS 上跑不通(uid: root, errno: EPERM):&amp;lt; &lt;/p&gt;
&lt;p&gt;在反复调试无果之后，希望得到一种可以跟踪内核执行流的工具。功夫不负有心人，在内核文档中找到了—— &lt;code&gt;ftrace&lt;/code&gt; 。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Ftrace 是位于内核内部的跟踪器，可以用来调试和分析发生在用户空间（内核空间）之外的延迟和性能问题。&lt;/p&gt;
&lt;p&gt;虽然 Ftrace 是一款函数跟踪器，但也支持基于其它目的的跟踪，例如：跟踪上下文切换、跟踪高优先级任务的执行时间等等。另外还可以通过插件的方式自定义更多的跟踪。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然，目前仅仅是做简单的介绍。毕竟最初的目的是为了确认 &lt;code&gt;ffstrings&lt;/code&gt; 出现 &lt;code&gt;EPERM&lt;/code&gt; 的原因。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://DorMOUSE-None.github.io/tags/Linux/"/>
    
      <category term="Kernel" scheme="https://DorMOUSE-None.github.io/tags/Kernel/"/>
    
      <category term="ftrace" scheme="https://DorMOUSE-None.github.io/tags/ftrace/"/>
    
  </entry>
  
  <entry>
    <title>理解 Linux Kernel (11) - 进程间通信</title>
    <link href="https://DorMOUSE-None.github.io/2019-05-27-understand-Kernel-11/"/>
    <id>https://DorMOUSE-None.github.io/2019-05-27-understand-Kernel-11/</id>
    <published>2019-05-26T16:00:00.000Z</published>
    <updated>2019-05-27T00:46:07.618Z</updated>
    
    <content type="html"><![CDATA[<p>进程间通信(IPC, inter-process communication)是多个执行上下文实现数据交互的重要功能，也是 Linux Kernel 一个重要的模块。本篇主要着眼于 Linux 基于 System V 引入的 3 种 IPC 机制——信号量、消息队列、共享内存。除此之外，Linux 还有更多的方式能够实现进程间通信，但本文不做介绍。</p><p><em>本篇基于 Linux 4.9.87 版本源码</em></p><a id="more"></a><h2 id="IPC-命名空间"><a href="#IPC-命名空间" class="headerlink" title="IPC 命名空间"></a>IPC 命名空间</h2><p>读过前几篇的同学应该都能够了解，内核统一维护了所有的资源，并有限地向各个执行流暴露所需的资源。这保证了各个执行流看似独立地运行，但也为进程间的协作制造了障碍。基于这个原因，内核又提供了额外的机制来超脱这个限制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">spinlock_t</span>lock;</span><br><span class="line"><span class="keyword">bool</span>deleted;</span><br><span class="line"><span class="keyword">int</span>id;             <span class="comment">/* 内核态内部 id */</span></span><br><span class="line"><span class="keyword">key_t</span>key;        <span class="comment">/* 保存用户程序用来唯一区分信号量的一个魔数 */</span></span><br><span class="line"><span class="keyword">kuid_t</span>uid;</span><br><span class="line"><span class="keyword">kgid_t</span>gid;</span><br><span class="line"><span class="keyword">kuid_t</span>cuid;</span><br><span class="line"><span class="keyword">kgid_t</span>cgid;</span><br><span class="line"><span class="keyword">umode_t</span>mode;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>seq;</span><br><span class="line"><span class="keyword">void</span>*security;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_ids</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> in_use;                 <span class="comment">/* 使用中的 IPC 对象数量 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> seq;         <span class="comment">/* 用户空间 IPC 对象 ID */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">rwsem</span>;</span>  <span class="comment">/* 内核信号量，内核操作必备的锁机制 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">idr</span> <span class="title">ipcs_idr</span>;</span>        <span class="comment">/* id 管理器，ipcs_idr 总是指向 kern_ipc_perm 对象 */</span></span><br><span class="line"><span class="keyword">int</span> next_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> &#123;</span></span><br><span class="line"><span class="keyword">atomic_t</span>count;          <span class="comment">/* 被引用的次数 */</span></span><br><span class="line">    <span class="comment">/* “核心”，每个数组元素对应一种 IPC 机制：信号量、消息队列、共享内存 */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       from ipc/util.h</span></span><br><span class="line"><span class="comment">        #define IPC_SEM_IDS 0   信号量</span></span><br><span class="line"><span class="comment">        #define IPC_MSG_IDS 1   消息队列</span></span><br><span class="line"><span class="comment">        #define IPC_SHM_IDS 2   共享内存</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_ids</span><span class="title">ids</span>[3];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 以下都是对三种 IPC 机制设置的限制，诸如共享内存页的最大数量等 */</span></span><br><span class="line"><span class="keyword">int</span>sem_ctls[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span>used_sems;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>msg_ctlmax;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>msg_ctlmnb;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>msg_ctlmni;</span><br><span class="line"><span class="keyword">atomic_t</span>msg_bytes;</span><br><span class="line"><span class="keyword">atomic_t</span>msg_hdrs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span>shm_ctlmax;</span><br><span class="line"><span class="keyword">size_t</span>shm_ctlall;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>shm_tot;</span><br><span class="line"><span class="keyword">int</span>shm_ctlmni;</span><br><span class="line"><span class="keyword">int</span>shm_rmid_forced;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> <span class="title">ipcns_nb</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The kern_mount of the mqueuefs sb.  We take a ref on it */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span>*<span class="title">mq_mnt</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* # queues in this ns, protected by mq_lock */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>    mq_queues_count;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* next fields are set through sysctl */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>    mq_queues_max;   <span class="comment">/* initialized to DFLT_QUEUESMAX */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>    mq_msg_max;      <span class="comment">/* initialized to DFLT_MSGMAX */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>    mq_msgsize_max;  <span class="comment">/* initialized to DFLT_MSGSIZEMAX */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>    mq_msg_default;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>    mq_msgsize_default;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* user_ns which owns the ipc ns */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ucounts</span> *<span class="title">ucounts</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ns_common</span> <span class="title">ns</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>IPC 由一个被称为 <code>ipc_namespace</code> 的数据结构维护，如果熟悉 <code>pid_namespace</code> 之类的，应该能够理解内核通过命名空间实现了资源的隔离。这里的 <code>ipc_namespace</code> 也是为了实现多个 ipc 环境所做的抽象。首先看下初始化 IPC 命名空间的流程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* from init/init_task.c */</span></span><br><span class="line"><span class="comment">/* 内核抽象的第一个任务 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> <span class="title">init_task</span> = <span class="title">INIT_TASK</span>(<span class="title">init_task</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* from include/linux/init_task.h */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_TASK(tsk) \</span></span><br><span class="line">&#123;                                       \</span><br><span class="line">    .nsproxy= &amp;init_nsproxy,        \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* from kernel/nsproxy.c */</span></span><br><span class="line">struct nsproxy init_nsproxy = &#123;</span><br><span class="line">.count= ATOMIC_INIT(<span class="number">1</span>),</span><br><span class="line">.uts_ns= &amp;init_uts_ns,</span><br><span class="line">#<span class="keyword">if</span> defined(CONFIG_POSIX_MQUEUE) || defined(CONFIG_SYSVIPC)</span><br><span class="line">.ipc_ns= &amp;init_ipc_ns,</span><br><span class="line">#endif</span><br><span class="line">.mnt_ns= <span class="literal">NULL</span>,</span><br><span class="line">.pid_ns_for_children= &amp;init_pid_ns,</span><br><span class="line">#ifdef CONFIG_NET</span><br><span class="line">.net_ns= &amp;init_net,</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_CGROUPS</span><br><span class="line">.cgroup_ns= &amp;init_cgroup_ns,</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* from ipc/msgutil.c */</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> <span class="title">init_ipc_ns</span> = &#123;</span></span><br><span class="line">.count= ATOMIC_INIT(<span class="number">1</span>),</span><br><span class="line">.user_ns = &amp;init_user_ns,</span><br><span class="line">.ns.inum = PROC_IPC_INIT_INO,</span><br><span class="line">#ifdef CONFIG_IPC_NS</span><br><span class="line">.ns.ops = &amp;ipcns_operations,</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>任务通过 <code>fork</code>、<code>clone</code> 等操作构建新的任务，并由 <code>flag CLONE_NEWIPC</code> 决定与父任务共享 IPC 命名空间或创建新的 IPC 命名空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ipc_namespace *<span class="title">copy_ipcs</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">struct user_namespace *user_ns, struct ipc_namespace *ns)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!(flags &amp; CLONE_NEWIPC))</span><br><span class="line">        <span class="comment">/* 返回原来的 IPC 命名空间 */</span></span><br><span class="line"><span class="keyword">return</span> get_ipc_ns(ns);</span><br><span class="line">    <span class="comment">/* 返回一个新的 IPC 命名空间 */</span></span><br><span class="line"><span class="keyword">return</span> create_ipc_ns(user_ns, ns);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p><img src="http://img.ffutop.com/7A24F185-3480-4C29-A006-C66BB54E046F.png" alt=""></p><p>上图给出了各个结构间的关系，通过当前任务指向的 IPC 命名空间，找到 <code>struct ipc_ids</code> ，内核通过 <code>ipcs_idr</code> 找到 ID 到指针的映射关系，从而得到所需的 <code>kern_ipc_perm</code> 实例。同时 <code>kern_ipc_perm</code> 作为结构 <code>sem_array</code> 的第一个元素，使用技巧就可以直接定位到 <code>struct sem_array</code> 。</p><h3 id="syscall-semget"><a href="#syscall-semget" class="headerlink" title="syscall semget"></a>syscall <code>semget</code></h3><p>获取一个信号量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* from ipc/sem.c */</span></span><br><span class="line">SYSCALL_DEFINE3(semget, <span class="keyword">key_t</span>, key, <span class="keyword">int</span>, nsems, <span class="keyword">int</span>, semflg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ipc_ops</span> <span class="title">sem_ops</span> = &#123;</span></span><br><span class="line">.getnew = newary,</span><br><span class="line">.associate = sem_security,</span><br><span class="line">.more_checks = sem_more_checks,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_params</span> <span class="title">sem_params</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取当前任务的 IPC 命名空间 */</span></span><br><span class="line">ns = current-&gt;nsproxy-&gt;ipc_ns;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nsems &lt; <span class="number">0</span> || nsems &gt; ns-&gt;sc_semmsl)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">sem_params.key = key;</span><br><span class="line">sem_params.flg = semflg;</span><br><span class="line">sem_params.u.nsems = nsems;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ipcget(ns, &amp;sem_ids(ns), &amp;sem_ops, &amp;sem_params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* from ipc/util.c */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ipcget</span><span class="params">(struct ipc_namespace *ns, struct ipc_ids *ids,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> struct ipc_ops *ops, struct ipc_params *params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 如果标志位为“私有”，则创建新的 IPC 命名空间 */</span></span><br><span class="line"><span class="keyword">if</span> (params-&gt;key == IPC_PRIVATE)</span><br><span class="line"><span class="keyword">return</span> ipcget_new(ns, ids, ops, params);</span><br><span class="line">    <span class="comment">/* 使用当前任务的 IPC 命名空间 */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> ipcget_public(ns, ids, ops, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.ffutop.com/DED2216C-127B-4036-84D8-33A2E44C5B33.png" alt=""></p><p>这里额外展示了 <code>msgget</code>, <code>shmget</code>，分别意味着消息队列、共享内存。获取 IPC 对象的流程都是相同的，有所区别的只是获取、写入和存储数据的方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from 'ipc/util.c'</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ipcget_new</span><span class="params">(struct ipc_namespace *ns, struct ipc_ids *ids,</span></span></span><br><span class="line"><span class="function"><span class="params">struct ipc_ops *ops, struct ipc_params *params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line">retry:</span><br><span class="line">err = idr_pre_get(&amp;ids-&gt;ipcs_idr, GFP_KERNEL);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!err)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">down_write(&amp;ids-&gt;rw_mutex);</span><br><span class="line">err = ops-&gt;getnew(ns, params);</span><br><span class="line">up_write(&amp;ids-&gt;rw_mutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (err == -EAGAIN)</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ipcget_public</span><span class="params">(struct ipc_namespace *ns, struct ipc_ids *ids,</span></span></span><br><span class="line"><span class="function"><span class="params">struct ipc_ops *ops, struct ipc_params *params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> *<span class="title">ipcp</span>;</span></span><br><span class="line"><span class="keyword">int</span> flg = params-&gt;flg;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line">retry:</span><br><span class="line">err = idr_pre_get(&amp;ids-&gt;ipcs_idr, GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读写锁保护临界区</span></span><br><span class="line">down_write(&amp;ids-&gt;rw_mutex);</span><br><span class="line">  <span class="comment">// 确认 KEY 是否存在</span></span><br><span class="line">ipcp = ipc_findkey(ids, params-&gt;key);</span><br><span class="line"><span class="keyword">if</span> (ipcp == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">/* KEY 不存在，创建新的 */</span></span><br><span class="line"><span class="keyword">if</span> (!(flg &amp; IPC_CREAT))</span><br><span class="line">err = -ENOENT;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!err)</span><br><span class="line">err = -ENOMEM;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">err = ops-&gt;getnew(ns, params);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* KEY 存在，check ACL */</span></span><br><span class="line"><span class="keyword">if</span> (flg &amp; IPC_CREAT &amp;&amp; flg &amp; IPC_EXCL)</span><br><span class="line">err = -EEXIST;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">err = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (ops-&gt;more_checks)</span><br><span class="line">err = ops-&gt;more_checks(ipcp, params);</span><br><span class="line"><span class="keyword">if</span> (!err)</span><br><span class="line">err = ipc_check_perms(ipcp, ops, params);</span><br><span class="line">&#125;</span><br><span class="line">ipc_unlock(ipcp);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 离开临界区</span></span><br><span class="line">up_write(&amp;ids-&gt;rw_mutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (err == -EAGAIN)</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ipcget_new</code> 和 <code>ipcget_public</code> ，核心的目标用 key 去换取一个 id (代表 <code>struct kern_ipc_perm</code> 在 <code>ipcs_idr</code> 整数指针管理器中的 id )。</p><p>如果这个 key 不存在，就考虑创建一个新的 <code>struct kern_ipc_perm</code> 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from 'include/linux/sem.h'</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem_array</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span><span class="title">sem_perm</span>;</span><span class="comment">/* permissions .. see ipc.h */</span></span><br><span class="line"><span class="keyword">time_t</span>sem_otime;<span class="comment">/* last semop time */</span></span><br><span class="line"><span class="keyword">time_t</span>sem_ctime;<span class="comment">/* last change time */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem</span>*<span class="title">sem_base</span>;</span><span class="comment">/* ptr to first semaphore in array */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span>*<span class="title">sem_pending</span>;</span><span class="comment">/* pending operations to be processed */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span>**<span class="title">sem_pending_last</span>;</span> <span class="comment">/* last pending operation */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem_undo</span>*<span class="title">undo</span>;</span><span class="comment">/* undo requests on this array */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>sem_nsems;<span class="comment">/* no. of semaphores in array */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// from 'ipc/sem.c'</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">newary</span><span class="params">(struct ipc_namespace *ns, struct ipc_params *params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">int</span> retval;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem_array</span> *<span class="title">sma</span>;</span></span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">key_t</span> key = params-&gt;key;</span><br><span class="line"><span class="keyword">int</span> nsems = params-&gt;u.nsems;</span><br><span class="line"><span class="keyword">int</span> semflg = params-&gt;flg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!nsems)<span class="comment">// 信号量集合中信号量数量不能为0.</span></span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (ns-&gt;used_sems + nsems &gt; ns-&gt;sc_semmns) <span class="comment">// 不能超过 IPC 信号量数量上限</span></span><br><span class="line"><span class="keyword">return</span> -ENOSPC;</span><br><span class="line"></span><br><span class="line">size = <span class="keyword">sizeof</span> (*sma) + nsems * <span class="keyword">sizeof</span> (struct sem);</span><br><span class="line">sma = ipc_rcu_alloc(size);</span><br><span class="line"><span class="keyword">if</span> (!sma) &#123;</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span> (sma, <span class="number">0</span>, size);</span><br><span class="line"></span><br><span class="line">sma-&gt;sem_perm.mode = (semflg &amp; S_IRWXUGO);</span><br><span class="line">sma-&gt;sem_perm.key = key;</span><br><span class="line"></span><br><span class="line">sma-&gt;sem_perm.security = <span class="literal">NULL</span>;</span><br><span class="line">retval = security_sem_alloc(sma);</span><br><span class="line"><span class="keyword">if</span> (retval) &#123;</span><br><span class="line">ipc_rcu_putref(sma);</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id = ipc_addid(&amp;sem_ids(ns), &amp;sma-&gt;sem_perm, ns-&gt;sc_semmni);</span><br><span class="line"><span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">security_sem_free(sma);</span><br><span class="line">ipc_rcu_putref(sma);</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line">ns-&gt;used_sems += nsems;</span><br><span class="line"></span><br><span class="line">sma-&gt;sem_perm.id = sem_buildid(id, sma-&gt;sem_perm.seq);</span><br><span class="line">sma-&gt;sem_base = (struct sem *) &amp;sma[<span class="number">1</span>];</span><br><span class="line"><span class="comment">/* sma-&gt;sem_pending = NULL; */</span></span><br><span class="line">sma-&gt;sem_pending_last = &amp;sma-&gt;sem_pending;</span><br><span class="line"><span class="comment">/* sma-&gt;undo = NULL; */</span></span><br><span class="line">sma-&gt;sem_nsems = nsems;</span><br><span class="line">sma-&gt;sem_ctime = get_seconds();</span><br><span class="line">sem_unlock(sma);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sma-&gt;sem_perm.id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="syscall-semctl"><a href="#syscall-semctl" class="headerlink" title="syscall semctl"></a>syscall <code>semctl</code></h3><p>信号量控制操作。根据 <code>cmd</code> 的不同，可以获得信号集合中所有值(GETALL)，获取最后一个操作信号集合的进程号(GETPID)，统一设置信号集合中所有值(SETALL)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE4(semctl, <span class="keyword">int</span>, semid, <span class="keyword">int</span>, semnum, <span class="keyword">int</span>, cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span>, arg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> version;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line"><span class="keyword">void</span> __user *p = (<span class="keyword">void</span> __user *)arg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (semid &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">version = ipc_parse_version(&amp;cmd);</span><br><span class="line">ns = current-&gt;nsproxy-&gt;ipc_ns;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line"><span class="keyword">case</span> IPC_INFO:</span><br><span class="line"><span class="keyword">case</span> SEM_INFO:</span><br><span class="line"><span class="keyword">case</span> IPC_STAT:</span><br><span class="line"><span class="keyword">case</span> SEM_STAT:</span><br><span class="line"><span class="keyword">return</span> semctl_nolock(ns, semid, cmd, version, p);</span><br><span class="line"><span class="keyword">case</span> GETALL:</span><br><span class="line"><span class="keyword">case</span> GETVAL:</span><br><span class="line"><span class="keyword">case</span> GETPID:</span><br><span class="line"><span class="keyword">case</span> GETNCNT:</span><br><span class="line"><span class="keyword">case</span> GETZCNT:</span><br><span class="line"><span class="keyword">case</span> SETALL:</span><br><span class="line"><span class="keyword">return</span> semctl_main(ns, semid, semnum, cmd, p);</span><br><span class="line"><span class="keyword">case</span> SETVAL:</span><br><span class="line"><span class="keyword">return</span> semctl_setval(ns, semid, semnum, arg);</span><br><span class="line"><span class="keyword">case</span> IPC_RMID:</span><br><span class="line"><span class="keyword">case</span> IPC_SET:</span><br><span class="line"><span class="keyword">return</span> semctl_down(ns, semid, cmd, version, p);</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="syscall-semop"><a href="#syscall-semop" class="headerlink" title="syscall semop"></a>syscall <code>semop</code></h3><p>信号的 P/V 操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from 'ipc/sem.c'</span></span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_semop</span> <span class="params">(<span class="keyword">int</span> semid, struct sembuf __user *tsops, <span class="keyword">unsigned</span> nsops)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sys_semtimedop(semid, tsops, nsops, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_semtimedop</span><span class="params">(<span class="keyword">int</span> semid, struct sembuf __user *tsops,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> nsops, <span class="keyword">const</span> struct timespec __user *timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> error = -EINVAL;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem_array</span> *<span class="title">sma</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">fast_sops</span>[<span class="title">SEMOPM_FAST</span>];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span>* <span class="title">sops</span> = <span class="title">fast_sops</span>, *<span class="title">sop</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem_undo</span> *<span class="title">un</span>;</span></span><br><span class="line"><span class="keyword">int</span> undos = <span class="number">0</span>, alter = <span class="number">0</span>, max;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> <span class="title">queue</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> jiffies_left = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取当前任务的 ipc 命名空间</span></span><br><span class="line">ns = current-&gt;nsproxy-&gt;ipc_ns;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nsops &lt; <span class="number">1</span> || semid &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (nsops &gt; ns-&gt;sc_semopm)</span><br><span class="line"><span class="keyword">return</span> -E2BIG;</span><br><span class="line"><span class="keyword">if</span>(nsops &gt; SEMOPM_FAST) &#123;</span><br><span class="line">sops = kmalloc(<span class="keyword">sizeof</span>(*sops)*nsops,GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span>(sops==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (copy_from_user (sops, tsops, nsops * <span class="keyword">sizeof</span>(*tsops))) &#123;</span><br><span class="line">error=-EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out_free;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (timeout) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> _<span class="title">timeout</span>;</span></span><br><span class="line"><span class="keyword">if</span> (copy_from_user(&amp;_timeout, timeout, <span class="keyword">sizeof</span>(*timeout))) &#123;</span><br><span class="line">error = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out_free;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (_timeout.tv_sec &lt; <span class="number">0</span> || _timeout.tv_nsec &lt; <span class="number">0</span> ||</span><br><span class="line">_timeout.tv_nsec &gt;= <span class="number">1000000000L</span>) &#123;</span><br><span class="line">error = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> out_free;</span><br><span class="line">&#125;</span><br><span class="line">jiffies_left = timespec_to_jiffies(&amp;_timeout);</span><br><span class="line">&#125;</span><br><span class="line">max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (sop = sops; sop &lt; sops + nsops; sop++) &#123;</span><br><span class="line"><span class="keyword">if</span> (sop-&gt;sem_num &gt;= max)</span><br><span class="line">max = sop-&gt;sem_num;</span><br><span class="line"><span class="keyword">if</span> (sop-&gt;sem_flg &amp; SEM_UNDO)</span><br><span class="line">undos = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (sop-&gt;sem_op != <span class="number">0</span>)</span><br><span class="line">alter = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">retry_undos:</span><br><span class="line"><span class="keyword">if</span> (undos) &#123;</span><br><span class="line">un = find_undo(ns, semid);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(un)) &#123;</span><br><span class="line">error = PTR_ERR(un);</span><br><span class="line"><span class="keyword">goto</span> out_free;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">un = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">sma = sem_lock_check(ns, semid);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(sma)) &#123;</span><br><span class="line">error = PTR_ERR(sma);</span><br><span class="line"><span class="keyword">goto</span> out_free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * semid identifiers are not unique - find_undo may have</span></span><br><span class="line"><span class="comment"> * allocated an undo structure, it was invalidated by an RMID</span></span><br><span class="line"><span class="comment"> * and now a new array with received the same id. Check and retry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (un &amp;&amp; un-&gt;semid == <span class="number">-1</span>) &#123;</span><br><span class="line">sem_unlock(sma);</span><br><span class="line"><span class="keyword">goto</span> retry_undos;</span><br><span class="line">&#125;</span><br><span class="line">error = -EFBIG;</span><br><span class="line"><span class="keyword">if</span> (max &gt;= sma-&gt;sem_nsems)</span><br><span class="line"><span class="keyword">goto</span> out_unlock_free;</span><br><span class="line"></span><br><span class="line">error = -EACCES;</span><br><span class="line"><span class="keyword">if</span> (ipcperms(&amp;sma-&gt;sem_perm, alter ? S_IWUGO : S_IRUGO))</span><br><span class="line"><span class="keyword">goto</span> out_unlock_free;</span><br><span class="line"></span><br><span class="line">error = security_sem_semop(sma, sops, nsops, alter);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">goto</span> out_unlock_free;</span><br><span class="line"></span><br><span class="line">error = try_atomic_semop (sma, sops, nsops, un, task_tgid_vnr(current));</span><br><span class="line"><span class="keyword">if</span> (error &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (alter &amp;&amp; error == <span class="number">0</span>)</span><br><span class="line">update_queue (sma);</span><br><span class="line"><span class="keyword">goto</span> out_unlock_free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We need to sleep on this operation, so we put the current</span></span><br><span class="line"><span class="comment"> * task into the pending queue and go to sleep.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>.sma = sma;</span><br><span class="line"><span class="built_in">queue</span>.sops = sops;</span><br><span class="line"><span class="built_in">queue</span>.nsops = nsops;</span><br><span class="line"><span class="built_in">queue</span>.undo = un;</span><br><span class="line"><span class="built_in">queue</span>.pid = task_tgid_vnr(current);</span><br><span class="line"><span class="built_in">queue</span>.id = semid;</span><br><span class="line"><span class="built_in">queue</span>.alter = alter;</span><br><span class="line"><span class="keyword">if</span> (alter)</span><br><span class="line">append_to_queue(sma ,&amp;<span class="built_in">queue</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">prepend_to_queue(sma ,&amp;<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>.status = -EINTR;</span><br><span class="line"><span class="built_in">queue</span>.sleeper = current;</span><br><span class="line">current-&gt;state = TASK_INTERRUPTIBLE;</span><br><span class="line">sem_unlock(sma);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (timeout)</span><br><span class="line">jiffies_left = schedule_timeout(jiffies_left);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">schedule();</span><br><span class="line"></span><br><span class="line">error = <span class="built_in">queue</span>.status;</span><br><span class="line"><span class="keyword">while</span>(unlikely(error == IN_WAKEUP)) &#123;</span><br><span class="line">cpu_relax();</span><br><span class="line">error = <span class="built_in">queue</span>.status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (error != -EINTR) &#123;</span><br><span class="line"><span class="comment">/* fast path: update_queue already obtained all requested</span></span><br><span class="line"><span class="comment"> * resources */</span></span><br><span class="line"><span class="keyword">goto</span> out_free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sma = sem_lock(ns, semid);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(sma)) &#123;</span><br><span class="line">BUG_ON(<span class="built_in">queue</span>.prev != <span class="literal">NULL</span>);</span><br><span class="line">error = -EIDRM;</span><br><span class="line"><span class="keyword">goto</span> out_free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If queue.status != -EINTR we are woken up by another process</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">error = <span class="built_in">queue</span>.status;</span><br><span class="line"><span class="keyword">if</span> (error != -EINTR) &#123;</span><br><span class="line"><span class="keyword">goto</span> out_unlock_free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If an interrupt occurred we have to clean up the queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (timeout &amp;&amp; jiffies_left == <span class="number">0</span>)</span><br><span class="line">error = -EAGAIN;</span><br><span class="line">remove_from_queue(sma,&amp;<span class="built_in">queue</span>);</span><br><span class="line"><span class="keyword">goto</span> out_unlock_free;</span><br><span class="line"></span><br><span class="line">out_unlock_free:</span><br><span class="line">sem_unlock(sma);</span><br><span class="line">out_free:</span><br><span class="line"><span class="keyword">if</span>(sops != fast_sops)</span><br><span class="line">kfree(sops);</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>至于消息队列和共享内存，都利用了类似的技术，通过在 IPC 命名空间下，使用 <code>struct idr</code> 做 KEY, VALUE 的管理，从而维护起了一系列互不干扰的消息队列、共享内存。</p><p><img src="http://img.ffutop.com/409ECF12-A0E5-4B0F-AD96-FE9EA73FD972.png" alt=""></p><h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p><img src="http://img.ffutop.com/85BB67B8-0EE1-4657-8242-760645A06ED1.png" alt=""></p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>局限于目前未能找到 SysV IPC 的经典利用场景，加之平时工作接触甚少。本篇匆匆结尾，未详细展示不同 IPC 技术在不同使用场景下的优劣。</p><p>相对而言，日常更多使用的 IPC 技术反而是管道、多进程共同读写文档等。</p><p>此坑估计不会再填了…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;进程间通信(IPC, inter-process communication)是多个执行上下文实现数据交互的重要功能，也是 Linux Kernel 一个重要的模块。本篇主要着眼于 Linux 基于 System V 引入的 3 种 IPC 机制——信号量、消息队列、共享内存。除此之外，Linux 还有更多的方式能够实现进程间通信，但本文不做介绍。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;本篇基于 Linux 4.9.87 版本源码&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://DorMOUSE-None.github.io/tags/Linux/"/>
    
      <category term="Kernel" scheme="https://DorMOUSE-None.github.io/tags/Kernel/"/>
    
      <category term="IPC" scheme="https://DorMOUSE-None.github.io/tags/IPC/"/>
    
  </entry>
  
  <entry>
    <title>pipe 导致的 CLOSE_WAIT</title>
    <link href="https://DorMOUSE-None.github.io/2019-05-20-CLOSE_WAIT_PROBLEM/"/>
    <id>https://DorMOUSE-None.github.io/2019-05-20-CLOSE_WAIT_PROBLEM/</id>
    <published>2019-05-19T16:00:00.000Z</published>
    <updated>2019-05-20T11:43:46.005Z</updated>
    
    <content type="html"><![CDATA[<p>历时一周总算把导致服务大量 <code>CLOSE_WAIT</code> 的原因给找到了。打印任务调用栈果然的必备手段啊！</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>Python 服务 A，用于接收心跳包确认其他服务是否存活。其他服务每 5 分钟向 A 发送一次心跳包；总计 &lt; 100 个其他服务。</p><ul><li>05-11 19:30 ，首次出现 Python 服务大量 <code>CLOSE_WAIT</code>，至 13 日发现，总计 10k 左右 <code>CLOSE_WAIT</code> 的 TCP 连接。05-13 15:30 通过运维平台重新部署…</li><li>05-14 16:30 ，再次出现。19:30 手动重启。</li><li>其间给 Python 服务 A 添加了打印调用栈的模块 <a href="https://pypi.org/project/pdbx/" target="_blank" rel="noopener">pdbx</a>，通过运维平台重新部署</li><li>05-17 19:00 ，再次出现。等待打印调用栈，不小心杀掉了服务…</li><li>05-19 14:30 ，重现。</li><li>05-20 08:30 ，查找原因，解决问题。</li></ul><p>由于不是本人负责的服务，于 16 日凭兴趣开始有限介入，协助排查。现将排查流程一一记述，给自己和大家未来排查问题提供一个借鉴。</p><a id="more"></a><h2 id="问题探究"><a href="#问题探究" class="headerlink" title="问题探究"></a>问题探究</h2><h3 id="CLOSE-WAIT-现象梳理"><a href="#CLOSE-WAIT-现象梳理" class="headerlink" title="CLOSE_WAIT 现象梳理"></a>CLOSE_WAIT 现象梳理</h3><p>16 日拿到的信息只有前两次问题记录。</p><p><img src="http://img.ffutop.com/82B074FB-68FF-4A21-B664-A557FECBB2DF.png" alt=""></p><p>大量 <code>CLOSE_WAIT</code> 状态的 TCP 连接，<code>Recv-Q</code> 数据大小平均在 300 Bytes 左右。对比实际的 HTTP 包大小，恰好是一次 HTTP Request 请求大小。同时参考 Nginx 打印的日志，确定是一次 HTTP 请求的数据包大小，同时都以 Timeout 为结束。</p><p>OK，简单地建立起了第一个印象，TCP 断开连接的 FIN 包由 Nginx 请求超时后发起(<code>proxy_read_timeout 300s</code>) 。A 服务所在的 Linux 机器接收到 FIN 包，并由内核线程直接将套接字状态置位为 <code>CLOSE_WAIT</code> 。</p><p>A 服务没意识到 FIN 包？当然，接收了 FIN 包之后，再回应 ACK 包，这“四次挥手”的第二个数据包并不会被 A 服务所认知，而是由内核的 <code>[ksoftirqd]</code> 内核线程直接处理。看下内核处理 FIN 包的代码 (from <code>net/ipv4/tcp_input.c</code>)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 处理 FIN 包</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果当前套接字是 ESTABLISHED 状态，则接收 FIN 包，进入 CLOSE-WAIT</span></span><br><span class="line"><span class="comment"> * 状态 </span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tcp_fin</span><span class="params">(struct sock *sk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> = <span class="title">tcp_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line"></span><br><span class="line">inet_csk_schedule_ack(sk);</span><br><span class="line"></span><br><span class="line">sk-&gt;sk_shutdown |= RCV_SHUTDOWN;</span><br><span class="line">sock_set_flag(sk, SOCK_DONE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (sk-&gt;sk_state) &#123;</span><br><span class="line"><span class="keyword">case</span> TCP_SYN_RECV:</span><br><span class="line"><span class="keyword">case</span> TCP_ESTABLISHED:</span><br><span class="line">        <span class="comment">/* 当前为 ESTABLISHED 状态，进入 CLOSE_WAIT */</span></span><br><span class="line">tcp_set_state(sk, TCP_CLOSE_WAIT);</span><br><span class="line">inet_csk(sk)-&gt;icsk_ack.pingpong = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... more omitted </span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... more omitted </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多关于网络相关的内核实现请参考 <a href="https://www.ffutop.com/2019-01-15-understand-Kernel-8/" target="_blank" rel="noopener">理解 Linux Kernel (8) - 网络</a></p><p>再结合 <code>Recv-Q</code> 恰好等于一次完整 HTTP 请求的条件，可以认识到 Python 线程根本没有 <code>recv</code> 请求数据。更别提意识到远端发出来 FIN 包。</p><p>到此为止，由前两次的问题得到的线索，只能认为 Python 服务 A 的所有工作线程都在哪段代码阻塞了。而我所能认知的唯一条件就是事务死锁（当然，我犯了比较大的错误）。事实上看代码根本就没有任何死锁代码。暂时无果。</p><h3 id="打印线程调用栈-一次失败的尝试"><a href="#打印线程调用栈-一次失败的尝试" class="headerlink" title="打印线程调用栈 (一次失败的尝试)"></a>打印线程调用栈 (一次失败的尝试)</h3><p>集成了调用栈打印工具 <code>pdbx</code> （强烈安利，我们老大写的，很好用的工具）之后，按理说 18 日解决问题是非常容易的。</p><p>结果按照文档的描述，使用 <code>kill -30 &lt;PID&gt;</code> ，Python 服务进程莫名挂掉。功亏一篑啊。后来查看源码发现 <code>pdbx</code> 重定义了 <code>USR1</code> 信号的处理函数。T_T Linux x86 平台下，对应的信号值为 10. </p><hr><p>额外地穿插一点信号相关的内容。<code>signal</code> 是一种异步处理机制，一般由执行流在退出内核态回到用户态之前 Check 当前任务的信号队列（为什么会主动 check 呢？当然是内核代码提前写好的流程），并主动针对获得的信号调用对应的信号处理函数。</p><p>可怕的是，之前竟然一直没有意识到信号值在不同的 CPU 架构下是不同的。USR1 在 x86 平台下是 10，在 平台下是 30 。而 BSD 又与 Linux 的编号方案不同。</p><blockquote><p>Linux  supports  the standard signals listed below.  Several signal numbers are architecture-dependent, as indicated in the “Value” column.  (Where three values are given, the first one is usually valid for alpha and sparc, the middle one for x86, arm, and most other architectures, and the last one for mips.  (Values for parisc are not shown; see the Linux kernel source for signal numbering on that architecture.)  A dash (-) denotes that a signal is absent on the corresponding architecture.<br>Linux 支持的标准信号如下。一些信号值是平台相关的（Value 列，第一个值用于 alpha 和 sparc 平台，中间的值用于 x86、arm 和大量其他架构，最后一个值用于 mips 平台）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; Signal     Value     Action   Comment</span><br><span class="line">&gt; ----------------------------------------------------------------------</span><br><span class="line">&gt; SIGHUP        1       Term    Hangup detected on controlling terminal or death of controlling process</span><br><span class="line">&gt; SIGINT        2       Term    Interrupt from keyboard</span><br><span class="line">&gt; SIGQUIT       3       Core    Quit from keyboard</span><br><span class="line">&gt; SIGKILL       9       Term    Kill signal</span><br><span class="line">&gt; SIGUSR1   30,10,16    Term    User-defined signal 1</span><br><span class="line">&gt; SIGUSR2   31,12,17    Term    User-defined signal 2</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>总结下，最靠谱的写法就是直接用信号的字符描述啦。<code>kill -s USR1 &lt;PID&gt;</code></p><hr><h3 id="打印线程调用栈"><a href="#打印线程调用栈" class="headerlink" title="打印线程调用栈"></a>打印线程调用栈</h3><p>19 日下午再次重现，等到 20 日周一上班，总是成功地拿到了线程的调用栈。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&quot;CP Server Thread-10&quot; tid=139694658537216</span><br><span class="line">    at self.__bootstrap_inner()(threading.py:785)</span><br><span class="line">    at self.run()(threading.py:812)</span><br><span class="line">    at conn.communicate()(wsgiserver2.py:1532)</span><br><span class="line">    ... more omitted</span><br><span class="line">    at instances = list(db.select(&apos;instance&apos;, vars, where=&apos;app_name=$app_name and host=$host and port=$port&apos;))(xxx.py:233)</span><br><span class="line">    at return self.query(qout, processed=True)(db.py:720)</span><br><span class="line">    at self._db_execute(db_cursor, sql_query)(db.py:680)</span><br><span class="line">    at print(&apos;%s (%s): %s&apos; % (round(b-a, 2), self.ctx.dbq_count, str(sql_query)), file=debug)(db.py:623)</span><br><span class="line">    at out.write(x)(webapi.py:512)</span><br><span class="line"></span><br><span class="line">&quot;CP Server Thread-9&quot; tid=139694666929920</span><br><span class="line">    at self.__bootstrap_inner()(threading.py:785)</span><br><span class="line">    at self.run()(threading.py:812)</span><br><span class="line">    at conn.communicate()(wsgiserver2.py:1532)</span><br><span class="line">    ... more omitted </span><br><span class="line">    at apps = list(db.select(&apos;application&apos;, vars, where=&apos;name=$name&apos;))(xxx.py:149)</span><br><span class="line">    at return self.query(qout, processed=True)(db.py:720)</span><br><span class="line">    at self._db_execute(db_cursor, sql_query)(db.py:680)</span><br><span class="line">    at print(&apos;%s (%s): %s&apos; % (round(b-a, 2), self.ctx.dbq_count, str(sql_query)), file=debug)(db.py:623)</span><br><span class="line">    at out.write(x)(webapi.py:512)</span><br><span class="line"></span><br><span class="line">&quot;MainThread&quot; tid=139695478638400</span><br><span class="line">    at app.run()(xxx.py:326)</span><br><span class="line">    at return wsgi.runwsgi(self.wsgifunc(*middleware))(application.py:341)</span><br><span class="line">    at return httpserver.runsimple(func, server_addr)(wsgi.py:59)</span><br><span class="line">    at server.start()(httpserver.py:177)</span><br><span class="line">    at self.tick()(wsgiserver2.py:1956)</span><br><span class="line">    at s, addr = self.socket.accept()(wsgiserver2.py:2008)</span><br><span class="line">    at sock, addr = self._sock.accept()(socket.py:202)</span><br><span class="line">    at pystack()(pdbx.py:181)</span><br><span class="line">    at for filename, lineno, _, line in traceback.extract_stack(stack):(pdbx.py:169)</span><br><span class="line"></span><br><span class="line">... omit CP Server Thread-1 / Thread-2 / Thread-6 / Thread-7 / Thread-8</span><br><span class="line">... same as other thread</span><br><span class="line"></span><br><span class="line">&quot;CP Server Thread-4&quot; tid=139695180908288</span><br><span class="line">    at self.__bootstrap_inner()(threading.py:785)</span><br><span class="line">    at self.run()(threading.py:812)</span><br><span class="line">    at conn.communicate()(wsgiserver2.py:1532)</span><br><span class="line">    ... more omitted </span><br><span class="line">    at instances = list(db.select(&apos;instance&apos;, vars, where=&apos;app_name=$app_name and host=$host and port=$port&apos;))(xxx.py:233)</span><br><span class="line">    at return self.query(qout, processed=True)(db.py:720)</span><br><span class="line">    at self._db_execute(db_cursor, sql_query)(db.py:680)</span><br><span class="line">    at print(&apos;%s (%s): %s&apos; % (round(b-a, 2), self.ctx.dbq_count, str(sql_query)), file=debug)(db.py:623)</span><br><span class="line">    at out.write(x)(webapi.py:512)</span><br><span class="line"></span><br><span class="line">&quot;APScheduler&quot; tid=139695219828480</span><br><span class="line">    at self.__bootstrap_inner()(threading.py:785)</span><br><span class="line">    at self.run()(threading.py:812)</span><br><span class="line">    at self.__target(*self.__args, **self.__kwargs)(threading.py:765)</span><br><span class="line">    at self._event.wait(wait_seconds)(blocking.py:28)</span><br><span class="line">    at self.__cond.wait(timeout, balancing)(threading.py:622)</span><br><span class="line">    at waiter.acquire()(threading.py:339)</span><br><span class="line"></span><br><span class="line">&quot;CP Server Thread-3&quot; tid=139695189300992</span><br><span class="line">    at self.__bootstrap_inner()(threading.py:785)</span><br><span class="line">    at self.run()(threading.py:812)</span><br><span class="line">    at conn.communicate()(wsgiserver2.py:1532)</span><br><span class="line">    ... more omitted </span><br><span class="line">    at instances = list(db.select(&apos;instance&apos;, vars, where=&apos;app_name=$app_name and host=$host and port=$port&apos;))(xxx.py:233)</span><br><span class="line">    at return self.query(qout, processed=True)(db.py:720)</span><br><span class="line">    at self._db_execute(db_cursor, sql_query)(db.py:680)</span><br><span class="line">    at print(&apos;%s (%s): %s&apos; % (round(b-a, 2), self.ctx.dbq_count, str(sql_query)), file=debug)(db.py:623)</span><br><span class="line">    at out.write(x)(webapi.py:512)</span><br><span class="line"></span><br><span class="line">&quot;CP Server Thread-5&quot; tid=139695172515584</span><br><span class="line">    at self.__bootstrap_inner()(threading.py:785)</span><br><span class="line">    at self.run()(threading.py:812)</span><br><span class="line">    at conn.communicate()(wsgiserver2.py:1532)</span><br><span class="line">    ... more omitted </span><br><span class="line">    at instances = list(db.select(&apos;instance&apos;, vars, where=&apos;app_name=$app_name and host=$host and port=$port&apos;))(xxx.py:233)</span><br><span class="line">    at return self.query(qout, processed=True)(db.py:720)</span><br><span class="line">    at self._db_execute(db_cursor, sql_query)(db.py:680)</span><br><span class="line">    at print(&apos;%s (%s): %s&apos; % (round(b-a, 2), self.ctx.dbq_count, str(sql_query)), file=debug)(db.py:623)</span><br><span class="line">    at out.write(x)(webapi.py:512)</span><br></pre></td></tr></table></figure><p>OK，总计 10 个工作线程，全都阻塞在 <code>out.write(x)</code> ，多次打印调用栈结果相同。基本可以断定是 <code>write</code> 方法出了问题了。不过直到这个时候，都还是深陷在死锁原因中无法自拔（还是接触得太少了）。</p><p>虚度半个多钟… 后看代码了解到，其准备将 SQL 执行结果打印到标准错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_debugwrite</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        out = ctx.environ[<span class="string">'wsgi.errors'</span>]</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        out = sys.stderr</span><br><span class="line">    out.write(x)</span><br><span class="line">debug.write = _debugwrite</span><br></pre></td></tr></table></figure><p>果断去查看 Python 服务的文件描述符 <code>lsof -p &lt;PID&gt;</code> / <code>ls -al /proc/&lt;PID&gt;/fd</code> 。总算见着可信的证据了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; lsof -p &lt;PID&gt;</span><br><span class="line">python  139756 sysop    0r  FIFO     0,9       0t0 5210639 pipe</span><br><span class="line">python  139756 sysop    1w   REG   253,1      5187 1188500 /home/www/wwwroot/logs/eswitch-console.9999.log</span><br><span class="line">python  139756 sysop    2w  FIFO     0,9       0t0 5210641 pipe</span><br><span class="line">python  139756 sysop    3u  IPv4 5210787       0t0     TCP 10.1.5.60:65442-&gt;10.1.6.104:mysql (ESTABLISHED)</span><br><span class="line">python  139756 sysop    4r  FIFO     0,9       0t0 5210774 pipe</span><br><span class="line">python  139756 sysop    5w  FIFO     0,9       0t0 5210774 pipe</span><br><span class="line">python  139756 sysop    6r  FIFO     0,9       0t0 5210778 pipe</span><br><span class="line">python  139756 sysop    7w  FIFO     0,9       0t0 5210778 pipe</span><br><span class="line">python  139756 sysop    8u  IPv4 5210788       0t0     TCP *:distinct (LISTEN)</span><br><span class="line">python  139756 sysop    9u  IPv4 5226722       0t0     TCP localhost:distinct-&gt;localhost:26032 (CLOSE_WAIT)</span><br><span class="line">python  139756 sysop   10u  IPv4 5226858       0t0     TCP localhost:distinct-&gt;localhost:26052 (CLOSE_WAIT)</span><br><span class="line">... more omitted</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; ls -al /proc/&lt;PID&gt;/fd</span><br><span class="line">lr-x------ 1 sysop sysop 64 May 20 13:47 0 -&gt; pipe:[5210639]</span><br><span class="line">l-wx------ 1 sysop sysop 64 May 20 13:47 1 -&gt; /home/path/to/logs/xxx.log</span><br><span class="line">l-wx------ 1 sysop sysop 64 May 20 13:47 2 -&gt; pipe:[5210641]</span><br><span class="line">lrwx------ 1 sysop sysop 64 May 20 13:47 3 -&gt; socket:[5210787]</span><br><span class="line">lr-x------ 1 sysop sysop 64 May 20 13:47 4 -&gt; pipe:[5210774]</span><br><span class="line">l-wx------ 1 sysop sysop 64 May 20 13:47 5 -&gt; pipe:[5210774]</span><br><span class="line">lr-x------ 1 sysop sysop 64 May 20 13:47 6 -&gt; pipe:[5210778]</span><br><span class="line">l-wx------ 1 sysop sysop 64 May 20 13:47 7 -&gt; pipe:[5210778]</span><br><span class="line">... more omitted</span><br></pre></td></tr></table></figure><p>标准错误(fd = 2)指向了一个匿名管道（inode = 5210641）。但是找遍整个系统都没有这个匿名管道的读取方，只有写入方</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; sudo lsof | grep 5210641</span><br><span class="line">bash      139747          sysop    2w     FIFO                0,9       0t0    5210641 pipe</span><br><span class="line">python    139756          sysop    2w     FIFO                0,9       0t0    5210641 pipe</span><br><span class="line">python    139756 139764   sysop    2w     FIFO                0,9       0t0    5210641 pipe</span><br></pre></td></tr></table></figure><p>OK，合理的解释出现了。管道的缓冲区大小有限(经过测试是 64KB)，Python 服务在不断地向标准错误打印日志，从而导致匿名管道(inode = 5210641)的缓冲区数据不断积累，最终达到满的状态。这个过程大概需要一天多的心跳包才能积累得到。而系统调用 <code>write</code> 发现标准错误对应的文件已满，为等待 IO 就绪而陷入睡眠状态。同时，Main 线程在不断地 Accept 新的套接字的建立，而没有更多工作线程来处理新的请求，Nginx 因为连接超时直接发出来 FIN 包。最后，积累了几千/上万请求的 Python 服务也没法主动 close 已有的套接字（即 FIN,ACK 包因为没法发送而在本机不断积累 <code>CLOSE_WAIT</code> 状态的连接）</p><h3 id="重定向标准错误的原因"><a href="#重定向标准错误的原因" class="headerlink" title="重定向标准错误的原因"></a>重定向标准错误的原因</h3><p>至于为何会将标准错误重定向到一个匿名管道呢？百思不得其解，不过最后还是从应用负责人那儿得到了提示。新的发布方式采用了全新的启动命令:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -fn xx.xx.x.60 <span class="string">'cd /home/path/to/xxx ; python -u xxx.py 8080 &gt;&gt; /home/path/to/logs/xxx.log'</span></span><br></pre></td></tr></table></figure><p>一看就能和前面的原因衔接，使用 ssh 直接调用命名，不会建立一个终端，由 ssh 远程命令启动的任务，其标准输入/输出/错误默认将会通过管道重定向的 ssh server 端，并通过网络传回发起的 ssh client 端。</p><p><em>以发起 <code>ssh -fn ...</code> 的机器为 xx.192，目标机器为 xx.60</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">xx.192                       |           xx.60</span><br><span class="line">-----------------------------+-------------------------------</span><br><span class="line">                             | </span><br><span class="line">  ssh client                 |          ssh serve           python serve</span><br><span class="line">+------------+               |        +------------+       +-------------+</span><br><span class="line">| 0 | stdin  |               |        | y | pipe[a]| &lt;---&gt; | 0 | pipe[a] |</span><br><span class="line">| 1 | stdout |               |        | z | pipe[b]| &lt;-+   | 1 | xxx.log |</span><br><span class="line">| 2 | stderr |               |        |   |        |   +-&gt; | 2 | pipe[b] |</span><br><span class="line">| ...        |               |        | ...        |       | ...         |</span><br><span class="line">| x | sock   | &lt;--------------------&gt; | w | sock   |       | ...         |</span><br><span class="line">+------------+               |        +------------+       +-------------+</span><br></pre></td></tr></table></figure><p>Python 服务通过管道与 ssh serve 进行进程间交互，最终会将标准错误打印到 192 机器的标准输出/错误上（一般是终端，也就是我们将在终端上看到 Python 服务的错误日志）。而问题在于 ssh serve 任务被杀掉了，从而 <code>pipe[b]</code> 只能不断地向匿名管道写入数据，而没有任务读取数据，一天多时间也就将缓冲区写满了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到此为止，问题总算得到了圆满的解释，历时 5 天。最重要的就是通过调用栈定位代码阻塞的原因，否则就真是瞎找。对于匿名管道问题的发现、write 系统调用导致的线程睡眠，都是建立在调用栈信息之上的定向探究的过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;历时一周总算把导致服务大量 &lt;code&gt;CLOSE_WAIT&lt;/code&gt; 的原因给找到了。打印任务调用栈果然的必备手段啊！&lt;/p&gt;
&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;Python 服务 A，用于接收心跳包确认其他服务是否存活。其他服务每 5 分钟向 A 发送一次心跳包；总计 &amp;lt; 100 个其他服务。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;05-11 19:30 ，首次出现 Python 服务大量 &lt;code&gt;CLOSE_WAIT&lt;/code&gt;，至 13 日发现，总计 10k 左右 &lt;code&gt;CLOSE_WAIT&lt;/code&gt; 的 TCP 连接。05-13 15:30 通过运维平台重新部署…&lt;/li&gt;
&lt;li&gt;05-14 16:30 ，再次出现。19:30 手动重启。&lt;/li&gt;
&lt;li&gt;其间给 Python 服务 A 添加了打印调用栈的模块 &lt;a href=&quot;https://pypi.org/project/pdbx/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pdbx&lt;/a&gt;，通过运维平台重新部署&lt;/li&gt;
&lt;li&gt;05-17 19:00 ，再次出现。等待打印调用栈，不小心杀掉了服务…&lt;/li&gt;
&lt;li&gt;05-19 14:30 ，重现。&lt;/li&gt;
&lt;li&gt;05-20 08:30 ，查找原因，解决问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于不是本人负责的服务，于 16 日凭兴趣开始有限介入，协助排查。现将排查流程一一记述，给自己和大家未来排查问题提供一个借鉴。&lt;/p&gt;
    
    </summary>
    
    
      <category term="pipe" scheme="https://DorMOUSE-None.github.io/tags/pipe/"/>
    
      <category term="CLOSE_WAIT" scheme="https://DorMOUSE-None.github.io/tags/CLOSE-WAIT/"/>
    
  </entry>
  
  <entry>
    <title>PNG 文件格式</title>
    <link href="https://DorMOUSE-None.github.io/2019-05-10-png-structure/"/>
    <id>https://DorMOUSE-None.github.io/2019-05-10-png-structure/</id>
    <published>2019-05-09T16:00:00.000Z</published>
    <updated>2019-05-11T08:40:47.886Z</updated>
    
    <content type="html"><![CDATA[<p>PNG (Portable Network Graphics) 文件格式(第二版)。PNG 文件格式由两类结构——<code>PNG 签名(PNG Signature)</code>和若干<code>数据块(chunk)</code>组成。</p><p>PNG 签名相当于其他文件格式中的魔数，用于声明二进制数据所代表的格式。类似的有 <code>JAVA</code> class 文件的 <code>ca fe ba be</code>、<code>ELF</code> 文件的 <code>7f 45 4c 46</code> (.ELF) 。PNG 签名使用 <code>89 50 4e 47 0d 0a 1a 0a</code> (.PNG….) 作为魔数。</p><blockquote><p>HINT 上述的 <code>.</code> 仅仅是为了指代非打印字符，并非真的是 <code>点号</code>。</p></blockquote><p>在 <code>PNG 签名</code> 数据之后，紧接着就是 <code>数据块(chunk)</code> 的数据。虽然统称<code>数据块</code>，但存在不同类型的数据块（例如 IHDR, PLTE, IDAT, IEND 等）。每个 PNG 文件可以有若干连续的数据块（至少 3 个数据块），其中第一个数据块和最后一个数据块类型分别是 IHDR、IEND 。</p><a id="more"></a><h2 id="Chunk-Layout"><a href="#Chunk-Layout" class="headerlink" title="Chunk Layout"></a>Chunk Layout</h2><p>数据块由三/四部分组成：长度、数据块类型、数据（可选）、CRC 校验码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ ------ + ---------- + ---------- + --- +</span><br><span class="line">| LENGTH | CHUNK TYPE | CHUNK DATA | CRC |</span><br><span class="line">+ ------ + ---------- + ---------- + --- +</span><br><span class="line">OR</span><br><span class="line">+ --------- + ---------- + --- +</span><br><span class="line">| LENGTH(0) | CHUNK TYPE | CRC |</span><br><span class="line">+ --------- + ---------- + --- +</span><br></pre></td></tr></table></figure><ul><li>长度 (4 bytes, unsigned integer): 只负责记录数据(CHUNK DATA)的长度</li><li>数据块类型 (4 bytes, char sequence): 由 4 个大小写字母组成</li><li>数据: 一系列数据字符</li><li>CRC (4 bytes): 循环冗余校验码。对数据块类型和数据两块二进制信息进行校验，不包括长度部分。</li></ul><p><strong>数据类型</strong></p><p>有趣的是：由4个大小写字母组成的数据块类型还额外的携带了一些配置信息。通过大写代表0，小写代表1。这里提供了4 bits信息。</p><ul><li>第一个字母: <ul><li>0 (critical, 决定性的数据块)</li><li>1 (ancillary, 辅助性的数据块)</li></ul></li><li>第二个字母:<ul><li>0 (public, 由本协议预定义的数据块类型)</li><li>1 (private, 自定义的数据块类型)</li></ul></li><li>第三个字母:<ul><li>0 (遵循当前版本规范的数据块)</li><li>1 (为未来版本预留的位)</li></ul></li><li>第四个字母:<ul><li>0 (unsafe to copy)</li><li>1 (safe to copy)</li></ul></li></ul><p>例如数据类型 <code>cHNk</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cHNk  &lt;-- 32 bit chunk type represented in text form</span><br><span class="line">||||</span><br><span class="line">|||+- Safe-to-copy bit is 1 (lower case letter; bit 5 is 1)</span><br><span class="line">||+-- Reserved bit is 0     (upper case letter; bit 5 is 0)</span><br><span class="line">|+--- Private bit is 0      (upper case letter; bit 5 is 0)</span><br><span class="line">+---- Ancillary bit is 1    (lower case letter; bit 5 is 1)</span><br></pre></td></tr></table></figure><center>数据块顺序规范</center><br><center><small>Copied From <a href="https://www.w3.org/TR/2003/REC-PNG-20031110/" target="_blank" rel="noopener">W3C PNG Specification (Table 5.3)</a></small></center><table><thead><tr><th>决定性的数据块类型</th><th></th><th></th></tr></thead><tbody><tr><td>类型</td><td>是否允许出现多次</td><td>顺序限制</td></tr><tr><td><a href="https://www.w3.org/TR/2003/REC-PNG-20031110/#11IHDR" target="_blank" rel="noopener"><strong>IHDR</strong></a></td><td>No</td><td>必须出现在开始处</td></tr><tr><td><a href="https://www.w3.org/TR/2003/REC-PNG-20031110/#11PLTE" target="_blank" rel="noopener"><strong>PLTE</strong></a></td><td>No</td><td>必须早于第一个 <strong>IDAT</strong></td></tr><tr><td><a href="https://www.w3.org/TR/2003/REC-PNG-20031110/#11IDAT" target="_blank" rel="noopener"><strong>IDAT</strong></a></td><td>Yes</td><td>可选；多个 <strong>IDAT</strong> 必须连续，不允许间断</td></tr><tr><td><a href="https://www.w3.org/TR/2003/REC-PNG-20031110/#11IEND" target="_blank" rel="noopener"><strong>IEND</strong></a></td><td>No</td><td>必须出现在结束处</td></tr><tr><td>辅助性的数据块类型</td><td></td><td></td></tr><tr><td>类型</td><td>是否允许出现多次</td><td>顺序限制</td></tr><tr><td><a href="https://www.w3.org/TR/2003/REC-PNG-20031110/#11cHRM" target="_blank" rel="noopener"><strong>cHRM</strong></a></td><td>No</td><td>可选；需早于 <strong>PLTE</strong> 和 <strong>IDAT</strong> 出现</td></tr><tr><td><a href="https://www.w3.org/TR/2003/REC-PNG-20031110/#11gAMA" target="_blank" rel="noopener"><strong>gAMA</strong></a></td><td>No</td><td>可选；需早于 <strong>PLTE</strong> 和 <strong>IDAT</strong> 出现</td></tr><tr><td><a href="https://www.w3.org/TR/2003/REC-PNG-20031110/#11iCCP" target="_blank" rel="noopener"><strong>iCCP</strong></a></td><td>No</td><td>可选；需早于 <strong>PLTE</strong> 和 <strong>IDAT</strong> 出现；与 <strong>sBIT</strong> 不能同时出现</td></tr><tr><td><a href="https://www.w3.org/TR/2003/REC-PNG-20031110/#11sBIT" target="_blank" rel="noopener"><strong>sBIT</strong></a></td><td>No</td><td>可选；需早于 <strong>PLTE</strong> 和 <strong>IDAT</strong> 出现</td></tr><tr><td><a href="https://www.w3.org/TR/2003/REC-PNG-20031110/#11sRGB" target="_blank" rel="noopener"><strong>sRGB</strong></a></td><td>No</td><td>可选；需早于 <strong>PLTE</strong> 和 <strong>IDAT</strong> 出现；与 <strong>iCCP</strong> 不能同时出现</td></tr><tr><td><a href="https://www.w3.org/TR/2003/REC-PNG-20031110/#11bKGD" target="_blank" rel="noopener"><strong>bKGD</strong></a></td><td>No</td><td>可选；在 <strong>PLTE</strong> 之后，<strong>IDAT</strong> 之前出现</td></tr><tr><td><a href="https://www.w3.org/TR/2003/REC-PNG-20031110/#11hIST" target="_blank" rel="noopener"><strong>hIST</strong></a></td><td>No</td><td>可选；在 <strong>PLTE</strong> 之后，<strong>IDAT</strong> 之前出现</td></tr><tr><td><a href="https://www.w3.org/TR/2003/REC-PNG-20031110/#11tRNS" target="_blank" rel="noopener"><strong>tRNS</strong></a></td><td>No</td><td>可选；在 <strong>PLTE</strong> 之后，<strong>IDAT</strong> 之前出现</td></tr><tr><td><a href="https://www.w3.org/TR/2003/REC-PNG-20031110/#11pHYs" target="_blank" rel="noopener"><strong>pHYs</strong></a></td><td>No</td><td>可选；在 <strong>IDAT</strong> 之前出现</td></tr><tr><td><a href="https://www.w3.org/TR/2003/REC-PNG-20031110/#11sPLT" target="_blank" rel="noopener"><strong>sPLT</strong></a></td><td>Yes</td><td>可选；在 <strong>IDAT</strong> 之前出现</td></tr><tr><td><a href="https://www.w3.org/TR/2003/REC-PNG-20031110/#11tIME" target="_blank" rel="noopener"><strong>tIME</strong></a></td><td>No</td><td>可选</td></tr><tr><td><a href="https://www.w3.org/TR/2003/REC-PNG-20031110/#11iTXt" target="_blank" rel="noopener"><strong>iTXt</strong></a></td><td>Yes</td><td>可选</td></tr><tr><td><a href="https://www.w3.org/TR/2003/REC-PNG-20031110/#11tEXt" target="_blank" rel="noopener"><strong>tEXt</strong></a></td><td>Yes</td><td>可选</td></tr><tr><td><a href="https://www.w3.org/TR/2003/REC-PNG-20031110/#11zTXt" target="_blank" rel="noopener"><strong>zTXt</strong></a></td><td>Yes</td><td>可选</td></tr></tbody></table><p>如果想要可视化直观的了解，详见 <a href="https://www.w3.org/TR/2003/REC-PNG-20031110/#figure52" target="_blank" rel="noopener">W3C PNG Specification (Figure 5.2/5.3)</a></p><h2 id="Color-Type"><a href="#Color-Type" class="headerlink" title="Color Type"></a>Color Type</h2><p>根据图像的颜色类型划分，PNG 总计支持五类图像。</p><table><thead><tr><th>PNG image type</th><th>Colour type</th></tr></thead><tbody><tr><td>灰度</td><td>0</td></tr><tr><td>真彩色</td><td>2</td></tr><tr><td>索引颜色</td><td>3</td></tr><tr><td>有透明通道的灰度</td><td>4</td></tr><tr><td>有透明通道的真彩色</td><td>6</td></tr></tbody></table><p>针对这五种类型，其实都支持透明度配置，只是各有区分罢了。灰度(0)、真彩色(2)、索引颜色(3) 通过 <strong>tRNS</strong> 数据块来维护透明度设置。其中灰度(0)、真彩色(2)支持由配置一个统一的透明度(2字节)，无法为每个像素单独配置透明度；索引颜色(3)支持为每个索引颜色设置透明度，但每个索引颜色的透明度设置最大只有 8 bits 的选择空间。</p><p>对于有透明通道的真彩色(6)、灰度(4)，它们不能拥有 <strong>tRNS</strong> 数据块，因为它们本身的就有透明通道来记录每个像素点的透明度。</p><h2 id="Interlacing-and-pass-extraction"><a href="#Interlacing-and-pass-extraction" class="headerlink" title="Interlacing and pass extraction"></a>Interlacing and pass extraction</h2><p>交错渲染，中文资料中更多看到“隔行渲染”的翻译。PNG 提供 Interlace 选项: 0(不交错渲染)、1(Adam7 算法交错渲染)。</p><p>Adam7 交错渲染可以简单的理解为将图像像素点矩阵划分为7级，如下表，逐级分别提取 1~7 级都能构成一个矩阵，每个级别与更高级别只是相近的像素点缺失了。但随着 1~7 级获得的像素点信息越多，图像就会越细腻。从而达到网络加载图片逐渐从模糊到清晰的效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 6 4 6 2 6 4 6</span><br><span class="line">7 7 7 7 7 7 7 7</span><br><span class="line">5 6 5 6 5 6 5 6</span><br><span class="line">7 7 7 7 7 7 7 7</span><br><span class="line">3 6 4 6 3 6 4 6</span><br><span class="line">7 7 7 7 7 7 7 7</span><br><span class="line">5 6 5 6 5 6 5 6</span><br><span class="line">7 7 7 7 7 7 7 7</span><br></pre></td></tr></table></figure><h2 id="Chunk-specifications"><a href="#Chunk-specifications" class="headerlink" title="Chunk specifications"></a>Chunk specifications</h2><p>下列的各个数据块的内容，将以一套比较实际的二进制数据来辅助解析。</p><h3 id="IHDR"><a href="#IHDR" class="headerlink" title="IHDR"></a>IHDR</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Width</td><td>4 bytes</td></tr><tr><td>Height</td><td>4 bytes</td></tr><tr><td>Bit depth</td><td>1 byte</td></tr><tr><td>Colour type</td><td>1 byte</td></tr><tr><td>Compression method</td><td>1 byte</td></tr><tr><td>Filter method</td><td>1 byte</td></tr><tr><td>Interlace method</td><td>1 byte</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0000 000d 4948 4452 0000 004c 0000 0019 </span><br><span class="line">0806 0000 009b d4c8 6f</span><br><span class="line"></span><br><span class="line">LENGTH: 0x0000000d</span><br><span class="line">TYPE: 0x49484452 (IHDR)</span><br><span class="line">Width: 0x0000004c (76)</span><br><span class="line">Height: 0x00000019 (25)</span><br><span class="line">Bit depth: 08 (每样本点取值区间 0 ~ 2^8-1)</span><br><span class="line">Colour type: 06 (有透明通道的真彩色)</span><br><span class="line">Compression method: 00 (默认)</span><br><span class="line">Filter method: 00 (五种过滤算法自适应)</span><br><span class="line">Interlace method: 00 (无交错渲染)</span><br><span class="line">CRC: 0x9bd4c86f</span><br></pre></td></tr></table></figure><h3 id="PLTE"><a href="#PLTE" class="headerlink" title="PLTE"></a>PLTE</h3><p>索引颜色(3)所使用的数据块，用于描述每个索引对应的 RGB 值（每个 RBG 值总计占 3 字节）</p><p>索引颜色主要见于使用较少颜色的图像中，对出现的颜色建立索引，每个像素点直接指向索引即可。</p><h3 id="IDAT"><a href="#IDAT" class="headerlink" title="IDAT"></a>IDAT</h3><p>IDAT 数据块用于存储各像素点的数据，具体数据由 <strong>IHDR</strong> 中声明的 <code>Filter method</code> 和 <code>Compression method</code> 共同决定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0000 0020 4944 4154 081d 63e8 64fd f9bf </span><br><span class="line">9de3 bb02 0308 8038 400a 8419 9840 0410 </span><br><span class="line">3082 0800 dcfc 07b5 4c0c 837a </span><br><span class="line"></span><br><span class="line">LENGTH: 0x00000020 (32 bytes)</span><br><span class="line">TYPE: 0x49444154 (IDAT)</span><br><span class="line">DATA: 稍后解析</span><br><span class="line">CRC: 0x4c0c837a</span><br></pre></td></tr></table></figure><p>DATA 部分的数据由于已经被压缩过了，因此看不出任何与原图相关的内容 <a href="https://github.com/DorMOUSE-None/Repo/blob/master/z.png" target="_blank" rel="noopener">原图</a> 大小为 3×3 像素</p><p>OK，在 <strong>IHDR</strong> 有个数据描述的是使用的压缩算法 (Compression)，0 代表默认，即 PNG 规范所指出的 Zlib 。在 MacOS 下，抽取出 DATA 数据，用 <code>zlib_decompress</code> 解压，得到如下数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000: 0089 05f9 ff87 08f7 2000 0000 00  </span><br><span class="line">0000000d: 0089 05f9 ff00 0000 ff00 0000 00  </span><br><span class="line">0000001a: 0200 0000 0000 0000 0100 0000 00</span><br></pre></td></tr></table></figure><p>OK，现在应该能看出点内容来了。<strong>Colour Type</strong> 描述过图像是带透明通道的真彩色，每个样本点用 8 bits 来描述。3×3 的图像也就意味着需要 4 字节/像素 (RGBA) × 3 像素/行 × 3 行 = 36 字节。好吧，莫名其妙多了 3 字节？这当然与 <code>Filter method</code> 有关。用于描述图像每行的像素点将被如何描述。0 代表直接通过 RGBA 描述，而 2 代表需要借助上一行数据与当前行做累加。还有更多详见 <a href="https://www.w3.org/TR/2003/REC-PNG-20031110/#9Filters" target="_blank" rel="noopener">Filters</a></p><p>每行像素点描述的最开始一个字节就是对 <code>Filter method</code> 所使用的类型的描述。</p><p>简单解析一下，9 个像素点的数据如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000: 8905f9ff 8708f720 00000000  </span><br><span class="line">0000000d: 8905f9ff 000000ff 00000000  </span><br><span class="line">0000001a: 8905f9ff 00000000 00000000</span><br></pre></td></tr></table></figure><p>去看看<a href="https://github.com/DorMOUSE-None/Repo/blob/master/z.png" target="_blank" rel="noopener">实际的图像</a>，恰如解析出的结果，完全匹配。</p><h3 id="IEND"><a href="#IEND" class="headerlink" title="IEND"></a>IEND</h3><p><strong>IEND</strong> 的内容最为简单，只是为了标识 chunks 的结束。其内容就是 <code>00000000 49454e44 ae426082</code></p><h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p>PNG 规范的文档很长，对规范的描述也相当详细，除了对初次接触图像的非专业人士存在很大的障碍。有太多的新名词的出现。</p><p>本篇仅仅只是摘录及翻译了一部分内容，只是为了能够对 PNG 的文件格式建立初步的印象，以及能够简单解析一些图像信息。更多的内容请移步 <a href="https://www.w3.org/TR/2003/REC-PNG-20031110/" target="_blank" rel="noopener">PNG 规范</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PNG (Portable Network Graphics) 文件格式(第二版)。PNG 文件格式由两类结构——&lt;code&gt;PNG 签名(PNG Signature)&lt;/code&gt;和若干&lt;code&gt;数据块(chunk)&lt;/code&gt;组成。&lt;/p&gt;
&lt;p&gt;PNG 签名相当于其他文件格式中的魔数，用于声明二进制数据所代表的格式。类似的有 &lt;code&gt;JAVA&lt;/code&gt; class 文件的 &lt;code&gt;ca fe ba be&lt;/code&gt;、&lt;code&gt;ELF&lt;/code&gt; 文件的 &lt;code&gt;7f 45 4c 46&lt;/code&gt; (.ELF) 。PNG 签名使用 &lt;code&gt;89 50 4e 47 0d 0a 1a 0a&lt;/code&gt; (.PNG….) 作为魔数。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HINT 上述的 &lt;code&gt;.&lt;/code&gt; 仅仅是为了指代非打印字符，并非真的是 &lt;code&gt;点号&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 &lt;code&gt;PNG 签名&lt;/code&gt; 数据之后，紧接着就是 &lt;code&gt;数据块(chunk)&lt;/code&gt; 的数据。虽然统称&lt;code&gt;数据块&lt;/code&gt;，但存在不同类型的数据块（例如 IHDR, PLTE, IDAT, IEND 等）。每个 PNG 文件可以有若干连续的数据块（至少 3 个数据块），其中第一个数据块和最后一个数据块类型分别是 IHDR、IEND 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="File Format" scheme="https://DorMOUSE-None.github.io/tags/File-Format/"/>
    
      <category term="PNG" scheme="https://DorMOUSE-None.github.io/tags/PNG/"/>
    
  </entry>
  
  <entry>
    <title>MySQL TIMESTAMP 时间精度问题</title>
    <link href="https://DorMOUSE-None.github.io/2019-04-26-time-accuracy/"/>
    <id>https://DorMOUSE-None.github.io/2019-04-26-time-accuracy/</id>
    <published>2019-04-25T16:00:00.000Z</published>
    <updated>2019-04-26T01:37:09.672Z</updated>
    
    <content type="html"><![CDATA[<p>最近一段单元测试代码总是不定时地爆炸。test pass 与 failed 的比例大约 10:1 。伪代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 表结构</span></span><br><span class="line"><span class="comment">  * CREATE TABLE `time_0` (</span></span><br><span class="line"><span class="comment">  *     `timeout` timestamp NOT NULL</span></span><br><span class="line"><span class="comment">  * )</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// part 1</span></span><br><span class="line">jdbcTemplate.execute(<span class="string">"UPDATE `time_0` SET `timeout`=now() WHERE `id` = xxx;"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// part 2</span></span><br><span class="line">Date timeout = jdbcTemplate.queryForObject(<span class="string">"SELECT `timeout` FROM `time_0` WHERE `id` = xxx;"</span>, Date.class);</span><br><span class="line">Assert.assertTrue(timeout.getTime() &lt; System.currentTimeMillis());</span><br></pre></td></tr></table></figure><p>在绝大多数模拟中，先执行 <code>part 1</code>，紧跟着执行 <code>part 2</code> 都能通过测试。但偶尔还是挂掉了。</p><a id="more"></a><h2 id="MySQL-时间表示"><a href="#MySQL-时间表示" class="headerlink" title="MySQL 时间表示"></a>MySQL 时间表示</h2><table><thead><tr><th><strong>Type</strong></th><th><strong>Storage before MySQL 5.6.4</strong></th><th><strong>Storage as of MySQL 5.6.4</strong></th></tr></thead><tbody><tr><td>YEAR</td><td>1 byte, little endian</td><td>Unchanged</td></tr><tr><td>DATE</td><td>3 bytes, little endian</td><td>Unchanged</td></tr><tr><td>TIME</td><td>3 bytes, little endian</td><td>3 bytes + fractional-seconds storage, big endian</td></tr><tr><td>TIMESTAMP</td><td>4 bytes, little endian</td><td>4 bytes + fractional-seconds storage, big endian</td></tr><tr><td>DATETIME</td><td>8 bytes, little endian</td><td>5 bytes + fractional-seconds storage, big endian</td></tr></tbody></table><center><small>本表来源于 <a href="https://dev.mysql.com/doc/internals/en/date-and-time-data-type-representation.html" target="_blank" rel="noopener">Date and Time Data Type Representation</a></small></center><p><code>TimeStamp</code> 由四字节描述，可以存储 <code>1970-01-01 00:00:00</code> 到 <code>2038-01-19 03:14:07</code>。4 字节存储正好是精确到秒为止。根据表中所描述的毫秒存储，是依赖于额外的存储空间。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">'version'</span>;</span><br><span class="line">+---------------+--------+</span><br><span class="line">| Variable_name | Value  |</span><br><span class="line">+---------------+--------+</span><br><span class="line">| version       | 5.7.20 |</span><br><span class="line">+---------------+--------+</span><br></pre></td></tr></table></figure><p>OK，版本大于 5.6.4，能够支持毫秒级精度。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysql-cli 直接插入新的数据</span></span><br><span class="line">mysql&gt; INSERT INTO `time_0` (timeout) VALUES (<span class="string">'2019-04-26 08:00:00.500'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># Check 结果</span></span><br><span class="line">mysql&gt; SELECT * FROM `time_0`;</span><br><span class="line">+---------------------+</span><br><span class="line">| timeout             |</span><br><span class="line">+---------------------+</span><br><span class="line">| 2019-04-26 08:00:01 |</span><br><span class="line">+---------------------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p>被向上取整了？没有存储毫秒级数据？还是说 <code>SELECT</code> 展示结果的时候被加工了？直接去检查数据文件 <code>/path/to/time_0.ibd</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2019-04-26 08:00:00 -&gt; 1556236800 second -&gt; 0x5cc24a00 </span></span><br><span class="line"><span class="comment"># 2019-04-26 08:00:00 -&gt; 1556236801 second -&gt; 0x5cc24a01</span></span><br><span class="line">$ xxd time_0.ibd | grep 5cc2</span><br><span class="line">0000c090: 5cc2 4a01 0000 0000 0000 0000 0000 0000  \.J.............</span><br></pre></td></tr></table></figure><p>存储时已经被四舍五入了，存了 <code>5cc24a01</code>。</p><p>:&lt; 如果需要存储毫秒级精度，需要在声明类型 <code>timestamp</code> 时添加毫秒精度的声明。Like <code>timestamp(1)</code>：最小精度 0.1 秒。不同的毫秒精度还将决定所需的存储空间大小。</p><table><thead><tr><th>毫秒精度</th><th>存储空间</th></tr></thead><tbody><tr><td>0</td><td>0 bytes</td></tr><tr><td>1,2</td><td>1 byte</td></tr><tr><td>3,4</td><td>2 bytes</td></tr><tr><td>4,5</td><td>3 bytes</td></tr></tbody></table><p>新建表 <code>time_1</code> (timestamp(3))</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into time_1 (timeout) values (<span class="string">'2019-04-26 08:00:00.500'</span>);</span><br><span class="line">mysql&gt; select * from time_1;</span><br><span class="line">+----+-------------------------+</span><br><span class="line">| id | timeout                 |</span><br><span class="line">+----+-------------------------+</span><br><span class="line">|  1 | 2019-04-26 08:00:00.500 |</span><br><span class="line">+----+-------------------------+</span><br></pre></td></tr></table></figure><p>从 <code>/path/to/time_1.ibd</code> 检查数据</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2019-04-26 08:00:00.500 -&gt; 2019-04-26 08:00:00.5000  3,4 位毫秒级精度存储方式相同</span></span><br><span class="line"><span class="comment"># -&gt; 1556236800.5000 second -&gt; 0x5cc24a00 0x1388</span></span><br><span class="line">$ xxd time_1.ibd | grep -A 1 5cc2</span><br><span class="line">0000c080: 0100 0000 008c 87ce 0000 01e4 0110 5cc2  ..............\.</span><br><span class="line">0000c090: 4a00 1388 0000 0000 0000 0000 0000 0000  J...............</span><br></pre></td></tr></table></figure><p>OK，看来确实如此。</p><h2 id="NOW"><a href="#NOW" class="headerlink" title="NOW()"></a>NOW()</h2><p>确认了 MySQL 对 <code>TIMESTAMP</code> 的存储方式。还有 <code>now()</code> 函数的表现亟待确认。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT now();</span><br><span class="line">+---------------------+</span><br><span class="line">| now()               |</span><br><span class="line">+---------------------+</span><br><span class="line">| 2019-04-26 09:03:27 |</span><br><span class="line">+---------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT now(3);</span><br><span class="line">+-------------------------+</span><br><span class="line">| now(3)                  |</span><br><span class="line">+-------------------------+</span><br><span class="line">| 2019-04-26 09:03:31.491 |</span><br><span class="line">+-------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># 加入 `sleep(1)` 是为了体现两个 now() 是同时产生效果的。</span><br><span class="line"># 但并没有出现四舍五入的现象。从网上的源码看到 now(3) 对于毫秒级数据是额外附加的。</span><br><span class="line">mysql&gt; SELECT now(), sleep(1), now(3);</span><br><span class="line">+---------------------+----------+-------------------------+</span><br><span class="line">| now()               | sleep(1) | now(3)                  |</span><br><span class="line">+---------------------+----------+-------------------------+</span><br><span class="line">| 2019-04-26 09:04:58 |        0 | 2019-04-26 09:04:58.946 |</span><br><span class="line">+---------------------+----------+-------------------------+</span><br><span class="line">1 row in set (1.00 sec)</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>综合 <code>now()</code> 和 <code>timestamp</code> 的表现，结论就是默认是按向下取整的方式进行的。因为 <code>UPDATE</code> 语句用了 <code>now()</code>。</p><p>既然如此，还能够出现已经设置 <code>timeout = now()</code> 而 SELECT 得到的 <code>timeout &gt; System.currentTimeMillis()</code>。只能推断为数据库服务器和本机的系统时间不一致，而且数据库服务器的时间更快，但快的有限，不超过 1 秒。</p><p>至于如何比较两台机器的时间差，<code>clockdiff</code> 是个好工具，但没找到 MacOS 下的替代品。具体计算时间差，只能暂时放弃了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一段单元测试代码总是不定时地爆炸。test pass 与 failed 的比例大约 10:1 。伪代码如下:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;  * 表结构&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;  * CREATE TABLE `time_0` (&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;  *     `timeout` timestamp NOT NULL&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;  * )&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;  */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// part 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;jdbcTemplate.execute(&lt;span class=&quot;string&quot;&gt;&quot;UPDATE `time_0` SET `timeout`=now() WHERE `id` = xxx;&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// part 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Date timeout = jdbcTemplate.queryForObject(&lt;span class=&quot;string&quot;&gt;&quot;SELECT `timeout` FROM `time_0` WHERE `id` = xxx;&quot;&lt;/span&gt;, Date.class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Assert.assertTrue(timeout.getTime() &amp;lt; System.currentTimeMillis());&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在绝大多数模拟中，先执行 &lt;code&gt;part 1&lt;/code&gt;，紧跟着执行 &lt;code&gt;part 2&lt;/code&gt; 都能通过测试。但偶尔还是挂掉了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="https://DorMOUSE-None.github.io/tags/MySQL/"/>
    
      <category term="DateTime" scheme="https://DorMOUSE-None.github.io/tags/DateTime/"/>
    
      <category term="TimeStamp" scheme="https://DorMOUSE-None.github.io/tags/TimeStamp/"/>
    
      <category term="time accuracy" scheme="https://DorMOUSE-None.github.io/tags/time-accuracy/"/>
    
  </entry>
  
  <entry>
    <title>Lex &amp; Yacc 学习笔记</title>
    <link href="https://DorMOUSE-None.github.io/2019-04-25-lex-and-yacc/"/>
    <id>https://DorMOUSE-None.github.io/2019-04-25-lex-and-yacc/</id>
    <published>2019-04-24T16:00:00.000Z</published>
    <updated>2019-04-25T00:42:02.963Z</updated>
    
    <content type="html"><![CDATA[<p>高级语言相较于机器语言、汇编语言，更加符合人的思考习惯。换句话说，更偏向于自然语言的风格而更偏离指令化的描述。用高级语言编写的一行代码，最终可能需要处理器执行若干条指令。如何让机器意识到高级语言代码对应的机器指令是哪些呢？当然就需要一个优秀的翻译。</p><p>无论是编译型语言还是解释型语言，总逃脱不了这样一个流程：高级语言 ➜ 目标平台的指令。所谓编译型/解释型的区别，在于其转换流程是在线的(online)还是离线的(offline)。在线的方式无法意识到后续的代码，但胜在即时反应；离线的方式可以统揽全局，进行更多的优化，但代码文本必须完整。</p><p>高级语言 ➜ 目标平台的指令，这样的流程如何实现。一般来说，划分为四个阶段：词法分析、语法分析、语义分析、目标代码生成。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g2b583io0ej30wq094aa5.jpg" alt=""></p><p>本篇的主要目的，是展示“语言翻译”的几个阶段工作，以及通过 Lex &amp; Yacc 工具演示一门自定义语言的“翻译”。</p><a id="more"></a><h2 id="词法分析-lt-Lex"><a href="#词法分析-lt-Lex" class="headerlink" title="词法分析 &lt;- Lex"></a>词法分析 &lt;- Lex</h2><p>词法分析的核心就是识别源代码，并将它按照特定的规则划分成一系列的标记(Token)。</p><p>比如 <code>int value = 12 + 23 * 323</code> 以 C 语言的划分方式可以分成 <code>int</code>, <code>value</code>, <code>=</code>, <code>12</code>, <code>+</code>, <code>23</code>, <code>*</code>, <code>323</code> 这些标记。</p><p>如何将源代码划分为标记呢？再不济不过是逐一扫描每种标记罢了。但是，规则是变化的，其它实现字符匹配的代码都是一致的。有没有一套框架，用户提供规则表就能实现词法分析呢？当然有，Lex 以及 Flex 就是这方面的好手。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g2boqbqx3oj31pi0q0q44.jpg" alt=""></p><p><strong>Lex 语法规范</strong></p><p>整个 <code>&lt;name&gt;.lex</code> 规则文件分为三部分，由 <code>%%</code> 进行分隔</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">definitions</span><br><span class="line">%%</span><br><span class="line">rules</span><br><span class="line">%%</span><br><span class="line">user code</span><br></pre></td></tr></table></figure><p><code>definitions</code>，定义区的所有声明可以类比 C 语言中的宏，只不过无需 <code>#define</code>。</p><p>例如 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DIGIT [0-9]+</span><br><span class="line">NZDIGIT [1-9]&#123;DIGIT&#125;</span><br><span class="line">%%</span><br><span class="line">&#123;NZDIGIT&#125;   &#123;   printf(&quot;nzdigit = %s\n&quot;, yytext);   &#125;</span><br><span class="line">&#123;DIGIT&#125;     &#123;   printf(&quot;digit = %s\n&quot;, yytext); &#125;</span><br><span class="line">%%</span><br></pre></td></tr></table></figure><p>等效于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%%</span><br><span class="line">[1-9][0-9]+ &#123;   printf(&quot;nzdigit = %s\n&quot;, yytext);   &#125;</span><br><span class="line">[0-9]+      &#123;   printf(&quot;digit = %s\n&quot;, yytext); &#125;</span><br><span class="line">%%</span><br></pre></td></tr></table></figure><p><code>rule</code>，规则区就是定义标记识别规则的核心块。lex 将按最长匹配原则确定最终匹配上的标记(Token)，如果都没匹配上，则按原样输出。如果多个匹配上，则按最先声明的规则为准。</p><p><code>user code</code> 用户代码区的所有代码将原样拷贝到生成的 <code>&lt;name&gt;.c</code> 文件中。</p><h2 id="语法分析-lt-Yacc"><a href="#语法分析-lt-Yacc" class="headerlink" title="语法分析 &lt;- Yacc"></a>语法分析 &lt;- Yacc</h2><p>仅仅是词法分析还做不了太多的事情。之后的工作都将交给语法分析器来完成。Yacc、Bison 就是两个优秀的语法分析器。当然，它们也有着一些局限（由于只是学习使用，未对其中原理展开深入了解）。Yacc / Bison 只能解决能被 BNF(Backus-Naur Form, 巴科斯范式) 描述的语法规则，而且只支持符合 LALR(1) 规则的。</p><p>不过，这也已经足够了。在 <a href="https://www.rfc-editor.org/" target="_blank" rel="noopener">RFC</a> 上看到大量的规范性文档都通过 BNF 描述其语法规则，通过 Yacc/Bison 其实也能解决对这些规则的解析。</p><p><strong>Bison 语法规范</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">C declarations</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">Bison declarations</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">Grammar rules</span><br><span class="line">%%</span><br><span class="line">Additional C code</span><br></pre></td></tr></table></figure><ul><li><p>C 声明区将定义后面需要用到的类型和变量。当然，在这个区域使用 C 语言宏也是被允许的。比如 <code>#define</code>, <code>#include</code> 等</p></li><li><p>Bison 声明区被用来定义<code>终止符号(terminal symbols)</code>和<code>非终止符号(nonterminal symbols)</code>，当然也可以用来定义符号操作优先级和<code>语义值</code>的数据类型。</p></li><li><p>语法规则区将<code>非终止符号</code>是如何被组成的（在这个区域声明 BNF）</p></li><li><p>C 代码区与 lex 的规范一致，该区所有代码将被原样拷贝到生成的解析器源文件中。 </p></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>简单计算器语言的实现（改编自 <a href="http://dinosaur.compilertools.net/bison/bison_5.html#SEC29" target="_blank" rel="noopener">mfcalc</a>）：</p><ol><li>支持简单四则运算</li><li>支持乘方、平方根</li><li>支持三角函数</li><li>支持变量声明</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ ./calc</span><br><span class="line">3*10+2*(3-1)</span><br><span class="line">34</span><br><span class="line">alpha=beta=5*3+4</span><br><span class="line">19</span><br><span class="line">sin(PI/2)</span><br><span class="line">1</span><br><span class="line">cos(PI)</span><br><span class="line">-1</span><br><span class="line">ln(alpha)</span><br><span class="line">2.944438979</span><br><span class="line">beta=ln(alpha)</span><br><span class="line">2.944438979</span><br><span class="line">sqrt(25)</span><br><span class="line">5</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;ctype.h&gt;</span><br><span class="line">#include &quot;calc.h&quot;</span><br><span class="line">%&#125;</span><br><span class="line">%union &#123;</span><br><span class="line">double val;</span><br><span class="line">symrec *tptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%token &lt;val&gt; NUM</span><br><span class="line">%token &lt;tptr&gt; VAR FNCT</span><br><span class="line">%type &lt;val&gt; expr</span><br><span class="line"></span><br><span class="line">%right &apos;=&apos;</span><br><span class="line">%left &apos;+&apos; &apos;-&apos;</span><br><span class="line">%left &apos;*&apos; &apos;/&apos;</span><br><span class="line">%left NEG</span><br><span class="line">%right &apos;^&apos;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">input:</span><br><span class="line">        | input line</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">line: &apos;\n&apos;</span><br><span class="line">        | expr &apos;\n&apos; &#123;   printf(&quot;\t%.10g\n&quot;, $1);    &#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">expr: NUM   &#123; $$ = $1;  &#125;</span><br><span class="line">        | VAR   &#123; $$ = $1-&gt;value.var;   &#125;</span><br><span class="line">        | VAR &apos;=&apos; expr  &#123; $$ = $3;  $1-&gt;value.var = $3; &#125;</span><br><span class="line">        | FNCT &apos;(&apos; expr &apos;)&apos; &#123; $$ = (*($1-&gt;value.fnctptr))($3);  &#125;</span><br><span class="line">        | expr &apos;+&apos; expr &#123; $$ = $1 + $3; &#125;</span><br><span class="line">        | expr &apos;-&apos; expr &#123; $$ = $1 - $3; &#125;</span><br><span class="line">        | expr &apos;*&apos; expr &#123; $$ = $1 * $3; &#125;</span><br><span class="line">        | expr &apos;/&apos; expr &#123; $$ = $1 / $3; &#125;</span><br><span class="line">        | expr &apos;^&apos; expr &#123; $$ = pow($1, $3); &#125;</span><br><span class="line">        | &apos;-&apos; expr %prec NEG    &#123; $$ = -$2; &#125;</span><br><span class="line">        | &apos;(&apos; expr &apos;)&apos;  &#123; $$ = $2;  &#125;</span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    init_table();</span><br><span class="line">    yyparse();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int yyerror (char *s)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%s\n&quot;, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct init_fnct</span><br><span class="line">&#123;</span><br><span class="line">    char *fname;</span><br><span class="line">    double (*fnct)();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct init_fnct arith_fncts[] = &#123;</span><br><span class="line">    &quot;sin&quot;, sin,</span><br><span class="line">    &quot;cos&quot;, cos,</span><br><span class="line">    &quot;atan&quot;, atan,</span><br><span class="line">    &quot;ln&quot;, log,</span><br><span class="line">    &quot;exp&quot;, exp,</span><br><span class="line">    &quot;sqrt&quot;, sqrt,</span><br><span class="line">    &quot;floor&quot;, floor,</span><br><span class="line">    &quot;ceil&quot;, ceil,</span><br><span class="line">    &quot;abs&quot;, fabs,</span><br><span class="line">    0, 0</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct init_var &#123;</span><br><span class="line">    char *vname;</span><br><span class="line">    double value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct init_var constant_var[] = &#123;</span><br><span class="line">    &quot;PI&quot;, M_PI,</span><br><span class="line">    &quot;E&quot;, M_E,</span><br><span class="line">    0, 0</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">symrec *sym_table = (symrec *) 0;</span><br><span class="line"></span><br><span class="line">int init_table()</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    symrec *ptr;</span><br><span class="line">    for (int i=0;constant_var[i].vname != 0;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr = putsym(constant_var[i].vname, VAR);</span><br><span class="line">        ptr-&gt;value.var = constant_var[i].value; </span><br><span class="line">    &#125;</span><br><span class="line">    for (int i=0;arith_fncts[i].fname != 0;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr = putsym(arith_fncts[i].fname, FNCT);</span><br><span class="line">        ptr-&gt;value.fnctptr = arith_fncts[i].fnct;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">symrec * putsym(char *sym_name, int sym_type)</span><br><span class="line">&#123;</span><br><span class="line">    symrec *ptr;</span><br><span class="line">    ptr = (symrec *) malloc(sizeof(symrec));</span><br><span class="line">    ptr-&gt;name = (char *) malloc(strlen(sym_name) + 1);</span><br><span class="line">    strcpy(ptr-&gt;name, sym_name);</span><br><span class="line">    ptr-&gt;type = sym_type;</span><br><span class="line">    ptr-&gt;value.var = 0;</span><br><span class="line">    ptr-&gt;next = (struct symrec *) sym_table;</span><br><span class="line">    sym_table = ptr;</span><br><span class="line">    return ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">symrec * getsym(char *sym_name)</span><br><span class="line">&#123;</span><br><span class="line">    symrec *ptr;</span><br><span class="line">    for (ptr = sym_table; ptr != (symrec *) 0;ptr = (symrec *) ptr-&gt;next)</span><br><span class="line">        if (strcmp(ptr-&gt;name, sym_name) == 0)</span><br><span class="line">            return ptr;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int yylex()</span><br><span class="line">&#123;</span><br><span class="line">    int c;</span><br><span class="line">    while ((c = getchar()) == &apos; &apos; || c == &apos;\t&apos;);</span><br><span class="line"></span><br><span class="line">    if (c == EOF)</span><br><span class="line">        return 0;</span><br><span class="line">    </span><br><span class="line">    if (c == &apos;.&apos; || isdigit(c))</span><br><span class="line">    &#123;</span><br><span class="line">        ungetc(c, stdin);</span><br><span class="line">        scanf(&quot;%lf&quot;, &amp;yylval.val);</span><br><span class="line">        return NUM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (isalpha(c))</span><br><span class="line">    &#123;</span><br><span class="line">        symrec *s;</span><br><span class="line">        static char *symbuf = 0;</span><br><span class="line">        static int length = 0;</span><br><span class="line">        int i;</span><br><span class="line">        if (length == 0)</span><br><span class="line">            length = 40, symbuf = (char *) malloc(length + 1);</span><br><span class="line">        i = 0;</span><br><span class="line">        do &#123;</span><br><span class="line">            if (i == length)</span><br><span class="line">            &#123;</span><br><span class="line">                length *= 2;</span><br><span class="line">                symbuf = realloc(symbuf, length + 1);</span><br><span class="line">            &#125;</span><br><span class="line">            symbuf[i++] = c;</span><br><span class="line">            c = getchar();</span><br><span class="line">        &#125; while (c != EOF &amp;&amp; isalnum(c));</span><br><span class="line"></span><br><span class="line">        ungetc(c, stdin);</span><br><span class="line">        symbuf[i] = &apos;\0&apos;;</span><br><span class="line">        s = getsym(symbuf);</span><br><span class="line">        if (s == 0)</span><br><span class="line">            s = putsym(symbuf, VAR);</span><br><span class="line">        yylval.tptr = s;</span><br><span class="line">        return s-&gt;type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Data type for links in the chain of symbols.      */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">symrec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *name;  <span class="comment">/* name of symbol                     */</span></span><br><span class="line">    <span class="keyword">int</span> type;    <span class="comment">/* type of symbol: either VAR or FNCT */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">double</span> var;           <span class="comment">/* value of a VAR          */</span></span><br><span class="line">        <span class="keyword">double</span> (*fnctptr)();  <span class="comment">/* value of a FNCT         */</span></span><br><span class="line">    &#125; value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">symrec</span> *<span class="title">next</span>;</span>    <span class="comment">/* link field              */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">symrec</span> <span class="title">symrec</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The symbol table: a chain of `struct symrec'.     */</span></span><br><span class="line"><span class="keyword">extern</span> symrec *sym_table;</span><br><span class="line"></span><br><span class="line"><span class="function">symrec *<span class="title">putsym</span> <span class="params">()</span></span>;</span><br><span class="line"><span class="function">symrec *<span class="title">getsym</span> <span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">calc: calc.y calc.h</span><br><span class="line">bison -o calc.c calc.y </span><br><span class="line">gcc -o calc calc.c -w</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;高级语言相较于机器语言、汇编语言，更加符合人的思考习惯。换句话说，更偏向于自然语言的风格而更偏离指令化的描述。用高级语言编写的一行代码，最终可能需要处理器执行若干条指令。如何让机器意识到高级语言代码对应的机器指令是哪些呢？当然就需要一个优秀的翻译。&lt;/p&gt;
&lt;p&gt;无论是编译型语言还是解释型语言，总逃脱不了这样一个流程：高级语言 ➜ 目标平台的指令。所谓编译型/解释型的区别，在于其转换流程是在线的(online)还是离线的(offline)。在线的方式无法意识到后续的代码，但胜在即时反应；离线的方式可以统揽全局，进行更多的优化，但代码文本必须完整。&lt;/p&gt;
&lt;p&gt;高级语言 ➜ 目标平台的指令，这样的流程如何实现。一般来说，划分为四个阶段：词法分析、语法分析、语义分析、目标代码生成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tNc79ly1g2b583io0ej30wq094aa5.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;本篇的主要目的，是展示“语言翻译”的几个阶段工作，以及通过 Lex &amp;amp; Yacc 工具演示一门自定义语言的“翻译”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Lex" scheme="https://DorMOUSE-None.github.io/tags/Lex/"/>
    
      <category term="Yacc" scheme="https://DorMOUSE-None.github.io/tags/Yacc/"/>
    
  </entry>
  
  <entry>
    <title>理解 Linux Kernel(10) - Context of Execution</title>
    <link href="https://DorMOUSE-None.github.io/2019-04-10-understand-Kernel-10/"/>
    <id>https://DorMOUSE-None.github.io/2019-04-10-understand-Kernel-10/</id>
    <published>2019-04-09T16:00:00.000Z</published>
    <updated>2019-04-10T13:42:03.667Z</updated>
    
    <content type="html"><![CDATA[<p>在进行<a href="https://www.ffutop.com/2018-10-12-understand-Kernel-4/" target="_blank" rel="noopener">第四篇(任务调度)</a>行文描述时，就一直闹不清内核所谓的<code>task</code>的概念。之前一直将其与进程(process)的概念等同视之。但这又导致了线程的概念无处安置（毕竟在计算机科学的概念中，线程作为进程的子集存在，负责程序执行）。不过，现在这个疑惑总算得到了合理的解释：<strong>我们错误地将理论和实践不加区分地混淆了</strong>。内核开发社区与学术界的合作在整个内核开发历史上并没有想象中的频繁，正相反，学术界对内核代码的贡献不到1%[1]。如果想要将进程/线程的思想代入内核，并逐一印证，那么过程将非常痛苦并最终一无所获。所谓进程/线程，在内核中只有一个概念——执行的上下文(Context of Execution)，任何想要对进程/线程概念进行区分的行为都将是作茧自缚[2]。同时，<code>task</code> 也就是 <code>Context of Execution</code> 概念在实现上的表征。</p><a id="more"></a><p>执行的上下文(Context of Execution, COE)，记录了所有程序执行中的状态，包括：CPU状态（寄存器信息等）、MMU状态（页映射）、权限状态（uid、gid等）和一些公共属性（打开的文件、信号处理函数等）。对比理论上的进程/线程概念，粗略地讲就是同一线程组的线程各自持有CPU状态而共享其它状态，而认为两进程不共享任何状态。当然，在内核的概念里，进程/线程只是COE共享部分状态中的一个特例。</p><h2 id="fork-clone"><a href="#fork-clone" class="headerlink" title="fork, clone"></a>fork, clone</h2><p>如果用进程/线程的概念来看，内核提供了 <code>fork</code> 来完成进程的复制，提供了 <code>clone</code> 来处理线程的拷贝，另外还有 <code>vfork</code> , <code>kernel_thread</code> 等。</p><p><strong>syscall fork</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">int</span> <span class="title">sys_fork</span><span class="params">(struct pt_regs regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> do_fork(SIGCHLD, regs.esp, &amp;regs, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>syscall clone</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">int</span> <span class="title">sys_clone</span><span class="params">(struct pt_regs regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> newsp;</span><br><span class="line">    <span class="keyword">int</span> __user *parent_tidptr, *child_tidptr;</span><br><span class="line">    </span><br><span class="line">    clone_flags = regs.ebx;</span><br><span class="line">    newsp = regs.ecx;</span><br><span class="line">    parent_tidptr = (<span class="keyword">int</span> __user *)regs.edx;</span><br><span class="line">    child_tidptr = (<span class="keyword">int</span> __user *)regs.edi;</span><br><span class="line">    <span class="keyword">if</span> (!newsp)</span><br><span class="line">        newsp = regs.esp;</span><br><span class="line">    <span class="keyword">return</span> do_fork(clone_flags, newsp, &amp;regs, <span class="number">0</span>, parent_tidptr, child_tidptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>syscall vfork</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">int</span> <span class="title">sys_vfork</span><span class="params">(struct pt_regs regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, regs.esp, &amp;regs, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>kernel function: kernel_thread</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kernel_thread</span><span class="params">(<span class="keyword">int</span> (*fn)(<span class="keyword">void</span> *), <span class="keyword">void</span> * arg, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> do_fork(flags | CLONE_VM | CLONE_UNTRACED, <span class="number">0</span>, &amp;regs, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>fork</code>, <code>clone</code>, <code>vfork</code> 的入参怎么和日常使用的系统调用入参不同？且看：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">.macro PTREGSCALL label, func, arg</span><br><span class="line">.globl \label</span><br><span class="line">\label:</span><br><span class="line">leaq \func(%rip),%rax</span><br><span class="line">leaq -ARGOFFSET+<span class="number">8</span>(%rsp),\arg<span class="comment">/* 8 for return address */</span></span><br><span class="line">jmp  ia32_ptregs_common</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line">CFI_STARTPROC32</span><br><span class="line"></span><br><span class="line">PTREGSCALL stub32_rt_sigreturn, sys32_rt_sigreturn, %rdi</span><br><span class="line">PTREGSCALL stub32_sigreturn, sys32_sigreturn, %rdi</span><br><span class="line">PTREGSCALL stub32_sigaltstack, sys32_sigaltstack, %rdx</span><br><span class="line">PTREGSCALL stub32_sigsuspend, sys32_sigsuspend, %rcx</span><br><span class="line">PTREGSCALL stub32_execve, sys32_execve, %rcx</span><br><span class="line">PTREGSCALL stub32_fork, sys_fork, %rdi</span><br><span class="line">PTREGSCALL stub32_clone, sys32_clone, %rdx</span><br><span class="line">PTREGSCALL stub32_vfork, sys_vfork, %rdi</span><br><span class="line">PTREGSCALL stub32_iopl, sys_iopl, %rsi</span><br><span class="line">PTREGSCALL stub32_rt_sigsuspend, sys_rt_sigsuspend, %rdx</span><br><span class="line"></span><br><span class="line">ENTRY(ia32_ptregs_common)</span><br><span class="line">popq %r11</span><br><span class="line">CFI_ENDPROC</span><br><span class="line">CFI_STARTPROC32simple</span><br><span class="line">CFI_SIGNAL_FRAME</span><br><span class="line">CFI_DEF_CFArsp,SS+<span class="number">8</span>-ARGOFFSET</span><br><span class="line">CFI_REL_OFFSETrax,RAX-ARGOFFSET</span><br><span class="line">CFI_REL_OFFSETrcx,RCX-ARGOFFSET</span><br><span class="line">CFI_REL_OFFSETrdx,RDX-ARGOFFSET</span><br><span class="line">CFI_REL_OFFSETrsi,RSI-ARGOFFSET</span><br><span class="line">CFI_REL_OFFSETrdi,RDI-ARGOFFSET</span><br><span class="line">CFI_REL_OFFSETrip,RIP-ARGOFFSET</span><br><span class="line"><span class="comment">/*CFI_REL_OFFSETcs,CS-ARGOFFSET*/</span></span><br><span class="line"><span class="comment">/*CFI_REL_OFFSETrflags,EFLAGS-ARGOFFSET*/</span></span><br><span class="line">CFI_REL_OFFSETrsp,RSP-ARGOFFSET</span><br><span class="line"><span class="comment">/*CFI_REL_OFFSETss,SS-ARGOFFSET*/</span></span><br><span class="line">SAVE_REST</span><br><span class="line">call *%rax</span><br><span class="line">RESTORE_REST</span><br><span class="line">jmp  ia32_sysret<span class="comment">/* misbalances the return cache */</span></span><br><span class="line">CFI_ENDPROC</span><br><span class="line">END(ia32_ptregs_common)</span><br></pre></td></tr></table></figure><p>进行系统调用时的处理逻辑统一地将这些内容进行了整合，并将CPU状态（所有通用寄存器状态）维护到 <code>struct pt_regs</code> 数据块中。总结起来，三种系统调用最终都委托给 <code>do_fork</code> 进行实现，只是在参数的选择方面做了不同的预处理。这在用户层的函数原型上就更为明显，<code>fork</code> 和 <code>vfork</code> 都不允许参数的调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* for x86-32 */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">clone</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> flags, <span class="keyword">void</span> *child_stack,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> *ptid, <span class="keyword">unsigned</span> <span class="keyword">long</span> newtls,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> *ctid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> vfork(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure><p>再看看 <code>flags</code> 有哪些值可选。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * cloning flags:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSIGNAL0x000000ff<span class="comment">/* signal mask to be sent at exit */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_VM0x00000100<span class="comment">/* set if VM shared between processes */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_FS0x00000200<span class="comment">/* set if fs info shared between processes */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_FILES0x00000400<span class="comment">/* set if open files shared between processes */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_SIGHAND0x00000800<span class="comment">/* set if signal handlers and blocked signals shared */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_PTRACE0x00002000<span class="comment">/* set if we want to let tracing continue on the child too */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_VFORK0x00004000<span class="comment">/* set if the parent wants the child to wake it up on mm_release */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_PARENT0x00008000<span class="comment">/* set if we want to have the same parent as the cloner */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_THREAD0x00010000<span class="comment">/* Same thread group? */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_NEWNS0x00020000<span class="comment">/* New namespace group? */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_SYSVSEM0x00040000<span class="comment">/* share system V SEM_UNDO semantics */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_SETTLS0x00080000<span class="comment">/* create a new TLS for the child */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_PARENT_SETTID0x00100000<span class="comment">/* set the TID in the parent */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_CHILD_CLEARTID0x00200000<span class="comment">/* clear the TID in the child */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_DETACHED0x00400000<span class="comment">/* Unused, ignored */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_UNTRACED0x00800000<span class="comment">/* set if the tracing process can't force CLONE_PTRACE on this clone */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_CHILD_SETTID0x01000000<span class="comment">/* set the TID in the child */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_STOPPED0x02000000<span class="comment">/* Start in stopped state */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_NEWUTS0x04000000<span class="comment">/* New utsname group? */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_NEWIPC0x08000000<span class="comment">/* New ipcs */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_NEWUSER0x10000000<span class="comment">/* New user namespace */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_NEWPID0x20000000<span class="comment">/* New pid namespace */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_NEWNET0x40000000<span class="comment">/* New network namespace */</span></span></span><br></pre></td></tr></table></figure><p><code>xxx shared between processes</code> ，描述即将被创建的新任务将进行哪些状态/资源的共享，而哪些状态需要进行拷贝。</p><h3 id="do-fork"><a href="#do-fork" class="headerlink" title="do_fork"></a><code>do_fork</code></h3><p>先看看核心的 <code>do_fork</code> 的逻辑。</p><p><em>Hint: 下列代码经过大量的删减</em><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">do_fork</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_start,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct pt_regs *regs,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_size,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> __user *parent_tidptr,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> __user *child_tidptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = copy_process(clone_flags, stack_start, regs, stack_size, child_tidptr, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!IS_ERR(p)) &#123;</span><br><span class="line">        nr = (clone_flags &amp; CLONE_NEWPID) ?</span><br><span class="line">            task_pid_nr_ns(p, current-&gt;nsproxy-&gt;pid_ns) :</span><br><span class="line">                task_pid_vnr(p);</span><br><span class="line">        <span class="keyword">if</span> (!(clone_flags &amp; CLONE_STOPPED))</span><br><span class="line">            wake_up_new_task(p, clone_flags);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p-&gt;state = TASK_STOPPED;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nr = PTR_ERR(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct task_struct *<span class="title">copy_process</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_start,</span></span></span><br><span class="line"><span class="function"><span class="params">                    struct pt_regs *regs,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> __user *child_tidptr,</span></span></span><br><span class="line"><span class="function"><span class="params">                    struct pid *pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 预分配 task_struct 数据结构空间 */</span></span><br><span class="line">    retval = security_task_create(clone_flags);</span><br><span class="line">    <span class="comment">/* 复制 current 的 task_struct 数据结构 */</span></span><br><span class="line">    p = dup_task_struct(current);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nr_threads &gt;= max_threads)</span><br><span class="line">    <span class="keyword">goto</span> bad_fork_cleanup_count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 针对多核CPU，为新任务分配CPU */</span></span><br><span class="line">    sched_fork(p, clone_flags);</span><br><span class="line">    <span class="comment">/* 复制 thread_info 数据结构及线程栈 */</span></span><br><span class="line">    retval = copy_thread(<span class="number">0</span>, clone_flags, stack_start, stack_size, p, regs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 分配新的 pid */</span></span><br><span class="line">    p-&gt;pid = pid_nr(pid);</span><br><span class="line">    <span class="comment">/* thread group id = new pid */</span></span><br><span class="line">    p-&gt;tgid = p-&gt;pid;</span><br><span class="line">    <span class="comment">/* 如果标志是 CLONE_THREAD，tgid = 父任务id */</span></span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_THREAD)</span><br><span class="line">    p-&gt;tgid = current-&gt;tgid;</span><br><span class="line"></span><br><span class="line">    p-&gt;set_child_tid = (clone_flags &amp; CLONE_CHILD_SETTID) ? child_tidptr : <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;clear_child_tid = (clone_flags &amp; CLONE_CHILD_CLEARTID) ? child_tidptr: <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * sigaltstack should be cleared when sharing the same VM</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((clone_flags &amp; (CLONE_VM|CLONE_VFORK)) == CLONE_VM)</span><br><span class="line">    p-&gt;sas_ss_sp = p-&gt;sas_ss_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ok, now we should be set up.. */</span></span><br><span class="line">    p-&gt;exit_signal = (clone_flags &amp; CLONE_THREAD) ? <span class="number">-1</span> : (clone_flags &amp; CSIGNAL);</span><br><span class="line">    p-&gt;pdeath_signal = <span class="number">0</span>;</span><br><span class="line">    p-&gt;exit_state = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ok, make it visible to the rest of the system.</span></span><br><span class="line"><span class="comment">     * We dont wake it up yet.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    p-&gt;group_leader = p;</span><br><span class="line">    INIT_LIST_HEAD(&amp;p-&gt;thread_group);</span><br><span class="line">    INIT_LIST_HEAD(&amp;p-&gt;ptrace_children);</span><br><span class="line">    INIT_LIST_HEAD(&amp;p-&gt;ptrace_list);</span><br><span class="line"></span><br><span class="line">    p-&gt;cpus_allowed = current-&gt;cpus_allowed;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!cpu_isset(task_cpu(p), p-&gt;cpus_allowed) ||</span><br><span class="line">    !cpu_online(task_cpu(p))))</span><br><span class="line">    set_task_cpu(p, smp_processor_id());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CLONE_PARENT re-uses the old parent */</span></span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; (CLONE_PARENT|CLONE_THREAD))</span><br><span class="line">    p-&gt;real_parent = current-&gt;real_parent;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    p-&gt;real_parent = current;</span><br><span class="line">    p-&gt;parent = p-&gt;real_parent;</span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_THREAD) &#123;</span><br><span class="line">    p-&gt;group_leader = current-&gt;group_leader;</span><br><span class="line">    list_add_tail_rcu(&amp;p-&gt;thread_group, &amp;p-&gt;group_leader-&gt;thread_group);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cputime_eq(current-&gt;signal-&gt;it_virt_expires,</span><br><span class="line">    cputime_zero) ||</span><br><span class="line">        !cputime_eq(current-&gt;signal-&gt;it_prof_expires,</span><br><span class="line">    cputime_zero) ||</span><br><span class="line">        current-&gt;signal-&gt;rlim[RLIMIT_CPU].rlim_cur != RLIM_INFINITY ||</span><br><span class="line">        !list_empty(&amp;current-&gt;signal-&gt;cpu_timers[<span class="number">0</span>]) ||</span><br><span class="line">        !list_empty(&amp;current-&gt;signal-&gt;cpu_timers[<span class="number">1</span>]) ||</span><br><span class="line">        !list_empty(&amp;current-&gt;signal-&gt;cpu_timers[<span class="number">2</span>])) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Have child wake up on its first tick to check</span></span><br><span class="line"><span class="comment">     * for process CPU timers.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    p-&gt;it_prof_expires = jiffies_to_cputime(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (likely(p-&gt;pid)) &#123;</span><br><span class="line">    add_parent(p);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(p-&gt;ptrace &amp; PT_PTRACED))</span><br><span class="line">    __ptrace_link(p, current-&gt;parent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (thread_group_leader(p)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_NEWPID)</span><br><span class="line">    p-&gt;nsproxy-&gt;pid_ns-&gt;child_reaper = p;</span><br><span class="line"></span><br><span class="line">    p-&gt;signal-&gt;tty = current-&gt;signal-&gt;tty;</span><br><span class="line">    set_task_pgrp(p, task_pgrp_nr(current));</span><br><span class="line">    set_task_session(p, task_session_nr(current));</span><br><span class="line">    attach_pid(p, PIDTYPE_PGID, task_pgrp(current));</span><br><span class="line">    attach_pid(p, PIDTYPE_SID, task_session(current));</span><br><span class="line">    list_add_tail_rcu(&amp;p-&gt;tasks, &amp;init_task.tasks);</span><br><span class="line">    __get_cpu_var(process_counts)++;</span><br><span class="line">    &#125;</span><br><span class="line">    attach_pid(p, PIDTYPE_PID, pid);</span><br><span class="line">    nr_threads++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    total_forks++;</span><br><span class="line">    spin_unlock(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line">    write_unlock_irq(&amp;tasklist_lock);</span><br><span class="line">    proc_fork_connector(p);</span><br><span class="line">    cgroup_post_fork(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据入参配置的 <code>flags</code> ，<code>copy_process</code> 确定了新任务与父任务共享的状态，以及一些需要拷贝的状态。</p><ul><li><code>fork</code> 产生一个新的任务，与父任务不存在任何资源共享的情况。</li><li><code>clone</code> 可高度定制化的系统调用，几乎可以自由组合定制新的任务</li><li><code>vfork</code> 历史原因而存在的系统调用，设计目的在于一般 <code>fork</code> 之后都将调用 <code>execve</code> 来执行全新的任务，也就导致了 <code>fork</code> 所做的拷贝全部白费，因此搞了个轻量级的 <code>vfork</code> 来避免做内存的拷贝。</li></ul><blockquote><p><strong>VFORK</strong><br>Historic description<br>Under Linux, fork(2) is implemented using copy-on-write pages, so the only penalty incurred by fork(2) is the time and memory required to duplicate the  parent’s page tables, and to create a unique task structure for the child.  However, in the bad old days a fork(2) would require making a complete copy of the caller’s data space, often needlessly, since usually immediately afterward an exec(3) is done.  Thus, for greater efficiency, BSD introduced  the  vfork() system call, which did not fully copy the address space of the parent process, but borrowed the parent’s memory and thread of control until a call to execve(2) or an exit occurred.  The parent process was suspended while the child was using its resources.   The  use  of vfork() was tricky: for example, not modifying data in the parent process depended on knowing which variables were held in a register.</p></blockquote><h2 id="pid-tgid"><a href="#pid-tgid" class="headerlink" title="pid, tgid"></a>pid, tgid</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 分配新的 pid */</span></span><br><span class="line">p-&gt;pid = pid_nr(pid);</span><br><span class="line"><span class="comment">/* thread group id = new pid */</span></span><br><span class="line">p-&gt;tgid = p-&gt;pid;</span><br><span class="line"><span class="comment">/* 如果标志是 CLONE_THREAD，tgid = 父任务id */</span></span><br><span class="line"><span class="keyword">if</span> (clone_flags &amp; CLONE_THREAD)</span><br><span class="line">p-&gt;tgid = current-&gt;tgid;</span><br></pre></td></tr></table></figure><p><code>pid</code> 作为每个 <code>task</code> 的唯一标识符存在。<code>tgid</code> 用于指代线程组id，从代码上看也就是进程主线程id。（请原谅我又用了进程/线程的表述）</p><p>看着没有问题？当然不可能。这段代码可是意味着 <code>pid</code> 唯一啊，这可不符合日常表述啊。对于系统的终端用户来讲，一个进程可以有一个或多个线程。<code>pid</code> 可是一直被翻译成进程ID(process id)。难道？</p><p>这就是本质实现与表面功夫的差别啦。<code>pid_t getpid(void);</code>, <code>pid_t gettid(void);</code> 两个系统调用分别被用来提供进程ID和线程ID（请仔细思考下代码实现和对外展示的差距）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sys_getpid - return the thread group id of the current process</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note, despite the name, this returns the tgid not the pid.  The tgid and</span></span><br><span class="line"><span class="comment"> * the pid are identical unless CLONE_THREAD was specified on clone() in</span></span><br><span class="line"><span class="comment"> * which case the tgid is the same in all threads of the same group.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is SMP safe as current-&gt;tgid does not change.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_getpid</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> task_tgid_vnr(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Thread ID - the internal kernel "pid" */</span></span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_gettid</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> task_pid_vnr(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就好懂多了吧。用户态通过系统调用取到的 <code>pid</code>, <code>tid</code> 已经经过了一层加工，分别映射着内核实现的 <code>tgid</code>, <code>pid</code> 。</p><p><em>额外地：想通过 <code>ps</code> 查看进程/线程可以使用 <code>ps -eLf</code></em></p><h2 id="schedule"><a href="#schedule" class="headerlink" title="schedule"></a>schedule</h2><p>再来回顾下任务调度是如何实现的。与<a href="https://www.ffutop.com/2018-10-12-understand-Kernel-4/" target="_blank" rel="noopener">第四篇 任务调度</a>描述的并无太大不同。要说最大的区分，就是早期版本与时下版本顺时的演进。当然，还有就是多核CPU下的SMP调度。</p><p>至于多核下的所谓进程/线程如何调度。内核根本认识不到进程/线程的概念，唯一的只有任务(task, or COE)。而每个用户所认为的线程在内核的认识下也是一个任务。因此，所谓用户认识到的多线程并发执行在多核CPU下也就完全是可行的。</p><h2 id="concept-of-Thread"><a href="#concept-of-Thread" class="headerlink" title="concept of Thread"></a>concept of Thread</h2><p>且不论Linux内核没有线程概念的前提，线程的定义总是存在的，而满足其定义的实现，也就可以被称为“线程”。哪些要素组成了线程呢？</p><ol><li>线程是与其它代码共享进程地址空间的最小执行流</li><li>诸如栈、寄存器信息、本地线程数据需要保持独立</li><li>互斥锁(Mutex)、条件变量(Condition Variable)、线程间同步管理的支持</li><li>…</li></ol><p>既然都说了Linux内核没有线程概念，现在却又开始提，这不是打脸嘛？OK，具体情况是：内核本身不支持线程，甚至没有线程概念。但其通过GLIBC的NPTL(Native POSIX Thread Library)支持了线程。</p><blockquote><p>在Linux内核2.6出现之前任务是(最小)可调度的对象，当时的Linux不真正支持线程。但是Linux内核有一个系统调用指令<code>clone()</code>，这个指令将产生一个调用方任务的拷贝，而且这个拷贝可以与原任务使用同一地址空间。LinuxThreads计划使用这个系统调用来提供一个内核级别的线程支持。但是这个解决方法与真正的POSIX标准有一些不兼容的地方，尤其是在信号处理、进程调度和进程间同步原语方面。<br><em>Copied From <a href="https://en.wikipedia.org/wiki/Native_POSIX_Thread_Library" target="_blank" rel="noopener">Wikipedia NPTL</a></em></p></blockquote><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g1x9mjuahnj31400u0doi.jpg" alt="Linux 架构"></p><h2 id="Thread-Model"><a href="#Thread-Model" class="headerlink" title="Thread Model"></a>Thread Model</h2><p>最后，聊聊线程模型。相信各位不管懂或不懂，至少都听说过 1:1, N:1, M:N 线程模型。至于究竟这些模型是怎么回事呢？且看：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g1xhulou5bj30go08zglv.jpg" alt="Thread Model"></p><h3 id="1-1-Model"><a href="#1-1-Model" class="headerlink" title="1:1 Model"></a>1:1 Model</h3><p>最简单的线程模型，也是内核通过NPTL最容易实现的一种模型。每个通过 <code>clone</code> 产生的新任务（当然，至少要符合共享内存等线程定义）对应用程序来说就是一个新线程。所谓的用户级线程和内核级线程，在 1:1 模型中就是同一个任务，只是新任务在被内核 <code>clone</code> 之后，又由NPTL做了进一步的管理，因此在形式上看似有用户级/内核级之分。</p><h3 id="N-1-Model"><a href="#N-1-Model" class="headerlink" title="N:1 Model"></a>N:1 Model</h3><p>N:1 线程模型又称为“用户级线程模型”。在这种模型下，线程的概念由用户态代码进行支持，包括用来管理线程的用户空间调度器以及以非阻塞模式捕捉和处理I/O机制。使用N:1模型的好处在于其上下文切换的代价几乎为零，毕竟这是纯用户态的。当然，缺点也比较明显：由于对内核来说，认为这只是单个任务，也就无法充分利用多核CPU的特性。</p><h3 id="M-N-Model"><a href="#M-N-Model" class="headerlink" title="M:N Model"></a>M:N Model</h3><p>有没有方式整合1:1模型和N:1模型，让内核意识到有几个任务，但又存在更多的线程在用户级执行呢？当然也是可行，但如何协调调度又是费事费力的实现了。</p><h2 id="Threads-vs-Events"><a href="#Threads-vs-Events" class="headerlink" title="Threads vs Events"></a>Threads vs Events</h2><p>线程怎么又和事件扯上关系了呢？先来回顾下任务调度的几种模式：</p><ol><li>串行，每个任务依次执行，不存在任务调度</li><li>抢占式，通过时钟中断决定是否切换任务</li><li>协作式，只有当任务主动放弃对CPU的占用，才能轮到下一个任务。</li></ol><p>对于用户级线程来说，内核无法意识到这些线程的存在，硬件发起的所有中断又都被内核捕获。因此，想要实现抢占式是不可能完成的任务（至少以本人目前所知是不可能的）。故协作式线程调度是用户级线程的唯一选择。而协作式就意味着是由线程硬编码主动放弃任务执行（<code>yield</code> / <code>schedule</code> / etc.）。如此这般，与事件驱动下，不同代码片之间的调度又是何其相似。当然，只是开个玩笑，如果都一样了，直接用事件驱动不就OK了。线程之所以是线程，有其独特的定义在。不过不再细说，可以参考 <a href="http://courses.cs.vt.edu/cs5204/fall09-kafura/Presentations/Threads-VS-Events.pdf" target="_blank" rel="noopener">Threads vs Events</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1]. Mauerer W. Professional Linux kernel architecture[M]. John Wiley &amp; Sons, 2010.<br>[2]. <a href="http://lkml.iu.edu/hypermail/linux/kernel/9608/0191.html" target="_blank" rel="noopener">Linus Torvalds. Re: proc fs and shared pids</a>[EL/OL]. Aug 6th, 1996.<br>[3]. <a href="https://randu.org/tutorials/threads/" target="_blank" rel="noopener">Multithreaded Programming (POSIX pthreads Tutorial)</a>[EL/OL].<br>[4]. <a href="https://blog.csdn.net/u012432778/article/details/47378321" target="_blank" rel="noopener">线程模型</a>[EL/OL].<br>[5]. <a href="https://www.evanjones.ca/software/threading.html" target="_blank" rel="noopener">Implementing a Thread Library on Linux</a>[EL/OL]. Dec 10th, 2003.</p><h2 id="用户级线程资料参考"><a href="#用户级线程资料参考" class="headerlink" title="用户级线程资料参考"></a>用户级线程资料参考</h2><p>[1]. <code>man makecontext</code> &amp; <code>man swapcontext</code><br>[2]. <a href="https://github.com/brianwatling/libfiber" target="_blank" rel="noopener">Libfiber</a><br>[3]. <a href="https://github.com/dramesh/GTThreads" target="_blank" rel="noopener"><strong>所谓的</strong>抢占式用户线程实现</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在进行&lt;a href=&quot;https://www.ffutop.com/2018-10-12-understand-Kernel-4/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;第四篇(任务调度)&lt;/a&gt;行文描述时，就一直闹不清内核所谓的&lt;code&gt;task&lt;/code&gt;的概念。之前一直将其与进程(process)的概念等同视之。但这又导致了线程的概念无处安置（毕竟在计算机科学的概念中，线程作为进程的子集存在，负责程序执行）。不过，现在这个疑惑总算得到了合理的解释：&lt;strong&gt;我们错误地将理论和实践不加区分地混淆了&lt;/strong&gt;。内核开发社区与学术界的合作在整个内核开发历史上并没有想象中的频繁，正相反，学术界对内核代码的贡献不到1%[1]。如果想要将进程/线程的思想代入内核，并逐一印证，那么过程将非常痛苦并最终一无所获。所谓进程/线程，在内核中只有一个概念——执行的上下文(Context of Execution)，任何想要对进程/线程概念进行区分的行为都将是作茧自缚[2]。同时，&lt;code&gt;task&lt;/code&gt; 也就是 &lt;code&gt;Context of Execution&lt;/code&gt; 概念在实现上的表征。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://DorMOUSE-None.github.io/tags/Linux/"/>
    
      <category term="Kernel" scheme="https://DorMOUSE-None.github.io/tags/Kernel/"/>
    
      <category term="COE" scheme="https://DorMOUSE-None.github.io/tags/COE/"/>
    
  </entry>
  
  <entry>
    <title>如何获取运行时进程堆栈</title>
    <link href="https://DorMOUSE-None.github.io/2019-03-25-mem-dump/"/>
    <id>https://DorMOUSE-None.github.io/2019-03-25-mem-dump/</id>
    <published>2019-03-24T16:00:00.000Z</published>
    <updated>2019-03-25T01:28:42.233Z</updated>
    
    <content type="html"><![CDATA[<p>前些天看了关于在密码学应用中使用<code>java.lang.String</code>与<code>byte[]</code>的相关讨论，不推荐使用<code>java.lang.String</code>的重点就是其将在JVM中驻留，从而可能被窃取。但是，如何从内存中获取这些内容？JVM当然提供了一些机制，但是个人更喜欢从内核的角度来看看这个问题。</p><h2 id="proc-pid-maps"><a href="#proc-pid-maps" class="headerlink" title="/proc/${pid}/maps"></a>/proc/${pid}/maps</h2><p>首先当然是确定进程堆栈在物理内存的位置啦。很遗憾，没有找到相关的方案。毕竟进程记录的都是虚拟线性地址，而通过内核分段、分页机制最终映射到物理内存。不过，从<code>/proc</code>虚拟文件系统中，提供了进程虚拟地址映射。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">address                   perm offset   dev   inode                      pathname</span><br><span class="line">556566cb5000-556566cb6000 r-xp 00000000 fc:01 2496598                    /root/ffTrace/run</span><br><span class="line">556566eb5000-556566eb6000 r--p 00000000 fc:01 2496598                    /root/ffTrace/run</span><br><span class="line">556566eb6000-556566eb7000 rw-p 00001000 fc:01 2496598                    /root/ffTrace/run</span><br><span class="line">55656814f000-556568170000 rw-p 00000000 00:00 0                          [heap]</span><br><span class="line">7f2a95f91000-7f2a96178000 r-xp 00000000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so</span><br><span class="line">7f2a96178000-7f2a96378000 ---p 001e7000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so</span><br><span class="line">7f2a96378000-7f2a9637c000 r--p 001e7000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so</span><br><span class="line">7f2a9637c000-7f2a9637e000 rw-p 001eb000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so</span><br><span class="line">7f2a9637e000-7f2a96382000 rw-p 00000000 00:00 0</span><br><span class="line">7f2a96382000-7f2a963a9000 r-xp 00000000 fc:01 1835410                    /lib/x86_64-linux-gnu/ld-2.27.so</span><br><span class="line">7f2a965a0000-7f2a965a2000 rw-p 00000000 00:00 0</span><br><span class="line">7f2a965a9000-7f2a965aa000 r--p 00027000 fc:01 1835410                    /lib/x86_64-linux-gnu/ld-2.27.so</span><br><span class="line">7f2a965aa000-7f2a965ab000 rw-p 00028000 fc:01 1835410                    /lib/x86_64-linux-gnu/ld-2.27.so</span><br><span class="line">7f2a965ab000-7f2a965ac000 rw-p 00000000 00:00 0</span><br><span class="line">7ffe2cf5e000-7ffe2cf7f000 rw-p 00000000 00:00 0                          [stack]</span><br><span class="line">7ffe2cfed000-7ffe2cff0000 r--p 00000000 00:00 0                          [vvar]</span><br><span class="line">7ffe2cff0000-7ffe2cff2000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line">ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]</span><br></pre></td></tr></table></figure><a id="more"></a><p><code>/proc/${pid}/maps</code> 记录了当前进程虚拟内存区域的分配以及其访问控制。</p><ul><li>前三行表述的是当前进程ELF文件在虚拟内存中的地址（这里使用的ELF文件名为 <code>run</code> ）<ul><li>第一行 <code>r-xp</code> 表示其将配合<code>Code Segment Register (CS)</code> 作为CPU执行指令的直接依据。</li><li>第二三行分别用作可读、可写数据区，将配合 <code>Data Segment Register (DS), ES, FS, GS</code> 等使用</li></ul></li><li>第四行直截了当，就是分配给堆的地址空间。当然，如果不够，可以不断地向上扩张。</li><li><code>xxx.so</code> 文件描述的是C共享库在虚拟内存中的地址。</li><li>最后才是栈内存，将以倒序的方式下内存低地址扩张。</li><li>至于之后的内容，不了解，不表。</li></ul><h2 id="ptrace"><a href="#ptrace" class="headerlink" title="ptrace"></a>ptrace</h2><p>拿到了进程虚拟内存分布，又如何获取其中的内容。<code>ptrace</code> 总算是派上用场了。之前在阅读内核源码的时候，任务数据结构 <code>struct task</code> 专门为此预留了一些字段来加以描述，但始终找不到其用途。现在总算对其有了初步的了解。</p><p>一般来说，进程彼此之间应该相互独立，虽然运行在同一台机器上，但应该是相互间不知道其他进程的存在。那又如何能够通过一个进程的代码来获取另一个进程的堆栈数据呢？<code>ptrace</code> 提供的就是这么一种可能性。通过 <code>PTRACE_ATTACH</code> 和 <code>PTRACE_DETACH</code>，A进程会使得目标进程B陷入Sleeping状态，而等待A继续通过其他命令来获取其数据。至于为什么会是陷入Sleeping呢？一旦B进程的在运行，数据等随时可能改变，显然不适合读取数据啊。</p><p>如何读取？<code>PTRACE_PEEKTEXT</code> 就是这样一个实现进程间交互的好工具。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ptrace(PTRACE_ATTACH, options.pid, <span class="literal">NULL</span>, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"ptract attach failed. %s(errno: %d)\n"</span>, strerror(errno), errno);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"attach to %d success!\n"</span>, options.pid);</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">peek</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> maps[<span class="number">17</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(maps, <span class="string">"/proc/%d/maps"</span>, options.pid);</span><br><span class="line">    FILE *fd = fopen(maps, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"open /proc/%d/maps failed. %s(errno: %d)\n"</span>, strerror(errno), errno);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">map</span> *<span class="title">map</span> = (<span class="title">struct</span> <span class="title">map</span> *) <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">map</span> *));</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> word;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fscanf</span>(fd, <span class="string">"%llx-%llx %s %lx %*s %*s%*[^\n]"</span>, &amp;<span class="built_in">map</span>-&gt;start_addr, &amp;<span class="built_in">map</span>-&gt;end_addr, <span class="built_in">map</span>-&gt;op_flag, &amp;<span class="built_in">map</span>-&gt;offset) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;op_flag[<span class="number">0</span>] == <span class="string">'-'</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"peek from [%llx-%llx]\n"</span>, <span class="built_in">map</span>-&gt;start_addr, <span class="built_in">map</span>-&gt;end_addr);</span><br><span class="line">        <span class="keyword">long</span> mem_len = <span class="built_in">map</span>-&gt;end_addr - <span class="built_in">map</span>-&gt;start_addr;</span><br><span class="line">        <span class="keyword">char</span> *data = <span class="built_in">malloc</span>(mem_len + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> cursor = <span class="built_in">map</span>-&gt;start_addr;cursor &lt; <span class="built_in">map</span>-&gt;end_addr;cursor += <span class="keyword">sizeof</span>(<span class="keyword">long</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((word = ptrace(PTRACE_PEEKTEXT, options.pid, cursor, <span class="literal">NULL</span>)) == <span class="number">-1</span> &amp;&amp; errno)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"peek failed. %s(errno: %d)\n"</span>, strerror(errno), errno);</span><br><span class="line">                <span class="built_in">free</span>(data);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memcpy</span>(data+cursor-<span class="built_in">map</span>-&gt;start_addr, &amp;word, <span class="keyword">sizeof</span>(word));</span><br><span class="line">        &#125;</span><br><span class="line">        dump(data, mem_len);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">map</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">detach</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ptrace(PTRACE_DETACH, options.pid, <span class="literal">NULL</span>, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="string">"ptract detach failed. %s(errno: %d)\n"</span>, strerror(errno), errno);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"detach from %d success!"</span>, options.pid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    attach();</span><br><span class="line">    peek();</span><br><span class="line">    detach();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处的代码片段就能完成dump堆栈的工作了（当然，由于没有对其它内容进行处理，同时会dump下ELF数据等）。<a href="https://github.com/DorMOUSE-None/ffDump" target="_blank" rel="noopener">完整代码</a></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>当然，之后才发现 GDB 的实现借用的也正是这样一套机制。同时也意味着上面这段代码的实现在 GDB 中有现成的工具了:&lt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前些天看了关于在密码学应用中使用&lt;code&gt;java.lang.String&lt;/code&gt;与&lt;code&gt;byte[]&lt;/code&gt;的相关讨论，不推荐使用&lt;code&gt;java.lang.String&lt;/code&gt;的重点就是其将在JVM中驻留，从而可能被窃取。但是，如何从内存中获取这些内容？JVM当然提供了一些机制，但是个人更喜欢从内核的角度来看看这个问题。&lt;/p&gt;
&lt;h2 id=&quot;proc-pid-maps&quot;&gt;&lt;a href=&quot;#proc-pid-maps&quot; class=&quot;headerlink&quot; title=&quot;/proc/${pid}/maps&quot;&gt;&lt;/a&gt;/proc/${pid}/maps&lt;/h2&gt;&lt;p&gt;首先当然是确定进程堆栈在物理内存的位置啦。很遗憾，没有找到相关的方案。毕竟进程记录的都是虚拟线性地址，而通过内核分段、分页机制最终映射到物理内存。不过，从&lt;code&gt;/proc&lt;/code&gt;虚拟文件系统中，提供了进程虚拟地址映射。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;address                   perm offset   dev   inode                      pathname&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;556566cb5000-556566cb6000 r-xp 00000000 fc:01 2496598                    /root/ffTrace/run&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;556566eb5000-556566eb6000 r--p 00000000 fc:01 2496598                    /root/ffTrace/run&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;556566eb6000-556566eb7000 rw-p 00001000 fc:01 2496598                    /root/ffTrace/run&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55656814f000-556568170000 rw-p 00000000 00:00 0                          [heap]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7f2a95f91000-7f2a96178000 r-xp 00000000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7f2a96178000-7f2a96378000 ---p 001e7000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7f2a96378000-7f2a9637c000 r--p 001e7000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7f2a9637c000-7f2a9637e000 rw-p 001eb000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7f2a9637e000-7f2a96382000 rw-p 00000000 00:00 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7f2a96382000-7f2a963a9000 r-xp 00000000 fc:01 1835410                    /lib/x86_64-linux-gnu/ld-2.27.so&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7f2a965a0000-7f2a965a2000 rw-p 00000000 00:00 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7f2a965a9000-7f2a965aa000 r--p 00027000 fc:01 1835410                    /lib/x86_64-linux-gnu/ld-2.27.so&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7f2a965aa000-7f2a965ab000 rw-p 00028000 fc:01 1835410                    /lib/x86_64-linux-gnu/ld-2.27.so&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7f2a965ab000-7f2a965ac000 rw-p 00000000 00:00 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7ffe2cf5e000-7ffe2cf7f000 rw-p 00000000 00:00 0                          [stack]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7ffe2cfed000-7ffe2cff0000 r--p 00000000 00:00 0                          [vvar]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7ffe2cff0000-7ffe2cff2000 r-xp 00000000 00:00 0                          [vdso]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://DorMOUSE-None.github.io/tags/Linux/"/>
    
      <category term="Kernel" scheme="https://DorMOUSE-None.github.io/tags/Kernel/"/>
    
      <category term="dump" scheme="https://DorMOUSE-None.github.io/tags/dump/"/>
    
  </entry>
  
  <entry>
    <title>认证与授权·简述</title>
    <link href="https://DorMOUSE-None.github.io/2019-03-19-JANUS/"/>
    <id>https://DorMOUSE-None.github.io/2019-03-19-JANUS/</id>
    <published>2019-03-18T16:00:00.000Z</published>
    <updated>2019-03-21T11:27:55.521Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>在大多数系统中，都或多或少需要认证授权模型/系统的支持。</p></blockquote><p>认证/授权是什么？最简单的，我们的系统要求用户必须在“登录”之后才允许进行一些操作。“登录”的过程就是认证；而区别与未登录状态，只允许登录用户进行一些操作，这就是授权。认证与授权相互独立，有协同配合，共同支撑起系统对安全的基本要求。</p><a id="more"></a><h2 id="认证与授权"><a href="#认证与授权" class="headerlink" title="认证与授权"></a>认证与授权</h2><p>认证的目的在于认出用户。日常生活中，我们通过视觉、声音等因素认出一个人。但是就网络应用而言，应用最多只能够认识到发起请求的浏览器、手机APP、物联网设备等用户代理(User Agent)，也无法直接地将用户与用户代理进行绑定。因此，向应用证明操作这些用户代理的实体就成了至关重要的步骤。你需要通过密码、手机验证码、人脸识别或其它形式凭证来完成“登录”操作，即认证。</p><p>当然了，我们也认识到，不是所有的操作都需要一个这般复制“登录”流程的，即使这些操作逻辑上也需要认出背后的用户是谁。这部分所使用到的技术就是“会话管理”了。在一定的有效期范围内，用户无需重复证明自己的身份，而用户-应用间保持最基本的信任。当然，一般来说，修改密码等危险操作还是需要再次进行认证。</p><p>总而言之，无论是“登录”认证抑或是“会话”认证，其目的都是为了认出用户。</p><p>完成认证之后，就要启用授权了。授权负责的是控制用户能干什么。管理员和普通员工所能进行的操作肯定是有所差别的。借助于前置认证提供用户身份信息，授权将对用户的操作进行决断。</p><h2 id="访问控制（权限控制）"><a href="#访问控制（权限控制）" class="headerlink" title="访问控制（权限控制）"></a>访问控制（权限控制）</h2><p>授权旨在界定用户能够进行哪些操作，而访问控制正是进行授权界定的措施、手段。该如何实施访问控制呢？看人下菜是最简单、最容易被接受的方式——为每个用户独立地分配权限。但是，就Web应用而言，如此行事的代价将是及其巨大的。动辄几十万、上百万…的用户量，又如何维护得起这般细致的控制呢。而且，每个用户独立设置权限，同时也意味着每个权限需要直接对接百十万的用户。</p><p>撇开可行性，访问控制做的就是这种活计——控制主体（用户）对客体（系统、API等）的操作。</p><p>主要的访问控制技术分为三类：自主访问控制、强制访问控制、基于角色的访问控制</p><h3 id="自主访问控制-Discretionary-Access-Control，DAC"><a href="#自主访问控制-Discretionary-Access-Control，DAC" class="headerlink" title="自主访问控制(Discretionary Access Control，DAC)"></a>自主访问控制(Discretionary Access Control，DAC)</h3><ul><li>每个客体都独立维护一张访问控制表(Access Control List, ACL)</li><li>每个客体都有一个所有者</li><li>所有者可以将其负责的客体访问权限分配给其它用户</li><li>每次主体对客体的访问都面向ACL做确认后执行</li><li>强依赖于所有者对安全要求的认知</li></ul><h3 id="强制访问控制-Mandatory-Access-Control-MAC"><a href="#强制访问控制-Mandatory-Access-Control-MAC" class="headerlink" title="强制访问控制(Mandatory Access Control, MAC)"></a>强制访问控制(Mandatory Access Control, MAC)</h3><ul><li>预置相应的密级，例如绝密级、机密级和普通级。密级有强弱关系</li><li>每个主体/客体都分配一个密级</li><li>每次主体对客体的操作，判定主体密级 &gt;= 客体密级即允许访问</li></ul><h3 id="基于角色的访问控制-Role-Based-Access-Control-RBAC"><a href="#基于角色的访问控制-Role-Based-Access-Control-RBAC" class="headerlink" title="基于角色的访问控制(Role-Based Access Control, RBAC)"></a>基于角色的访问控制(Role-Based Access Control, RBAC)</h3><ul><li>角色作为一系列有较强相关性权限的持有者</li><li>用户通过被分配一系列角色，从而间接地拥有权限集</li></ul><p><em>一般来说，DAC、MAC都不太适合于Web应用的访问控制。因此，后续的讨论都将基于RBAC进行。</em></p><h2 id="控制粒度"><a href="#控制粒度" class="headerlink" title="控制粒度"></a>控制粒度</h2><p>如何定义一个客体，就涉及到控制粒度了。就Web应用而言，比较粗略的有数据粒度、方法粒度、URL粒度、系统粒度等等。任意粒度，都可以作为访问控制的组成部分，作为授权的一部分。但是，粒度的控制也会导致一些相当致命的问题。</p><p>越权问题就是一种粒度控制下的问题。</p><p><strong>纵向访问控制</strong></p><p>顾名思义，纵向访问控制所控制的权限拥有一定的优先级概念，例如管理员操作与普通用户操作。特别适合于使用强制访问控制的解决方案，使用RBAC也并不困难，基本上只要定义两类角色也能解决。业内对于这类问题的解决方案相当成熟，需要的只是根据不同的业务场景进行适配。</p><p><strong>横向访问控制</strong></p><p>对于横向访问控制，问题就不再那么的简单。在方法粒度下的RBAC模型，很容易就会导致A用户事实上访问了B用户数据的问题发生，也就是横向越权。而想要实现数据粒度的通用模型，却又不可避免地将对业务代码进行侵入。</p><p>控制粒度的取舍，就很大程度上取决于Web应用的实际需求。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>认证、授权的基本目的在于满足对安全的基本要求，其涉及的知识相当广泛。本篇的目的，仅仅在于阐释认证、授权两个术语的基本定义，并对访问控制技术做概要式的介绍。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在大多数系统中，都或多或少需要认证授权模型/系统的支持。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;认证/授权是什么？最简单的，我们的系统要求用户必须在“登录”之后才允许进行一些操作。“登录”的过程就是认证；而区别与未登录状态，只允许登录用户进行一些操作，这就是授权。认证与授权相互独立，有协同配合，共同支撑起系统对安全的基本要求。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Authenticate" scheme="https://DorMOUSE-None.github.io/tags/Authenticate/"/>
    
      <category term="Authorize" scheme="https://DorMOUSE-None.github.io/tags/Authorize/"/>
    
  </entry>
  
  <entry>
    <title>理解 Linux Kernel (9) - IO Multiplexing</title>
    <link href="https://DorMOUSE-None.github.io/2019-03-05-understand-Kernel-9/"/>
    <id>https://DorMOUSE-None.github.io/2019-03-05-understand-Kernel-9/</id>
    <published>2019-03-04T16:00:00.000Z</published>
    <updated>2019-03-05T00:58:05.350Z</updated>
    
    <content type="html"><![CDATA[<p><a href="./2019-01-15-understand-Kernel-8/">前一篇</a>已经对 Linux 内核网络相关的内容进行了基础性的介绍。数据从到达网卡，到最终被用户进程获取，最少经过了三个进程/硬中断的配合：网络中断负责将网络接收到的数据读取到内存并添加到 softnet_data 队列，并设置软中断通知内核进程 ksoftirqd；内核进程 ksoftirqd 被调度并处于运行状态，处理位于 softnet_data 中的 <code>struct sock</code> 对象，将其逐级从网络接口层逐级提升到网络层、传输层…最终添加到接收队列 <code>sk_receive_queue</code> 中；用户进程通过 <code>read</code>、<code>recv</code>、<code>recvfrom</code> 等命令检查并获取 <code>sk_receive_queue</code> 中的数据。</p><p>整个流程从概述上可以很轻松地配合进行网络数据交互，但如果要监控多个网络套接字呢？处理流程将变得复杂。我们无法预知哪个套接字能优先接收到数据。因此，最直接的办法就是轮询，在用户程序硬编码，通过设置超时时间的方式尝试获取数据。当然，这个效率就相当低下了。每次试探都需要触发系统调用（要知道这代价可是相当大的），另外超时时间的设置也是一个硬性的阻塞式消耗。</p><p>那么，有没有解决方案呢？当然有。通过用户程序硬编码式的轮询显然是陷入性能瓶颈的根源。因此内核主动提供了轮询式的系统调用（<code>select</code>, <code>poll</code>, <code>epoll</code>）。通过将轮询逻辑下沉到内核态，系统调用就只会有一次，而且超时时间的设置也显得统一。本篇就要就 <code>select</code> 和 <code>epoll</code> 两类系统调用的实现进行探究。</p><a id="more"></a><h2 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h2><p><code>select</code> 是一种比较古老的系统调用方式，存在着许多的调用限制。当然，相对的也就比较容易理解。</p><p><code>select</code> 系统调用最初的逻辑就是对超时时间的相关操作，完成从用户数据段到内核数据段的数据拷贝工作，而使用 <code>copy_from_user</code> 的目的，虽然看似比较晦涩，不如大家在用户程序中普通调用的memcpy，但究其原因，是为了处理MMU相关的问题。将内核复制的数据timeval做一定的取整操作（因为硬件中断的精度可能达不到timeval所描述的粒度，故根据HZ做取整，恰好为时钟中断周期的整数倍）。调用 <code>core_sys_select</code> 进行真正的轮询操作（当然，好像也算不上真正的逻辑，还有一层核心的调用呢）。结束后的操作当然是准备更新timeval。因为进行轮询的结果有两种，一种是因为超时而结束 <code>core_sys_select</code> 函数调用；另一种是得到了一个或多个准备就绪的数据，才结束调用并返回。显然，因为第二种结果而更新timeval有着一定的实际意义——到底等待了多久。不过这里需要注意的是，不是所有的Linux系统都支持对timeval做更新。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_select</span><span class="params">(<span class="keyword">int</span> n, fd_set __user *inp, fd_set __user *outp,</span></span></span><br><span class="line"><span class="function"><span class="params">fd_set __user *<span class="built_in">exp</span>, struct timeval __user *tvp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">s64 timeout = <span class="number">-1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果设置了超时时间 */</span></span><br><span class="line"><span class="keyword">if</span> (tvp) &#123;</span><br><span class="line"><span class="keyword">if</span> (copy_from_user(&amp;tv, tvp, <span class="keyword">sizeof</span>(tv)))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 计时器不能设置为负数 */</span></span><br><span class="line"><span class="keyword">if</span> (tv.tv_sec &lt; <span class="number">0</span> || tv.tv_usec &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Cast to u64 to make GCC stop complaining */</span></span><br><span class="line">        <span class="comment">/* 对 timeout 做一定的处理，根据时钟周期对 usec 进行取整 */</span></span><br><span class="line"><span class="keyword">if</span> ((u64)tv.tv_sec &gt;= (u64)MAX_INT64_SECONDS)</span><br><span class="line">timeout = <span class="number">-1</span>;<span class="comment">/* 无限等待 */</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">timeout = DIV_ROUND_UP(tv.tv_usec, USEC_PER_SEC/HZ);</span><br><span class="line">timeout += tv.tv_sec * HZ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 核心的 select 实现逻辑 */</span></span><br><span class="line">ret = core_sys_select(n, inp, outp, <span class="built_in">exp</span>, &amp;timeout);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果设置了超时时间 */</span></span><br><span class="line"><span class="keyword">if</span> (tvp) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">rtv</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (current-&gt;personality &amp; STICKY_TIMEOUTS)</span><br><span class="line"><span class="keyword">goto</span> sticky;</span><br><span class="line">rtv.tv_usec = jiffies_to_usecs(do_div((*(u64*)&amp;timeout), HZ));</span><br><span class="line">rtv.tv_sec = timeout;</span><br><span class="line"><span class="keyword">if</span> (timeval_compare(&amp;rtv, &amp;tv) &gt;= <span class="number">0</span>)</span><br><span class="line">rtv = tv;</span><br><span class="line">        <span class="comment">/* 内核数据-&gt;用户数据的拷贝，更新距离超时剩余的时间间隔 */</span></span><br><span class="line"><span class="keyword">if</span> (copy_to_user(tvp, &amp;rtv, <span class="keyword">sizeof</span>(rtv))) &#123;</span><br><span class="line">sticky:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 如果应用程序把timeval放在只读内存中，内核就无需特别的更新它</span></span><br><span class="line"><span class="comment"> * If an application puts its timeval in read-only</span></span><br><span class="line"><span class="comment"> * memory, we don't want the Linux-specific update to</span></span><br><span class="line"><span class="comment"> * the timeval to cause a fault after the select has</span></span><br><span class="line"><span class="comment"> * completed successfully. However, because we're not</span></span><br><span class="line"><span class="comment"> * updating the timeval, we can't restart the system</span></span><br><span class="line"><span class="comment"> * call.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (ret == -ERESTARTNOHAND)</span><br><span class="line">ret = -EINTR;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>core_sys_select</code> 也没有太多核心操作，完全是在为三个位图——输入、输出、错误从用户数据段到内核数据段的拷贝工作，以及在结束 <code>do_select</code> 调用后的反向拷贝操作。不过，无论是 <code>sys_select</code> 还是 <code>core_sys_select</code> 都将各自需要完成的工作分割得非常清晰，一个完成timeval的处理工作，另一个完成位图的处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 内核数据-位图的准备，调用do_select完成核心的逻辑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">core_sys_select</span><span class="params">(<span class="keyword">int</span> n, fd_set __user *inp, fd_set __user *outp,</span></span></span><br><span class="line"><span class="function"><span class="params">   fd_set __user *<span class="built_in">exp</span>, s64 *timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fd_set_bits fds;</span><br><span class="line"><span class="keyword">void</span> *bits;</span><br><span class="line"><span class="keyword">int</span> ret, max_fds;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span>;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 在栈中定义较小的数组，减少堆内存的占用，同时可以更快；</span></span><br><span class="line"><span class="comment">     * SELECT_STACK_ALLOC = 256</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">long</span> stack_fds[SELECT_STACK_ALLOC/<span class="keyword">sizeof</span>(<span class="keyword">long</span>)];</span><br><span class="line"></span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out_nofds;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* max_fds can increase, so grab it once to avoid race */</span></span><br><span class="line">    <span class="comment">/* max_fds 可能同时在增加，所以提前获取一份固定的拷贝避免竞争 */</span></span><br><span class="line">rcu_read_lock();</span><br><span class="line">    <span class="comment">/* 获取当前任务的文件描述符表 */</span></span><br><span class="line">fdt = files_fdtable(current-&gt;files);</span><br><span class="line">max_fds = fdt-&gt;max_fds;</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"><span class="keyword">if</span> (n &gt; max_fds)</span><br><span class="line">n = max_fds;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We need 6 bitmaps (in/out/ex for both incoming and outgoing),</span></span><br><span class="line"><span class="comment"> * since we used fdset we need to allocate memory in units of</span></span><br><span class="line"><span class="comment"> * long-words.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">size = FDS_BYTES(n);</span><br><span class="line">bits = stack_fds;</span><br><span class="line"><span class="keyword">if</span> (size &gt; <span class="keyword">sizeof</span>(stack_fds) / <span class="number">6</span>) &#123;</span><br><span class="line"><span class="comment">/* Not enough space in on-stack array; must use kmalloc */</span></span><br><span class="line">        <span class="comment">/* 栈数组大小不足；使用 kmalloc 获取新的空间 */</span></span><br><span class="line">ret = -ENOMEM;</span><br><span class="line">bits = kmalloc(<span class="number">6</span> * size, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!bits)</span><br><span class="line"><span class="keyword">goto</span> out_nofds;</span><br><span class="line">&#125;</span><br><span class="line">fds.in      = bits;</span><br><span class="line">fds.out     = bits +   size;</span><br><span class="line">fds.ex      = bits + <span class="number">2</span>*size;</span><br><span class="line">fds.res_in  = bits + <span class="number">3</span>*size;</span><br><span class="line">fds.res_out = bits + <span class="number">4</span>*size;</span><br><span class="line">fds.res_ex  = bits + <span class="number">5</span>*size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 用户数据段的数据 inp、outp、exp 往内核数据段 fds.xxx 拷贝 */</span></span><br><span class="line"><span class="keyword">if</span> ((ret = get_fd_set(n, inp, fds.in)) ||</span><br><span class="line">    (ret = get_fd_set(n, outp, fds.out)) ||</span><br><span class="line">    (ret = get_fd_set(n, <span class="built_in">exp</span>, fds.ex)))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">    <span class="comment">/* fds.res_xxx 作为 do_select 的执行结果，预置为0，表示每一位相应的fd都未准备就绪 */</span></span><br><span class="line">zero_fd_set(n, fds.res_in);</span><br><span class="line">zero_fd_set(n, fds.res_out);</span><br><span class="line">zero_fd_set(n, fds.res_ex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 交由 do_select 完成真正核心的操作 */</span></span><br><span class="line">ret = do_select(n, &amp;fds, timeout);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">ret = -ERESTARTNOHAND;</span><br><span class="line"><span class="keyword">if</span> (signal_pending(current))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将结果集拷贝回用户数据段的 inp、outp、exp 中 */</span></span><br><span class="line"><span class="keyword">if</span> (set_fd_set(n, inp, fds.res_in) ||</span><br><span class="line">    set_fd_set(n, outp, fds.res_out) ||</span><br><span class="line">    set_fd_set(n, <span class="built_in">exp</span>, fds.res_ex))</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="keyword">if</span> (bits != stack_fds)</span><br><span class="line">kfree(bits);</span><br><span class="line">out_nofds:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于是核心的逻辑了，逐一地将当前任务挂到相应文件的等待队列上，并等待调用 <code>poll</code> 函数被唤醒</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_select</span><span class="params">(<span class="keyword">int</span> n, fd_set_bits *fds, s64 *timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> <span class="title">table</span>;</span></span><br><span class="line">poll_table *wait;</span><br><span class="line"><span class="keyword">int</span> retval, i;</span><br><span class="line"></span><br><span class="line">rcu_read_lock();</span><br><span class="line">    <span class="comment">/* 确认fds.xxx所需轮询的fd全部全部处于打开状态，同时返回最大的fd */</span></span><br><span class="line">retval = max_select_fd(n, fds);</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">n = retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 把当前任务放入自己的等待队列中 */</span></span><br><span class="line">poll_initwait(&amp;table);</span><br><span class="line">wait = &amp;table.pt;</span><br><span class="line">    <span class="comment">/* 如果超时时间为0，即无需等待 */</span></span><br><span class="line"><span class="keyword">if</span> (!*timeout)</span><br><span class="line">wait = <span class="literal">NULL</span>;</span><br><span class="line">retval = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 无限循环 */</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *rinp, *routp, *rexp, *inp, *outp, *<span class="built_in">exp</span>;</span><br><span class="line"><span class="keyword">long</span> __timeout;</span><br><span class="line"></span><br><span class="line">set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line"></span><br><span class="line">inp = fds-&gt;in; outp = fds-&gt;out; <span class="built_in">exp</span> = fds-&gt;ex;</span><br><span class="line">rinp = fds-&gt;res_in; routp = fds-&gt;res_out; rexp = fds-&gt;res_ex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++rinp, ++routp, ++rexp) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> in, out, ex, all_bits, bit = <span class="number">1</span>, mask, j;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> res_in = <span class="number">0</span>, res_out = <span class="number">0</span>, res_ex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">f_op</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">in = *inp++; out = *outp++; ex = *<span class="built_in">exp</span>++;</span><br><span class="line">all_bits = in | out | ex;</span><br><span class="line"><span class="keyword">if</span> (all_bits == <span class="number">0</span>) &#123;</span><br><span class="line">i += __NFDBITS;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 对 unsigned long 的每一位进行确认 */</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; __NFDBITS; ++j, ++i, bit &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> fput_needed;</span><br><span class="line">                <span class="comment">/* 超过需检测的最大的文件描述符 */</span></span><br><span class="line"><span class="keyword">if</span> (i &gt;= n)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">/* 该 fd 无需检测，直接下一个 */</span></span><br><span class="line"><span class="keyword">if</span> (!(bit &amp; all_bits))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">/* 获取相应的文件实例 */</span></span><br><span class="line">file = fget_light(i, &amp;fput_needed);</span><br><span class="line"><span class="keyword">if</span> (file) &#123;</span><br><span class="line">f_op = file-&gt;f_op;</span><br><span class="line">mask = DEFAULT_POLLMASK;</span><br><span class="line">                    <span class="comment">/* 对于套接字，调用的是sock_poll，在poll成功时将唤醒wait队列的任务（即把当前任务唤醒）*/</span></span><br><span class="line"><span class="keyword">if</span> (f_op &amp;&amp; f_op-&gt;poll)</span><br><span class="line">mask = (*f_op-&gt;poll)(file, retval ? <span class="literal">NULL</span> : wait);</span><br><span class="line">fput_light(file, fput_needed);</span><br><span class="line"><span class="keyword">if</span> ((mask &amp; POLLIN_SET) &amp;&amp; (in &amp; bit)) &#123;</span><br><span class="line">res_in |= bit;</span><br><span class="line">retval++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((mask &amp; POLLOUT_SET) &amp;&amp; (out &amp; bit)) &#123;</span><br><span class="line">res_out |= bit;</span><br><span class="line">retval++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((mask &amp; POLLEX_SET) &amp;&amp; (ex &amp; bit)) &#123;</span><br><span class="line">res_ex |= bit;</span><br><span class="line">retval++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">                <span class="comment">/* 主动让出CPU片，等待重新调度（提前设置了最高优先级PREEMPT_ACTIVE）*/</span></span><br><span class="line">cond_resched();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (res_in)</span><br><span class="line">*rinp = res_in;</span><br><span class="line"><span class="keyword">if</span> (res_out)</span><br><span class="line">*routp = res_out;</span><br><span class="line"><span class="keyword">if</span> (res_ex)</span><br><span class="line">*rexp = res_ex;</span><br><span class="line">&#125;</span><br><span class="line">wait = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (retval || !*timeout || signal_pending(current))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>(table.error) &#123;</span><br><span class="line">retval = table.error;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/* Wait indefinitely */</span></span><br><span class="line">__timeout = MAX_SCHEDULE_TIMEOUT;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlikely(*timeout &gt;= (s64)MAX_SCHEDULE_TIMEOUT - <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="comment">/* Wait for longer than MAX_SCHEDULE_TIMEOUT. Do it in a loop */</span></span><br><span class="line">__timeout = MAX_SCHEDULE_TIMEOUT - <span class="number">1</span>;</span><br><span class="line">*timeout -= __timeout;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">__timeout = *timeout;</span><br><span class="line">*timeout = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">/* 进入延时唤醒状态，待定预定的超时时间 */</span></span><br><span class="line">__timeout = schedule_timeout(__timeout);</span><br><span class="line"><span class="keyword">if</span> (*timeout &gt;= <span class="number">0</span>)</span><br><span class="line">*timeout += __timeout;</span><br><span class="line">&#125;</span><br><span class="line">__set_current_state(TASK_RUNNING);</span><br><span class="line"></span><br><span class="line">poll_freewait(&amp;table);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结来看，<code>select</code> 完全能够支持IO多路复用。至少比用户程序自行实现轮询优秀得多。但是，也存在着一些明显的缺陷：</p><ol><li>支持的文件描述符存在上限，默认是1024。</li><li>每次陷入内核态 <code>select</code> 函数之后，都需要按位遍历所有的文件描述符（无论该fd是否存在），max(fd)越大，开销越大。</li><li>每次调用 <code>select</code> 都需要将fd集合从用户态复制到内核态，max(fd)越大，开销越大。</li></ol><h2 id="EPOLL"><a href="#EPOLL" class="headerlink" title="EPOLL"></a>EPOLL</h2><p>简单地描述过 <code>select</code> 系统调用之后，我们着重来聊一聊 <code>epoll</code> 的实现。毕竟 <code>select</code> 和 <code>poll</code> 的复杂度是 $O(N)$，而 <code>epoll</code> 只是 $O(\log{N})$ （当然，这里对时间复杂度的比较维度不同，稍候细讲）。<code>epoll</code> 区别于传统I/O复用模型的最大特色在于：它将创建并维护一个 <code>eventpoll</code> 实例，并通过注册请 <code>epoll</code> 对新的文件描述符进行监听，这意味着数据从用户数据区到内核数据区的拷贝只有一次；相对的，传统方式在每次轮询时，都需要全量地将数据从用户数据区拷贝到内核数据区。 </p><h3 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a><code>epoll_create</code></h3><p><code>epoll_create</code> 负责创建一个新的 <code>eventpoll</code> 实例。这里的size并没有实际意义（由于历史原因而存在），传入的参数将被忽略。看源码总是件有意思的事，这个size被描述成了检查精神健全的标志…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> error, fd = <span class="number">-1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line"></span><br><span class="line">DNPRINTK(<span class="number">3</span>, (KERN_INFO <span class="string">"[%p] eventpoll: sys_epoll_create(%d)\n"</span>,</span><br><span class="line">     current, size));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 精神健全检测(size)；同时建立内部数据结构 struct eventpoll</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">error = -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (size &lt;= <span class="number">0</span> || (error = ep_alloc(&amp;ep)) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> error_return;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 创建一个新的文件描述符，文件数据结构和i节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">error = anon_inode_getfd(&amp;fd, &amp;inode, &amp;file, <span class="string">"[eventpoll]"</span>,</span><br><span class="line"> &amp;eventpoll_fops, ep);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">goto</span> error_free;</span><br><span class="line"></span><br><span class="line">DNPRINTK(<span class="number">3</span>, (KERN_INFO <span class="string">"[%p] eventpoll: sys_epoll_create(%d) = %d\n"</span>,</span><br><span class="line">     current, size, fd));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fd;</span><br><span class="line"></span><br><span class="line">error_free:</span><br><span class="line">ep_free(ep);</span><br><span class="line">error_return:</span><br><span class="line">DNPRINTK(<span class="number">3</span>, (KERN_INFO <span class="string">"[%p] eventpoll: sys_epoll_create(%d) = %d\n"</span>,</span><br><span class="line">     current, size, error));</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g0qi7lrtgzj31eu0u075i.jpg" alt="Epoll Create | Model"></p><h3 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a><code>epoll_ctl</code></h3><p><code>epoll_ctl</code> 顾名思义——<code>epoll</code>控制器，用于增加、修改、删除监听的事件。这里 <code>epfd</code> 用于找到 <code>eventpoll</code> 实例，<code>fd</code> 表示需要监听的文件描述符，<code>op</code> 区分增删改，<code>event</code> 表示监听的具体事件描述。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd,</span></span></span><br><span class="line"><span class="function"><span class="params">      struct epoll_event __user *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> error;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>, *<span class="title">tfile</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epds</span>;</span></span><br><span class="line"></span><br><span class="line">DNPRINTK(<span class="number">3</span>, (KERN_INFO <span class="string">"[%p] eventpoll: sys_epoll_ctl(%d, %d, %d, %p)\n"</span>,</span><br><span class="line">     current, epfd, op, fd, event));</span><br><span class="line"></span><br><span class="line">error = -EFAULT;</span><br><span class="line">    <span class="comment">/* 如果是增改操作，需要把事件描述拷贝到内核数据区; 删除操作不需要 */</span></span><br><span class="line"><span class="keyword">if</span> (ep_op_has_event(op) &amp;&amp;</span><br><span class="line">    copy_from_user(&amp;epds, event, <span class="keyword">sizeof</span>(struct epoll_event)))</span><br><span class="line"><span class="keyword">goto</span> error_return;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the "struct file *" for the eventpoll file */</span></span><br><span class="line">error = -EBADF;</span><br><span class="line">file = fget(epfd);</span><br><span class="line"><span class="keyword">if</span> (!file)</span><br><span class="line"><span class="keyword">goto</span> error_return;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the "struct file *" for the target file */</span></span><br><span class="line">tfile = fget(fd);</span><br><span class="line"><span class="keyword">if</span> (!tfile)</span><br><span class="line"><span class="keyword">goto</span> error_fput;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 需要监听的文件描述符必须支持文件操作 poll */</span></span><br><span class="line">error = -EPERM;</span><br><span class="line"><span class="keyword">if</span> (!tfile-&gt;f_op || !tfile-&gt;f_op-&gt;poll)</span><br><span class="line"><span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 需要确保不能把epfd作为被监听的fd加入 */</span></span><br><span class="line">error = -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (file == tfile || !is_file_epoll(file))</span><br><span class="line"><span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 这里的文件描述符一定是指eventpoll实例对应的文件描述符</span></span><br><span class="line"><span class="comment">     * 因此直接从中拿私有数据--预定义的*eventpoll</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">ep = file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;ep-&gt;mtx);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 从RB树中查找已经维护起来的监听事件</span></span><br><span class="line"><span class="comment">     * 当然，必须先把这个RB树结构锁定，防止查找时结构改变</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">epi = ep_find(ep, tfile, fd);</span><br><span class="line"></span><br><span class="line">error = -EINVAL;</span><br><span class="line"><span class="keyword">switch</span> (op) &#123;</span><br><span class="line"><span class="keyword">case</span> EPOLL_CTL_ADD:     <span class="comment">// 新增监听</span></span><br><span class="line"><span class="keyword">if</span> (!epi) &#123;</span><br><span class="line">epds.events |= POLLERR | POLLHUP;</span><br><span class="line"></span><br><span class="line">error = ep_insert(ep, &amp;epds, tfile, fd);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">error = -EEXIST;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EPOLL_CTL_DEL:     <span class="comment">// 删除监听</span></span><br><span class="line"><span class="keyword">if</span> (epi)</span><br><span class="line">error = ep_remove(ep, epi);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">error = -ENOENT;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EPOLL_CTL_MOD:     <span class="comment">// 修改监听</span></span><br><span class="line"><span class="keyword">if</span> (epi) &#123;</span><br><span class="line">epds.events |= POLLERR | POLLHUP;</span><br><span class="line">error = ep_modify(ep, epi, &amp;epds);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">error = -ENOENT;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">mutex_unlock(&amp;ep-&gt;mtx);</span><br><span class="line"></span><br><span class="line">error_tgt_fput:</span><br><span class="line">fput(tfile);</span><br><span class="line">error_fput:</span><br><span class="line">fput(file);</span><br><span class="line">error_return:</span><br><span class="line">DNPRINTK(<span class="number">3</span>, (KERN_INFO <span class="string">"[%p] eventpoll: sys_epoll_ctl(%d, %d, %d, %p) = %d\n"</span>,</span><br><span class="line">     current, epfd, op, fd, event, error));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的核心操作，就是往 <code>eventpoll</code> 实例中增删改监听的事件。以 <code>ep_insert</code> 为例，先看看怎么新增监听。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 实例化 epitem */</span></span><br><span class="line"><span class="keyword">if</span> (!(epi = kmem_cache_alloc(epi_cache, GFP_KERNEL)))</span><br><span class="line">    <span class="keyword">goto</span> error_return;</span><br><span class="line"><span class="comment">/* 对 epitem 实例进行初始化数据 */</span></span><br><span class="line">ep_rb_initnode(&amp;epi-&gt;rbn);</span><br><span class="line">INIT_LIST_HEAD(&amp;epi-&gt;rdllink);</span><br><span class="line">INIT_LIST_HEAD(&amp;epi-&gt;fllink);</span><br><span class="line">INIT_LIST_HEAD(&amp;epi-&gt;pwqlist);</span><br><span class="line">epi-&gt;ep = ep;</span><br><span class="line"><span class="comment">/* 构建struct epoll_filefd，作为rb_tree比较不同的key */</span></span><br><span class="line">ep_set_ffd(&amp;epi-&gt;ffd, tfile, fd);</span><br><span class="line">epi-&gt;event = *event;</span><br><span class="line">epi-&gt;nwait = <span class="number">0</span>;</span><br><span class="line">epi-&gt;next = EP_UNACTIVE_PTR;</span><br></pre></td></tr></table></figure><p>接下来要接触的就是一段比较烧脑的逻辑。</p><p><code>poll_table</code> 是在 VFS 实现中相当重要的一个数据结构，用来与<code>poll</code>配合（这里的<code>poll</code>是指文件操作中的，而不是<code>poll()</code>系统调用）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_struct</span> &#123;</span></span><br><span class="line">poll_queue_proc _qproc;</span><br><span class="line">&#125; poll_table;</span><br></pre></td></tr></table></figure><p>其中<code>poll_queue_proc</code>是一个函数指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*poll_queue_proc)</span><span class="params">(struct file *, <span class="keyword">wait_queue_head_t</span> *, struct poll_table_struct *)</span></span>;</span><br></pre></td></tr></table></figure><p>为了让 <code>epitem</code> 更方便地追踪 <code>poll_queue_proc</code>，<code>epoll_ctl</code> 中使用了一个 <code>ep_pqueue</code> 的数据结构来包装 <code>poll_table</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 使用 queue 回调函数初始化 poll table */</span></span><br><span class="line">epq.epi = epi;</span><br><span class="line">init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g0qwphhnz0j30xa0o6aan.jpg" alt=""></p><p>之后就是把这个 <code>poll_table</code> 作为钩子方法挂载到被监控的文件上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">revents = tfile-&gt;f_op-&gt;poll(tfile, &amp;epq.pt);</span><br></pre></td></tr></table></figure><p>这里以 <code>tcp_poll</code> 为例，先看看这段逻辑怎么实现的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sock_poll</span><span class="params">(struct file *file, poll_table *wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">    <span class="comment">/* 获取 struct sock 内核套接字数据结构 */</span></span><br><span class="line">    sock = file-&gt;private_data;</span><br><span class="line">    <span class="keyword">return</span> sock-&gt;ops-&gt;poll(file, sock, wait);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">tcp_poll</span><span class="params">(struct file *file, struct socket *sock, poll_table *wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> mask;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = <span class="title">sock</span>-&gt;<span class="title">sk</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> = <span class="title">tcp_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这里将调用 poll_table *wait 维护的回调函数</span></span><br><span class="line"><span class="comment">     * 将持有 eventpoll 实例的进程注册到 sk 的等待队列中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">poll_wait(file, sk-&gt;sk_sleep, wait);</span><br><span class="line"><span class="keyword">if</span> (sk-&gt;sk_state == TCP_LISTEN)</span><br><span class="line"><span class="keyword">return</span> inet_csk_listen_poll(sk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这里省略了部分逻辑，主要是负责处理 struct sock 接收到的事件</span></span><br><span class="line"><span class="comment">     * 处理成 mask 并返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">poll_wait</span><span class="params">(struct file * filp, <span class="keyword">wait_queue_head_t</span> * wait_address, poll_table *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &amp;&amp; wait_address)</span><br><span class="line">        p-&gt;qproc(filp, wait_address, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看epoll定义的回调函数的实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ep_ptable_queue_proc</span><span class="params">(struct file *file, <span class="keyword">wait_queue_head_t</span> *whead,</span></span></span><br><span class="line"><span class="function"><span class="params"> poll_table *pt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span> = <span class="title">ep_item_from_epqueue</span>(<span class="title">pt</span>);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eppoll_entry</span> *<span class="title">pwq</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (epi-&gt;nwait &gt;= <span class="number">0</span> &amp;&amp; (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) &#123;</span><br><span class="line">init_waitqueue_func_entry(&amp;pwq-&gt;wait, ep_poll_callback);</span><br><span class="line">pwq-&gt;whead = whead;</span><br><span class="line">pwq-&gt;base = epi;</span><br><span class="line">        <span class="comment">/* 添加到 struct sock 等待队列队首 */</span></span><br><span class="line">add_wait_queue(whead, &amp;pwq-&gt;wait);</span><br><span class="line">list_add_tail(&amp;pwq-&gt;llink, &amp;epi-&gt;pwqlist);</span><br><span class="line">epi-&gt;nwait++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* We have to signal that an error occurred */</span></span><br><span class="line">epi-&gt;nwait = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，<code>ep_insert</code> 核心的逻辑已经介绍完毕。主要就是将当前的 <code>eventpoll</code> 实例注册到监听目标（文件描述符）的等待队列上，并注册<code>ep_poll_callback</code>作为回调函数。回调函数实现是怎样呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_poll_callback</span><span class="params">(<span class="keyword">wait_queue_t</span> *wait, <span class="keyword">unsigned</span> mode, <span class="keyword">int</span> sync, <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pwake = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="comment">/* 获取 wait 结构维护的 epitem 实例 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span> = <span class="title">ep_item_from_wait</span>(<span class="title">wait</span>);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span> = <span class="title">epi</span>-&gt;<span class="title">ep</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... code omitted...</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 把当前的 epitem 实例添加到 eventpoll 实例的就绪队列中 </span></span><br><span class="line"><span class="comment">     * 这是显然的，毕竟此回调函数只有在fd准备就绪后被回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line"></span><br><span class="line">is_linked:</span><br><span class="line">    <span class="comment">/* 如果 wait 结构维护的进程处于Sleeping状态，则将其唤醒并加入任务就绪队列 */</span></span><br><span class="line"><span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">__wake_up_locked(&amp;ep-&gt;wq, TASK_UNINTERRUPTIBLE |</span><br><span class="line"> TASK_INTERRUPTIBLE);</span><br><span class="line"><span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">pwake++;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We have to call this outside the lock */</span></span><br><span class="line"><span class="keyword">if</span> (pwake)</span><br><span class="line">ep_poll_safewake(&amp;psw, &amp;ep-&gt;poll_wait);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a><code>epoll_wait</code></h3><p>处理完所有的监听事件的维护，用户程序需要通过 <code>epoll_wait</code> 与 <code>eventpoll</code> 实例进行交互，并被告知所有正在监听中的事件是否发生。由于 <code>epoll_wait</code> 的整个逻辑基本上都是在进行错误检测，此处不表。我们只关注其中的核心逻辑，即调用的 <code>ep_poll</code> 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_poll</span><span class="params">(struct eventpoll *ep, struct epoll_event __user *events,</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">int</span> maxevents, <span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res, eavail;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"><span class="keyword">long</span> jtimeout;</span><br><span class="line"><span class="keyword">wait_queue_t</span> wait;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Calculate the timeout by checking for the "infinite" value ( -1 )</span></span><br><span class="line"><span class="comment"> * and the overflow condition. The passed timeout is in milliseconds,</span></span><br><span class="line"><span class="comment"> * that why (t * HZ) / 1000.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jtimeout = (timeout &lt; <span class="number">0</span> || timeout &gt;= EP_MAX_MSTIMEO) ?</span><br><span class="line">MAX_SCHEDULE_TIMEOUT : (timeout * HZ + <span class="number">999</span>) / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 如果 eventpoll 实例的就绪队列为空，表明有没任何监听的事件发生。</span></span><br><span class="line"><span class="comment">     * 主动让进程陷入Sleeping状态，知道被 ep_poll_callback() 唤醒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (list_empty(&amp;ep-&gt;rdllist)) &#123;</span><br><span class="line">init_waitqueue_entry(&amp;wait, current);</span><br><span class="line">wait.flags |= WQ_FLAG_EXCLUSIVE;</span><br><span class="line">__add_wait_queue(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We don't want to sleep if the ep_poll_callback() sends us</span></span><br><span class="line"><span class="comment"> * a wakeup in between. That's why we set the task state</span></span><br><span class="line"><span class="comment"> * to TASK_INTERRUPTIBLE before doing the checks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line"><span class="keyword">if</span> (!list_empty(&amp;ep-&gt;rdllist) || !jtimeout)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">res = -EINTR;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line">            <span class="comment">/* 主动陷入Sleeping状态 */</span></span><br><span class="line">jtimeout = schedule_timeout(jtimeout);</span><br><span class="line">spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">__remove_wait_queue(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line"></span><br><span class="line">set_current_state(TASK_RUNNING);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Is it worth to try to dig for events ? */</span></span><br><span class="line">eavail = !list_empty(&amp;ep-&gt;rdllist);</span><br><span class="line"></span><br><span class="line">spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 将监听到的事件拷贝到用户空间。如果没有事件就绪且还没超时，就再抱着</span></span><br><span class="line"><span class="comment">     * 希望试一次。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!res &amp;&amp; eavail &amp;&amp;</span><br><span class="line">    !(res = ep_send_events(ep, events, maxevents)) &amp;&amp; jtimeout)</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>这部分的数据结构配合着一些胶水代码比较难以理解，最好配合着类图看看（个人使用，不一定适合各位）</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1g0rmx65dzhj324y0t8di4.jpg" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>Linux Kernel 2.6.24</li><li><a href="https://idndx.com/2014/09/01/the-implementation-of-epoll-1/" target="_blank" rel="noopener">The Implementation of epoll(1)</a></li><li><a href="https://idndx.com/2014/09/02/the-implementation-of-epoll-2/" target="_blank" rel="noopener">The Implementation of epoll(2)</a></li><li><a href="https://idndx.com/2014/09/22/the-implementation-of-epoll-3/" target="_blank" rel="noopener">The Implementation of epoll(3)</a></li><li><a href="https://idndx.com/2015/07/08/the-implementation-of-epoll-4/" target="_blank" rel="noopener">The Implementation of epoll(4)</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;./2019-01-15-understand-Kernel-8/&quot;&gt;前一篇&lt;/a&gt;已经对 Linux 内核网络相关的内容进行了基础性的介绍。数据从到达网卡，到最终被用户进程获取，最少经过了三个进程/硬中断的配合：网络中断负责将网络接收到的数据读取到内存并添加到 softnet_data 队列，并设置软中断通知内核进程 ksoftirqd；内核进程 ksoftirqd 被调度并处于运行状态，处理位于 softnet_data 中的 &lt;code&gt;struct sock&lt;/code&gt; 对象，将其逐级从网络接口层逐级提升到网络层、传输层…最终添加到接收队列 &lt;code&gt;sk_receive_queue&lt;/code&gt; 中；用户进程通过 &lt;code&gt;read&lt;/code&gt;、&lt;code&gt;recv&lt;/code&gt;、&lt;code&gt;recvfrom&lt;/code&gt; 等命令检查并获取 &lt;code&gt;sk_receive_queue&lt;/code&gt; 中的数据。&lt;/p&gt;
&lt;p&gt;整个流程从概述上可以很轻松地配合进行网络数据交互，但如果要监控多个网络套接字呢？处理流程将变得复杂。我们无法预知哪个套接字能优先接收到数据。因此，最直接的办法就是轮询，在用户程序硬编码，通过设置超时时间的方式尝试获取数据。当然，这个效率就相当低下了。每次试探都需要触发系统调用（要知道这代价可是相当大的），另外超时时间的设置也是一个硬性的阻塞式消耗。&lt;/p&gt;
&lt;p&gt;那么，有没有解决方案呢？当然有。通过用户程序硬编码式的轮询显然是陷入性能瓶颈的根源。因此内核主动提供了轮询式的系统调用（&lt;code&gt;select&lt;/code&gt;, &lt;code&gt;poll&lt;/code&gt;, &lt;code&gt;epoll&lt;/code&gt;）。通过将轮询逻辑下沉到内核态，系统调用就只会有一次，而且超时时间的设置也显得统一。本篇就要就 &lt;code&gt;select&lt;/code&gt; 和 &lt;code&gt;epoll&lt;/code&gt; 两类系统调用的实现进行探究。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://DorMOUSE-None.github.io/tags/Linux/"/>
    
      <category term="Kernel" scheme="https://DorMOUSE-None.github.io/tags/Kernel/"/>
    
      <category term="IO Model" scheme="https://DorMOUSE-None.github.io/tags/IO-Model/"/>
    
  </entry>
  
  <entry>
    <title>【Java】API 参数误定义的后果</title>
    <link href="https://DorMOUSE-None.github.io/2019-02-27-Java-Fatal-API/"/>
    <id>https://DorMOUSE-None.github.io/2019-02-27-Java-Fatal-API/</id>
    <published>2019-02-26T16:00:00.000Z</published>
    <updated>2019-02-27T22:55:02.662Z</updated>
    
    <content type="html"><![CDATA[<p>工程项目中，定义 API 总是一个慎之又慎的操作。不能少，不满足调用方的需求就惨了；也不能多，不然就乱套了，自己维护困难，调用方也开始了自我发挥。虽然足够慎重，但绝大多数都逃不过最终不得不“改” API 的情况。今天要讨论的是在同一个类内同方法名不同参数（入参/出参）的情况。</p><p>想要做到同方法名不同入参，很简单，就是“重载（Overload）”，日常都在使用。不再赘述！</p><p>想要做到同方法名不同出参，答案就不再那么肯定了。当然，如果问把<code>void add(int)</code> API 改写成 <code>int add(int)</code>，可能得到的大多数回答都是可以。</p><a id="more"></a><h2 id="看山是山"><a href="#看山是山" class="headerlink" title="看山是山"></a>看山是山</h2><p>首先举一个具体点的例子来描述（为了方便，就不定义<code>CountService</code>的接口类了）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ffutop.signature;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fangfeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019-02-26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CountService countService = <span class="keyword">new</span> CountService();</span><br><span class="line">        countService.add(<span class="number">1</span>);</span><br><span class="line">        System.out.println(String.format(<span class="string">"currentValue = %d"</span>, countService.getCurrentValue()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ffutop.signature;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fangfeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019-02-26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentValue = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请把 add(int) 理解成 API</span></span><br><span class="line"><span class="comment">     * 虽然已经做了实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> addend)</span> </span>&#123;</span><br><span class="line">        currentValue += addend;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCurrentValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在已经有 <code>void add(int)</code> 方法，完成的工作是累加。现在要把 API 改成 <code>int add(int)</code>，是否可以呢？看似本来没有返回值，现在只是加上一个返回值，对于原来的代码没有任何问题，而新代码又能拿到int类型的返回值，皆大欢喜啊。</p><h2 id="看山不是山"><a href="#看山不是山" class="headerlink" title="看山不是山"></a>看山不是山</h2><p>先给大家执行下代码吧！（请严格按照顺序，且避免使用IDE，否则将得不到预想的结果）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> # 准备好两个类的代码（CountService的API是 `void add(int)`）</span><br><span class="line"><span class="meta">$</span> # 编译Main类</span><br><span class="line"><span class="meta">$</span> javac com/ffutop/signature/Main.java</span><br><span class="line"><span class="meta">$</span>  </span><br><span class="line"><span class="meta">$</span> # 修改CountService的API为`int add(int)`</span><br><span class="line"><span class="meta">$</span> # 编译 CountService 类</span><br><span class="line"><span class="meta">$</span> javac com/ffutop/signature/CountService.java</span><br><span class="line"><span class="meta">$</span> </span><br><span class="line"><span class="meta">$</span> # 执行主程序</span><br><span class="line"><span class="meta">$</span> java com.ffutop.signature.Main</span><br><span class="line">Exception in thread "main" java.lang.NoSuchMethodError: com.ffutop.signature.CountService.add(I)V</span><br><span class="line">at com.ffutop.signature.Main.main(Main.java:11)</span><br></pre></td></tr></table></figure><p>很遗憾，执行失败了，报了个Error（没有这样的方法）。方法写的是 <code>com.ffutop.signature.CountService.add(I)V</code> 。简单的翻译一下就是需要<code>类名+方法名=x.y.CountService.add</code>，且入参为int，出参为void的方法（想了解更多请优先学习<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.4" target="_blank" rel="noopener">Java ClassFile Format</a>）。</p><p>那么，现在得到的结论是不行。</p><h2 id="看山还是山"><a href="#看山还是山" class="headerlink" title="看山还是山"></a>看山还是山</h2><p>那么，就一定不行吗？都是同名方法，不同参数。凭什么改个入参是可以的，改个出参就不行了。</p><p>从 Java 的角度来说，一定不行。“同一类中不能存在两个名字及描述符完全相同的方法”</p><p>但是，如果从 JVM 的角度来说，完全是可行的。“在class文件中，两个方法可以拥有完全相同的特征签名，前提是返回值不能相同”</p><p>什么意思呢？我们都知道建立在 JVM 之上的语言不只有 Java。像 Groovy、Kotlin 等语言都实现了各自的区别于 Java 独有的特征。这些特征的实现都是依赖于 JVM，但为什么 Java 没有呢？只能说 Java 语言的规范是 JVM 的子集（好像这话有点不严谨啊）</p><p>通过直接操作字节码，就能够达到在同一个类中建立两个同名、相同入参，但返回值不同的方法。<br>先通过<code>javap</code>命令看看最终提供的<code>CountService.class</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> javap com.ffutop.signature.CountService</span><br><span class="line">public class com.ffutop.signature.CountService &#123;</span><br><span class="line">  public int add(int);</span><br><span class="line">  public com.ffutop.signature.CountService();</span><br><span class="line">  public void add(int);</span><br><span class="line">  public int getCurrentValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有两个同名的方法<code>add(int)</code>，至于执行，也会相当顺利。</p><p>还是写个程序来说明，在原有 <code>Main.java</code> 的基础上，再创建一个全限定名为 <code>com.ffutop.signature.other.Main2</code> 的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ffutop.signature.other;</span><br><span class="line"><span class="keyword">import</span> com.ffutop.signature.CountService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fangfeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019-02-27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CountService countService = <span class="keyword">new</span> CountService();</span><br><span class="line">        System.out.println(String.format(<span class="string">"currentValue = %d"</span>, countService.add(<span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与 Main.java 比较，很明显的就是一个调用了 <code>CountService</code> 的 <code>int add(int)</code> 方法，而另一个调用 <code>void add(int)</code> 方法。</p><p>那么是否有效呢？先来验证一下（这里要模拟的一个场景是，CountService 类(只有 <code>void add(int)</code> 方法)作为二方库C.jar version 1.0 的主要服务类。CountService 类(同时有 <code>void add(int)</code> 和 <code>int add(int)</code> 方法)作为二方库C.jar version 2.0 的主要服务类。Main 类根据 C.jar version 1.0 做的编译，而 Main2 类根据 C.jar version 2.0 做的编译。在 Main 和 Main2 类运行时只提供 C.jar version 2.0）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> # 编译 Main 类和 CountService 类</span><br><span class="line"><span class="meta">$</span> javac com/ffutop/signature/Main.java</span><br><span class="line"><span class="meta">$</span></span><br><span class="line"><span class="meta">$</span> # 操作 CountService.class 字节码，增加方法 `int add(int)` </span><br><span class="line"><span class="meta">$</span> # 通过 ASM 实现，详见附录源码 com/ffutop/signature/support/Generator.java</span><br><span class="line"><span class="meta">$</span> </span><br><span class="line"><span class="meta">$</span> # 编译 Main2 类 (提供 classpath，即根据 CountService.class 编译)</span><br><span class="line"><span class="meta">$</span> javac com/ffutop/signature/other/Main2.java -classpath .</span><br><span class="line"><span class="meta">$</span></span><br><span class="line"><span class="meta">$</span> # 验证</span><br><span class="line"><span class="meta">$</span> java com.ffutop.signature.Main</span><br><span class="line">currentValue = 1</span><br><span class="line"><span class="meta">$</span> java com.ffutop.signature.other.Main2</span><br><span class="line">currentValue = 1</span><br><span class="line"><span class="meta">$</span> # OK，验证通过</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一旦 API 定义错误，并已经作为二方库提供给调用方。后果必然是灾难性的。至少，只能重新定义 API 。如果对于入参定义错误，Java 语言级别也能够支持。但如果是返回值，如果非要保持方法名一致，那就不得不下沉到 JVM 级别来进行处理了。当然，在工程项目中是否应该直接操作字节码？至少个人还没直接接触过。</p><p>做个记录，未来可以翻一翻，至少是一种可行的解决方案。</p><p>Update: 如果直接操作字节码为添加了不同返回值的同名同参数方法，可能引起调用方静态编译失败。此操作需慎之又慎。也许提供类加载器加载时的字节码操作能更加完美地解决这个问题。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://raw.githubusercontent.com/DorMOUSE-None/Repo/master/signature.zip" target="_blank" rel="noopener">源码.zip</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工程项目中，定义 API 总是一个慎之又慎的操作。不能少，不满足调用方的需求就惨了；也不能多，不然就乱套了，自己维护困难，调用方也开始了自我发挥。虽然足够慎重，但绝大多数都逃不过最终不得不“改” API 的情况。今天要讨论的是在同一个类内同方法名不同参数（入参/出参）的情况。&lt;/p&gt;
&lt;p&gt;想要做到同方法名不同入参，很简单，就是“重载（Overload）”，日常都在使用。不再赘述！&lt;/p&gt;
&lt;p&gt;想要做到同方法名不同出参，答案就不再那么肯定了。当然，如果问把&lt;code&gt;void add(int)&lt;/code&gt; API 改写成 &lt;code&gt;int add(int)&lt;/code&gt;，可能得到的大多数回答都是可以。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://DorMOUSE-None.github.io/tags/Java/"/>
    
      <category term="API" scheme="https://DorMOUSE-None.github.io/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>字符集与字符编码</title>
    <link href="https://DorMOUSE-None.github.io/2019-02-02-unicode/"/>
    <id>https://DorMOUSE-None.github.io/2019-02-02-unicode/</id>
    <published>2019-02-01T16:00:00.000Z</published>
    <updated>2019-02-02T06:32:39.666Z</updated>
    
    <content type="html"><![CDATA[<div class="row"><iframe src="https://drive.google.com/file/d/1MuBNtZPMWCt9kGlpqiAtG3i3Al2MaknY/preview" style="width:100%; height:550px"></iframe></div>]]></content>
    
    <summary type="html">
    
      
      
        

	&lt;div class=&quot;row&quot;&gt;
		&lt;iframe src=&quot;https://drive.google.com/file/d/1MuBNtZPMWCt9kGlpqiAtG3i3Al2MaknY/preview&quot; style=&quot;width:100%; height:550
      
    
    </summary>
    
    
      <category term="Unicode" scheme="https://DorMOUSE-None.github.io/tags/Unicode/"/>
    
      <category term="Character Encoding" scheme="https://DorMOUSE-None.github.io/tags/Character-Encoding/"/>
    
  </entry>
  
  <entry>
    <title>理解 Linux Kernel (8) - 网络</title>
    <link href="https://DorMOUSE-None.github.io/2019-01-15-understand-Kernel-8/"/>
    <id>https://DorMOUSE-None.github.io/2019-01-15-understand-Kernel-8/</id>
    <published>2019-01-14T16:00:00.000Z</published>
    <updated>2019-01-15T06:05:20.845Z</updated>
    
    <content type="html"><![CDATA[<div class="row"><iframe src="https://drive.google.com/file/d/1l5Vjrs8vKy6b9EvZFP7c7hOblv2kHgNx/preview" style="width:100%; height:550px"></iframe></div>]]></content>
    
    <summary type="html">
    
      
      
        

	&lt;div class=&quot;row&quot;&gt;
		&lt;iframe src=&quot;https://drive.google.com/file/d/1l5Vjrs8vKy6b9EvZFP7c7hOblv2kHgNx/preview&quot; style=&quot;width:100%; height:550
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://DorMOUSE-None.github.io/tags/Linux/"/>
    
      <category term="Kernel" scheme="https://DorMOUSE-None.github.io/tags/Kernel/"/>
    
      <category term="Network" scheme="https://DorMOUSE-None.github.io/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>理解 Linux Kernel (7) - 字符设备</title>
    <link href="https://DorMOUSE-None.github.io/2018-12-28-understand-Kernel-7/"/>
    <id>https://DorMOUSE-None.github.io/2018-12-28-understand-Kernel-7/</id>
    <published>2018-12-27T16:00:00.000Z</published>
    <updated>2018-12-27T23:47:28.308Z</updated>
    
    <content type="html"><![CDATA[<p>相比较于块设备，字符设备无论从物理认知上，抑或是理论理解上，都存在着相当大的入门门槛。特别是在将字符设备与控制台、命令行终端混淆的时候，就更加难以进行分辨了。</p><p>回到字符设备本身，字符设备与块设备最主要的区别就在于块设备可以随机读写，而字符设备只能够顺序读，顺序写。</p><p>那么，常见的字符设备有什么？显示器、键盘、鼠标。</p><a id="more"></a><h2 id="宏观概览"><a href="#宏观概览" class="headerlink" title="宏观概览"></a>宏观概览</h2><p>通常在我们的认识中，命令行终端就被认为是与一套字符设备相配合来使用的。很正常嘛。我们打开一个 Shell ，通过键盘输入一些字符，配合显示器把这些经过加工的字符展示出来。</p><p>那么，是不是就意味着 Shell 作为一个任务(进程)，以键盘设备作为标准输入，以显示设备作为标准输出?</p><p>看看一个 1 号任务 <code>/bin/bash</code> 的文件描述符说明吧。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ls -al</span><br><span class="line">total 0</span><br><span class="line">dr-x------ 2 root root  0 Dec 13 23:20 .</span><br><span class="line">dr-xr-xr-x 9 root root  0 Dec 13 23:20 ..</span><br><span class="line">lrwx------ 1 root root 64 Dec 13 23:20 0 -&gt; /dev/pts/0</span><br><span class="line">lrwx------ 1 root root 64 Dec 13 23:20 1 -&gt; /dev/pts/0</span><br><span class="line">lrwx------ 1 root root 64 Dec 13 23:20 2 -&gt; /dev/pts/0</span><br><span class="line">lrwx------ 1 root root 64 Dec 25 01:09 255 -&gt; /dev/pts/0</span><br></pre></td></tr></table></figure><p>这里文件描述符 0, 1, 2 分别表示任务的标准输入、标准输出、标准错误。这些内容在表现形式上做了一个链接。</p><p>那么，<code>/dev/pts/0</code> 是什么? </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crw--w---- 1 root tty 136, 0 Dec 13 23:20 /dev/pts/0</span><br></pre></td></tr></table></figure><p>一个字符设备。到此为止，似乎和最初预想的有比较大的区别。至少在假象中，至少是一个输入(键盘)，一个输出(显示器)。怎么就混成了一个呢？</p><p>本来是怎么都想不通的，但后来配合”Unix一切皆文件”的信条，总算是有点明白了。</p><p>相信大家都有这这样的经历，某个程序是以键盘输入作为标准输入的。其实就和上面👆展示的一样 <code>0 -&gt; /dev/pts/0</code> 。那么，有没有考虑过这整套流程是怎么协作的呢？</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fyjvtjiu0zj31980oqmxe.jpg" alt=""></p><p>对于程序来说，我们还是普通的调用 <code>read</code>, <code>write</code> 等经过封装的函数，来读取一个所谓的文件。</p><p>但对于文件是字符设备时，最终调用的就是 <code>tty_read</code>, <code>tty_write</code> 了。通俗的讲，大概率的就是键盘作为输入，显示器作为输出了。</p><h2 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h2><h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><p>这部分上一篇已经介绍过了，不做过多说明。</p><p>简单回顾下 <code>sys_read</code> 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_read</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> fd,<span class="keyword">char</span> * buf,<span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">file</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fd&gt;=NR_OPEN || count&lt;<span class="number">0</span> || !(file=current-&gt;filp[fd]))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (!count)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">verify_area(buf,count);</span><br><span class="line">inode = file-&gt;f_inode;</span><br><span class="line"><span class="keyword">if</span> (inode-&gt;i_pipe)</span><br><span class="line"><span class="keyword">return</span> (file-&gt;f_mode&amp;<span class="number">1</span>)?read_pipe(inode,buf,count):-EIO;</span><br><span class="line">    <span class="comment">/* 确认到i节点描述的是字符设备 */</span></span><br><span class="line"><span class="keyword">if</span> (S_ISCHR(inode-&gt;i_mode)) </span><br><span class="line"><span class="keyword">return</span> rw_char(READ,inode-&gt;i_zone[<span class="number">0</span>],buf,count,&amp;file-&gt;f_pos);</span><br><span class="line"><span class="keyword">if</span> (S_ISBLK(inode-&gt;i_mode))</span><br><span class="line"><span class="keyword">return</span> block_read(inode-&gt;i_zone[<span class="number">0</span>],&amp;file-&gt;f_pos,buf,count);</span><br><span class="line"><span class="keyword">if</span> (S_ISDIR(inode-&gt;i_mode) || S_ISREG(inode-&gt;i_mode)) &#123;</span><br><span class="line"><span class="keyword">if</span> (count+file-&gt;f_pos &gt; inode-&gt;i_size)</span><br><span class="line">count = inode-&gt;i_size - file-&gt;f_pos;</span><br><span class="line"><span class="keyword">if</span> (count&lt;=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> file_read(inode,file,buf,count);</span><br><span class="line">&#125;</span><br><span class="line">printk(<span class="string">"(Read)inode-&gt;i_mode=%06o\n\r"</span>,inode-&gt;i_mode);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>S_ISCHR()</code> 就是在对i节点的类型进行判别，从而进行不同的分发。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> crw_ptr crw_table[]=&#123;</span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">/* nodev */</span></span><br><span class="line">rw_memory,<span class="comment">/* /dev/mem etc */</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">/* /dev/fd */</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">/* /dev/hd */</span></span><br><span class="line">rw_ttyx,<span class="comment">/* /dev/ttyx */</span></span><br><span class="line">rw_tty,<span class="comment">/* /dev/tty */</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">/* /dev/lp */</span></span><br><span class="line"><span class="literal">NULL</span>&#125;;<span class="comment">/* unnamed pipes */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这段还是涉及到分发，由不同的设备号(dev) 来确定执行函数 (ttyx, 串口终端; tty, 控制台终端; mem, /dev/mem 等)</span></span><br><span class="line"><span class="comment"> * crw_ptr 是 C 语言中常见的函数指针。由dev号来确定调用哪个函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rw_char</span><span class="params">(<span class="keyword">int</span> rw,<span class="keyword">int</span> dev, <span class="keyword">char</span> * buf, <span class="keyword">int</span> count, <span class="keyword">off_t</span> * pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">crw_ptr call_addr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (MAJOR(dev)&gt;=NRDEVS)</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line"><span class="keyword">if</span> (!(call_addr=crw_table[MAJOR(dev)]))</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line"><span class="keyword">return</span> call_addr(rw,MINOR(dev),buf,count,pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行到 <code>rw_tty</code>, <code>rw_ttyx</code> 两个函数，就将对读/写进行区分，并由特定的函数进行处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rw_ttyx</span><span class="params">(<span class="keyword">int</span> rw,<span class="keyword">unsigned</span> minor,<span class="keyword">char</span> * buf,<span class="keyword">int</span> count,<span class="keyword">off_t</span> * pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ((rw==READ)?tty_read(minor,buf,count):</span><br><span class="line">tty_write(minor,buf,count));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rw_tty</span><span class="params">(<span class="keyword">int</span> rw,<span class="keyword">unsigned</span> minor,<span class="keyword">char</span> * buf,<span class="keyword">int</span> count, <span class="keyword">off_t</span> * pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (current-&gt;tty&lt;<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line"><span class="keyword">return</span> rw_ttyx(rw,current-&gt;tty,buf,count,pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，应该能够基本了解了字符设备，作为 Linux 的文件，所应该有的读写的相关支持。</p><p>但是，究竟读、写的内容在哪呢？比如正规文件，都很容易地可以理解到，就是从磁盘中取出某个/某几个盘块的内容即可。字符设备的IO要从哪里取(往哪里送)数据呢?</p><h3 id="字符设备驱动"><a href="#字符设备驱动" class="headerlink" title="字符设备驱动"></a>字符设备驱动</h3><p>对于设备驱动这个概念，至今没有搞清楚。不过，这不妨碍对代码的理解。反正对于字符设备驱动来说，也就是 Linux 内核中的一些软件层面的代码，与普通代码的唯一区别，就是对外设硬件做了相应的交互支持。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fykyc6lo9pj31i40u0ac8.jpg" alt=""></p><p>承接操作系统的字符设备接口，<code>tty_read</code>、<code>tty_write</code> 负责读入和写出。</p><p>从哪里读？<code>secondary</code> 数据队列；往哪里写？<code>write_q</code> 数据队列。</p><p>同时，也可以看到，与这些队列直接相关的，就是我们熟知的键盘和显示器了。是不是有了点豁然开朗的感觉。</p><p>好，我们先来看看这里描述的三个队列究竟是怎么工作的。这里就不得不先看看内存中抽象出来的描述终端的数据结构 <code>tty_struct</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * copied from include/linux/tty.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">termios</span>;</span>     <span class="comment">/* terminal IO conf */</span></span><br><span class="line"><span class="keyword">int</span> pgrp;                   <span class="comment">/* 所属进程组 */</span></span><br><span class="line"><span class="keyword">int</span> stopped;                <span class="comment">/* 停止标志 */</span></span><br><span class="line"><span class="keyword">void</span> (*write)(struct tty_struct * tty); <span class="comment">/* 终端写函数指针 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_queue</span> <span class="title">read_q</span>;</span>    <span class="comment">/* 终端读队列 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_queue</span> <span class="title">write_q</span>;</span>   <span class="comment">/* 终端写队列 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_queue</span> <span class="title">secondary</span>;</span> <span class="comment">/* 终端辅助队列 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * copied from include/termios.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">termios</span> &#123;</span>                <span class="comment">/* terminal IO 属性 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> c_iflag;<span class="comment">/* input mode flags */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> c_oflag;<span class="comment">/* output mode flags */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> c_cflag;<span class="comment">/* control mode flags */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> c_lflag;<span class="comment">/* local mode flags */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> c_line;<span class="comment">/* line discipline */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> c_cc[NCCS];<span class="comment">/* control characters */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * copied from include/linux/tty.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_queue</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> data;         <span class="comment">/* 字符行数量 | 串口终端则存储端口号 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> head;         <span class="comment">/* 头指针 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> tail;         <span class="comment">/* 尾指针 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">proc_list</span>;</span> <span class="comment">/* 等待该终端的任务队列 */</span></span><br><span class="line"><span class="keyword">char</span> buf[TTY_BUF_SIZE];     <span class="comment">/* 队列的缓冲区 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于任何任务需要读写字符设备(这里指终端设备)，最终直接读取/写入到的就是 <code>secondary</code> 和 <code>write_q</code>。</p><hr><p>这里可能有个小小的疑问? 为什么读终端设备不是读 <code>read_q</code> 呢？</p><p>其实也比较好解释，相信日常在操作命令行的时候，我们在键盘上敲击的键位与显示器上实际展示的内容是不相匹配的。最普通的，我们键入了 <strong>delete(删除键)</strong>，为什么不是一个 <strong>delete</strong> 对应的 ascii (当然，这里请先忽视非打印字符的问题)，而是删除了最后一个字符呢？完全可以想象，反正任何键位与驱动交互的时候都是传入一串二进制码嘛。</p><p>这里的 <code>secondary</code> 完成的就是怎么一个工作，<code>read_q</code> 存储的是所有的外设(这里是键盘)的输入，并原样存储。而到了 <code>secondary</code> 就是经过相应的加工，诸如控制字符之类的都展现了各自的意义，并完成一些加工工作，而不再仅仅只是普通地展示了。</p><hr><p>另外，可能还有一个问题。虽然我们已经习惯了在命令行交互时，所有的输入都将直接在显示器上进行展示，好像我们在直接往显示器上写内容。但是，前面我们描述的内容都是，键盘设备作为输入，是要写到 <code>read_q</code> 乃至 <code>secondary</code> 并最终作为进程的输入的。在显示器上显示并不是它本来应该干的事情 (比较显示器上展示的应该是 <code>write_q</code> 的内容，也就是进程的标准输出)</p><p>事实上，这仅仅只是一个回显，将 <code>secondary</code> 队列的内容复制了一份到写队列，也就呈现出让显示器打印相应键盘输入的效果了。</p><p>同时，这也就能够直接解释为什么我们在使用 <code>passwd</code>, <code>su</code>, <code>sudo</code> 等命令时，要求输入密码都是不在显示器上回显的。实现也相当简单了嘛。把 tty_struct.termios 的相应控制属性 (ECHO) 重置，就可以实现不回显的效果了。</p><h3 id="终端设备交互"><a href="#终端设备交互" class="headerlink" title="终端设备交互"></a>终端设备交互</h3><p>最后一部分，应该也是最关心的了。外设如何与操作系统完成交互。其实也能够想得到了——中断。</p><p>在操作系统初始化时，就把中断描述符表的中断表项配置得当。之后的事情就是等待键盘等外设输入的中断信号了。</p><p>又看回到了 <code>init/main.c</code> 程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">trap_init();</span><br><span class="line">blk_dev_init();</span><br><span class="line">chr_dev_init(); <span class="comment">/* 块设备相关初始化, 方法体是空的，没有实现 */</span></span><br><span class="line">tty_init();     <span class="comment">/* tty 终端设备初始化 */</span></span><br><span class="line">time_init();</span><br><span class="line">sched_init();</span><br><span class="line">buffer_init(buffer_memory_end);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Copied from kernel/chr_drv/tty_io.c</span><br><span class="line"> * 终端设备初识化</span><br><span class="line"> */</span><br><span class="line">void tty_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    /** 串口设备初始化 */</span><br><span class="line">rs_init();</span><br><span class="line">    /** 控制台设备初始化 */</span><br><span class="line">con_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于为什么有两种初始化方式。这来源于终端又区分为控制台终端与串口终端，区别就是一个是直接建立在主机上，串口终端是通过串行接口连接到主机的。当然，这都是古老的方式了，细节就不太清楚了。</p><p>下面来看看 <code>con_init()</code> 做了哪些工作(<code>rs_init()</code> 的内容请自行了解)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">con_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> a;</span><br><span class="line"><span class="keyword">char</span> *display_desc = <span class="string">"????"</span>;</span><br><span class="line"><span class="keyword">char</span> *display_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取 setup.s 程序预处理的内容</span></span><br><span class="line"><span class="comment">     * 包括显示器的各种配置参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">video_num_columns = ORIG_VIDEO_COLS;</span><br><span class="line">video_size_row = video_num_columns * <span class="number">2</span>;</span><br><span class="line">video_num_lines = ORIG_VIDEO_LINES;</span><br><span class="line">video_page = ORIG_VIDEO_PAGE;</span><br><span class="line">video_erase_char = <span class="number">0x0720</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取显示器的配置并进行相关设置 (省略代码)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">origin= video_mem_start;</span><br><span class="line">scr_end= video_mem_start + video_num_lines * video_size_row;</span><br><span class="line">top= <span class="number">0</span>;</span><br><span class="line">bottom= video_num_lines;</span><br><span class="line"></span><br><span class="line">gotoxy(ORIG_X,ORIG_Y);</span><br><span class="line">    <span class="comment">/** 设置陷阱门 */</span></span><br><span class="line">set_trap_gate(<span class="number">0x21</span>,&amp;keyboard_interrupt);</span><br><span class="line">outb_p(inb_p(<span class="number">0x21</span>)&amp;<span class="number">0xfd</span>,<span class="number">0x21</span>);</span><br><span class="line">a=inb_p(<span class="number">0x61</span>);</span><br><span class="line">outb_p(a|<span class="number">0x80</span>,<span class="number">0x61</span>);</span><br><span class="line">outb(a,<span class="number">0x61</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该能够看到最重要的内容就是<strong>设置键盘中断陷阱门</strong>了。</p><p>之后只有静静地等待键位敲击，也就能够产生硬件中断，从而让 <code>read_q</code> 获得到相应的字符输入。</p><p>至于键盘中断的相应处理流程，这里不再详述。简述一些步骤:</p><ol><li><p>产生硬中断 <code>keyboard_interrupt</code>，由程序 <code>Keyboard.s</code> 的汇编代码进行处理</p></li><li><p>根据不同的键盘(US 键盘、德式键盘等等)将获得的键位信号进行相应的字符转换(查转换表)</p></li><li><p>调用 <code>do_tty_interrupt</code> 处理函数 (确认是给哪个终端的信号)</p></li><li><p>调用 <code>copy_to_cooked(tty)</code> ，即完成 <code>read_q</code> 到 <code>secondary</code> 的相关加工。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相比较于块设备，字符设备无论从物理认知上，抑或是理论理解上，都存在着相当大的入门门槛。特别是在将字符设备与控制台、命令行终端混淆的时候，就更加难以进行分辨了。&lt;/p&gt;
&lt;p&gt;回到字符设备本身，字符设备与块设备最主要的区别就在于块设备可以随机读写，而字符设备只能够顺序读，顺序写。&lt;/p&gt;
&lt;p&gt;那么，常见的字符设备有什么？显示器、键盘、鼠标。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://DorMOUSE-None.github.io/tags/Linux/"/>
    
      <category term="Kernel" scheme="https://DorMOUSE-None.github.io/tags/Kernel/"/>
    
      <category term="Char Dev" scheme="https://DorMOUSE-None.github.io/tags/Char-Dev/"/>
    
  </entry>
  
  <entry>
    <title>SQL 注入</title>
    <link href="https://DorMOUSE-None.github.io/2018-12-15-sql-injection/"/>
    <id>https://DorMOUSE-None.github.io/2018-12-15-sql-injection/</id>
    <published>2018-12-14T16:00:00.000Z</published>
    <updated>2018-12-15T03:00:14.679Z</updated>
    
    <content type="html"><![CDATA[<p>说实话此前对 SQL 注入的理解仅仅只是皮毛。当然，目前也是，只是有了一定程度的理解。</p><p>最近好像工具用得有些过头了，需要停下来整理下工具的实现原理。</p><p>更好地理解了工具实现，才能更加心安理得地使用工具。毕竟等别人怼的时候，还能够比较安心地回道: “我用不用现成的工具只是取决于我想不想自己再写一套”</p><p>当然，毕竟成熟的工具有更多的优化，这就不是短时间内我想不想自己写的问题了，哈哈。</p><a id="more"></a><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>SQL 注入漏洞究竟会产生怎么样的危害性，仅仅只是绕过某些登录账号密码的验证? 只是绕过某些访问限制实现特权内容的访问?</p><p>此前我的认识也仅仅只是停留在这里。可谁曾想，SQL SELECT 语句真的是功能强大啊。通过各种各样的字符串拼接，最终能达到的目的，可以说把整个数据库的内容拖下来也不为过。当然，这也是限定在没有实现分库分表，数据库查询账号的权限过大的前提下。</p><p>不过，这也就够了。只有真正认识到问题的严重性，最终才会想着去做出一些改善。</p><h2 id="SQL-注入技术"><a href="#SQL-注入技术" class="headerlink" title="SQL 注入技术"></a>SQL 注入技术</h2><h3 id="基于布尔的注入"><a href="#基于布尔的注入" class="headerlink" title="基于布尔的注入"></a>基于布尔的注入</h3><p>最早接触到 SQL 注入问题，还是两个月前。操作的内容也相当简单，猜解某账号的密码。</p><p>某接口提供了查询账号的功能，后台的拼接 SQL 可以简单理解成 <code>SELECT * FROM users WHERE username = &#39;${}&#39;</code> 。其中 <code>${}</code> 就是直接使用的接口请求参数。</p><p>而接口的请求结果会根据 SQL 查询的结果，有或没有记录呈现两个不同的页面。</p><p>这算是最简单容易的 SQL 注入了，也是凭借个人能力直接能够想到注入点的问题了。</p><p>最先做的就是猜解存储密码字段的字段名究竟是什么? 很好，符合常理的设计，直接就是 <code>passwd</code> 。</p><p>下面就是苦力工作，利用 SQL LIKE 操作符，逐一去猜每一位。<code>${}</code> 的注入内容就类似 <code>admin&#39; AND passwd LIKE &#39;?%</code> 这里的问号就是逐一猜解的内容(1-9a-zA-Z + 特殊符号)</p><p>至于为什么利用 LIKE 操作符，很明确，减少猜解的次数。否则，在密码未知的情况下，即使六位密码也有猜解百万次。而 LIKE 操作符能将猜解次数降为线性，<code>密码长度 * 字符集数</code> 次</p><p>这里仅仅用了 <code>AND</code>，但熟悉了一个，其它就基本类似了。</p><p>如果登录也能够注入，认证 SQL 类似 <code>SELECT * FROM users WHERE username = &#39;${}&#39; AND passwd = &#39;${}&#39;</code>，那么直接在第一个 <code>${}</code> 处注入 <code>admin&#39; OR 1=1; --</code></p><h3 id="基于时间的注入"><a href="#基于时间的注入" class="headerlink" title="基于时间的注入"></a>基于时间的注入</h3><p>绝大多数时候，注入绝对没有这么简单。也许注入点背后的拼接 SQL 并不对返回值产生影响。例如仅仅只是为了从 DB 查询用户信息，并打一条日志，返回的永远是静态日志（当然，我知道这个例子不恰当，无奈目前只能想到这个）。</p><p>既然拼接 SQL 总是存在，但没法给我们一个直观的注入成功 OR 失败的提示。那么，时间就成了一个最好的判断。毕竟是阻塞式的执行。</p><p>还是以 <code>SELECT * FROM users WHERE username = &#39;${}&#39;</code> 为例，使用类似 <code>admin&#39; AND IF(passwd LIKE &#39;5%&#39;, SLEEP(5), 1);--</code> 的 PAYLOAD ，当满足 <code>passwd</code> 以 5 开始时，则 IF 判断进入 <code>SLEEP(5)</code> ，根据网页的响应时长就可以进行相应的判断。</p><h3 id="基于报错的注入"><a href="#基于报错的注入" class="headerlink" title="基于报错的注入"></a>基于报错的注入</h3><p>这应该也算一种比较容易自动化的注入方式了。其实在猜解存储密码字段的字段名时，前面也是这样用的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT * FROM users WHERE password ='1';</span><br><span class="line">ERROR 1054 (42S22): Unknown column 'password' in 'where clause'</span><br></pre></td></tr></table></figure><p>如果程序不做任何处理，对 SQL 错误直接抛出，那么，通过这个就能获得相当多的信息。</p><p>由于这部分接触不深，仅仅给出 sqlmap 提的 PAYLOAD</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AND (SELECT [RANDNUM] FROM(SELECT COUNT(*),CONCAT(&apos;[DELIMITER_START]&apos;,([QUERY]),&apos;[DELIMITER_STOP]&apos;,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a)</span><br></pre></td></tr></table></figure><p>很标准的 PAYLOAD，而且完全可以。<code>INFORMATION_SCHEMA</code> 库的表对所有用户都可查，因此不存在授权的问题。而且表中数据至少大于等于 3 条。</p><p>这个 PAYLOAD 一定导致报错的主因，就是对 <code>RAND()</code> 与 <code>GROUP BY</code> 的配合应用。</p><blockquote><p>Use of a column with RAND() values in an ORDER BY or GROUP BY clause may yield unexpected results because for either clause a RAND() expression can be evaluated multiple times for the same row, each time returning a different result. If the goal is to retrieve rows in random order, you can use a statement like this:</p></blockquote><p>而真正想要得到的内容，通过 <code>CONCAT(&#39;[DELIMITER_START]&#39;,([QUERY]),&#39;[DELIMITER_STOP]&#39;,FLOOR(RAND(0)*2))x</code> 得到，<code>[QUERY]</code> 就是真正想要注入的完整SQL串。</p><p>而这里的 <code>DELIMITER_START</code> <code>DELIMITER_STOP</code> 作为界定符，帮助程序提取 <code>[QUERY]</code> 得到的结果。否则，直接对请求返回的结果进行过滤可真是太困难了。</p><h3 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h3><p>联合查询，应该算是最顾名思义的注入方式。使用 <code>UNION</code> 在原 SQL 已经限定了查询表的前提下，获得数据库其它库表的信息。</p><p>LIKE: <code>1&#39; UNION SELECT * FROM users;--</code> 这样的 PAYLOAD。</p><h3 id="堆查询注入"><a href="#堆查询注入" class="headerlink" title="堆查询注入"></a>堆查询注入</h3><p>我想这应该是最让人摸不着头脑的命名方式了。</p><p>形象化的，我们利用 PAYLOAD 来进行说明。<code>1&#39;; INSERT INTO users (user, passwd) VALUES (&#39;aaa&#39;, &#39;aaa&#39;);--</code></p><p>看起来和 UNION 挺像的哈，都是补充上一个 OR 多个 SQL 。当然，也是有区别的，否则为什么会出现这样一种技术呢。</p><p>最大的区别，就是堆查询注入能够完成 <code>UPDATE</code>, <code>INSERT</code>, <code>DELETE</code> 等操作，毕竟，UNION 联合的只能是作为查询了（可能说法不太恰当，但姑且这样吧）</p><h3 id="另类注入"><a href="#另类注入" class="headerlink" title="另类注入"></a>另类注入</h3><p>之前的几种，我们都是利用了 <code>SELECT</code> 完成的注入，那么对于 <code>INSERT</code>, <code>UPDATE</code> 之类的语句是否有注入的可能呢。当然也是存在可能的。</p><p>不过，精力有限，而且目前看来也不需要做到这一步。暂时挖个坑吧。不填</p><h2 id="SQLMAP"><a href="#SQLMAP" class="headerlink" title="SQLMAP"></a>SQLMAP</h2><p>简单的了解了几种注入原理之后，还是要看看 SQL 注入神器的——<code>SQLMAP</code></p><p>也算是尝试了好久才真正了解它的强大之处。此处强烈推荐 DVWA，<code>Damn Vulnerable Web Application</code>，一个用来合法攻击的工具。</p><p>部署方式也是开箱可用，只要有 docker，直接 <code>docker run --rm -it -p 80:80 vulnerables/web-dvwa</code> 即可完成部署。</p><p>对于将 DVWA 安全级别设置为 low 时，仅仅只需要执行下列命令就可以获取到 DB 里几乎完整的信息。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sqlmap -u http://127.0.0.1/vulnerabilities/sqli/\?id\=1\&amp;Submit\=Submit\<span class="comment"># --cookie="PHPSESSID=jhton35qahj78l3unjea9k2lf7;security=low" -v 3 --banner</span></span><br></pre></td></tr></table></figure><p>当然，换一下相关获取的内容，例如把 <code>--banner</code> 换成 <code>--dump</code> ，我们借此来简单看看 SQL 注入漏洞的可怕之处</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[10:41:39] [INFO] using default dictionary</span><br><span class="line"><span class="keyword">do</span> you want to use common password suffixes? (slow!) [y/N]</span><br><span class="line">[10:41:40] [INFO] starting dictionary-based cracking (md5_generic_passwd)</span><br><span class="line">[10:41:40] [INFO] starting 8 processes</span><br><span class="line">[10:41:42] [INFO] cracked password <span class="string">'abc123'</span> <span class="keyword">for</span> <span class="built_in">hash</span> <span class="string">'e99a18c428cb38d5f260853678922e03'</span></span><br><span class="line">[10:41:44] [INFO] cracked password <span class="string">'charley'</span> <span class="keyword">for</span> <span class="built_in">hash</span> <span class="string">'8d3533d75ae2c3966d7e0d4fcc69216b'</span></span><br><span class="line">[10:41:47] [INFO] cracked password <span class="string">'letmein'</span> <span class="keyword">for</span> <span class="built_in">hash</span> <span class="string">'0d107d09f5bbe40cade3de5c71e9e9b7'</span></span><br><span class="line">[10:41:49] [INFO] cracked password <span class="string">'password'</span> <span class="keyword">for</span> <span class="built_in">hash</span> <span class="string">'5f4dcc3b5aa765d61d8327deb882cf99'</span></span><br><span class="line">[10:41:53] [DEBUG] post-processing table dump</span><br><span class="line">Database: dvwa</span><br><span class="line">Table: users</span><br><span class="line">[5 entries]</span><br><span class="line">+---------+-----------------------------+---------+---------------------------------------------+-----------+------------+---------------------+--------------+</span><br><span class="line">| user_id | avatar                      | user    | password                                    | last_name | first_name | last_login          | failed_login |</span><br><span class="line">+---------+-----------------------------+---------+---------------------------------------------+-----------+------------+---------------------+--------------+</span><br><span class="line">| 1       | /hackable/users/admin.jpg   | admin   | 5f4dcc3b5aa765d61d8327deb882cf99 (password) | admin     | admin      | 2018-12-15 00:42:31 | 0            |</span><br><span class="line">| 2       | /hackable/users/gordonb.jpg | gordonb | e99a18c428cb38d5f260853678922e03 (abc123)   | Brown     | Gordon     | 2018-12-15 00:42:31 | 0            |</span><br><span class="line">| 3       | /hackable/users/1337.jpg    | 1337    | 8d3533d75ae2c3966d7e0d4fcc69216b (charley)  | Me        | Hack       | 2018-12-15 00:42:31 | 0            |</span><br><span class="line">| 4       | /hackable/users/pablo.jpg   | pablo   | 0d107d09f5bbe40cade3de5c71e9e9b7 (letmein)  | Picasso   | Pablo      | 2018-12-15 00:42:31 | 0            |</span><br><span class="line">| 5       | /hackable/users/smithy.jpg  | smithy  | 5f4dcc3b5aa765d61d8327deb882cf99 (password) | Smith     | Bob        | 2018-12-15 00:42:31 | 0            |</span><br><span class="line">+---------+-----------------------------+---------+---------------------------------------------+-----------+------------+---------------------+--------------+</span><br></pre></td></tr></table></figure><p>这里就可以看到 <code>dvwa.users</code> 表的全部内容，甚至连简单密码都帮你完成了爆破。</p><p>更多内容可以自行尝试，说真的，这个工具相当强大。如果仅仅说我针对某型数据库(例如 MySQL)完成诸如基于报错的注入，在不考虑鲁棒性的情况下，完全可以做到。但是支持超10余种数据库，且自动完成注入的全过程…</p><h2 id="预编译-SQL"><a href="#预编译-SQL" class="headerlink" title="预编译 SQL"></a>预编译 SQL</h2><p>提了这么多，究竟 SQL 注入就不能够预防吗? 当然可以，不然整个网络环境下的WEB应用不得都完蛋了。有釜底抽薪的处理方式吗，也有。</p><p>预编译 SQL 就是一个超级 OK 的解决方案。同时在使用上也能够明显提升 DB 查询效率</p><p>我相信预编译 SQL 很多人写过，毕竟借助例如 MyBatis 框架，能够快速实现 SQL 预编译语句的编写。同时在求学过程中估计也都用过 Java 原生 JDBC 的 <code>PreparedStatement</code> 。</p><p>那么，与 MySQL 交互时的预编译 SQL 是怎么样地填上了占位符呢? 先来看看再说</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; prepare &#123;name&#125; from 'SELECT * FROM users WHERE user=? AND passwd=?'; # 这里的 &#123;name&#125; 可以自定义命名，无需 &#123;&#125;</span><br><span class="line"></span><br><span class="line">mysql&gt; set @a='admin', @b='password';     # 声明变量，并赋值</span><br><span class="line"></span><br><span class="line">mysql&gt; execute &#123;name&#125; using @a, @b;     # 提供变量并执行预编译 SQL</span><br></pre></td></tr></table></figure><p>我想看到这里应该就应该能够明白了吧，MySQL 对于预编译 SQL 的每一个占位符，都已经认定了是单一的元素，也就不可能存在允许打破已有预编译结果的内容了。</p><p>即使真的注入了 <code>admin OR 1=1</code> 之类的内容，也是会被认为这是一个完整的字符串，用来替代 <code>user</code> 字段或 <code>passwd</code> 字段，根本不可能重新拆解。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说实话此前对 SQL 注入的理解仅仅只是皮毛。当然，目前也是，只是有了一定程度的理解。&lt;/p&gt;
&lt;p&gt;最近好像工具用得有些过头了，需要停下来整理下工具的实现原理。&lt;/p&gt;
&lt;p&gt;更好地理解了工具实现，才能更加心安理得地使用工具。毕竟等别人怼的时候，还能够比较安心地回道: “我用不用现成的工具只是取决于我想不想自己再写一套”&lt;/p&gt;
&lt;p&gt;当然，毕竟成熟的工具有更多的优化，这就不是短时间内我想不想自己写的问题了，哈哈。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Security" scheme="https://DorMOUSE-None.github.io/tags/Security/"/>
    
      <category term="SQL" scheme="https://DorMOUSE-None.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式指数爆炸</title>
    <link href="https://DorMOUSE-None.github.io/2018-11-16-regex-exponential-explosion/"/>
    <id>https://DorMOUSE-None.github.io/2018-11-16-regex-exponential-explosion/</id>
    <published>2018-11-15T16:00:00.000Z</published>
    <updated>2018-11-16T07:22:56.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>昨天接触到一个很有意思的问题, 公司测试环境一台机器 CPU 跑到了 400%，导致该机器上的所有服务都挂掉了。</p><p>最后查到的原因竟然是正则表达式所引起的，大大出乎意料啊。虽然早就知道正则效率很差，但绝对没有想到会导致整个机器上服务崩溃的情况。</p><p>先简单展示下问题正则:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String regex = <span class="string">"(\\w+,?)+"</span>;</span><br><span class="line">String val = <span class="string">"abcdefghijklmno,abcdefghijklmno+"</span>;</span><br><span class="line">System.out.println(val.matches(regex));</span><br></pre></td></tr></table></figure><p>最终的执行时间是 17s 左右。</p><p>相反，如果改成 <code>String val = &quot;abcdefghijklmno,abcdefghijklmno&quot;</code> ，实际执行时间 1ms 左右。</p><p>哈哈，完全不是一个量级的结果。</p><p>最后，当然是要找原因了:&lt; 当然，有其它重要的事在耽搁，没时间去看 Java Regex 源码。不过，从正则本身下手反而是个好事情。毕竟几乎所有的编程语言都有对正则的支持。而同样的，都存在着这样的问题。那就可以大胆猜想其实是和语言本身无关，而在于正则规范本身了。</p><p>先给个结果，罪魁祸首就是<code>指数爆炸</code></p><a id="more"></a><h2 id="追本溯源"><a href="#追本溯源" class="headerlink" title="追本溯源"></a>追本溯源</h2><p>这里并不准备一步一步地阐述正则的，如果真的是零基础的话，推荐先看一下 <a href="https://github.com/ziishaned/learn-regex/blob/master/README-cn.md" target="_blank" rel="noopener">学习正则</a></p><p>就事论事，还是以 <code>regex ::= (\w+,?)+</code> 作为示例来进行说明。</p><p>首先需要了解的是 <code>val.matches(regex)</code> 所要进行的工作是判断 <code>val</code> 全串是否符合 <code>regex</code> 正则模式。而正则所要做的工作就是尝试所有的匹配可能性(当然，对于 <code>val</code> 这个串来说，最后匹配到 <code>abcd..,abcd..mno+</code> 的 <code>+</code> 的时候一定是失败的，因为 <code>regex</code> 并不匹配 <code>+</code>)</p><p>简单扩展一下对<code>尝试所有匹配可能性</code>这句话的描述:</p><p>我们以 <code>()</code> 对应 <code>regex</code> 中的一组 <code>(\w+,?)</code> ，而最后一个 <code>+</code> 表示一个或多个(即允许存在多个<code>()</code>)</p><p>对 <code>val</code> 串的匹配可能性有</p><ul><li><p>(abcdefghijklmno,)(abcdefghijklmno)+</p></li><li><p>(abcd)(efghijklmno,)(abcdefghijklmno)+</p></li><li><p>(abcdefghijklmno,)(abcdef)(ghijklmno)+</p></li><li><p>(abc)(defghijklmno,)(abcde)(fg)(hijklmno)+</p></li><li><p>…</p></li></ul><p>有相当多的匹配可能，不再一一详述(事实上，光靠个人手工根本列举不完。</p><p>那么到底会有多少中匹配可能性呢?</p><p>下面我们就来简单计算一下:</p><p>首先，我们把 <code>(\w+,?)+</code> 这个正则扩展一下，它与下列这些串都是等价的 <code>(\w+,|\w+)+</code>, <code>(\w+,)?(\w+)?(\w+,?)+</code>, <code>(\w+,)?(\w+)?(\w+)?(\w+,?)+</code> …</p><p>也就是说，我们能够至少把 <code>abcdefghijklmno,abcdefghijklmno+</code> 按照匹配串划分出1组，2组，3组…30组(因为每个组至少需要一个<code>\w</code> )</p><p>不过这个按照1组，2组…去计算可能性的话实在是费力不讨好的事情。用组合数学来考虑这个问题</p><p>首先，整个 <code>abcdefghijklmno,abcdefghijklmno+</code> 的开始应该有一个左括号 <code>(</code>，即 <code>(abcdefghijklmno,abcdefghijklmno+</code></p><p>其次，到 <code>,</code> 为止至少应该有一个右左括号 <code>)(</code>，即 <code>(abcdefghijklmno,)(abcdefghijklmno+</code></p><p>再次，由于到 <code>o+</code> 为止一定匹配失败，因此，<code>+</code> 之前应该有一个 <code>)</code>, 即 <code>(abcdefghijklmno,)(abcdefghijklmno)+</code></p><p>至于其他字符间的空隙，除了 <code>o,</code> 之间不能存在右左括号 <code>)(</code> ，其他字符间都可以随意插入 <code>)(</code> (至于为什么是右左括号，表示前一个组的结束与新的组的开始)</p><p>那么总共有多少种可能? </p><ul><li><p>插入零个右左括号 <code>)(</code> , $C_{28}^0$ = 1 种可行方案</p></li><li><p>插入一个右左括号 <code>)(</code> , $C_{28}^1$ = 28 种可行方案 (总共 28 个可用字符间隙)</p></li><li><p>插入两个右左括号 <code>)(</code> , $C_{28}^2$ 种可行方案</p></li><li><p>…</p></li><li><p>插入28个右左括号 <code>)(</code> , $C_{28}^{28}$ 种可行方案</p></li></ul><p>累加的结果为 $C_{28}^1 + C_{28}^2 + C_{28}^3 + … + C_{28}^{28} = 2^{28}$</p><p>可想而知为什么会花 17s 了吧。毕竟达到了 2500 万以上的计算量级，加上 regex 本身就是偏慢的。</p><p>至于为什么把 <code>abcdefghijklmno,abcdefghijklmno+</code> 串的 <code>+</code> 去掉就变快了？理由也很简单，<code>matches(regex)</code> 在正则串与原串匹配上之后就会快速结束，因为结果只需要告知某次匹配成功了即可。而失败的匹配会不断地尝试所有的可能性。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>至于解决方案，从上面的原因就可以看到，拒绝在贪婪组模式下(<code>(...)+</code>) 的组内多模式匹配可能。即 <code>(a+a+)+</code> 是不能被允许的，而 <code>(a+b+)+</code> 是可靠的。</p><p>写得仓促，如有根源性错误，欢迎指正。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.regular-expressions.info/catastrophic.html" target="_blank" rel="noopener">Catastrophic Backtracking(灾难性回溯)</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;昨天接触到一个很有意思的问题, 公司测试环境一台机器 CPU 跑到了 400%，导致该机器上的所有服务都挂掉了。&lt;/p&gt;
&lt;p&gt;最后查到的原因竟然是正则表达式所引起的，大大出乎意料啊。虽然早就知道正则效率很差，但绝对没有想到会导致整个机器上服务崩溃的情况。&lt;/p&gt;
&lt;p&gt;先简单展示下问题正则:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;String regex = &lt;span class=&quot;string&quot;&gt;&quot;(\\w+,?)+&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String val = &lt;span class=&quot;string&quot;&gt;&quot;abcdefghijklmno,abcdefghijklmno+&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(val.matches(regex));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最终的执行时间是 17s 左右。&lt;/p&gt;
&lt;p&gt;相反，如果改成 &lt;code&gt;String val = &amp;quot;abcdefghijklmno,abcdefghijklmno&amp;quot;&lt;/code&gt; ，实际执行时间 1ms 左右。&lt;/p&gt;
&lt;p&gt;哈哈，完全不是一个量级的结果。&lt;/p&gt;
&lt;p&gt;最后，当然是要找原因了:&amp;lt; 当然，有其它重要的事在耽搁，没时间去看 Java Regex 源码。不过，从正则本身下手反而是个好事情。毕竟几乎所有的编程语言都有对正则的支持。而同样的，都存在着这样的问题。那就可以大胆猜想其实是和语言本身无关，而在于正则规范本身了。&lt;/p&gt;
&lt;p&gt;先给个结果，罪魁祸首就是&lt;code&gt;指数爆炸&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="regular expression" scheme="https://DorMOUSE-None.github.io/tags/regular-expression/"/>
    
      <category term="指数爆炸" scheme="https://DorMOUSE-None.github.io/tags/%E6%8C%87%E6%95%B0%E7%88%86%E7%82%B8/"/>
    
  </entry>
  
  <entry>
    <title>理解 Linux Kernel (6) - read &amp; write</title>
    <link href="https://DorMOUSE-None.github.io/2018-11-11-understand-Kernel-6/"/>
    <id>https://DorMOUSE-None.github.io/2018-11-11-understand-Kernel-6/</id>
    <published>2018-11-10T16:00:00.000Z</published>
    <updated>2018-11-11T02:42:26.367Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://dormouse-none.github.io/2018-10-14-understand-Kernel-5/">前一篇</a>已经描述对文件系统进行了宏观性的描述，这一篇，将以特定的文件读写操作为示例，串联对整个文件系统的基本操作。</p><p>首先先来看看平台相关的文件读写操作的 C 代码是怎样一个调用方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">panic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s (errno=%d)\n"</span>, strerror(errno), errno);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 打开文件 frw.txt (以可读写 | 若不存在则新建的形式) */</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/root/frw.txt"</span>, O_RDWR | O_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> panic();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 向文件写入 Hello World! 共计 12 个字符 */</span></span><br><span class="line">    <span class="keyword">ssize_t</span> wsize = write(fd, <span class="string">"Hello World!"</span>, <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">if</span> (wsize == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> panic();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 重定位文件读写指针 */</span></span><br><span class="line">    <span class="keyword">off_t</span> off = lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    <span class="keyword">if</span> (off == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> panic();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* buf = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(wsize);</span><br><span class="line">    <span class="comment">/* 读取文件内容 */</span></span><br><span class="line">    <span class="keyword">ssize_t</span> rsize = read(fd, buf, wsize);</span><br><span class="line">    <span class="keyword">if</span> (rsize == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> panic();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buf);</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">    <span class="comment">/* 关闭文件 */</span></span><br><span class="line">    <span class="keyword">int</span> stat = close(fd);</span><br><span class="line">    <span class="keyword">if</span> (stat == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> panic();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="高速缓冲区初始化"><a href="#高速缓冲区初始化" class="headerlink" title="高速缓冲区初始化"></a>高速缓冲区初始化</h2><p>上一篇已经描述过了，文件系统的结构、包括数据，都是持久化地存储在存储设备中的。</p><p>但是，我们应该也隐约的了解另一个事实，文件读写操作并不会直接操作存储设备上的数据，而是先经过一个称之为高速缓冲的内存区域。</p><p>那么，高速缓冲是什么? 究竟承担什么工作? 先来看看它的初始化流程吧。</p><p>首先回到 <code>main.c</code> (内核代码的主函数)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> ROOT_DEV = ORIG_ROOT_DEV;</span><br><span class="line"> drive_info = DRIVE_INFO;</span><br><span class="line">memory_end = (<span class="number">1</span>&lt;&lt;<span class="number">20</span>) + (EXT_MEM_K&lt;&lt;<span class="number">10</span>);</span><br><span class="line">memory_end &amp;= <span class="number">0xfffff000</span>;</span><br><span class="line"><span class="keyword">if</span> (memory_end &gt; <span class="number">16</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">memory_end = <span class="number">16</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">if</span> (memory_end &gt; <span class="number">12</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">buffer_memory_end = <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (memory_end &gt; <span class="number">6</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">buffer_memory_end = <span class="number">2</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">buffer_memory_end = <span class="number">1</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">main_memory_start = buffer_memory_end;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RAMDISK</span></span><br><span class="line">main_memory_start += rd_init(main_memory_start, RAMDISK*<span class="number">1024</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">mem_init(main_memory_start,memory_end);</span><br><span class="line">trap_init();</span><br><span class="line">blk_dev_init();</span><br><span class="line">chr_dev_init();</span><br><span class="line">tty_init();</span><br><span class="line">time_init();</span><br><span class="line">sched_init();                       <span class="comment">// 第四篇已经讲过，负责任务调度模块的初始化</span></span><br><span class="line">buffer_init(buffer_memory_end);     <span class="comment">// 本篇的起始，负责缓冲区的初始化</span></span><br><span class="line">hd_init();</span><br><span class="line">floppy_init();</span><br><span class="line">sti();</span><br><span class="line">move_to_user_mode();</span><br><span class="line"><span class="keyword">if</span> (!fork()) &#123;<span class="comment">/* we count on this going ok */</span></span><br><span class="line">init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(;;) pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>buffer_init(buffer_memory_end);</code> 用来初始化缓冲区。此处有几个原因:</p><ol><li><p>CPU 读写操作如果直接操作外存，速度上是一个极大的考验。毕竟内存已经较之 CPU 速度慢，外存的读写速度就更慢了。</p></li><li><p>解耦，其实读写操作并不仅仅发生在外存(块存储设备)，同样的，字符设备等等也都会需要读写操作，增加中间层可以封装变化。</p></li><li><p>更多，个人了解有限…</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> &#123;</span></span><br><span class="line"> <span class="keyword">char</span> * b_data;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">long</span> b_blocknr;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> b_dev;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> b_uptodate;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> b_dirt;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> b_count;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> b_lock;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">b_wait</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_prev</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_next</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_prev_free</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_next_free</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* from fs/buffer.c */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buffer_init</span><span class="params">(<span class="keyword">long</span> buffer_end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">h</span> = <span class="title">start_buffer</span>;</span></span><br><span class="line"><span class="keyword">void</span> * b;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (buffer_end == <span class="number">1</span>&lt;&lt;<span class="number">20</span>)</span><br><span class="line">b = (<span class="keyword">void</span> *) (<span class="number">640</span>*<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">b = (<span class="keyword">void</span> *) buffer_end;</span><br><span class="line"><span class="keyword">while</span> ( (b -= BLOCK_SIZE) &gt;= ((<span class="keyword">void</span> *) (h+<span class="number">1</span>)) ) &#123;</span><br><span class="line">h-&gt;b_dev = <span class="number">0</span>;</span><br><span class="line">h-&gt;b_dirt = <span class="number">0</span>;</span><br><span class="line">h-&gt;b_count = <span class="number">0</span>;</span><br><span class="line">h-&gt;b_lock = <span class="number">0</span>;</span><br><span class="line">h-&gt;b_uptodate = <span class="number">0</span>;</span><br><span class="line">h-&gt;b_wait = <span class="literal">NULL</span>;</span><br><span class="line">h-&gt;b_next = <span class="literal">NULL</span>;</span><br><span class="line">h-&gt;b_prev = <span class="literal">NULL</span>;</span><br><span class="line">h-&gt;b_data = (<span class="keyword">char</span> *) b;</span><br><span class="line">h-&gt;b_prev_free = h<span class="number">-1</span>;</span><br><span class="line">h-&gt;b_next_free = h+<span class="number">1</span>;</span><br><span class="line">h++;</span><br><span class="line">NR_BUFFERS++;</span><br><span class="line">        <span class="comment">/* 跳过 640K ~ 1M 的显存和 BIOS RAM 部分 */</span></span><br><span class="line"><span class="keyword">if</span> (b == (<span class="keyword">void</span> *) <span class="number">0x100000</span>)</span><br><span class="line">b = (<span class="keyword">void</span> *) <span class="number">0xA0000</span>;</span><br><span class="line">&#125;</span><br><span class="line">h--;</span><br><span class="line">free_list = start_buffer;</span><br><span class="line">free_list-&gt;b_prev_free = h;</span><br><span class="line">h-&gt;b_next_free = free_list;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;NR_HASH;i++)</span><br><span class="line">hash_table[i]=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缓冲块的所有关键信息都由 <code>buffer_head</code> 数据结构进行记录, 至于有多少个 <code>buffer_head</code>? 只能说能划分多少就划分多少。</p><p>比较直观的结构信息如下</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwy2iag1exj31kw0k1dgb.jpg" alt=""></p><p>在 <code>main.c</code> 中已经提前确认了内核程序占用内存的大小，缓冲区大小以及主内存大小。</p><p>在高速缓冲区的开始位置，都用来存储 <code>buffer_head</code> 的信息，与每个缓冲块(从缓冲区结束位置开始分配)一一对应，直到中间某个位置不足以分配缓冲块为止。</p><p>另外的信息，就是可以看到一个 <code>hash_table</code> 数据结构了。</p><p>应该都能够想象，每个缓存块与外存中的数据块相对应，通过设备号 + 数据块号进行唯一定位。但是，如何快速查找需要操作的数据块是否已经存在与高速缓存中了呢? 显然直接遍历查找是不太可靠的办法。采用开放地址法的哈希表能够协助快速定位缓冲块。</p><h2 id="挂载文件系统"><a href="#挂载文件系统" class="headerlink" title="挂载文件系统"></a>挂载文件系统</h2><p>既然高速缓冲区都准备就绪了，那么文件系统是否已经挂载了呢? 很遗憾，知道 <code>main()</code> 调用 <code>init()</code> 函数之前，文件系统依然没有挂载，也就是说，CPU 仍然只能通过基本输入输出对存储设备进行相当初级的 IO 操作。</p><p>那么，什么时候才能去挂载根目录呢?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* from init/main.c */</span></span><br><span class="line"><span class="comment">/* 由 main() 触发 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pid,i;</span><br><span class="line">    <span class="comment">/* 这是比较重要的一环了，开始挂载的起始动作 */</span></span><br><span class="line">setup((<span class="keyword">void</span> *) &amp;drive_info);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>setup</code> 函数做了什么呢？这是一个内嵌汇编，主要做的就是触发系统调用 <code>int 0x80</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">__inline__ int setup(void * BIOS) &#123; </span><br><span class="line">    long __res; </span><br><span class="line">    __asm__ volatile (</span><br><span class="line">            &quot;int $0x80&quot; </span><br><span class="line">            : &quot;=a&quot; (__res) </span><br><span class="line">            : &quot;0&quot; (0),&quot;b&quot; ((long)(BIOS))</span><br><span class="line">    ); </span><br><span class="line">    if (__res &gt;= 0) </span><br><span class="line">        return (int) __res; </span><br><span class="line">    errno = -__res; </span><br><span class="line">    return -1; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中看到给出的 <code>EAX = 0</code>, 查表(表在 <code>include/linux/sys.h</code> 里) 可以知道触发的是 <code>sys_setup</code> 函数(函数位于 <code>kernel/blk_drv/hd.c</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This may be used only once, enforced by 'static int callable' */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_setup</span><span class="params">(<span class="keyword">void</span> * BIOS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> callable = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> i,drive;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> cmos_disks;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">partition</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* setup 只允许被调用一次 */</span></span><br><span class="line"><span class="keyword">if</span> (!callable)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">callable = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 可以强制在源码中指定硬盘参数, 所以加了宏定义作判断*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HD_TYPE</span></span><br><span class="line"><span class="keyword">for</span> (drive=<span class="number">0</span> ; drive&lt;<span class="number">2</span> ; drive++) &#123;</span><br><span class="line">hd_info[drive].cyl = *(<span class="keyword">unsigned</span> <span class="keyword">short</span> *) BIOS;</span><br><span class="line">hd_info[drive].head = *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *) (<span class="number">2</span>+BIOS);</span><br><span class="line">hd_info[drive].wpcom = *(<span class="keyword">unsigned</span> <span class="keyword">short</span> *) (<span class="number">5</span>+BIOS);</span><br><span class="line">hd_info[drive].ctl = *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *) (<span class="number">8</span>+BIOS);</span><br><span class="line">hd_info[drive].lzone = *(<span class="keyword">unsigned</span> <span class="keyword">short</span> *) (<span class="number">12</span>+BIOS);</span><br><span class="line">hd_info[drive].sect = *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *) (<span class="number">14</span>+BIOS);</span><br><span class="line">BIOS += <span class="number">16</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hd_info[<span class="number">1</span>].cyl)</span><br><span class="line">NR_HD=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">NR_HD=<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;NR_HD ; i++) &#123;</span><br><span class="line">hd[i*<span class="number">5</span>].start_sect = <span class="number">0</span>;</span><br><span class="line">hd[i*<span class="number">5</span>].nr_sects = hd_info[i].head*</span><br><span class="line">hd_info[i].sect*hd_info[i].cyl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">We querry CMOS about hard disks : it could be that</span></span><br><span class="line"><span class="comment">we have a SCSI/ESDI/etc controller that is BIOS</span></span><br><span class="line"><span class="comment">compatable with ST-506, and thus showing up in our</span></span><br><span class="line"><span class="comment">BIOS table, but not register compatable, and therefore</span></span><br><span class="line"><span class="comment">not present in CMOS.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Furthurmore, we will assume that our ST-506 drives</span></span><br><span class="line"><span class="comment">&lt;if any&gt; are the primary drives in the system, and</span></span><br><span class="line"><span class="comment">the ones reflected as drive 1 or 2.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The first drive is stored in the high nibble of CMOS</span></span><br><span class="line"><span class="comment">byte 0x12, the second in the low nibble.  This will be</span></span><br><span class="line"><span class="comment">either a 4 bit drive type or 0xf indicating use byte 0x19</span></span><br><span class="line"><span class="comment">for an 8 bit type, drive 1, 0x1a for drive 2 in CMOS.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Needless to say, a non-zero value means we have</span></span><br><span class="line"><span class="comment">an AT controller hard disk for that drive.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((cmos_disks = CMOS_READ(<span class="number">0x12</span>)) &amp; <span class="number">0xf0</span>)</span><br><span class="line"><span class="keyword">if</span> (cmos_disks &amp; <span class="number">0x0f</span>)</span><br><span class="line">NR_HD = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">NR_HD = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">NR_HD = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = NR_HD ; i &lt; <span class="number">2</span> ; i++) &#123;</span><br><span class="line">hd[i*<span class="number">5</span>].start_sect = <span class="number">0</span>;</span><br><span class="line">hd[i*<span class="number">5</span>].nr_sects = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/* 更进一步设置每个盘的参数 */</span></span><br><span class="line"><span class="keyword">for</span> (drive=<span class="number">0</span> ; drive&lt;NR_HD ; drive++) &#123;</span><br><span class="line">        <span class="comment">/* 0x300 和 0x305 分别代表两个硬盘 */</span></span><br><span class="line">        <span class="comment">/* 读取每个硬盘的第一块数据 (1024B) */</span></span><br><span class="line"><span class="keyword">if</span> (!(bh = bread(<span class="number">0x300</span> + drive*<span class="number">5</span>,<span class="number">0</span>))) &#123;</span><br><span class="line">printk(<span class="string">"Unable to read partition table of drive %d\n\r"</span>,</span><br><span class="line">drive);</span><br><span class="line">panic(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">/* 判断硬盘有效性 */</span></span><br><span class="line"><span class="keyword">if</span> (bh-&gt;b_data[<span class="number">510</span>] != <span class="number">0x55</span> || (<span class="keyword">unsigned</span> <span class="keyword">char</span>)</span><br><span class="line">    bh-&gt;b_data[<span class="number">511</span>] != <span class="number">0xAA</span>) &#123;</span><br><span class="line">printk(<span class="string">"Bad partition table on drive %d\n\r"</span>,drive);</span><br><span class="line">panic(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">/* 读取分区表 (位于 引导扇区第 446 字节开始处 */</span></span><br><span class="line">p = <span class="number">0x1BE</span> + (<span class="keyword">void</span> *)bh-&gt;b_data;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;<span class="number">5</span>;i++,p++) &#123;</span><br><span class="line">hd[i+<span class="number">5</span>*drive].start_sect = p-&gt;start_sect;</span><br><span class="line">hd[i+<span class="number">5</span>*drive].nr_sects = p-&gt;nr_sects;</span><br><span class="line">&#125;</span><br><span class="line">brelse(bh);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (NR_HD)</span><br><span class="line">printk(<span class="string">"Partition table%s ok.\n\r"</span>,(NR_HD&gt;<span class="number">1</span>)?<span class="string">"s"</span>:<span class="string">""</span>);</span><br><span class="line">rd_load();              <span class="comment">/* 尝试创建并加载虚拟盘 */</span></span><br><span class="line">mount_root();           <span class="comment">/* mount 根文件系统 */</span></span><br><span class="line"><span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于到了挂载文件系统的时候了</p><p><code>mount_root</code> 用来做初级的初始化工作。同时，上一节已经描述过了，存储设备的超级块是用了记录整个文件系统最重要的结构。</p><p>那么通过将超级块的信息读取到内存，也就可以将内存与外存的文件系统相互联系起来了。</p><p>下面这段代码最重要的内容就是 <code>read_super()</code> 函数了 .</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mount_root</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,<span class="built_in">free</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">p</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">mi</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">32</span> != <span class="keyword">sizeof</span> (struct d_inode))</span><br><span class="line">panic(<span class="string">"bad i-node size"</span>);</span><br><span class="line">    <span class="comment">/* 先初始化文件表，该版本操作系统限制最大同时打开 NR_FILE(64个) 文件 */</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;NR_FILE;i++)</span><br><span class="line">        <span class="comment">/* f_count = 0 表明没有被引用 */</span></span><br><span class="line">file_table[i].f_count=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 如果引导盘是软盘的话，提示插入根文件系统盘 */</span></span><br><span class="line"><span class="keyword">if</span> (MAJOR(ROOT_DEV) == <span class="number">2</span>) &#123;</span><br><span class="line">printk(<span class="string">"Insert root floppy and press ENTER"</span>);</span><br><span class="line">wait_for_keypress();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/* 初始化内存超级块数据结构 (总共 8 个) */</span></span><br><span class="line"><span class="keyword">for</span>(p = &amp;super_block[<span class="number">0</span>] ; p &lt; &amp;super_block[NR_SUPER] ; p++) &#123;</span><br><span class="line">p-&gt;s_dev = <span class="number">0</span>;</span><br><span class="line">p-&gt;s_lock = <span class="number">0</span>;</span><br><span class="line">p-&gt;s_wait = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/* Hint: 读取超级块的信息，挂载根文件系统重要的部分(代码请往下翻) */</span></span><br><span class="line"><span class="keyword">if</span> (!(p=read_super(ROOT_DEV)))</span><br><span class="line">panic(<span class="string">"Unable to mount root"</span>);</span><br><span class="line">    <span class="comment">/* 读取文件系统的 1 号i节点 (即该设备上文件系统的根节点) */</span></span><br><span class="line"><span class="keyword">if</span> (!(mi=iget(ROOT_DEV,ROOT_INO)))</span><br><span class="line">panic(<span class="string">"Unable to read root i-node"</span>);</span><br><span class="line">mi-&gt;i_count += <span class="number">3</span> ;<span class="comment">/* NOTE! it is logically used 4 times, not 1 */</span></span><br><span class="line">p-&gt;s_isup = p-&gt;s_imount = mi;</span><br><span class="line">    <span class="comment">/* 应该还记得吧，current 指的是当前的任务(任务1)，以后所有的任务都会由任务1或任务1的子任务进行派生，也就意味着 current-&gt;root 会一直复制过去</span></span><br><span class="line"><span class="comment">     * 到这里为止，应该认为根文件系统以及被挂载了。是不是跟被耍了一样?</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">current-&gt;pwd = mi;</span><br><span class="line">current-&gt;root = mi;</span><br><span class="line"><span class="built_in">free</span>=<span class="number">0</span>;</span><br><span class="line">i=p-&gt;s_nzones;</span><br><span class="line">    <span class="comment">/* 统计还有多少空闲数据块以及多少可用i节点 (附上一张启动过程中打印的信息) */</span></span><br><span class="line"><span class="keyword">while</span> (-- i &gt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> (!set_bit(i&amp;<span class="number">8191</span>,p-&gt;s_zmap[i&gt;&gt;<span class="number">13</span>]-&gt;b_data))</span><br><span class="line"><span class="built_in">free</span>++;</span><br><span class="line">printk(<span class="string">"%d/%d free blocks\n\r"</span>,<span class="built_in">free</span>,p-&gt;s_nzones);</span><br><span class="line"><span class="built_in">free</span>=<span class="number">0</span>;</span><br><span class="line">i=p-&gt;s_ninodes+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (-- i &gt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> (!set_bit(i&amp;<span class="number">8191</span>,p-&gt;s_imap[i&gt;&gt;<span class="number">13</span>]-&gt;b_data))</span><br><span class="line"><span class="built_in">free</span>++;</span><br><span class="line">printk(<span class="string">"%d/%d free inodes\n\r"</span>,<span class="built_in">free</span>,p-&gt;s_ninodes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwz8kvvgbpj30l006i3yb.jpg" alt=""></p><p>重要要的部分，<code>read_super(int dev)</code>，用于读取超级块的数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct super_block * <span class="title">read_super</span><span class="params">(<span class="keyword">int</span> dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">s</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line"><span class="keyword">int</span> i,block;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!dev)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">check_disk_change(dev);</span><br><span class="line">    <span class="comment">/* 如果该超级块已经在内存中了，那么就直接使用 (和这里挂载根文件系统的流程无关) */</span></span><br><span class="line"><span class="keyword">if</span> (s = get_super(dev))</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">    <span class="comment">/* 设备超级块不在内存中，就先找一个空闲的内存超级块 (总共维护 8 个超级块数据结构) */</span></span><br><span class="line"><span class="keyword">for</span> (s = <span class="number">0</span>+super_block ;; s++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s &gt;= NR_SUPER+super_block)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (!s-&gt;s_dev)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">s-&gt;s_dev = dev;</span><br><span class="line">s-&gt;s_isup = <span class="literal">NULL</span>;</span><br><span class="line">s-&gt;s_imount = <span class="literal">NULL</span>;</span><br><span class="line">s-&gt;s_time = <span class="number">0</span>;</span><br><span class="line">s-&gt;s_rd_only = <span class="number">0</span>;</span><br><span class="line">s-&gt;s_dirt = <span class="number">0</span>;</span><br><span class="line">lock_super(s);</span><br><span class="line">    <span class="comment">/* 通过 block read 读取设备第一个物理块 (每个物理块 1024 B) */</span></span><br><span class="line"><span class="keyword">if</span> (!(bh = bread(dev,<span class="number">1</span>))) &#123;</span><br><span class="line">s-&gt;s_dev=<span class="number">0</span>;</span><br><span class="line">free_super(s);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/* 复制一份超级块的数据 */</span></span><br><span class="line">*((struct d_super_block *) s) =</span><br><span class="line">*((struct d_super_block *) bh-&gt;b_data);</span><br><span class="line">    <span class="comment">/* 释放缓冲区的数据 */</span></span><br><span class="line">brelse(bh);</span><br><span class="line">    <span class="comment">/* 验证魔数, 该版本操作系统只支持 1.0 版 Minix 文件系统，魔数 0x137F */</span></span><br><span class="line"><span class="keyword">if</span> (s-&gt;s_magic != SUPER_MAGIC) &#123;</span><br><span class="line">s-&gt;s_dev = <span class="number">0</span>;</span><br><span class="line">free_super(s);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/* 先清空内存中的数据 */</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;I_MAP_SLOTS;i++)</span><br><span class="line">s-&gt;s_imap[i] = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;Z_MAP_SLOTS;i++)</span><br><span class="line">s-&gt;s_zmap[i] = <span class="literal">NULL</span>;</span><br><span class="line">block=<span class="number">2</span>;</span><br><span class="line">    <span class="comment">/* 读取 i 节点位图块 */</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span> ; i &lt; s-&gt;s_imap_blocks ; i++)</span><br><span class="line"><span class="keyword">if</span> (s-&gt;s_imap[i]=bread(dev,block))</span><br><span class="line">block++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">/* 读取数据块位图 */</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span> ; i &lt; s-&gt;s_zmap_blocks ; i++)</span><br><span class="line"><span class="keyword">if</span> (s-&gt;s_zmap[i]=bread(dev,block))</span><br><span class="line">block++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (block != <span class="number">2</span>+s-&gt;s_imap_blocks+s-&gt;s_zmap_blocks) &#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;I_MAP_SLOTS;i++)</span><br><span class="line">brelse(s-&gt;s_imap[i]);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Z_MAP_SLOTS;i++)</span><br><span class="line">brelse(s-&gt;s_zmap[i]);</span><br><span class="line">s-&gt;s_dev=<span class="number">0</span>;</span><br><span class="line">free_super(s);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">s-&gt;s_imap[<span class="number">0</span>]-&gt;b_data[<span class="number">0</span>] |= <span class="number">1</span>;</span><br><span class="line">s-&gt;s_zmap[<span class="number">0</span>]-&gt;b_data[<span class="number">0</span>] |= <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* 与前面的 wait_on_super() 对应(解开lock标志) */</span></span><br><span class="line">free_super(s);</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是觉得也没什么，就这样根文件系统已经挂载了? 毫无实感是吧。</p><h2 id="Extra-普通挂载"><a href="#Extra-普通挂载" class="headerlink" title="Extra: 普通挂载"></a>Extra: 普通挂载</h2><p>既然讲过了根文件系统的挂载。那就顺带着讲讲普通文件系统的挂载吧。</p><p>相信从命令上来讲应该比较简单也比较熟悉吧。<code>mount disk.img /mnt</code> 也算是挂载到 /mnt 下了</p><p>但是，究竟是怎么实现的呢?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_mount</span><span class="params">(<span class="keyword">char</span> * dev_name, <span class="keyword">char</span> * dir_name, <span class="keyword">int</span> rw_flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">dev_i</span>, * <span class="title">dir_i</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">sb</span>;</span></span><br><span class="line"><span class="keyword">int</span> dev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 省略大部分判断逻辑, 主要就是:</span></span><br><span class="line"><span class="comment">     * 1. 判断 dev_name 所属的设备号，读取该设备上的超级块</span></span><br><span class="line"><span class="comment">     * 2. 读取 dir_name (需要挂载到的位置)，判定是否允许被挂载(比如根节点不允许挂其它设备)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置超级块的 mount 标志 */</span></span><br><span class="line">sb-&gt;s_imount=dir_i;</span><br><span class="line">    <span class="comment">/* 设置该 i 节点的 mount 标志 */</span></span><br><span class="line">dir_i-&gt;i_mount=<span class="number">1</span>;</span><br><span class="line">dir_i-&gt;i_dirt=<span class="number">1</span>;<span class="comment">/* NOTE! we don't iput(dir_i) */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">/* we do that in umount */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><p>前面讲了这么多，终于到了最关心的部分了。当然，也并不是说前面的内容不重要，事实上，相当重要，只是都隐藏在了内核引导的过程中，且调用频度低，才导致了没有存在感。但是这恰恰才是支持文件读写的基石。</p><p>不多说废话，下面就要开始文件读写的内容。</p><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>打开文件的函数原型是 <code>int open(const char * filename, int flag, ...);</code></p><p>当然，此类系统调用最终的实现都是 <code>int 0x80</code> , 明确一个调用号，然后就陷入内核态了。</p><p>内核态下调用的函数是: <code>int sys_open(const char * filename,int flag,int mode)</code> </p><p>来看看细节:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * filename,<span class="keyword">int</span> flag,<span class="keyword">int</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">f</span>;</span></span><br><span class="line"><span class="keyword">int</span> i,fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * current 是由内核数据段维护的当前任务的指针</span></span><br><span class="line"><span class="comment">     * umask 是指当前任务在新建文件时的默认掩码</span></span><br><span class="line"><span class="comment">     *   例如 Linux 默认是 022, 即新建文件被禁止了组用户与其它用户的写权限</span></span><br><span class="line"><span class="comment">     * 这里是先确定新建文件的权限</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">mode &amp;= <span class="number">0777</span> &amp; ~current-&gt;umask;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 文件描述符，每个文件单独维护一套，以数字标记</span></span><br><span class="line"><span class="comment">     * 找一个空闲的文件描述符项</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">for</span>(fd=<span class="number">0</span> ; fd&lt;NR_OPEN ; fd++)</span><br><span class="line"><span class="keyword">if</span> (!current-&gt;filp[fd])</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (fd&gt;=NR_OPEN)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 顾名思义，设置在调用 exec() 函数时主动关闭的文件</span></span><br><span class="line"><span class="comment">     * exec() 通常与 fork() 联用，fork() 负责复制一个任务，而 exec 负责替换新任务的代码和数据段(从而产生一个新的任务)</span></span><br><span class="line"><span class="comment">     * 这里的声明即是复位 fd 位置的标志，允许子任务也持有相同的文件描述符项</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">current-&gt;close_on_exec &amp;= ~(<span class="number">1</span>&lt;&lt;fd);</span><br><span class="line">f=<span class="number">0</span>+file_table;</span><br><span class="line">    <span class="comment">/* 在文件表中找一项空闲的 */</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;NR_FILE ; i++,f++)</span><br><span class="line"><span class="keyword">if</span> (!f-&gt;f_count) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (i&gt;=NR_FILE)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="comment">/* 当前任务的文件描述符项指向文件表项, 同时文件表项的引用计数+1*/</span></span><br><span class="line">(current-&gt;filp[fd]=f)-&gt;f_count++;</span><br><span class="line">    <span class="comment">/* 调用 open_namei 打开文件，如果失败则释放刚才占用的文件结构，并返回错误码 */</span></span><br><span class="line"><span class="keyword">if</span> ((i=open_namei(filename,flag,mode,&amp;inode))&lt;<span class="number">0</span>) &#123;</span><br><span class="line">current-&gt;filp[fd]=<span class="literal">NULL</span>;</span><br><span class="line">f-&gt;f_count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 对不同的文件进行不同的特殊处理, 毕竟有 "一切皆文件" 的口号嘛</span></span><br><span class="line"><span class="comment">     * 诸如字符设备等也都是文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">/* ttys are somewhat special (ttyxx major==4, tty major==5) */</span></span><br><span class="line"><span class="keyword">if</span> (S_ISCHR(inode-&gt;i_mode))</span><br><span class="line"><span class="keyword">if</span> (MAJOR(inode-&gt;i_zone[<span class="number">0</span>])==<span class="number">4</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (current-&gt;leader &amp;&amp; current-&gt;tty&lt;<span class="number">0</span>) &#123;</span><br><span class="line">current-&gt;tty = MINOR(inode-&gt;i_zone[<span class="number">0</span>]);</span><br><span class="line">tty_table[current-&gt;tty].pgrp = current-&gt;pgrp;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (MAJOR(inode-&gt;i_zone[<span class="number">0</span>])==<span class="number">5</span>)</span><br><span class="line"><span class="keyword">if</span> (current-&gt;tty&lt;<span class="number">0</span>) &#123;</span><br><span class="line">iput(inode);</span><br><span class="line">current-&gt;filp[fd]=<span class="literal">NULL</span>;</span><br><span class="line">f-&gt;f_count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Likewise with block-devices: check for floppy_change */</span></span><br><span class="line"><span class="keyword">if</span> (S_ISBLK(inode-&gt;i_mode))</span><br><span class="line">check_disk_change(inode-&gt;i_zone[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">/* 初始化内存文件结构的各个参数 */</span></span><br><span class="line">f-&gt;f_mode = inode-&gt;i_mode;</span><br><span class="line">f-&gt;f_flags = flag;</span><br><span class="line">f-&gt;f_count = <span class="number">1</span>;</span><br><span class="line">f-&gt;f_inode = inode;</span><br><span class="line">f-&gt;f_pos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> (fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在整个打开文件的过程中，除了真正去文件系统查找文件的时候用到了文件名，其它时候，都将是以文件描述符进行交互的。</p><p>再看看更细节的方面，毕竟就目前来说，我们跳过了最重要的一环 <code>open_namei</code> ，从而看似整个流程都简单了很多很多。</p><p>通常我们在编码过程中都是通过绝对地址/相对地址来唯一定位一个文件。因此，就必然存在逐级寻找文件的过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct m_inode * <span class="title">get_dir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * thisname;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line"><span class="keyword">int</span> namelen,inr,idev;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span> * <span class="title">de</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判定当前任务设定的根节点是否有效 */</span></span><br><span class="line"><span class="keyword">if</span> (!current-&gt;root || !current-&gt;root-&gt;i_count)</span><br><span class="line">panic(<span class="string">"No root inode"</span>);</span><br><span class="line">    <span class="comment">/* 判定当前路径i节点是否有效 */</span></span><br><span class="line"><span class="keyword">if</span> (!current-&gt;pwd || !current-&gt;pwd-&gt;i_count)</span><br><span class="line">panic(<span class="string">"No cwd inode"</span>);</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 这里的 get_fs_byte(..) 是宏定义，fs 指的是 FS 段寄存器</span></span><br><span class="line"><span class="comment">     * Linux 内核将 DS, ES 用于内核数据段, 用 FS 指向局部描述符表的当前任务数据段</span></span><br><span class="line"><span class="comment">     * 这里可以简单理解成取字符数组的第一个字节</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">if</span> ((c=get_fs_byte(pathname))==<span class="string">'/'</span>) &#123;</span><br><span class="line">inode = current-&gt;root;</span><br><span class="line">pathname++;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (c)</span><br><span class="line">inode = current-&gt;pwd;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">/* empty name is bad */</span></span><br><span class="line">inode-&gt;i_count++;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">thisname = pathname;</span><br><span class="line"><span class="keyword">if</span> (!S_ISDIR(inode-&gt;i_mode) || !permission(inode,MAY_EXEC)) &#123;</span><br><span class="line">iput(inode);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(namelen=<span class="number">0</span>;(c=get_fs_byte(pathname++))&amp;&amp;(c!=<span class="string">'/'</span>);namelen++)</span><br><span class="line"><span class="comment">/* nothing */</span> ;</span><br><span class="line"><span class="keyword">if</span> (!c)</span><br><span class="line"><span class="keyword">return</span> inode;</span><br><span class="line"><span class="keyword">if</span> (!(bh = find_entry(&amp;inode,thisname,namelen,&amp;de))) &#123;</span><br><span class="line">iput(inode);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">inr = de-&gt;inode;</span><br><span class="line">idev = inode-&gt;i_dev;</span><br><span class="line">brelse(bh);</span><br><span class="line">iput(inode);</span><br><span class="line"><span class="keyword">if</span> (!(inode = iget(idev,inr)))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *dir_namei()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 处理路径 pathname, 处理成i节点表示的最终一级目录+目录下文件名(也可能pathname表示的就是目录)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct m_inode * <span class="title">dir_namei</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname, <span class="keyword">int</span> * namelen, <span class="keyword">const</span> <span class="keyword">char</span> ** name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * basename;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">dir</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(dir = get_dir(pathname)))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">basename = pathname;</span><br><span class="line"><span class="keyword">while</span> (c=get_fs_byte(pathname++))</span><br><span class="line"><span class="keyword">if</span> (c==<span class="string">'/'</span>)</span><br><span class="line">basename=pathname;</span><br><span class="line">*namelen = pathname-basename<span class="number">-1</span>;</span><br><span class="line">*name = basename;</span><br><span class="line"><span class="keyword">return</span> dir;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *open_namei()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * namei for open - this is in fact almost the whole open-routine.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_namei</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname, <span class="keyword">int</span> flag, <span class="keyword">int</span> mode,</span></span></span><br><span class="line"><span class="function"><span class="params">struct m_inode ** res_inode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * basename;</span><br><span class="line"><span class="keyword">int</span> inr,dev,namelen;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">dir</span>, *<span class="title">inode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span> * <span class="title">de</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((flag &amp; O_TRUNC) &amp;&amp; !(flag &amp; O_ACCMODE))</span><br><span class="line">flag |= O_WRONLY;</span><br><span class="line">mode &amp;= <span class="number">0777</span> &amp; ~current-&gt;umask;</span><br><span class="line">mode |= I_REGULAR;</span><br><span class="line"><span class="keyword">if</span> (!(dir = dir_namei(pathname,&amp;namelen,&amp;basename)))</span><br><span class="line"><span class="keyword">return</span> -ENOENT;</span><br><span class="line">    <span class="comment">/* 如果给的 pathname 是一个目录 */</span></span><br><span class="line"><span class="keyword">if</span> (!namelen) &#123;<span class="comment">/* special case: '/usr/' etc */</span></span><br><span class="line"><span class="keyword">if</span> (!(flag &amp; (O_ACCMODE|O_CREAT|O_TRUNC))) &#123;</span><br><span class="line">*res_inode=dir;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">iput(dir);</span><br><span class="line"><span class="keyword">return</span> -EISDIR;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/* 找到目录对应的i节点的数据块 */</span></span><br><span class="line">bh = find_entry(&amp;dir,basename,namelen,&amp;de);</span><br><span class="line"><span class="keyword">if</span> (!bh) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(flag &amp; O_CREAT)) &#123;</span><br><span class="line">iput(dir);</span><br><span class="line"><span class="keyword">return</span> -ENOENT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!permission(dir,MAY_WRITE)) &#123;</span><br><span class="line">iput(dir);</span><br><span class="line"><span class="keyword">return</span> -EACCES;</span><br><span class="line">&#125;</span><br><span class="line">inode = new_inode(dir-&gt;i_dev);</span><br><span class="line"><span class="keyword">if</span> (!inode) &#123;</span><br><span class="line">iput(dir);</span><br><span class="line"><span class="keyword">return</span> -ENOSPC;</span><br><span class="line">&#125;</span><br><span class="line">inode-&gt;i_uid = current-&gt;euid;</span><br><span class="line">inode-&gt;i_mode = mode;</span><br><span class="line">inode-&gt;i_dirt = <span class="number">1</span>;</span><br><span class="line">bh = add_entry(dir,basename,namelen,&amp;de);</span><br><span class="line"><span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">inode-&gt;i_nlinks--;</span><br><span class="line">iput(inode);</span><br><span class="line">iput(dir);</span><br><span class="line"><span class="keyword">return</span> -ENOSPC;</span><br><span class="line">&#125;</span><br><span class="line">de-&gt;inode = inode-&gt;i_num;</span><br><span class="line">bh-&gt;b_dirt = <span class="number">1</span>;</span><br><span class="line">brelse(bh);</span><br><span class="line">iput(dir);</span><br><span class="line">*res_inode = inode;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">inr = de-&gt;inode;</span><br><span class="line">dev = dir-&gt;i_dev;</span><br><span class="line">brelse(bh);</span><br><span class="line">iput(dir);</span><br><span class="line"><span class="keyword">if</span> (flag &amp; O_EXCL)</span><br><span class="line"><span class="keyword">return</span> -EEXIST;</span><br><span class="line"><span class="keyword">if</span> (!(inode=iget(dev,inr)))</span><br><span class="line"><span class="keyword">return</span> -EACCES;</span><br><span class="line"><span class="keyword">if</span> ((S_ISDIR(inode-&gt;i_mode) &amp;&amp; (flag &amp; O_ACCMODE)) ||</span><br><span class="line">    !permission(inode,ACC_MODE(flag))) &#123;</span><br><span class="line">iput(inode);</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line">&#125;</span><br><span class="line">inode-&gt;i_atime = CURRENT_TIME;</span><br><span class="line"><span class="keyword">if</span> (flag &amp; O_TRUNC)</span><br><span class="line">truncate(inode);</span><br><span class="line">*res_inode = inode;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h3><p>接下来就要进行文件写入的流程了</p><p>如何陷入内核态函数就不再细说了，相信看过这么多系统调用之后，也能知道基本上系统调用在内核态对应的函数都是以 sys_<method> 形式出现的</method></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_write</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> fd,<span class="keyword">char</span> * buf,<span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">file</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 非法 fd , 抛异常 */</span></span><br><span class="line"><span class="keyword">if</span> (fd&gt;=NR_OPEN || count &lt;<span class="number">0</span> || !(file=current-&gt;filp[fd]))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="comment">/* count = 0，无需写入数据 */</span></span><br><span class="line"><span class="keyword">if</span> (!count)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">inode=file-&gt;f_inode;</span><br><span class="line">    <span class="comment">/* 针对不同的i节点类型，有不同的写入函数 */</span></span><br><span class="line"><span class="keyword">if</span> (inode-&gt;i_pipe)</span><br><span class="line"><span class="keyword">return</span> (file-&gt;f_mode&amp;<span class="number">2</span>)?write_pipe(inode,buf,count):-EIO;</span><br><span class="line"><span class="keyword">if</span> (S_ISCHR(inode-&gt;i_mode))</span><br><span class="line"><span class="keyword">return</span> rw_char(WRITE,inode-&gt;i_zone[<span class="number">0</span>],buf,count,&amp;file-&gt;f_pos);</span><br><span class="line"><span class="keyword">if</span> (S_ISBLK(inode-&gt;i_mode))</span><br><span class="line"><span class="keyword">return</span> block_write(inode-&gt;i_zone[<span class="number">0</span>],&amp;file-&gt;f_pos,buf,count);</span><br><span class="line"><span class="keyword">if</span> (S_ISREG(inode-&gt;i_mode))</span><br><span class="line"><span class="keyword">return</span> file_write(inode,file,buf,count);</span><br><span class="line">printk(<span class="string">"(Write)inode-&gt;i_mode=%06o\n\r"</span>,inode-&gt;i_mode);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看对于常规文件是怎么操作的吧。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_write</span><span class="params">(struct m_inode * inode, struct file * filp, <span class="keyword">char</span> * buf, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">off_t</span> pos;      <span class="comment">/* 偏移量 */</span></span><br><span class="line"><span class="keyword">int</span> block,c;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line"><span class="keyword">char</span> * p;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果是 Append 模式，把偏移量重置到文件末尾 */</span></span><br><span class="line"><span class="keyword">if</span> (filp-&gt;f_flags &amp; O_APPEND) </span><br><span class="line">pos = inode-&gt;i_size;</span><br><span class="line">    <span class="comment">/* 否则就使用当前文件数据结构持有的偏移量 */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        附上数据结构  file 的内容 </span></span><br><span class="line"><span class="comment">        struct file &#123;</span></span><br><span class="line"><span class="comment">        unsigned short f_mode;</span></span><br><span class="line"><span class="comment">        unsigned short f_flags;</span></span><br><span class="line"><span class="comment">        unsigned short f_count;</span></span><br><span class="line"><span class="comment">        struct m_inode * f_inode;</span></span><br><span class="line"><span class="comment">        off_t f_pos;    每个打开的文件都将持有当前的偏移值</span></span><br><span class="line"><span class="comment">        &#125;;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">pos = filp-&gt;f_pos;</span><br><span class="line">    <span class="comment">/* 逐字符向缓冲区写入数据 */</span></span><br><span class="line"><span class="keyword">while</span> (i&lt;count) &#123;</span><br><span class="line">        <span class="comment">/* 最开始当然是创建在磁盘上占用一个数据块了 (如果文件对应的块不存在的话) */</span></span><br><span class="line"><span class="keyword">if</span> (!(block = create_block(inode,pos/BLOCK_SIZE)))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/* 根据数据块获得相应的缓冲块 */</span></span><br><span class="line"><span class="keyword">if</span> (!(bh=bread(inode-&gt;i_dev,block)))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/* 在缓冲块中的偏移量 */</span></span><br><span class="line">c = pos % BLOCK_SIZE;</span><br><span class="line">        <span class="comment">/* 定位到具体的缓冲区的内存地址 */</span></span><br><span class="line">p = c + bh-&gt;b_data;</span><br><span class="line">bh-&gt;b_dirt = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/* 当前这个缓冲块还有多少字节可写 */</span></span><br><span class="line">c = BLOCK_SIZE-c;</span><br><span class="line">        <span class="comment">/* 如果需要写入的数据量少于 c */</span></span><br><span class="line"><span class="keyword">if</span> (c &gt; count-i) c = count-i;</span><br><span class="line">        <span class="comment">/* 添加偏移量计数, 更新数据结构中维护的值 */</span></span><br><span class="line">pos += c;</span><br><span class="line"><span class="keyword">if</span> (pos &gt; inode-&gt;i_size) &#123;</span><br><span class="line">inode-&gt;i_size = pos;</span><br><span class="line">inode-&gt;i_dirt = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">i += c;</span><br><span class="line">        <span class="comment">/* 向缓冲块逐字节写入数据 */</span></span><br><span class="line"><span class="keyword">while</span> (c--&gt;<span class="number">0</span>)</span><br><span class="line">*(p++) = get_fs_byte(buf++);</span><br><span class="line">        <span class="comment">/* 释放对缓冲块的占用，当然，在释放前会完成缓冲块&lt;-&gt;外存数据块的同步 */</span></span><br><span class="line">brelse(bh);</span><br><span class="line">&#125;</span><br><span class="line">inode-&gt;i_mtime = CURRENT_TIME;</span><br><span class="line"><span class="keyword">if</span> (!(filp-&gt;f_flags &amp; O_APPEND)) &#123;</span><br><span class="line">        <span class="comment">/* 非 APPEND 模式，更新文件读写指针(偏移量); APPEND 模式是使用 inode-&gt;i_size ，所有就不需要在这里更新了 */</span></span><br><span class="line">filp-&gt;f_pos = pos;</span><br><span class="line">inode-&gt;i_ctime = CURRENT_TIME;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (i?i:<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是觉得也没有什么太高大上的操作。确实如此，更多关于缓存块与文件系统数据块的同步都已经被包装到 bread(), brelse() 中了。</p><p>不过，暂时无需细究。总之到此为止，先要有一个基础的观念: 所有与外存储器(这里也包括控制台等)进行数据交互都必须经过缓冲区</p><p>缓冲区封装了对外存储器的全部操作，而提供给 CPU 更高效的 I/O 操作，当然，也更为简单快捷</p><h3 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h3><p>至于文件读取，也基本类似了，所以也就不再深入描述。</p><p>当然，要注意的就是，在本篇开始的部分提供的例程中，write &amp; read 中插入了 <code>off_t off = lseek(fd, 0, SEEK_SET);</code>  这样的代码。</p><p>原因应该也能够想到，学习 <code>sys_write(..)</code> 的时候我们已经看到，任务对同一个文件在内存中维护了一个文件读写偏移量。因此，要读取刚才写入的内容，就不得不先改动这个读写偏移量了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_read</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> fd,<span class="keyword">char</span> * buf,<span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">file</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fd&gt;=NR_OPEN || count&lt;<span class="number">0</span> || !(file=current-&gt;filp[fd]))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (!count)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">verify_area(buf,count);</span><br><span class="line">inode = file-&gt;f_inode;</span><br><span class="line"><span class="keyword">if</span> (inode-&gt;i_pipe)</span><br><span class="line"><span class="keyword">return</span> (file-&gt;f_mode&amp;<span class="number">1</span>)?read_pipe(inode,buf,count):-EIO;</span><br><span class="line"><span class="keyword">if</span> (S_ISCHR(inode-&gt;i_mode))</span><br><span class="line"><span class="keyword">return</span> rw_char(READ,inode-&gt;i_zone[<span class="number">0</span>],buf,count,&amp;file-&gt;f_pos);</span><br><span class="line"><span class="keyword">if</span> (S_ISBLK(inode-&gt;i_mode))</span><br><span class="line"><span class="keyword">return</span> block_read(inode-&gt;i_zone[<span class="number">0</span>],&amp;file-&gt;f_pos,buf,count);</span><br><span class="line"><span class="keyword">if</span> (S_ISDIR(inode-&gt;i_mode) || S_ISREG(inode-&gt;i_mode)) &#123;</span><br><span class="line"><span class="keyword">if</span> (count+file-&gt;f_pos &gt; inode-&gt;i_size)</span><br><span class="line">count = inode-&gt;i_size - file-&gt;f_pos;</span><br><span class="line"><span class="keyword">if</span> (count&lt;=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> file_read(inode,file,buf,count);</span><br><span class="line">&#125;</span><br><span class="line">printk(<span class="string">"(Read)inode-&gt;i_mode=%06o\n\r"</span>,inode-&gt;i_mode);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这篇对文件系统的代码层面的描述，仅仅只是捡了一个相当有限的片面 (常规文件读写)。从文件系统的挂载开始提供了一个读写的完整流程介绍(当然，很多细节是缺失的，不过不要着急)。</p><p>虽然平常都能够了解到一个比较模糊的前提，文件读写需要利用缓冲区，但是究竟什么是缓存区，如何使用都不会有太多的概念。本篇最大的重点，就是首先请读者们建立起一个基础性的对缓冲区的了解。事实上，这个中介在 I/O 中扮演了相当重要的角色。而且内存也为其提供了相当大的一份空间，差不多有 1/4 了。</p><p>跨了差不多半个多月来写，上下文的承接可能有些生硬了，甚至不一致了… 尴尬…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://dormouse-none.github.io/2018-10-14-understand-Kernel-5/&quot;&gt;前一篇&lt;/a&gt;已经描述对文件系统进行了宏观性的描述，这一篇，将以特定的文件读写操作为示例，串联对整个文件系统的基本操作。&lt;/p&gt;
&lt;p&gt;首先先来看看平台相关的文件读写操作的 C 代码是怎样一个调用方式&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;fcntl.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;errno.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;sys/stat.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;fprintf&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;stderr&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;%s (errno=%d)\n&quot;&lt;/span&gt;, strerror(errno), errno);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *argv[])&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* 打开文件 frw.txt (以可读写 | 若不存在则新建的形式) */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; fd = open(&lt;span class=&quot;string&quot;&gt;&quot;/root/frw.txt&quot;&lt;/span&gt;, O_RDWR | O_CREAT);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (fd == &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; panic();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* 向文件写入 Hello World! 共计 12 个字符 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;ssize_t&lt;/span&gt; wsize = write(fd, &lt;span class=&quot;string&quot;&gt;&quot;Hello World!&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (wsize == &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; panic();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* 重定位文件读写指针 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;off_t&lt;/span&gt; off = lseek(fd, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, SEEK_SET);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (off == &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; panic();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;* buf = (&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *) &lt;span class=&quot;built_in&quot;&gt;malloc&lt;/span&gt;(wsize);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* 读取文件内容 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;ssize_t&lt;/span&gt; rsize = read(fd, buf, wsize);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (rsize == &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; panic();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%s\n&quot;&lt;/span&gt;, buf);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;free&lt;/span&gt;(buf);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* 关闭文件 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; stat = close(fd);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (stat == &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; panic();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://DorMOUSE-None.github.io/tags/Linux/"/>
    
      <category term="Kernel" scheme="https://DorMOUSE-None.github.io/tags/Kernel/"/>
    
      <category term="File System" scheme="https://DorMOUSE-None.github.io/tags/File-System/"/>
    
      <category term="read &amp; write" scheme="https://DorMOUSE-None.github.io/tags/read-write/"/>
    
  </entry>
  
  <entry>
    <title>理解 Linux Kernel (5) - 文件系统(宏观描述)</title>
    <link href="https://DorMOUSE-None.github.io/2018-10-14-understand-Kernel-5/"/>
    <id>https://DorMOUSE-None.github.io/2018-10-14-understand-Kernel-5/</id>
    <published>2018-10-13T16:00:00.000Z</published>
    <updated>2018-10-28T05:01:34.567Z</updated>
    
    <content type="html"><![CDATA[<p>用惯了类 Unix 系统，应该说文件系统是日常最常接触的一个操作系统模块之一了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">Applications Network      Users        bin          data         etc          net          sbin         usr</span><br><span class="line">Library      System       Volumes      cores        dev          home         private      tmp          var</span><br></pre></td></tr></table></figure><p>但是，究竟什么是文件系统? 为什么需要文件系统? 难道文件不是简单地存储到存储设备一块连续区域的吗?</p><a id="more"></a><h2 id="文件系统的形式"><a href="#文件系统的形式" class="headerlink" title="文件系统的形式"></a>文件系统的形式</h2><p>首先我们假设文件是简单地存储在存储设备(硬盘等)某一块连续区域的。</p><p>那么如何在小则几百G，大则几十T甚至更大的存储设备上找到具体的某一文件，并读取的内存中呢?</p><p>最普通的，就只能在存储设备上一字节一字节的查找，直到找到相应的目标文件。是不是可以想象，这会很慢很慢。</p><p>有没有快一点的？很容易想到，参考类似字典的形式就可以了。</p><p><strong>目录形式</strong></p><p>文件内容可能很大，但相比之下，文件名就小了很多(就算不同目录下同名文件很多，但是记录全路径名也代价不大。当然了，如果都是小文件、空文件，那就不一样了)</p><p>通过为所有文件通过文件名编一个目录，指明每个文件在存储设备上的具体位置。这样需要扫描的内容就会小很多，也能更快地定位到文件内容。</p><p><strong>逐级目录</strong></p><p>仅仅只编制一个目录，那么层次目录又有什么实际意义吗？只是为了方便用户分类不同功能、目的的文件吗？</p><p>利用逐级目录，可以考虑对次级目录的内容编制上一级目录。通过顶级目录定位次级目录的内容，次级目录定位再次级目录，最后对应目录下的文件的内容。</p><h2 id="文件系统的组织"><a href="#文件系统的组织" class="headerlink" title="文件系统的组织"></a>文件系统的组织</h2><p>在之前的理解里，文件系统是接管了整个存储设备。似乎文件系统和存储设备就是直接关联的，两个不可分割。没有建立文件系统的硬盘就不能使用，而没有硬盘，文件系统就没有了载体。</p><p>但是，在学习 Linux 的过程中，似乎发现也并不是这么一回事。没有直接硬盘，文件系统一样可以存在。一直都有在使用 <code>.img</code> 磁盘映像文件，只是没有意识到，这意识文件系统的一种载体。同样的，没有文件系统，在操作系统启动的过程中，一样是可以加载各种内容，乃至预置的文件信息。</p><p>在 Linux 中，最常见的文件系统就是 ext2, ext3, ext4 之流了。偶尔也有听过用过，比如说准备接入新的硬盘的时候。但是，真正里面是什么样的。还真不了解，ext2,3,4 的区别，也根本不知道。</p><p>当然了，本次也并不会对这些内容进行描述。由于一直在学习 Linux 0.11 版本的源码，接下来要描述的文件系统，也就是 0.11 版本直接使用的 minix 文件系统了。</p><p>最开始，当然是应该有一个感官的印象，才能更方便地来理解文件系统的组织形式啦!</p><h3 id="创建文件系统"><a href="#创建文件系统" class="headerlink" title="创建文件系统"></a>创建文件系统</h3><p>这里我们创建一个 512 KB 大小的文件系统</p><p><code>mkfs</code> 应该是最简单的方式了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch disk.img            <span class="comment"># 磁盘映像文件 (由于没有额外的磁盘，就以此作为新创建的 minix 文件系统的载体)</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> dd <span class="keyword">if</span>=/dev/zero of=disk.img bs=1024 count=512     <span class="comment"># 先将文件的大小扩展到 512 KB ，否则在创建文件系统的时候会失败</span></span></span><br><span class="line">512+0 records in</span><br><span class="line">512+0 records out</span><br><span class="line">524288 bytes (524 kB, 512 KiB) copied, 0.00216049 s, 243 MB/s</span><br><span class="line"><span class="meta">$</span><span class="bash"> mkfs.minix disk.img 512   <span class="comment"># 创建文件系统</span></span></span><br><span class="line">192 inodes                  # inodes - 应该很熟悉吧。每个文件都占用一个 inode</span><br><span class="line">512 blocks                  # 总共 512 个磁盘块</span><br><span class="line">Firstdatazone=10 (10)       # 第 10 个磁盘块开始是真正的数据块。前面是什么? 大部分是目录占用的</span><br><span class="line">Zonesize=1024               # 每个磁盘块的大小为 1024 B</span><br><span class="line">Maxsize=268966912           # 单一文件的最大大小</span><br></pre></td></tr></table></figure><p>先来看看目前 disk.img 里面的内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexdump disk.img</span></span><br><span class="line">0000000 0000 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">*                                                   # * 表示这段数据全为 0</span><br><span class="line">0000400 00c0 0200 0001 0001 000a 0000 1c00 1008</span><br><span class="line">0000410 138f 0001 0000 0000 0000 0000 0000 0000</span><br><span class="line">0000420 0000 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">*</span><br><span class="line">0000800 0003 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">0000810 0000 0000 0000 0000 fffe ffff ffff ffff</span><br><span class="line">0000820 ffff ffff ffff ffff ffff ffff ffff ffff</span><br><span class="line">*                                                   # * 表示这段数据全为 ff ( * 总是表示与前一段数据一致的省略)</span><br><span class="line">0000c00 0003 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">0000c10 0000 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">*</span><br><span class="line">0000c30 0000 0000 0000 0000 0000 0000 0000 ff80</span><br><span class="line">0000c40 ffff ffff ffff ffff ffff ffff ffff ffff</span><br><span class="line">*</span><br><span class="line">0001000 41ed 0000 0040 0000 cf12 5bd3 0200 000a</span><br><span class="line">0001010 0000 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">*</span><br><span class="line">0002800 0001 002e 0000 0000 0000 0000 0000 0000</span><br><span class="line">0002810 0000 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">0002820 0001 2e2e 0000 0000 0000 0000 0000 0000</span><br><span class="line">0002830 0000 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">0002840 0000 622e 6461 6c62 636f 736b 0000 0000</span><br><span class="line">0002850 0000 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">*</span><br><span class="line">0080000                                             # 截止字节，0x80000 = 512 KB 并不存在</span><br></pre></td></tr></table></figure><p>似乎并没有太多的感觉，现在我们往 disk.img 这个磁盘映像文件中添些内容再来看看。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mount disk.img /mnt   <span class="comment"># 把 disk.img 挂载到 /mnt 目录下</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /mnt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"#include &lt;stdio.h&gt;"</span> &gt; hello.c       <span class="comment"># 创建 hello.c 文件，并写入 #include &lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> umount /mnt           <span class="comment"># 解挂 disk.img</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexdump -C disk.img</span></span><br><span class="line">00000000  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">*</span><br><span class="line">00000400  c0 00 00 02 01 00 01 00  0a 00 00 00 00 1c 08 10  |................|</span><br><span class="line">00000410  8f 13 01 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00000420  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">*</span><br><span class="line">00000800  07 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00000810  00 00 00 00 00 00 00 00  fe ff ff ff ff ff ff ff  |................|</span><br><span class="line">00000820  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|</span><br><span class="line">*</span><br><span class="line">00000c00  07 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00000c10  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">*</span><br><span class="line">00000c30  00 00 00 00 00 00 00 00  00 00 00 00 00 00 80 ff  |................|</span><br><span class="line">00000c40  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|</span><br><span class="line">*</span><br><span class="line">00001000  ed 41 00 00 60 00 00 00  e5 0d d4 5b 00 02 0a 00  |.A..`......[....|</span><br><span class="line">00001010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00001020  a4 81 00 00 13 00 00 00  e5 0d d4 5b 00 01 0b 00  |...........[....|</span><br><span class="line">00001030  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">*</span><br><span class="line">00002800  01 00 2e 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00002810  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00002820  01 00 2e 2e 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00002830  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00002840  02 00 68 65 6c 6c 6f 2e  63 00 00 00 00 00 00 00  |..hello.c.......|</span><br><span class="line">00002850  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">*</span><br><span class="line">00002c00  23 69 6e 63 6c 75 64 65  20 3c 73 74 64 69 6f 2e  |#include &lt;stdio.|</span><br><span class="line">00002c10  68 3e 0a 00 00 00 00 00  00 00 00 00 00 00 00 00  |h&gt;..............|</span><br><span class="line">00002c20  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">*</span><br><span class="line">00080000</span><br></pre></td></tr></table></figure><p>很明显，我们看到了 <code>#include &lt;stdio.h&gt;</code> 字样的内容，同时也出现了 <code>hello.c</code> 的文件名。</p><p>需要注意，文件名和文件内容是相互割裂的，并没有直接存储在一起。</p><h3 id="文件系统存储结构"><a href="#文件系统存储结构" class="headerlink" title="文件系统存储结构"></a>文件系统存储结构</h3><p>那么，配合着上面的内容来看看文件系统的组织结构。</p><p>首先可以注意到的是，每一段非零的数据的开始地址，基本都是在 <code>0x0000, 0x0400, 0x0800, 0x0c00, 0x1000</code> 。间隔了 0x0400 = 1KB，这就是最基本的块的大小。</p><p>Minix 文件系统将 1024 B 作为基本块的大小。<code>disk.img</code> 这个 512 KB 的磁盘映像文件，也就恰好被分割成 512 块。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkfs.minix disk.img 512   <span class="comment"># 创建文件系统</span></span></span><br><span class="line">192 inodes                  # inodes - 应该很熟悉吧。每个文件都占用一个 inode</span><br><span class="line">512 blocks                  # 总共 512 个磁盘块</span><br><span class="line">Firstdatazone=10 (10)       # 第 10 个磁盘块开始是真正的数据块。前面是什么? 大部分是目录占用的</span><br><span class="line">Zonesize=1024               # 每个磁盘块的大小为 1024 B</span><br><span class="line">Maxsize=268966912           # 单一文件的最大大小</span><br></pre></td></tr></table></figure><p>在回过头来看看前面创建文件系统的时候的信息，相信也就能够看懂一部分了。</p><p><strong>块的作用划分</strong></p><p>那么，每个块如何进行使用呢？</p><p>首先，最开始的一个块并不会直接使用。我们知道引导程序应该出现在引导盘最开始 512 B。但是，有些盘有引导程序，有些盘又没有，如何处理呢？</p><p>文件系统结构中，默认地不对第一个 1024 B 的块进行操作，即原本是什么数据就是什么数据，与文件系统并不相干。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwnnc753epj31kw04tq35.jpg" alt=""></p><p>除了引导块，之后还有超级块，inode 位图，逻辑块位图，inode 区块，数据区块</p><p><strong>超级块</strong></p><p>真正对 MINIX 文件系统起着统领性作用的，是超级块(第二个块)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> &#123;</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> s_ninodes;          <span class="comment">/* i 节点的数量 */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> s_nzones;           <span class="comment">/* 总区块数量 */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> s_imap_blocks;      <span class="comment">/* i 节点位图的数量 */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> s_zmap_blocks;      <span class="comment">/* 区块位图的数量 */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> s_firstdatazone;    <span class="comment">/* 第一个数据块的编号 */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> s_log_zone_size;    <span class="comment">/* log2(磁盘块大小 / 逻辑块大小) */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">long</span> s_max_size;          <span class="comment">/* 单文件的最大长度 */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> s_magic;            <span class="comment">/* 文件系统的魔数 */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 下面的内容是在内存中使用的，并不会在磁盘上进行读写 */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">s_imap</span>[8];</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">s_zmap</span>[8];</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> s_dev;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">s_isup</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">s_imount</span>;</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">long</span> s_time;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">s_wait</span>;</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> s_lock;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> s_rd_only;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> s_dirt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结合着 <code>disk.img</code> 的数据来看看。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00000400  c0 00 00 02 01 00 01 00  0a 00 00 00 00 1c 08 10  |................|</span><br><span class="line">00000410  8f 13 01 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line"></span><br><span class="line">0x00c0  -&gt; 192 个 i 节点</span><br><span class="line">0x0200  -&gt; 512 个逻辑块</span><br><span class="line">0x0001  -&gt; 一个i节点位图</span><br><span class="line">0x0001  -&gt; 一个逻辑块位图</span><br><span class="line">0x000a  -&gt; 第一个数据块编号为 10 </span><br><span class="line">0x0000  -&gt; log2(磁盘块大小 / 逻辑块大小) = 0 ，即磁盘块大小 = 逻辑块大小 = 1024 B</span><br><span class="line">0x10081c00 -&gt; 单文件最大 268966912 B</span><br></pre></td></tr></table></figure><p><strong>inode 位图</strong></p><p>inode 位图的数据比较简单，是通过设置比特位 0、1 的方式，来直接表明相应编号的 i 节点是否存在。<br>默认 i 节点从 1 号开始编号，0 号节点在 inode 位图上一定设置为 1 </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000800  07 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00000810  00 00 00 00 00 00 00 00  fe ff ff ff ff ff ff ff  |................|</span><br><span class="line">00000820  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|</span><br></pre></td></tr></table></figure><p>总共 192 个 i 节点，加上 0 号节点总计需占用 193 位 ( = 193 / 8 = 24 字节 + 1 位)</p><p>其余多余的位，全部置位为 1 。</p><p>位图存储的最初数据 0x07 (注意，小端存储法) = 0b111</p><p>由此，总共有1号和2号i节点。</p><p><strong>逻辑块位图</strong></p><p>类似的，逻辑块位图是为了表明第n个逻辑块存储有数据，或处于空闲状态。</p><p><strong>inode 区块</strong></p><p>参照前面讲过的字典目录的形式，inode 就是一种分级编排后的目录。</p><p>当然，说目录可能还会引发误解。这里无论是对于操作系统下的目录或是文件，每一个都对应着一个独特的 inode</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">d_inode</span> &#123;</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> i_mode;     <span class="comment">/* 文件类型和属性 (rwx 位) */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> i_uid;      <span class="comment">/* 文件所有者 id */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">long</span> i_size;      <span class="comment">/* 文件大小 */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">long</span> i_time;      <span class="comment">/* 修改时间 */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> i_gid;       <span class="comment">/* 文件所在组 id */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> i_nlinks;    <span class="comment">/* 有多少个链接数 (有多少个文件目录项指向该 i 节点) */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> i_zone[<span class="number">9</span>];  <span class="comment">/* 文件数据所占用数据盘的指针 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个i节点的数据分别 32 字节</p><p>同样的，结合 <code>disk.img</code> 的数据来看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">00001000  ed 41 00 00 60 00 00 00  e5 0d d4 5b 00 02 0a 00  |.A..`......[....|</span><br><span class="line">00001010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00001020  a4 81 00 00 13 00 00 00  e5 0d d4 5b 00 01 0b 00  |...........[....|</span><br><span class="line">00001030  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line"></span><br><span class="line">0x41ed  -&gt; </span><br><span class="line">0x0000  -&gt;  文件所有者为 0 即 root</span><br><span class="line">0x00000060  -&gt;  文件大小为 96 B</span><br><span class="line">0x5bd40de5  -&gt;  文件最后修改时间为 Unix TimeStamp 1540623845 =&gt; 2018/10/27 15:4:5</span><br><span class="line">0x00    -&gt;  文件所在组 id</span><br><span class="line">0x02    -&gt;  有两个文件目录项指向1号i节点</span><br><span class="line">0x000a  -&gt;  1 号 i 节点指向的第0块数据为第10个逻辑块(即第1个数据块)</span><br><span class="line">0x0000  =&gt;  由于数据比较小，后面的 i_zone[1] ~ i_zone[8] 均为 0</span><br></pre></td></tr></table></figure><p>i_zone 指向的是数据实际存储的数据块的位置。</p><p>但是，仅仅只有 9 个指针，每个数据块能存储 1024 B ，是远远达不到之前所描述的单文件 <code>0x10081c00 = 268966912 B</code> 的上限的。</p><p>事实上，minix 在实际处理的过程中，把前7个指针作为直接数据块指针，最多存储 7168 B 数据。</p><p>i_zone[7] 表示一次间接指针，指向某一个数据块，但是该数据块每2字节作为一个指针，指向真正的数据块。</p><p>i_zone[8] 表示二次间接指针。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwnu3zrwuij310y0m6abj.jpg" alt=""><br><small>Copied from Linux 内核完全注释V3.0</small></p><p><strong>数据块</strong></p><p>最后，我们看看数据块的内容，也希望能够更好地来理解 Linux 目录和文件的异同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00002800  01 00 2e 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00002810  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00002820  01 00 2e 2e 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00002830  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00002840  02 00 68 65 6c 6c 6f 2e  63 00 00 00 00 00 00 00  |..hello.c.......|</span><br><span class="line">00002850  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">*</span><br><span class="line">00002c00  23 69 6e 63 6c 75 64 65  20 3c 73 74 64 69 6f 2e  |#include &lt;stdio.|</span><br><span class="line">00002c10  68 3e 0a 00 00 00 00 00  00 00 00 00 00 00 00 00  |h&gt;..............|</span><br><span class="line">00002c20  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br></pre></td></tr></table></figure><p>在i节点区块上，我们看到有1号i节点和2号i节点已经被使用了。</p><p>0x2800 ~ 0x2860 的位置表示的就是 1 号i节点的数据。事实上这是一个目录(当然，怎么区分目录还是文件，在i节点区块的 i_mode 字段已经描述过了)</p><p>对于目录文件，当然是用来记载目录项的，每个目录项占用 32 字节。</p><blockquote><p>这里需要进行说明，MINIX 1.0 版本的文件系统似乎是对每个目录项占用 16 字节的。</p><p>这里提供一个 Linux 0.11 版本的仿真运行结果以供证明<br><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwnuexcwx7j30nw0c8745.jpg" alt=""></p><p>上面描述的 <code>disk.img</code> 是在 Ubuntu 16.04 LTS 下跑出来的结果，所有确实出现了一些差别。<br>至于具体的一个规范，目前还没有找到，所有这部分只能做模糊处理了，勿怪。</p></blockquote><p>前2个字节用来表示该目录项所对应的 i 节点编号。之后的30个字节用来描述该目录项的名字。</p><p>因此，对 0x2800 ~ 0x2860 的数据进行重建的结果就是 <code>. .. hello.c</code> 三个目录项了。其中，由于是根目录，<code>.</code> 和 <code>..</code> 所指向的i节点的相同的，都是1号i节点。</p><p>而 hello.c 文件指向的是 2 号i节点。</p><p>哈哈，2号i节点的数据内容就在 0x2c00 开始的位置。通过右侧的 ASCII 结果我们也可以看到。</p><p>当然，之前说过每个数据块是 1024 B ，那么数据块多余的部分，就是留空咯，而不会被其它i节点占用(除非该文件or目录被完全移除了)</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到此为止，文件系统宏观的描述就已经完结了。</p><p>下一节将对操作系统如何使用文件系统进行描述。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用惯了类 Unix 系统，应该说文件系统是日常最常接触的一个操作系统模块之一了。&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; ls&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Applications Network      Users        bin          data         etc          net          sbin         usr&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Library      System       Volumes      cores        dev          home         private      tmp          var&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是，究竟什么是文件系统? 为什么需要文件系统? 难道文件不是简单地存储到存储设备一块连续区域的吗?&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://DorMOUSE-None.github.io/tags/Linux/"/>
    
      <category term="Kernel" scheme="https://DorMOUSE-None.github.io/tags/Kernel/"/>
    
      <category term="File System" scheme="https://DorMOUSE-None.github.io/tags/File-System/"/>
    
  </entry>
  
</feed>
