<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Utop&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://DorMOUSE-None.github.io/"/>
  <updated>2018-08-16T09:46:16.067Z</updated>
  <id>https://DorMOUSE-None.github.io/</id>
  
  <author>
    <name>Utop</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java Instrumentation</title>
    <link href="https://DorMOUSE-None.github.io/2018-08-15-Java-Instrumentation/"/>
    <id>https://DorMOUSE-None.github.io/2018-08-15-Java-Instrumentation/</id>
    <published>2018-08-14T16:00:00.000Z</published>
    <updated>2018-08-16T09:46:16.067Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><p>从现有的前置知识来说，我们能够认识到两个事实:</p><ol><li>Java Class 通过 ClassLoader 进行加载。<br>通过<code>全限定名</code>进行区分。当需要加载新的类时，ClassLoader 通过双亲委派机制判断是否已经加载过这个类。<br>换句话说: Class 一经加载，就不会尝试重复加载 (至少按绝大多数人的认知来说，确实是的)</li><li>有没有可能让被加载的 Class 与物理存储上的 .class 内容不同。<br>当然也是完全可以做到的。不管怎么说，CGlib 和 Java Proxy 也是一个耳熟能详的概念吧<br>(虽然可能不了解细节。在此，欢迎学习前置技能 <a href="https://dormouse-none.github.io/2018-07-10-CGlib-Enhancer/">CGlib Enhancer 主流程源码解析</a> 和 <a href="https://dormouse-none.github.io/2018-07-20-Java-Proxy/">Java Proxy 源码解析</a>。不过不影响本文后续内容)</li></ol><p>另一个方面，也许绝大多数人都听说过所谓的<code>热部署</code>。但是究竟怎么才能做到 <code>热部署</code>(话题开得有点大哈。Y_Y 本文不讲这个)</p><p>操作字节码一定是一个逃不开的话题，毕竟 Class 就是所谓的被加载到内存的字节码嘛。</p><p>如何操作字节码? ASM, CGlib, Java Proxy, Javassist ? 不过这些都要等到需要被操作的类被加载了才行啊，似乎有点晚…</p><p>Java 提供了一个可行的机制，用来在 ClassLoader 加载字节码之前完成对操作字节码的目的</p><h2 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a>Instrumentation</h2><p><code>java.lang.instrument.Instrumentation</code> 类为提供直接操作 Java 字节码的又一个途径(虽然 Java Doc 的说明是用来检测 Java 代码的)</p><p>相信我这个说明是没有问题的。毕竟完成对代码检测的途径是直接修改字节码。</p><p>下列有两种方法可以达到目的</p><ol><li>当 JVM 以指示一个代理类的方式启动时，将传递给代理类的 premain 方法一个 Instrumentation 实例。</li><li>当 JVM 提供某种机制在 JVM 启动之后某一时刻启动代理时，将传递给代理代码的 agentmain 方法一个 Instrumentation 实例。</li></ol><p>话不多说，下面将全部以实例来展现对这种 JVM 检测机制(虽然例子已经脱离了<em>检测</em>的目的)的使用</p><a id="more"></a><h2 id="对各方法进行执行时间统计"><a href="#对各方法进行执行时间统计" class="headerlink" title="对各方法进行执行时间统计"></a>对各方法进行执行时间统计</h2><h3 id="随-JVM-一起启动"><a href="#随-JVM-一起启动" class="headerlink" title="随 JVM 一起启动"></a>随 JVM 一起启动</h3><p>基本实例: 将对特定包 <code>me.fangfeng.client</code> 下的每个方法执行计时</p><p>首先了解一下 client 包的内容:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.fangfeng.client;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Main.java</span></span><br><span class="line"><span class="comment"> * 执行两个方法，rand() &amp; sleep() </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fangfeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/8/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Rand rand = <span class="keyword">new</span> Rand();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"&gt;&gt;&gt; start Rand.run() &lt;&lt;&lt;"</span>);</span><br><span class="line">            rand.run();</span><br><span class="line">            System.out.println(<span class="string">"&gt;&gt;&gt; end Rand.run() &lt;&lt;&lt;"</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"&gt;&gt;&gt; start Main.sleep() &lt;&lt;&lt;"</span>);</span><br><span class="line">            Main.sleep();</span><br><span class="line">            System.out.println(<span class="string">"&gt;&gt;&gt; end MAin.sleep() &lt;&lt;&lt;"</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.fangfeng.client;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Rand.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fangfeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/8/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rand</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">double</span> rand = Math.random();</span><br><span class="line">            <span class="keyword">if</span> (rand &gt; <span class="number">0.995</span>) &#123;</span><br><span class="line">                System.out.println(String.format(<span class="string">"get random, values %f"</span>, rand));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，来构造一个代理类，以及最重要的 <code>premain</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.fangfeng.javaagent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Agent - 代理</span></span><br><span class="line"><span class="comment"> * 基于 JVM TI (JVM Tool Interface) 实现的 Java ClassFile 的增强</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fangfeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/8/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Agent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// premain 将 JVM 初始化后，main(String... ) 执行前调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String args, Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// new 一个转换器实例</span></span><br><span class="line">        ClassTimer transformer = <span class="keyword">new</span> ClassTimer();</span><br><span class="line">        instrumentation.addTransformer(transformer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 之后的 agentmain(...) 将在这里提供，暂时隐去，避免对对读者产生干扰</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.fangfeng.javaagent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.ClassReader;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.ClassWriter;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.Opcodes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.ClassFileTransformer;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fangfeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/8/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTimer</span> <span class="keyword">implements</span> <span class="title">ClassFileTransformer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer) &#123;</span><br><span class="line">        <span class="comment">// 这里涉及到了 ASM 的内容，主要目的是向每个方法块的开始及方法块的结束部分插入与计时器有关的代码</span></span><br><span class="line">        <span class="comment">// 如果想了解 ASM 的内容，请参阅 https://dormouse-none.github.io/2018-06-25-ASM-Core/  提供了一些基础性的内容，更多的请自行学习</span></span><br><span class="line">        <span class="comment">// 不了解具体内容将不影响对主体内容的理解</span></span><br><span class="line">        ClassReader cr = <span class="keyword">new</span> ClassReader(classfileBuffer);</span><br><span class="line">        ClassWriter cw = <span class="keyword">new</span> ClassWriter(ClassWriter.COMPUTE_FRAMES);</span><br><span class="line">        MyClassWriter mcw = <span class="keyword">new</span> MyClassWriter(Opcodes.ASM6, cw);</span><br><span class="line">        cr.accept(mcw, ClassReader.EXPAND_FRAMES);</span><br><span class="line">        <span class="keyword">return</span> cw.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其它代码略，详见附件。</p><p>Java 这种对操作字节码的支持有个坑爹的地方，就是不得不打包成 Jar 来使用。</p><p>具体来看一下</p><p><code>me.fangfeng.javaagent</code> 包中包括 </p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fublsbbdw0j309o07g74u.jpg" alt=""></p><p>将被打包成 <code>agent.jar</code> 来使用</p><p>首先，来看一下需要打包在 <code>agent.jar</code> 的 <strong>MANIFEST.MF</strong> 的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Class-Path: /Users/fangfeng/.m2/repository/org/ow2/asm/asm/6.1.1/asm-6.1.1.jar</span><br><span class="line">Premain-Class: me.fangfeng.javaagent.Agent</span><br><span class="line">Can-Retransform-Classes: true</span><br></pre></td></tr></table></figure><p>再来个 SHELL 脚本，用来给打包这个 Jar</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 me.fangfeng.javaagent 包下的类</span></span><br><span class="line">javac -cp .:/Users/fangfeng/.m2/repository/org/ow2/asm/asm/6.1.1/asm-6.1.1.jar me/fangfeng/javaagent/Agent.java me/fangfeng/javaagent/ClassTimer.java me/fangfeng/javaagent/MyClassWriter.java me/fangfeng/javaagent/MyMethodWriter.java me/fangfeng/javaagent/StaticTimer.java</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包 me.fangfeng.javaagent 的 .class -&gt; agent.jar</span></span><br><span class="line">jar cvfm agent.jar MANIFEST-agent.MF me/fangfeng/javaagent/Agent.class me/fangfeng/javaagent/ClassTimer.class me/fangfeng/javaagent/MyClassWriter.class me/fangfeng/javaagent/MyMethodWriter.class me/fangfeng/javaagent/StaticTimer.class</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 me.fangfeng.client 包下的类</span></span><br><span class="line">javac me/fangfeng/client/Main.java me/fangfeng/client/Rand.java</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以 me.fangfeng.client.Main 作为主类启动</span></span><br><span class="line">java -javaagent:agent.jar me.fangfeng.client.Main</span><br></pre></td></tr></table></figure><p>执行后，可以看到类似如下内容:</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fubmp354ejj30tq0rmtdp.jpg" alt=""></p><p>而直接用 <code>java me.fangfeng.client.Main</code> 的执行结果是:</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fubmqmj4uhj30j00f0dho.jpg" alt=""></p><p>从理论上来讲，<code>-javaagent:agent.jar</code> 配合 <code>agent.jar</code> 中的 MANIFEST.MF 文件，<br>使得 JVM 在初始化之后触发了被声明为 <code>Pre-Main</code> 的 me.fangfeng.javaagent.Agent 类的 premain(…) 方法。</p><p>并为 ClassLoader 在加载类的流程上增加了一层<strong>拦截器</strong> (这里是 ClassTimer.java 类，它实现了 <code>ClassFileTransformer</code> 接口</p><p>另外，<code>Can-Retransform-Classes: true</code> 的配置使得 ClassTimer 被允许对字节码进行重新转换。(而操作字节码是通过 ASM 来实现的)</p><h3 id="在运行中进行增强"><a href="#在运行中进行增强" class="headerlink" title="在运行中进行增强"></a>在运行中进行增强</h3><p>随着程序启动时直接使用了 <code>-javaagent</code> 选项。</p><p>那么是否存在在程序运行中进行额外代理操作的支持呢？当然是可以的。这里要借助 Java 提供的另一个类 com.sun.tools.attach.VirtualMachine 。</p><p>启动一个新的进程来连接到 正在运行中的进程，并令其加载 java agent。</p><p>基本的类与上一节的描述相同，主要是包 <code>me.fangfeng.javaagent.*</code> 和 <code>me.fangfeng.client.*</code></p><p>新增一个类 <code>me.fangfeng.javaagent.Main</code> 用来启动另一个进程，并要求运行中的 java 进程加载 agent.jar 来进行增强。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.fangfeng.javaagent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.tools.attach.AgentInitializationException;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.attach.AgentLoadException;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.attach.AttachNotSupportedException;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.attach.VirtualMachine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fangfeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/8/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, AttachNotSupportedException, AgentLoadException, AgentInitializationException </span>&#123;</span><br><span class="line">        VirtualMachine vm = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 通过 VirtualMachine 连接到 运行中的进程 (可以通过 jps 找到进程号)</span></span><br><span class="line">            vm = VirtualMachine.attach(&lt;PID&gt;);</span><br><span class="line">            vm.loadAgent(&lt;agent.jar 的路径&gt;);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (vm != <span class="keyword">null</span>) &#123;</span><br><span class="line">                vm.detach();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Agent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String args, Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">        ClassTimer transformer = <span class="keyword">new</span> ClassTimer();</span><br><span class="line">        instrumentation.addTransformer(transformer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在在 Agent.java 上补上 agentmain(...) 的具体实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String args, Instrumentation instrumentation)</span> <span class="keyword">throws</span> UnmodifiableClassException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SUCCESS AGENTMAIN"</span>);</span><br><span class="line">        ClassTimer transformer = <span class="keyword">new</span> ClassTimer();</span><br><span class="line">        <span class="comment">// add Transformer</span></span><br><span class="line">        instrumentation.addTransformer(transformer, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 对 Rand.class 进行重新转换</span></span><br><span class="line">        instrumentation.retransformClasses(Rand.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其它内容基本相同</p><p>首先需要先打包 agent.jar 。当然，如果是顺着本文的顺序进行本机实验，则 agent.jar 已经存在</p><p>先启动进程 <code>java me.fangfeng.client.Main</code></p><p>通过 <code>jps</code> 获取 Main 进程的 <strong>PID</strong></p><p>在 <code>java me.fangfeng.javaagent.Main</code> 中替换上进程号，并执行</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fuboclcelsj30tu152dlw.jpg" alt=""></p><p>从执行结果可以看到，原进程首先正常执行代码，等到被 load Agent 之后，字节码已经有了新的变化，从而导致输出结果动态的产生了变化。</p><p><em>当然，需要注意的是，执行中的进程被要求 load Agent 之后，运行中的 Class 将被改写，并始终如此，知道进程终止。再下一次重新启动</em></p><h2 id="BTrace"><a href="#BTrace" class="headerlink" title="BTrace"></a>BTrace</h2><p>以上描述的内容也可以理解为是 BTrace 实现的基础。毕竟，JVMTI (JVM Tool Interface) 原本的目的就是赋予使用者一个在运行中<br>查询系统各项数据的权利</p><p>当然，实现上，上述代码直接将各种增强(计时)硬编码到该进程中，同时统一使用了该进程的输入输出。</p><p>但是，BTrace 通过 Socket 将这些分离，检测代码通过 Socket 发回新的进程来维持输入输出。</p><p>在此，不再细说。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Start&quot;&gt;&lt;a href=&quot;#Start&quot; class=&quot;headerlink&quot; title=&quot;Start&quot;&gt;&lt;/a&gt;Start&lt;/h2&gt;&lt;p&gt;从现有的前置知识来说，我们能够认识到两个事实:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Java Class 通过 ClassLoader 进行加载。&lt;br&gt;通过&lt;code&gt;全限定名&lt;/code&gt;进行区分。当需要加载新的类时，ClassLoader 通过双亲委派机制判断是否已经加载过这个类。&lt;br&gt;换句话说: Class 一经加载，就不会尝试重复加载 (至少按绝大多数人的认知来说，确实是的)&lt;/li&gt;
&lt;li&gt;有没有可能让被加载的 Class 与物理存储上的 .class 内容不同。&lt;br&gt;当然也是完全可以做到的。不管怎么说，CGlib 和 Java Proxy 也是一个耳熟能详的概念吧&lt;br&gt;(虽然可能不了解细节。在此，欢迎学习前置技能 &lt;a href=&quot;https://dormouse-none.github.io/2018-07-10-CGlib-Enhancer/&quot;&gt;CGlib Enhancer 主流程源码解析&lt;/a&gt; 和 &lt;a href=&quot;https://dormouse-none.github.io/2018-07-20-Java-Proxy/&quot;&gt;Java Proxy 源码解析&lt;/a&gt;。不过不影响本文后续内容)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另一个方面，也许绝大多数人都听说过所谓的&lt;code&gt;热部署&lt;/code&gt;。但是究竟怎么才能做到 &lt;code&gt;热部署&lt;/code&gt;(话题开得有点大哈。Y_Y 本文不讲这个)&lt;/p&gt;
&lt;p&gt;操作字节码一定是一个逃不开的话题，毕竟 Class 就是所谓的被加载到内存的字节码嘛。&lt;/p&gt;
&lt;p&gt;如何操作字节码? ASM, CGlib, Java Proxy, Javassist ? 不过这些都要等到需要被操作的类被加载了才行啊，似乎有点晚…&lt;/p&gt;
&lt;p&gt;Java 提供了一个可行的机制，用来在 ClassLoader 加载字节码之前完成对操作字节码的目的&lt;/p&gt;
&lt;h2 id=&quot;Instrumentation&quot;&gt;&lt;a href=&quot;#Instrumentation&quot; class=&quot;headerlink&quot; title=&quot;Instrumentation&quot;&gt;&lt;/a&gt;Instrumentation&lt;/h2&gt;&lt;p&gt;&lt;code&gt;java.lang.instrument.Instrumentation&lt;/code&gt; 类为提供直接操作 Java 字节码的又一个途径(虽然 Java Doc 的说明是用来检测 Java 代码的)&lt;/p&gt;
&lt;p&gt;相信我这个说明是没有问题的。毕竟完成对代码检测的途径是直接修改字节码。&lt;/p&gt;
&lt;p&gt;下列有两种方法可以达到目的&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当 JVM 以指示一个代理类的方式启动时，将传递给代理类的 premain 方法一个 Instrumentation 实例。&lt;/li&gt;
&lt;li&gt;当 JVM 提供某种机制在 JVM 启动之后某一时刻启动代理时，将传递给代理代码的 agentmain 方法一个 Instrumentation 实例。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;话不多说，下面将全部以实例来展现对这种 JVM 检测机制(虽然例子已经脱离了&lt;em&gt;检测&lt;/em&gt;的目的)的使用&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://DorMOUSE-None.github.io/tags/Java/"/>
    
      <category term="ASM" scheme="https://DorMOUSE-None.github.io/tags/ASM/"/>
    
      <category term="BTrace" scheme="https://DorMOUSE-None.github.io/tags/BTrace/"/>
    
  </entry>
  
  <entry>
    <title>JVM 指令简析</title>
    <link href="https://DorMOUSE-None.github.io/2018-07-24-JVM-Instruction/"/>
    <id>https://DorMOUSE-None.github.io/2018-07-24-JVM-Instruction/</id>
    <published>2018-07-23T16:00:00.000Z</published>
    <updated>2018-07-24T01:08:24.556Z</updated>
    
    <content type="html"><![CDATA[<p>在之前描述过包括 ASM, CGlib, Java Proxy 的基本内容之后，本文将就更为基础的 JVM 指令集进行简单而有效的介绍。</p><p>当然，在开始正文前，读者需要了解到，JVM 指令集这种类似于汇编的规范性内容，包含一百多个指令，若要求一一介绍。<br>那么，直接阅读 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" target="_blank" rel="noopener">官方文档</a> 绝对是比本文的内容更为详实且准确。</p><p>这篇文档的目的，只是为了使读者建立起关于 JVM 指令集基本的常识性观念。</p><a id="more"></a><h2 id="术语约定"><a href="#术语约定" class="headerlink" title="术语约定"></a>术语约定</h2><p>首先，需要就 <code>术语</code> 进行一些基础性的约定:</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1ftidi0xpmij30oa07kaaq.jpg" alt="变量"></p><ul><li><code>变量</code>: 在类中，区分于 <code>方法</code> 的声明<ul><li><code>成员变量</code>: 作用域为整个类，在方法体与语句块之外声明的内容。在 <code>字节码</code> 中通常被称为 <code>字段(Field)</code><ul><li><code>类成员变量 / 静态成员变量</code>: 被 <code>static</code> 修饰的 <code>成员变量</code>。一个类只有一份，在类被加载的时候即初始化。</li><li><code>实例成员变量</code>: 非 <code>static</code> 修饰的 <code>成员变量</code>。随着类被实例化而进行初始化，每个实例对象都有一份特有的 <code>实例变量</code>。</li></ul></li><li><code>局部变量</code>: 作用域为方法体或者语句块。</li></ul></li></ul><h3 id="JVM-指令"><a href="#JVM-指令" class="headerlink" title="JVM 指令"></a>JVM 指令</h3><p>通常，我们借助于 <code>javap</code> 命令来对 .class 文件的字节码内容进行查阅。</p><p>类似于汇编代码，<code>javap</code> 打印的JVM 指令将以下列格式进行展示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;index&gt; &lt;opcode&gt; [&lt;operand1&gt; [&lt;operand2&gt; ...]] [&lt;comment&gt;]</span><br></pre></td></tr></table></figure><p>其中 </p><ul><li><code>&lt;index&gt;</code> 指在 <code>code[]</code> 属性中这条指令的偏移量(从 0 开始计数)。</li><li><code>&lt;opcode&gt;</code> 指 <code>操作码</code></li><li><code>&lt;operandX&gt;</code> 指 <code>操作数</code>，每个 <code>&lt;opcode&gt;</code> 都需要确定数量的操作数(规范中已经确定)。</li><li><code>&lt;comment&gt;</code> 指注释</li></ul><h2 id="指令集概览"><a href="#指令集概览" class="headerlink" title="指令集概览"></a>指令集概览</h2><p>首先，Java 代码经编译后的所有指令都基于 <code>方法(Method)</code> 被定义在 <code>Code</code> 属性中。</p><p>在 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.3" target="_blank" rel="noopener">ClassFile</a> 的 <code>Code</code> 属性，结构定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Code_attribute &#123;</span><br><span class="line">    <span class="comment">// 其中 u1, u2, u4 分别表示这个变量所占的字节长度</span></span><br><span class="line">    u2 attribute_name_index;                    <span class="comment">// 属性名在常量池中的 index (执行常量池中 Code 的位置)</span></span><br><span class="line">    u4 attribute_length;                        <span class="comment">// 属性长度，不包括开始的六个字节</span></span><br><span class="line">    u2 max_stack;                               <span class="comment">// 运行时操作数栈的最大深度</span></span><br><span class="line">    u2 max_locals;                              <span class="comment">// 运行时所需的局部变量表的大小</span></span><br><span class="line">    u4 code_length;                             <span class="comment">// code 数组的长度</span></span><br><span class="line">    u1 code[code_length];                       <span class="comment">// code 数组，编译后方法体的内容都通过字节码指令存储在这里</span></span><br><span class="line">    u2 exception_table_length;                  <span class="comment">// 异常表的长度</span></span><br><span class="line">    &#123;   u2 start_pc;</span><br><span class="line">        u2 end_pc;</span><br><span class="line">        u2 handler_pc;</span><br><span class="line">        u2 catch_type;</span><br><span class="line">    &#125; exception_table[exception_table_length]; <span class="comment">// 异常表，Java 代码中所有的 catch, finally 的捕获都将由此表进行实现</span></span><br><span class="line">    u2 attributes_count;                       <span class="comment">// 属性计数</span></span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 虚拟机的指令是由一个字节长度的 <code>操作码</code> 配合上其后的 0 个或多个 <code>操作数</code> 所构成的。</p><p>其中，<code>操作数</code> 的数量取决于 <code>操作码</code>，不同的 <code>操作码</code> 需要不同数量的 <code>操作数</code>。</p><p>按照类型划分，<code>操作数</code> 主要包括下列几类:</p><ul><li>加载与存储指令，例如 iload, istore 等</li><li>运算指令，例如 iadd, isub, imul 等</li><li>类型转换指令，例如 i2b, i2s 等</li><li>对象创建与操作指令，例如 new, newarray 等</li><li>操作数栈管理指令，例如 dup, pop 等</li><li>控制转移指令，例如 if_icmpeq 等</li><li>方法调用与返回指令，例如 invokevirtual, invokestatic 等</li><li>抛出异常指令，例如 athrow 等</li><li>同步指令，例如 monitorenter 等</li></ul><p><strong>举几个简单的例子:</strong></p><p><code>iadd</code> 指令，表示对两个 int 数的相加指令。将从操作数栈顶依次取出两个数，并相加，再重新压入操作数栈中。</p><p><code>bipush 100</code> ，其中 <code>bipush</code> 是指令，后随一个操作数，表示把 <code>操作数 100 这个 byte 类型的数</code> 压入操作数栈顶</p><h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><p>JVM 定义了若干种运行期间会使用到的运行时数据区，见下图:</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ft5osi6it1j31kw0ql78e.jpg" alt="JVM 运行时数据区"></p><p>至于每一个的具体意义，在此不做详细展开，可用参考:</p><ul><li>由周志明等翻译的 《Java 虚拟机规范(Java SE 7版) 》 2.5节内容 <a href="http://icyfenix.iteye.com/blog/1256329" target="_blank" rel="noopener">链接</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5" target="_blank" rel="noopener">JVMS 2.5. Run-Time Data Areas</a></li></ul><h2 id="Getter-Setter-的指令代码"><a href="#Getter-Setter-的指令代码" class="headerlink" title="Getter, Setter 的指令代码"></a>Getter, Setter 的指令代码</h2><p>首先，有必要提及，想要得到 .class 可视且友好的展示结果，可以使用 JDK 自带的 <code>javap</code> 命令。</p><p>本节要展示的内容是常见的 POJO 的 get, set 方法的指令代码。使用的示例代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在经过 <code>javac</code> 编译，<code>javap</code> 解析之后，我们将看到下列内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">Classfile /Users/fangfeng/WorkPkg/lab/src/main/java/me/fangfeng/asm/Test.class</span><br><span class="line">  Last modified Jul 23, 2018; size 357 bytes</span><br><span class="line">  MD5 checksum bb1940cc6534d789359295b8dc80233b</span><br><span class="line">  Compiled from &quot;Test.java&quot;</span><br><span class="line">public class me.fangfeng.asm.Test</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #4.#17         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #3.#18         // me/fangfeng/asm/Test.number:I</span><br><span class="line">   #3 = Class              #19            // me/fangfeng/asm/Test</span><br><span class="line">   #4 = Class              #20            // java/lang/Object</span><br><span class="line">   #5 = Utf8               number</span><br><span class="line">   #6 = Utf8               I</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               getNumber</span><br><span class="line">  #12 = Utf8               ()I</span><br><span class="line">  #13 = Utf8               setNumber</span><br><span class="line">  #14 = Utf8               (I)V</span><br><span class="line">  #15 = Utf8               SourceFile</span><br><span class="line">  #16 = Utf8               Test.java</span><br><span class="line">  #17 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #18 = NameAndType        #5:#6          // number:I</span><br><span class="line">  #19 = Utf8               me/fangfeng/asm/Test</span><br><span class="line">  #20 = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  public me.fangfeng.asm.Test();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line"></span><br><span class="line">  public int getNumber();</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: getfield      #2                  // Field number:I</span><br><span class="line">         4: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 8: 0</span><br><span class="line"></span><br><span class="line">  public void setNumber(int);</span><br><span class="line">    descriptor: (I)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=2, args_size=2</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: iload_1</span><br><span class="line">         2: putfield      #2                  // Field number:I</span><br><span class="line">         5: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 12: 0</span><br><span class="line">        line 13: 5</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;Test.java&quot;</span><br></pre></td></tr></table></figure><p>打印出来的内容包括有 类的全限定名，访问控制权限，父类，接口，常量池以及各个方法。</p><p>以 <code>getNumber</code> 为例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public int getNumber();</span><br><span class="line">  descriptor: ()I</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=1, locals=1, args_size=1</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: getfield      #2                  // Field number:I</span><br><span class="line">       4: ireturn</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line 8: 0</span><br></pre></td></tr></table></figure><ul><li>descriptor: 表示方法描述符，其中 <code>()</code> 内容表示入参，<code>I</code> 表示返回值的类型</li><li>flags     : 表示方法的访问权限，当前限定为 <code>public</code></li><li>Code      : 存储有当前方法体指令码的一种方法内部属性。<ul><li>stack : 表示当前方法(意即在运行时所处的栈帧，每个方法的调用都将在 <code>虚拟机栈</code> 中构建一个新的 <code>栈帧</code>) 使用的 <code>操作数栈的最大深度</code></li><li>locals: 表示当前方法使用的 <code>局部变量表</code> 的大小</li><li>args_size : 表示变量个数</li><li>LineNumberTable : 与 Debug 有关，指当前的的指令集在源文件中的第几行开始</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0: aload_0              // 从局部变量表中加载 0 号元素到操作数栈中</span><br><span class="line">1: getfield #2          // 获取常量池中 2 号元素(即 Field number:I) 的值，并加载到操作数栈中</span><br><span class="line">4: ireturn              // 抛出当前操作数栈顶元素作为返回值</span><br></pre></td></tr></table></figure><p>其中，每条指令前的 0, 1, 4 指当前指令作为 <code>Code</code> 属性的内容的偏移量。</p><p>换一句话说，<code>aload_0</code> 是 Code 属性 code[] 的第 0 个字节的内容<br><code>getfield #2</code> 的是从 code[] 的第 1 个字节开始的。<br><code>ireturn</code> 是从 code[] 的第 4 个字节开始。</p><p>至于为什么每条指令的开始位置不同，这取决于每条指令的长度。<code>aload_0</code> 指令本身为 1 字节的长度，且不要求附带操作数。<br><code>getfield</code> 指令自长 1 个字节，但需要一个长度为 2 字节的常量池索引。因此 <code>ireturn</code> 将从第 4 字节开始</p><hr><p>同时，可能有人会有所疑问，<code>aload_0</code> 加载的 0 号元素是什么？它貌似没有被用到？</p><p>首先，在每个方法被触发，在构建新的栈帧时，<code>this</code> 将自动作为 0 号元素被存入新栈帧的局部变量表作为 0 号元素。<br>同时，如果方法有入参，则入参按入参声明顺序依次作为 1, 2, 3, … 元素存入。<br>(当然，这里存在特殊情况，诸如 long, double 这样长为 8 字节的元素，将占用 2 个局部变量表的数组下标，而其他元素顺延)。</p><p>至于看似 0 号元素 <code>this</code> 并没有被用到。事实上，它是作为 <code>getfield</code> 的一个限定被使用的。<br>试想，<code>getfield</code> 虽然通过 <code>#2</code> 能够知道需要获取到的变量名为 <code>number</code> 类型为 <code>I(即 int)</code> 的元素。但是，这个元素究竟属于哪个实例？<br>而操作数栈顶的 <code>this</code> 恰恰是指明，需要使用当前方法所在的类的 number 变量。</p><hr><p>类似的，我们看一下 <code>setNumber</code> 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0: aload_0              // 从局部变量表中加载 0 号元素到操作数栈中 (用于确定字段所属的类)</span><br><span class="line">1: iload_1              // 从局部变量表中加载 1 号元素到操作数栈中 (用于确定将要给字段赋的值)</span><br><span class="line">2: putfield      #2     // 获取常量池中 2 号元素(即 Field number:I) 的地址，并赋值</span><br><span class="line">5: return               // 无返回值的 return 指令来结束当前栈帧的执行</span><br></pre></td></tr></table></figure><h2 id="给变量赋初始值"><a href="#给变量赋初始值" class="headerlink" title="给变量赋初始值"></a>给变量赋初始值</h2><p>经常会见到在方法体内部有类似这样的声明 <code>int score = 100</code> ，那么这样的内容翻译成指令会是如何？</p><p>对于较小的值，例如 100，将通过 <code>bipush 100</code>, <code>istore_1(假设用局部变量表 1 号元素存储 score 变量</code> 类似的形式进行赋值。<br>类似的，还是 <code>sipush</code> ，两者的区别是 bipush 可以支持 1 字节大小的整数，sipush 支持 2 字节大小的整数。</p><p>但是，int 最大可是可以到达 4 字节，更甚者，long 将达到 8 字节。</p><p>这时候，将要借助的就是 <code>ldc #&lt;index&gt;</code> 用来读取常量池编号小于 128 的常量(例如整数常量，浮点常量等等)<br>那么，超出 128 编号的？使用 <code>ldc_w #&lt;index&gt;</code> 读取 2 字节内容作为编号，最大 65535。当然，更大的内容，常量池都不能支持了哈。</p><p>同时，区别于将 byte, short, int, float 统一作为 4 字节结果读取，对于 long, double 这样的八字节元素，使用 <code>ldc2_w</code></p><h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><p>作为一门图灵完备的语言，至少，控制结构是必不可少的元素。</p><p>那么，类似 <code>for(int i=0;i&lt;10;i++)</code> 的 Java 代码编译成指令到底是什么样的呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0: iconst_0                     // 赋值指令，往操作数栈顶添加整数值 0</span><br><span class="line">1: istore_1                     // 将操作数栈顶的元素存入局部变量表 1 号位置</span><br><span class="line">2: iload_1                      // 从局部变量表 1 号位置加载元素到操作数栈</span><br><span class="line">3: bipush        10             // 往操作数栈顶压入 byte 型值 10</span><br><span class="line">5: if_icmpge     21             // 将操作数栈顶的两个元素进行比较, 如果 次顶部元素 &gt;= 顶部元素，则重定向到偏移量为 21 的指令</span><br><span class="line">//  for (...) &#123;&#125; 语句块的内容</span><br><span class="line">15: iinc          1, 1          // 将局部变量表的 1 号位置元素 +1</span><br><span class="line">18: goto          2             // 跳转到偏移量为 2 的指令</span><br><span class="line">21: return                      // 调用无返回值的 return</span><br></pre></td></tr></table></figure><p>类似的，<code>if(...)</code> 语句的比较较之 <code>for(;;)</code> 就更为简单。类比偏移量为 5 的指令即可。</p><h2 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h2><p>JVM 指令集中总计有 4 种调用方法的指令，包括有: </p><ul><li><code>invokevirtual</code>, 对普通实例方法的调用，将根据对象类型进行分发调用</li><li><code>invokestatic</code>, 对静态方法的调用</li><li><code>invokespecial</code>, 用于调用类的初始化方法，也用于调用父类方法和私有方法</li><li><code>invokeinterface</code>, 用于调用接口方法</li></ul><p>以执行 <code>System.out.println()</code> 为例<br>假设常量池内容存在目标元素(具体以相应注释为准)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">invokevirtual #4                  // Method java/io/PrintStream.println:()V</span><br></pre></td></tr></table></figure><h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p>更多内容，包括: 如何实例化一个对象，如何抛出及处理异常，代码同步声明等，暂且不表。</p><p>有时间再做补充</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前描述过包括 ASM, CGlib, Java Proxy 的基本内容之后，本文将就更为基础的 JVM 指令集进行简单而有效的介绍。&lt;/p&gt;
&lt;p&gt;当然，在开始正文前，读者需要了解到，JVM 指令集这种类似于汇编的规范性内容，包含一百多个指令，若要求一一介绍。&lt;br&gt;那么，直接阅读 &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/html/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt; 绝对是比本文的内容更为详实且准确。&lt;/p&gt;
&lt;p&gt;这篇文档的目的，只是为了使读者建立起关于 JVM 指令集基本的常识性观念。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="https://DorMOUSE-None.github.io/tags/JVM/"/>
    
      <category term="Instruction" scheme="https://DorMOUSE-None.github.io/tags/Instruction/"/>
    
  </entry>
  
  <entry>
    <title>Java Proxy 源码解析</title>
    <link href="https://DorMOUSE-None.github.io/2018-07-20-Java-Proxy/"/>
    <id>https://DorMOUSE-None.github.io/2018-07-20-Java-Proxy/</id>
    <published>2018-07-19T16:00:00.000Z</published>
    <updated>2018-07-21T22:38:18.419Z</updated>
    
    <content type="html"><![CDATA[<p>在 Java 整个生态里面, 通用的有两类动态代理的应用: Java Proxy 与 CGlib 代理。</p><p>从宽泛的区别来说，Java Proxy 只能对接口进行增强，而 CGlib 同时适用于类和接口的增强。<br>而且，业内普遍的认知是，CGlib 动态代理较之于 Java Proxy 在生成字节码的速度上也更为高效。</p><a id="more"></a><h2 id="从实例开始…"><a href="#从实例开始…" class="headerlink" title="从实例开始…"></a>从实例开始…</h2><p>下面，首先来了解一下 Java Proxy 的使用编码:</p><p>ICodeFactory 接口, 作为将被 Java 动态代理增强的基本接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICodeFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Code <span class="title">getCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCode</span><span class="params">(Code code)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>CodeFactory 类, 作为 ICodeFactory 接口的实现类。被视为是真正被动态代理增强的内容，:) 因为接口方法并不存在方法体(当然，Java 8 及以上的 default 请容我忽视)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodeFactory</span> <span class="keyword">implements</span> <span class="title">ICodeFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Code code;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Code <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Code();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(Code code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>辅助类 Code 的内容(简单写，请忽略不符合实际编程规范的一些内容):<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> codeA;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String codeB;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>构建增强的代码逻辑:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main(String[]) 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部匿名类，用于动态代理生成类的构造方法及其它内容，后面讲。</span></span><br><span class="line">    InvocationHandler handler = <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line"></span><br><span class="line">        Object obj = <span class="keyword">new</span> CodeFactory();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (method.getName() == <span class="string">"getCode"</span>) &#123;</span><br><span class="line">                Code code = (Code) method.invoke(obj, args);</span><br><span class="line">                code.codeA = code.codeA + <span class="number">100</span>;</span><br><span class="line">                code.codeB = <span class="string">"Proxied: "</span> + code.codeB;</span><br><span class="line">                <span class="keyword">return</span> code;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> method.invoke(obj, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建生成类实例</span></span><br><span class="line">    Class&lt;?&gt; clazz = Proxy.getProxyClass(ICodeFactory.class.getClassLoader(), ICodeFactory.class);</span><br><span class="line">    <span class="comment">// 获取生成类对象</span></span><br><span class="line">    ICodeFactory factory = (ICodeFactory) clazz.getConstructor(<span class="keyword">new</span> Class[] &#123; InvocationHandler.class &#125;).newInstance(<span class="keyword">new</span> Object[] &#123; handler &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 getCode() 方法</span></span><br><span class="line">    Code code = factory.getCode();</span><br><span class="line">    <span class="comment">// 打印参数</span></span><br><span class="line">    System.out.println(code.codeA);</span><br><span class="line">    System.out.println(code.codeB);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从默认预期来讲，我们是对接口进行增强。接口方法不存在方法体，也许将在 <code>factory.getCode()</code> 时执行失败？<br>或者结合已有的认知，成功调用 <code>CodeFactory.getCode()</code> 方法，并获得 <code>new Code()</code> 。</p><p>那么，<code>code.codeA</code> <code>code.codeB</code> 的具体值将是什么？</p><p>执行结果将是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100</span><br><span class="line">Proxied: null</span><br></pre></td></tr></table></figure><h2 id="了解-Proxy-的内容逻辑"><a href="#了解-Proxy-的内容逻辑" class="headerlink" title="了解 Proxy 的内容逻辑"></a>了解 Proxy 的内容逻辑</h2><p>从 <code>Proxy.getProxyClass(ClassLoader, Class&lt;?&gt;...)</code> 入手，下面将展开对 <code>Proxy</code> 具体执行逻辑的探究。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces) <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">    <span class="comment">// 对 interfaces 数组的浅拷贝</span></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">    <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果配置了安全管理器，那么需要确认 Proxy 有创建新的代理类的许可</span></span><br><span class="line">        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 </span></span><br><span class="line">    <span class="keyword">return</span> getProxyClass0(loader, intfs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    <span class="comment">// 确认需要进行增强的接口数量少于等于 65535，详细原因请去了解 ClassFile 规范(规范中的接口上限)</span></span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要由指定 ClassLoader 加载, 实现给定 interfaces 的代理类已经存在, </span></span><br><span class="line">    <span class="comment">// 将直接返回已经缓存过的拷贝</span></span><br><span class="line">    <span class="comment">// 否则，通过 ProxyClassFactory 创建新的代理类</span></span><br><span class="line">    <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在需要额外来考察一下 proxyClassCache 的具体类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">        proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(), <span class="keyword">new</span> ProxyClassFactory());</span><br></pre></td></tr></table></figure><p><code>WeakCache</code>, 从名称来将，是一个缓存，同时应该使用了 WeakReference 技术</p><p>进入 <code>WeakCache.get(...)</code> 方法体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key, P parameter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// parameter 传入的是接口数组，要求不能为空</span></span><br><span class="line">    Objects.requireNonNull(parameter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除过期元素</span></span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建一个 WeakReference 对象(key 表示 ClassLoader)</span></span><br><span class="line">    Object cacheKey = CacheKey.valueOf(key, refQueue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lazily install the 2nd level valuesMap for the particular cacheKey</span></span><br><span class="line">    ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (valuesMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap</span><br><span class="line">                = map.putIfAbsent(cacheKey,</span><br><span class="line">                valuesMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line">        <span class="keyword">if</span> (oldValuesMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">            valuesMap = oldValuesMap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建次级 Key</span></span><br><span class="line">    <span class="comment">// 同时检索是否存在过去有同一个 ClassLoader 加载的表示 Supplier&lt;V&gt;</span></span><br><span class="line">    Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));</span><br><span class="line">    Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">    Factory factory = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (supplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// supplier might be a Factory or a CacheValue&lt;V&gt; instance</span></span><br><span class="line">            <span class="comment">// 最终 supplier 将非空，同时调用 .get() 方法获取 Class 类</span></span><br><span class="line">            V value = supplier.get();</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else no supplier in cache</span></span><br><span class="line">        <span class="comment">// or a supplier that returned null (could be a cleared CacheValue</span></span><br><span class="line">        <span class="comment">// or a Factory that wasn't successful in installing the CacheValue)</span></span><br><span class="line">        <span class="comment">// 未找到过去加载的记录</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 懒加载一个 Factory </span></span><br><span class="line">        <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            factory = <span class="keyword">new</span> Factory(key, parameter, subKey, valuesMap);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span><br><span class="line">            supplier = valuesMap.putIfAbsent(subKey, factory);</span><br><span class="line">            <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// successfully installed Factory</span></span><br><span class="line">                supplier = factory;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// else retry with winning supplier</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (valuesMap.replace(subKey, supplier, factory)) &#123;</span><br><span class="line">                <span class="comment">// successfully replaced</span></span><br><span class="line">                <span class="comment">// cleared CacheEntry / unsuccessful Factory</span></span><br><span class="line">                <span class="comment">// with our Factory</span></span><br><span class="line">                supplier = factory;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// retry with current supplier</span></span><br><span class="line">                supplier = valuesMap.get(subKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="comment">// serialize access</span></span><br><span class="line">    <span class="comment">// re-check</span></span><br><span class="line">    Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">    <span class="keyword">if</span> (supplier != <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// something changed while we were waiting:</span></span><br><span class="line">        <span class="comment">// might be that we were replaced by a CacheValue</span></span><br><span class="line">        <span class="comment">// or were removed because of failure -&gt;</span></span><br><span class="line">        <span class="comment">// return null to signal WeakCache.get() to retry</span></span><br><span class="line">        <span class="comment">// the loop</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// else still us (supplier == this)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// create new value</span></span><br><span class="line">    V value = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 触发 valueFactory.apply() 真正的构建</span></span><br><span class="line">        value = Objects.requireNonNull(valueFactory.apply(key, parameter));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123; <span class="comment">// remove us on failure</span></span><br><span class="line">            valuesMap.remove(subKey, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// the only path to reach here is with non-null value</span></span><br><span class="line">    <span class="keyword">assert</span> value != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wrap value with CacheValue (WeakReference)</span></span><br><span class="line">    CacheValue&lt;V&gt; cacheValue = <span class="keyword">new</span> CacheValue&lt;&gt;(value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// put into reverseMap</span></span><br><span class="line">    reverseMap.put(cacheValue, Boolean.TRUE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// try replacing us with CacheValue (this should always succeed)</span></span><br><span class="line">    <span class="keyword">if</span> (!valuesMap.replace(subKey, <span class="keyword">this</span>, cacheValue)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Should not reach here"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// successfully replaced us with new CacheValue -&gt; return the value</span></span><br><span class="line">    <span class="comment">// wrapped by it</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两段代码的内容，都是在反复确认将要构建的生成类是否在过去曾经创建过，如果是，则直接返回过去构建的类实例;<br>否则才会尝试创建，并最终将这个构建的类也进行缓存。</p><p>下面这段代码来自于 <code>Proxy</code> 的内部类 <code>ProxyClassFactory</code><br>这部分，也终于开始了对代理类字节码的统筹性构造的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 校验当前接口是由同一个 ClassLoader (将要用来加载新的代理类)加载的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class&lt;?&gt; interfaceClass = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            interfaceClass = Class.forName(intf.getName(), <span class="keyword">false</span>, loader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (interfaceClass != intf) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    intf + <span class="string">" is not visible from class loader"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 校验当前 Class 对象确实是一个接口</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    interfaceClass.getName() + <span class="string">" is not an interface"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 校验当前接口没有被要求重复进行代理增强</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (interfaceSet.put(interfaceClass, Boolean.TRUE) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"repeated interface: "</span> + interfaceClass.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String proxyPkg = <span class="keyword">null</span>;     <span class="comment">// 生成的代理类所属的 package</span></span><br><span class="line">    <span class="keyword">int</span> accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果代理的接口是非 PUBLIC ，那么生成的代理类的接口将与这个非 PUBLIC 接口</span></span><br><span class="line"><span class="comment">     * 在同一个包下。</span></span><br><span class="line"><span class="comment">     * 如果代理的接口有多个非 PUBLIC ，且分别位于不同的包下，那么抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">        <span class="keyword">int</span> flags = intf.getModifiers();</span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">            accessFlags = Modifier.FINAL;</span><br><span class="line">            String name = intf.getName();</span><br><span class="line">            <span class="keyword">int</span> n = name.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">            String pkg = ((n == -<span class="number">1</span>) ? <span class="string">""</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                proxyPkg = pkg;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                        <span class="string">"non-public interfaces from different packages"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果代理的接口全是 PUBLIC 的，那么使用默认的包 com.sun.proxy</span></span><br><span class="line">    <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// if no non-public proxy interfaces, use com.sun.proxy package</span></span><br><span class="line">        proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">"."</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 为将要生成的代理类选择一个全限定名</span></span><br><span class="line"><span class="comment">     * 规则是 包名 + "$Proxy" + &lt;唯一递增的id, 从0开始编号&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">    String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 生成一个特殊的代理类的字节码</span></span><br><span class="line"><span class="comment">     * byte[] proxyClassFile 就等同于 .class 文件的全部二进制内容。</span></span><br><span class="line"><span class="comment">     * 与 .class 文件的区别就在于一个写在了外存上，另一个完全在内存中创建</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">            proxyName, interfaces, accessFlags);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 调用 ClassLoader 的 defineClass0(...) 方法加载字节码内容，构造 Class 对象</span></span><br><span class="line"><span class="comment">          * 本来 defineClass0(...) 方法是定义在 ClassLoader 中，但这里额外声明了一个本地方法 defineClass0(...)</span></span><br><span class="line"><span class="comment">          * 想来实现也是类似的，最终的目的也是加载 Class </span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        <span class="keyword">return</span> defineClass0(loader, proxyName,</span><br><span class="line">                proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * A ClassFormatError here means that (barring bugs in the</span></span><br><span class="line"><span class="comment">         * proxy class generation code) there was some other</span></span><br><span class="line"><span class="comment">         * invalid aspect of the arguments supplied to the proxy</span></span><br><span class="line"><span class="comment">         * class creation (such as virtual machine limitations</span></span><br><span class="line"><span class="comment">         * exceeded).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在完成基础性的校验，并构造了生成类的类名等内容后，<br><code>ProxyGenerator.generateProxyClass</code> 将开始构造 <a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html" target="_blank" rel="noopener">ClassFile</a> 的具体内容。</p><p>关于这部分生成字节码的内容，请在了解了 ClassFile 的基础性内容之后，在自行学习，内容全部在 ProxyGenerator 类中。</p><p>这部分的规则是(在构建新的代理生成类时):</p><ul><li>额外添加三个 Object 的方法 (<code>hashCode</code>, <code>equals</code>, <code>toString</code>)</li><li>逐一读取所有需要增强的接口的方法，并对重复方法进行判断; 如果方法名相同，入参数量与类型相同，但返回参数不同，则抛出异常</li><li>在遍历所有接口的方法的时候，同时也将为新的生成类构造新的字段(内容就是通过反射获取该方法)</li><li>最后将新的生成类将要包含的所有字段与方法进行构造，同时维护一个常量池内容</li><li>输出这些内容的二进制表示 byte[];</li></ul><h2 id="如何对方法增强"><a href="#如何对方法增强" class="headerlink" title="如何对方法增强"></a>如何对方法增强</h2><p>想必上了上一节，虽然对 Java 动态代理的调用链有了一定的了解。</p><p>但是，究竟 Proxy 是如何完成对实现类方法的增强呢？</p><p>也许我们需要先看一下生成类 .class 文件的一些内容来对这个命题形成基础性的影响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Code <span class="title">getCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Code)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m4, (Object[])<span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">        <span class="keyword">throw</span> var2;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，生成类的 <code>getCode()</code> 方法几乎没有什么实质性的内容, 只是 <code>super.h.invoke(...)</code> 。</p><p><code>h</code> 实例变量是什么？<code>InvocationHandler</code> 的一个实例对象。</p><p>事实上，Java Proxy 生成类的每个方法结构几乎都是类似的。方法体的内容就是通过实例持有的 <code>h</code> 变量分发实际的操作指令</p><p>至于 h 的具体内容。:) 有编程者自定义，并在 Proxy 生成字节码，并被 ClassLoader 加载后，在准备实例化的时候作为构造参数进行传入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ICodeFactory factory = (ICodeFactory) clazz.getConstructor(<span class="keyword">new</span> Class[] &#123; InvocationHandler.class &#125;).newInstance(<span class="keyword">new</span> Object[] &#123; handler &#125;);</span><br></pre></td></tr></table></figure><p>至于具体将做哪些增强，调用例如上例的 <code>ICodeFactory</code> 的那个实现类的方法，全部有使用者自定义。</p><h2 id="生成类的反编译结果"><a href="#生成类的反编译结果" class="headerlink" title="生成类的反编译结果"></a>生成类的反编译结果</h2><p>仍然以本文开始的 ICodeFactory 的增强为例，看一下究竟通过 Java Proxy 动态代理生成的字节码的反编译结果究竟是什么？<br>并以此来对这种动态代理机制形成更为直观的印象</p><p>在 Java 源代码中，虽然默认不会输出生成类的二进制内容，但是，仍然预留了打印 .class 文件的可选项。</p><p>有兴趣的同学可以看一下 <code>ProxyGenerator.saveGeneratedFiles</code> 字段的内容，这就决定是在构造代理类后是否存储到外存中。</p><p>想要看到代理类的字节码，直接通过在 Java 执行程序中添加一行代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</span><br></pre></td></tr></table></figure><p>或者在启动程序的 <code>java</code> 命令下添加参数</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dsun.misc.ProxyGenerator.saveGeneratedFiles=<span class="literal">true</span>`</span><br></pre></td></tr></table></figure><p>至于生成类将打印在哪，首先必然是在项目所属的目录下。有上一节中构造生成类全限定名的内容，根据包名的规则去寻找即可。(具体不再详述)</p><p>直接通过 IDEA, Eclipse 或者其它工具，对生成类 .class 文件进行反编译可以查看到整个生成类的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sun.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"><span class="keyword">import</span> me.fangfeng.jdk.proxy.Code;</span><br><span class="line"><span class="keyword">import</span> me.fangfeng.jdk.proxy.ICodeFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">ICodeFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Code <span class="title">getCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Code)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m4, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(Code var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m4 = Class.forName(<span class="string">"me.fangfeng.jdk.proxy.ICodeFactory"</span>).getMethod(<span class="string">"getCode"</span>);</span><br><span class="line">            m3 = Class.forName(<span class="string">"me.fangfeng.jdk.proxy.ICodeFactory"</span>).getMethod(<span class="string">"setCode"</span>, Class.forName(<span class="string">"me.fangfeng.jdk.proxy.Code"</span>));</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Java 整个生态里面, 通用的有两类动态代理的应用: Java Proxy 与 CGlib 代理。&lt;/p&gt;
&lt;p&gt;从宽泛的区别来说，Java Proxy 只能对接口进行增强，而 CGlib 同时适用于类和接口的增强。&lt;br&gt;而且，业内普遍的认知是，CGlib 动态代理较之于 Java Proxy 在生成字节码的速度上也更为高效。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://DorMOUSE-None.github.io/tags/Java/"/>
    
      <category term="Proxy" scheme="https://DorMOUSE-None.github.io/tags/Proxy/"/>
    
  </entry>
  
  <entry>
    <title>如何方便地获取 CGlib 生成类</title>
    <link href="https://DorMOUSE-None.github.io/2018-07-13-How-to-easily-get-CGlib-generated-code/"/>
    <id>https://DorMOUSE-None.github.io/2018-07-13-How-to-easily-get-CGlib-generated-code/</id>
    <published>2018-07-12T16:00:00.000Z</published>
    <updated>2018-07-13T12:55:17.325Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h2><p><strong>命令行使用</strong></p><p>在 java 启动命令中添加参数配置项 <code>-Dcglib.debugLocation=&lt;Custom Path&gt;</code></p><p><strong>编码实现</strong></p><p>在执行 CGlib 获取新生成类之前，调用 <code>System.setProperty(&quot;cglib.debugLocation&quot;, &lt;Custom Path&gt;)</code></p><a id="more"></a><h2 id="如何游刃有余地-Debug-掺杂-CGlib-生成类的调用链"><a href="#如何游刃有余地-Debug-掺杂-CGlib-生成类的调用链" class="headerlink" title="如何游刃有余地 Debug 掺杂 CGlib 生成类的调用链"></a>如何游刃有余地 Debug 掺杂 CGlib 生成类的调用链</h2><p>经常会遇到，项目中不经意间就遇到了 CGlib 代理，然后对调用链的 Debug 就开始出现断层。继而，对对象或实例变量的跟踪就显得一头雾水。</p><p>特别是在不了解生成类到底是增强了那些内容的时候，甚至可能连调用链都跟踪不下去了 T_T 。</p><p>通过 <strong>配置参数</strong> 一节的内容，你就可以在你理想的目录 <code>&lt;Custom Path&gt;</code> 下看到<strong>所谓黑盒</strong>中生成类的完成内容了。</p><p>下面的内容，将简单地介绍如何配合 CGlib 生成类的内容实现: 保证 Debug 的每一步骤可见; 保证 Debug 的过程不会出现<em>黑盒</em>。</p><h3 id="确定-lt-Custom-Path-gt-下哪个文件是原有-Java-类的生成类"><a href="#确定-lt-Custom-Path-gt-下哪个文件是原有-Java-类的生成类" class="headerlink" title="确定 &lt;Custom Path&gt; 下哪个文件是原有 Java 类的生成类"></a>确定 <code>&lt;Custom Path&gt;</code> 下哪个文件是原有 Java 类的生成类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getClassName</span><span class="params">(String prefix, String source, Object key, Predicate names)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prefix == <span class="keyword">null</span>) &#123;</span><br><span class="line">        prefix = <span class="string">"net.sf.cglib.empty.Object"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prefix.startsWith(<span class="string">"java"</span>)) &#123;</span><br><span class="line">        prefix = <span class="string">"$"</span> + prefix;</span><br><span class="line">    &#125;</span><br><span class="line">    String base =</span><br><span class="line">        prefix + <span class="string">"$$"</span> +</span><br><span class="line">        source.substring(source.lastIndexOf(<span class="string">'.'</span>) + <span class="number">1</span>) +</span><br><span class="line">        getTag() + <span class="string">"$$"</span> +</span><br><span class="line">        Integer.toHexString(STRESS_HASH_CODE ? <span class="number">0</span> : key.hashCode());</span><br><span class="line">    String attempt = base;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (names.evaluate(attempt))</span><br><span class="line">        attempt = base + <span class="string">"_"</span> + index++;</span><br><span class="line">    <span class="keyword">return</span> attempt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CGlib 默认的类名生成策略下，生成类的全限定名将结合原文件的全限定名决定。</p><p>通常命名如下: <code>&lt;原 Java 类全限定名&gt;$$&lt;类似 EnhancerByCGlib&gt;$$&lt;生成类核心内容的 hash 值&gt;_&lt;index[可能存在]&gt;</code></p><p>例如: 原有 Java 类全限定名为 me.fangfeng.Test ，则生成类名可能为 <code>me.fangfeng.Test$$EnhancerByCGlib$$ab1203aa</code></p><p>当然，通常情况下会存在一个类名形如 <code>me.fangfeng.Test$$FastClassBySpring$$...</code> 的类，这是作为生成类 <code>me.fangfeng.Test$$EnhancerByCGlib$$ab1203aa</code> 的辅助类来使用。</p><h3 id="简单了解生成类下的调用关系"><a href="#简单了解生成类下的调用关系" class="headerlink" title="简单了解生成类下的调用关系"></a>简单了解生成类下的调用关系</h3><p>Java 代码触发被增强的类，将首先调用生成类。但是，这是没办法进行 Debug 的，因为这个生成类的字节码缺少 SourceFile 属性，同时缺少 LineNumberTable 属性。</p><p>但是，这并不影响对调用链的跟踪。</p><p>CGlib 的增强，所有的增强逻辑都是以 Callback 实现类的形式来提供的。同时在 CGlib 生成类中也有 Callback 的实例变量来持有这些注入的 Callback 。</p><p><strong>原有 Java 类</strong></p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1ft8e7kr7qvj30sc0j0wh4.jpg" alt="LogonService.java"></p><p><strong>对应的生成类</strong></p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1ft8e9ww4hqj31hg0oojzv.jpg" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1ft8eanb6c9j31j00lgn1e.jpg" alt=""></p><p><strong>跟踪 LogonService.addLogon(String var1) 演示</strong></p><p>当前 LogonService 的生成类全限定名为me.fangfeng.transactionBugs.LogonService$$EnhancerBySpringCGLIB$$bfc1dc3.class; 以下简称为 LogonSerivce$$bfc1dc3 </p><ol><li><p>首先，配置 <code>cglib.debugLocation</code> 参数，值 = 项目生成的 .class 路径</p></li><li><p>无断点直接运行一次需要处理的逻辑</p></li><li><p>找到 LogonSerive$$bfc1dc3.class, 随意打上一个看似有效的断点</p></li><li><p>在各处打上必要的断点，开始进行真正的调试工作</p></li><li><p>代码执行到 LogonService$$bfc1dc3.class, 虽然没有真正进入断点位置, 但是可以看到这个 LogonService$$bfc1dc3 实例的实例变量信息</p></li></ol><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1ft8eq1be61j319w0bwtde.jpg" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1ft8egtg1naj31ji0fmgp2.jpg" alt=""></p><p>比照生成类代码中 addLogon(String var1) 方法体的内容以及展示的实例变量信息。可以看到生成类调用的 Callback 实例是 <code>CGLIB$CALLBACK_0</code><br>类型是 CglibAopProxy 的静态内部私有类 DynamicAdvisedInterceptor 。</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1ft8eu91oscj31gq0ayju5.jpg" alt=""></p><p>在 intercept(…) 上打个断点，跳过生成类 addLogon(String var1) 方法的下一个调用方法就是 intercept(…) </p><p><strong>而且事实上，CGlib 生成类的内容基本也就是对调用方法进行的一种转发</strong></p><ol start="6"><li>继续 Debug ，对于生成类的内容，人肉了解并定位到触发的 Callback 实例或者 super.Xxx() 方法。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;配置参数&quot;&gt;&lt;a href=&quot;#配置参数&quot; class=&quot;headerlink&quot; title=&quot;配置参数&quot;&gt;&lt;/a&gt;配置参数&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;命令行使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 java 启动命令中添加参数配置项 &lt;code&gt;-Dcglib.debugLocation=&amp;lt;Custom Path&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编码实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在执行 CGlib 获取新生成类之前，调用 &lt;code&gt;System.setProperty(&amp;quot;cglib.debugLocation&amp;quot;, &amp;lt;Custom Path&amp;gt;)&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="CGlib" scheme="https://DorMOUSE-None.github.io/tags/CGlib/"/>
    
      <category term="tools" scheme="https://DorMOUSE-None.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>CGlib Enhancer 主流程源码解析</title>
    <link href="https://DorMOUSE-None.github.io/2018-07-10-CGlib-Enhancer/"/>
    <id>https://DorMOUSE-None.github.io/2018-07-10-CGlib-Enhancer/</id>
    <published>2018-07-09T16:00:00.000Z</published>
    <updated>2018-07-10T08:22:13.833Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此博文写作的目的: </p><ul><li>(Core) 通过了解 CGlib Enhancer 的整个调用链，了解其对于唯一依赖的 ASM 库的调用方式。</li><li>基于 Enhancer 对已有字节码进行增强的进一步理解与掌握。</li></ul><a id="more"></a><h2 id="Enhancer"><a href="#Enhancer" class="headerlink" title="Enhancer"></a>Enhancer</h2><p>从这篇不是官方但更胜于官方文档的 <a href="http://mydailyjava.blogspot.com/2013/11/cglib-missing-manual.html" target="_blank" rel="noopener">CGlib Guide</a> 来看，它首先提到的第一个类就是 Enhancer。<br>其被用于创建 Java 代理类，相较于 Java 标准库的 Proxy 类，它<strong>特别地</strong>，能够支持那些没有实现接口的类的代理工作。</p><h3 id="Enhancer-简单示例展示"><a href="#Enhancer-简单示例展示" class="headerlink" title="Enhancer 简单示例展示"></a>Enhancer 简单示例展示</h3><p>针对现有的 SampleClass 类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用 CGlib 的 Enhancer 对 SampleClass 进行增强，下列操作的目的在于将 test(String) 方法的返回值改写成 “Hello cglib!”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFixedValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// new 一个 Enhancer 实例</span></span><br><span class="line">    Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">    <span class="comment">// 声明使用的父类是 SampleClass</span></span><br><span class="line">    enhancer.setSuperclass(SampleClass.class);</span><br><span class="line">    <span class="comment">// 设置回调方法 - 回调方法实现为 FixedValue (固定值) .</span></span><br><span class="line">    enhancer.setCallback(<span class="keyword">new</span> FixedValue() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">loadObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Hello cglib!"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 创建 SampleClass 的代理子类实例</span></span><br><span class="line">    SampleClass proxy = (SampleClass) enhancer.create();</span><br><span class="line">    Assert.assertEquals(<span class="string">"Hello cglib!"</span>, proxy.test(<span class="keyword">null</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单测试上述代码，可以了解到确实，代理类的 test(String) 方法的返回值被改写了。<br>那么，究竟这种操作是如何实现的？下面👇将进行具体的探究。</p><h2 id="调用链跟踪"><a href="#调用链跟踪" class="headerlink" title="调用链跟踪"></a>调用链跟踪</h2><h3 id="高度抽象的时序图"><a href="#高度抽象的时序图" class="headerlink" title="高度抽象的时序图"></a>高度抽象的时序图</h3><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1ft4ifuo997j31jh0st42t.jpg" alt="Enhancer 调用链 时序图"></p><p><em>下列内容将根据时序图进行组织，根据调用编号(1,2,3…)进行展开</em></p><h3 id="Seq-1"><a href="#Seq-1" class="headerlink" title="Seq 1."></a>Seq 1.</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    classOnly = <span class="keyword">false</span>;</span><br><span class="line">    argumentTypes = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> createHelper();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">create</span><span class="params">(Class[] argumentTypes, Object[] arguments)</span> </span>&#123;</span><br><span class="line">    classOnly = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (argumentTypes == <span class="keyword">null</span> || arguments == <span class="keyword">null</span> || argumentTypes.length != arguments.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Arguments must be non-null and of equal length"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.argumentTypes = argumentTypes;</span><br><span class="line">    <span class="keyword">this</span>.arguments = arguments;</span><br><span class="line">    <span class="keyword">return</span> createHelper();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述两个 <code>create(...)</code> 方法。结合上一节的使用示例，可以看到 <code>create()</code> 对应的<strong>无参构造</strong>。<br>存在无参构造，那么<strong>有参的构造方法</strong>显然也是应该被支持id。<code>create(Class[], Object[])</code> 正是为了这个目标而存在。通过提供参数类型数组和参数实例数组，可以唯一地定位及调用代理类的特定构造方法。</p><p>这个方法比较简单，只是将 Enhancer 作为一个数据内容的持有者，重置了新代理类将使用的构造函数参数内容，之后就直接调用了 <code>createHelper()</code> 。</p><h3 id="Seq-2"><a href="#Seq-2" class="headerlink" title="Seq 2."></a>Seq 2.</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">createHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对预声明的回调方法进行验证，要求 [多个回调就必须存在 CallbackFilter 作为调度器]</span></span><br><span class="line">    preValidate();</span><br><span class="line">    <span class="comment">// 构建一个对这类增强操作唯一定位的 key</span></span><br><span class="line">    Object key = KEY_FACTORY.newInstance((superclass != <span class="keyword">null</span>) ? superclass.getName() : <span class="keyword">null</span>,</span><br><span class="line">            ReflectUtils.getNames(interfaces),</span><br><span class="line">            filter == ALL_ZERO ? <span class="keyword">null</span> : <span class="keyword">new</span> WeakCacheKey&lt;CallbackFilter&gt;(filter),</span><br><span class="line">            callbackTypes,</span><br><span class="line">            useFactory,</span><br><span class="line">            interceptDuringConstruction,</span><br><span class="line">            serialVersionUID);</span><br><span class="line">    <span class="keyword">this</span>.currentKey = key;</span><br><span class="line">    <span class="comment">// 调用父类通过的 create(...) 方法</span></span><br><span class="line">    Object result = <span class="keyword">super</span>.create(key);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Seq-3"><a href="#Seq-3" class="headerlink" title="Seq 3."></a>Seq 3.</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">create</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取用于 加载 生成类 的 ClassLoader</span></span><br><span class="line">        ClassLoader loader = getClassLoader();</span><br><span class="line">        <span class="comment">// 从缓存中加载 这个 ClassLoader 过去加载的相关数据</span></span><br><span class="line">        Map&lt;ClassLoader, ClassLoaderData&gt; cache = CACHE;</span><br><span class="line">        ClassLoaderData data = cache.get(loader);</span><br><span class="line">        <span class="comment">// 如果在 缓存 中找不到，则初始化构造关于这个 ClassLoader 的数据实例</span></span><br><span class="line">        <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 同步</span></span><br><span class="line">            <span class="keyword">synchronized</span> (AbstractClassGenerator.class) &#123;</span><br><span class="line">                <span class="comment">// 进入同步块后的 再次确认，避免重复初始化构建</span></span><br><span class="line">                cache = CACHE;</span><br><span class="line">                data = cache.get(loader);</span><br><span class="line">                <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 构建新的 缓存，拷贝原有的缓存集的内容</span></span><br><span class="line">                    Map&lt;ClassLoader, ClassLoaderData&gt; newCache = <span class="keyword">new</span> WeakHashMap&lt;ClassLoader, ClassLoaderData&gt;(cache);</span><br><span class="line">                    <span class="comment">// 初始化 ClassLoaderData ，真正的构造操作</span></span><br><span class="line">                    data = <span class="keyword">new</span> ClassLoaderData(loader);</span><br><span class="line">                    <span class="comment">// 添加到缓存中</span></span><br><span class="line">                    newCache.put(loader, data);</span><br><span class="line">                    CACHE = newCache;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        Object obj = data.get(<span class="keyword">this</span>, getUseCache());</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">            <span class="comment">// 初次实例化操作，就是 Class 利用反射来进行实例化</span></span><br><span class="line">            <span class="keyword">return</span> firstInstance((Class) obj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 非初次实例化，则是从 ClassLoaderData 中得到的之前维护的内容</span></span><br><span class="line">        <span class="keyword">return</span> nextInstance(obj);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CodeGenerationException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分内容比较多，且是调用链比较重要的一环。<strong>Seq 4.</strong> 和 <strong>Seq 5.</strong> 将作为其子内容进行调用，但为了本博文的结构完整， <em>Seq 4. &amp; Seq5.</em> 的标题与 <em>Seq 3.</em> 标题同级</p><h3 id="Seq-4"><a href="#Seq-4" class="headerlink" title="Seq 4."></a>Seq 4.</h3><p>首先应该认识到，每个被加载的 Class ，在 <code>equal</code> 的判断过程中，依据的是同一个 ClassLoader 加载的同一 Class 才被认为是相同的，否则即使 Class 是同一个，但仍会被认为是不同的(由不同的 ClassLoader 加载)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ClassLoader t = classLoader;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">        t = getDefaultClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">        t = getClass().getClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">        t = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot determine classloader"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，在这部分中，首先需要确定的是由哪个 ClassLoader 进行加载的工作。<code>getClassLoader()</code> 的确定顺序是:</p><ol><li>具体实现类声明的 <strong>默认 ClassLoader</strong> 为第一优先级</li><li>加载当前类(这里是 Enhancer) 的 ClassLoader 为第二优先级</li><li><strong>当前线程上下文 ClassLoader</strong> 为第三优先级</li><li>抛出异常</li></ol><p>回到 <strong>Seq 3.</strong> 的内容，<br>下一步是对当前这个<strong>AbstractClassGenerator</strong> 维护的 CACHE 进行处理，如果在 CACHE 中能够得到以确定的 ClassLoader 为 Key 的键值对，则直接获取 ClassLoader 对应的值，否则将进行初始化构建一个新的 ClassLoaderData 作为这个 ClassLoader 的值。</p><h3 id="Seq-5"><a href="#Seq-5" class="headerlink" title="Seq 5."></a>Seq 5.</h3><p>在构建 ClassLoaderData 的过程中，最重要的一步:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassLoaderData</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ClassLoader 不可为空</span></span><br><span class="line">    <span class="keyword">if</span> (classLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"classLoader == null is not yet supported"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建 ClassLoader 的弱引用</span></span><br><span class="line">    <span class="keyword">this</span>.classLoader = <span class="keyword">new</span> WeakReference&lt;ClassLoader&gt;(classLoader);</span><br><span class="line">    <span class="comment">// 写了个后置调用的函数，用于懒加载，只有调用了 load.apply(...) 才会构建 生成类</span></span><br><span class="line">    Function&lt;AbstractClassGenerator, Object&gt; load =</span><br><span class="line">            <span class="keyword">new</span> Function&lt;AbstractClassGenerator, Object&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">apply</span><span class="params">(AbstractClassGenerator gen)</span> </span>&#123;</span><br><span class="line">                    Class klass = gen.generate(ClassLoaderData.<span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">return</span> gen.wrapCachedClass(klass);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">    generatedClasses = <span class="keyword">new</span> LoadingCache&lt;AbstractClassGenerator, Object, Object&gt;(GET_KEY, load);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建了一个 Function 实例，这个 Function 作为函数式接口，预定义执行的具体流程，但由上下文确定具体的调用时刻。</p><h3 id="Seq-6"><a href="#Seq-6" class="headerlink" title="Seq 6."></a>Seq 6.</h3><p>在正确得到了 ClassLoader 对应的 ClassLoaderData 之后，ClassLoaderData 的 <code>get(...)</code> 方法将在特定的 ClassLoader 之下，进行更具体的加载新生成类的工作。<br>当然，这里的前提是新的生成类的字节码已经被构建:)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(AbstractClassGenerator gen, <span class="keyword">boolean</span> useCache)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标记为不使用缓存，直接构建 新的生成类</span></span><br><span class="line">    <span class="keyword">if</span> (!useCache) &#123;</span><br><span class="line">      <span class="keyword">return</span> gen.generate(ClassLoaderData.<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用缓冲的情况</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      Object cachedValue = generatedClasses.get(gen);</span><br><span class="line">      <span class="keyword">return</span> gen.unwrapCachedValue(cachedValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>gen.generate(ClassLoaderData.this)</code> 这段代码在 <code>get(...)</code> 方法和上一小节 <code>ClassLoaderData(...)</code> 构造方法的 Function 函数式实例都出现了。</p><p>实际上，这也是触发 ClassLoader 来加载动态生成的新 Class 的唯一入口。</p><p><em>判断逻辑</em> 的 <code>else</code> 内容的唯一区别就在于其构建的是一个加载缓存，将真正触发 gen.generate(ClassLoaderData.this) 的逻辑延迟。(不过，最终也还是会进行调用的，:) 这是毋庸置疑的)。</p><h3 id="Seq-7"><a href="#Seq-7" class="headerlink" title="Seq 7."></a>Seq 7.</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Class <span class="title">generate</span><span class="params">(ClassLoaderData data)</span> </span>&#123;</span><br><span class="line">    Class gen;</span><br><span class="line">    Object save = CURRENT.get();</span><br><span class="line">    CURRENT.set(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 拿到用于加载生成类的 ClassLoader</span></span><br><span class="line">        ClassLoader classLoader = data.getClassLoader();</span><br><span class="line">        <span class="keyword">if</span> (classLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"ClassLoader is null while trying to define class "</span> +</span><br><span class="line">                    getClassName() + <span class="string">". It seems that the loader has been expired from a weak reference somehow. "</span> +</span><br><span class="line">                    <span class="string">"Please file an issue at cglib's issue tracker."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构建一个合法的 生成类 的类名(非重复)</span></span><br><span class="line">        <span class="keyword">synchronized</span> (classLoader) &#123;</span><br><span class="line">          String name = generateClassName(data.getUniqueNamePredicate());</span><br><span class="line">          data.reserveName(name);</span><br><span class="line">          <span class="keyword">this</span>.setClassName(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (attemptLoad) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 尝试直接通过 ClassLoader 进行加载</span></span><br><span class="line">                gen = classLoader.loadClass(getClassName());</span><br><span class="line">                <span class="keyword">return</span> gen;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 策略下的生成类构建方法</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = strategy.generate(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 通过解析字节码的形式获取 生成类的 className</span></span><br><span class="line">        String className = ClassNameReader.getClassName(<span class="keyword">new</span> ClassReader(b));</span><br><span class="line">        ProtectionDomain protectionDomain = getProtectionDomain();</span><br><span class="line">        <span class="keyword">synchronized</span> (classLoader) &#123; <span class="comment">// just in case</span></span><br><span class="line">            <span class="comment">// 反射的形式加载 Class 类</span></span><br><span class="line">            <span class="keyword">if</span> (protectionDomain == <span class="keyword">null</span>) &#123;</span><br><span class="line">                gen = ReflectUtils.defineClass(className, b, classLoader);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                gen = ReflectUtils.defineClass(className, b, classLoader, protectionDomain);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> gen;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CodeGenerationException(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        CURRENT.set(save);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法，就是操作字节码，加载 Class 的核心调度方法。</p><p>可以看到 <code>generateClassName(...)</code> 方法将构建一个当前 ClassLoader 下唯一, 不重复的新的类名。</p><p><code>strategy.generate(this)</code> 将通过特定策略实现的形式生成新的字节码</p><p><code>ReflectUtils.defineClass(className, b, classLoader)</code> 将使用反射使得 ClassLoader 来加载这个新的生成类。</p><h3 id="Seq-8"><a href="#Seq-8" class="headerlink" title="Seq 8."></a>Seq 8.</h3><p>生成新的不重复类名这部分不做过多陈述，可以简单进行了解，并熟悉 CGlib 默认的新类名的命名规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultNamePolicy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getClassName</span><span class="params">(String prefix, String source, Object key, Predicate names)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prefix == <span class="keyword">null</span>) &#123;</span><br><span class="line">        prefix = <span class="string">"net.sf.cglib.empty.Object"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prefix.startsWith(<span class="string">"java"</span>)) &#123;</span><br><span class="line">        prefix = <span class="string">"$"</span> + prefix;</span><br><span class="line">    &#125;</span><br><span class="line">    String base =</span><br><span class="line">        prefix + <span class="string">"$$"</span> +</span><br><span class="line">        source.substring(source.lastIndexOf(<span class="string">'.'</span>) + <span class="number">1</span>) +</span><br><span class="line">        getTag() + <span class="string">"$$"</span> +</span><br><span class="line">        Integer.toHexString(STRESS_HASH_CODE ? <span class="number">0</span> : key.hashCode());</span><br><span class="line">    String attempt = base;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (names.evaluate(attempt))</span><br><span class="line">        attempt = base + <span class="string">"_"</span> + index++;</span><br><span class="line">    <span class="keyword">return</span> attempt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Seq-9"><a href="#Seq-9" class="headerlink" title="Seq 9."></a>Seq 9.</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下列是 DefaultGeneratorStrategy 的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] generate(ClassGenerator cg) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    DebuggingClassWriter cw = getClassVisitor();</span><br><span class="line">    transform(cg).generateClass(cw);</span><br><span class="line">    <span class="keyword">return</span> transform(cw.toByteArray());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Seq-10"><a href="#Seq-10" class="headerlink" title="Seq 10."></a>Seq 10.</h3><p>调用 <code>generateClass(ClassVisitor)</code> 将获得到新类的字节码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateClass</span><span class="params">(ClassVisitor v)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 确定生成类的 父类</span></span><br><span class="line">    Class sc = (superclass == <span class="keyword">null</span>) ? Object.class : superclass;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父类标识符不可以为 final</span></span><br><span class="line">    <span class="keyword">if</span> (TypeUtils.isFinal(sc.getModifiers()))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot subclass final class "</span> + sc.getName());</span><br><span class="line">    <span class="comment">// 获取父类直接声明的构造方法</span></span><br><span class="line">    List constructors = <span class="keyword">new</span> ArrayList(Arrays.asList(sc.getDeclaredConstructors()));</span><br><span class="line">    filterConstructors(sc, constructors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Order is very important: must add superclass, then</span></span><br><span class="line">    <span class="comment">// its superclass chain, then each interface and</span></span><br><span class="line">    <span class="comment">// its superinterfaces.</span></span><br><span class="line">    List actualMethods = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    List interfaceMethods = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">final</span> Set forcePublic = <span class="keyword">new</span> HashSet();</span><br><span class="line">    <span class="comment">// 从父类中提取各种信息</span></span><br><span class="line">    getMethods(sc, interfaces, actualMethods, interfaceMethods, forcePublic);</span><br><span class="line"></span><br><span class="line">    List methods = CollectionUtils.transform(actualMethods, <span class="keyword">new</span> Transformer() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">            Method method = (Method)value;</span><br><span class="line">            <span class="keyword">int</span> modifiers = Constants.ACC_FINAL</span><br><span class="line">                | (method.getModifiers()</span><br><span class="line">                   &amp; ~Constants.ACC_ABSTRACT</span><br><span class="line">                   &amp; ~Constants.ACC_NATIVE</span><br><span class="line">                   &amp; ~Constants.ACC_SYNCHRONIZED);</span><br><span class="line">            <span class="keyword">if</span> (forcePublic.contains(MethodWrapper.create(method))) &#123;</span><br><span class="line">                modifiers = (modifiers &amp; ~Constants.ACC_PROTECTED) | Constants.ACC_PUBLIC;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ReflectUtils.getMethodInfo(method, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    ClassEmitter e = <span class="keyword">new</span> ClassEmitter(v);</span><br><span class="line">    <span class="keyword">if</span> (currentData == <span class="keyword">null</span>) &#123;</span><br><span class="line">    e.begin_class(Constants.V1_2,</span><br><span class="line">                  Constants.ACC_PUBLIC,</span><br><span class="line">                  getClassName(),</span><br><span class="line">                  Type.getType(sc),</span><br><span class="line">                  (useFactory ?</span><br><span class="line">                   TypeUtils.add(TypeUtils.getTypes(interfaces), FACTORY) :</span><br><span class="line">                   TypeUtils.getTypes(interfaces)),</span><br><span class="line">                  Constants.SOURCE_FILE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        e.begin_class(Constants.V1_2,</span><br><span class="line">                Constants.ACC_PUBLIC,</span><br><span class="line">                getClassName(),</span><br><span class="line">                <span class="keyword">null</span>,</span><br><span class="line">                <span class="keyword">new</span> Type[]&#123;FACTORY&#125;,</span><br><span class="line">                Constants.SOURCE_FILE);</span><br><span class="line">    &#125;</span><br><span class="line">    List constructorInfo = CollectionUtils.transform(constructors, MethodInfoTransformer.getInstance());</span><br><span class="line"></span><br><span class="line">    e.declare_field(Constants.ACC_PRIVATE, BOUND_FIELD, Type.BOOLEAN_TYPE, <span class="keyword">null</span>);</span><br><span class="line">    e.declare_field(Constants.ACC_PUBLIC | Constants.ACC_STATIC, FACTORY_DATA_FIELD, OBJECT_TYPE, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (!interceptDuringConstruction) &#123;</span><br><span class="line">        e.declare_field(Constants.ACC_PRIVATE, CONSTRUCTED_FIELD, Type.BOOLEAN_TYPE, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    e.declare_field(Constants.PRIVATE_FINAL_STATIC, THREAD_CALLBACKS_FIELD, THREAD_LOCAL, <span class="keyword">null</span>);</span><br><span class="line">    e.declare_field(Constants.PRIVATE_FINAL_STATIC, STATIC_CALLBACKS_FIELD, CALLBACK_ARRAY, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (serialVersionUID != <span class="keyword">null</span>) &#123;</span><br><span class="line">        e.declare_field(Constants.PRIVATE_FINAL_STATIC, Constants.SUID_FIELD_NAME, Type.LONG_TYPE, serialVersionUID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; callbackTypes.length; i++) &#123;</span><br><span class="line">        e.declare_field(Constants.ACC_PRIVATE, getCallbackField(i), callbackTypes[i], <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// This is declared private to avoid "public field" pollution</span></span><br><span class="line">    e.declare_field(Constants.ACC_PRIVATE | Constants.ACC_STATIC, CALLBACK_FILTER_FIELD, OBJECT_TYPE, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentData == <span class="keyword">null</span>) &#123;</span><br><span class="line">        emitMethods(e, methods, actualMethods);</span><br><span class="line">        emitConstructors(e, constructorInfo);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        emitDefaultConstructor(e);</span><br><span class="line">    &#125;</span><br><span class="line">    emitSetThreadCallbacks(e);</span><br><span class="line">    emitSetStaticCallbacks(e);</span><br><span class="line">    emitBindCallbacks(e);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (useFactory || currentData != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] keys = getCallbackKeys();</span><br><span class="line">        emitNewInstanceCallbacks(e);</span><br><span class="line">        emitNewInstanceCallback(e);</span><br><span class="line">        emitNewInstanceMultiarg(e, constructorInfo);</span><br><span class="line">        emitGetCallback(e, keys);</span><br><span class="line">        emitSetCallback(e, keys);</span><br><span class="line">        emitGetCallbacks(e);</span><br><span class="line">        emitSetCallbacks(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    e.end_class();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>generateClass(...)</code> 执行的操作和 ASM 库的 ClassVisitor 访问 Class 文件结构的流程基本类似。</p><p>从上述截取到的部分代码，例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e.begin_class(Constants.V1_2, Constants.ACC_PUBLIC, getClassName(), Type.getType(sc), </span><br><span class="line">        (useFactory ? TypeUtils.add(TypeUtils.getTypes(interfaces), FACTORY) : TypeUtils.getTypes(interfaces)),</span><br><span class="line">        Constants.SOURCE_FILE);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.declare_field(Constants.PRIVATE_FINAL_STATIC, THREAD_CALLBACKS_FIELD, THREAD_LOCAL, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>都与 <code>classVisitor.visit(...)</code> 以及 <code>classVisitor.visitField(...)</code> 相当类似。而事实上，这些方法的具体实现也确实调用了 cv.visitXxx(…) 。<br>毕竟，作为 CGlib 唯一依赖的库，ASM 还是可以说是难以替代的(既然已经有了可用的轮子，又何必重复造呢?)</p><h2 id="构造的实例"><a href="#构造的实例" class="headerlink" title="构造的实例"></a>构造的实例</h2><p>下面将展示通过 CGlib 生成的新的类(由于生成的是字节码，懒得再自行解析 ClassFile 的内容，所有直接用 <code>IDEA</code> 做了字节码的解析)</p><p><strong>首先展示的需要进行增强的 SampleClass 的具体内容</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>用于增强的简单代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略部分代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">    enhancer.setSuperclass(SampleClass.class);</span><br><span class="line">    enhancer.setCallback(<span class="keyword">new</span> FixedValue() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">loadObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Hello cglib!"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    SampleClass proxy = (SampleClass) enhancer.create();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态生成的新的类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不用过多关注，只是 CGlib 保证生成类与原有的类一定属于同一包下，偷懒直接把 SampleClass 写在 CGlib 项目里了</span></span><br><span class="line"><span class="keyword">package</span> net.sf.cglib.samples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Callback;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Factory;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.FixedValue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新的类名，通过 $$EnhancerByCGLIB 以及 $$7cd64b81(这个是哈希值) 对类名进行唯一区分 </span></span><br><span class="line"><span class="comment"> * 如果还是重复了，在动态生成前会进行类名的检测，并通过增加序号 "_&lt;index&gt;" 的形式进行进一步区分</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 可以看到新生成的类继承了 SampleClass </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span>$$<span class="title">EnhancerByCGLIB</span>$$7<span class="title">cd64b81</span> <span class="keyword">extends</span> <span class="title">SampleClass</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> CGLIB$BOUND;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object CGLIB$FACTORY_DATA;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal CGLIB$THREAD_CALLBACKS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Callback[] CGLIB$STATIC_CALLBACKS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定一个在增强中声明的 Callback 实例</span></span><br><span class="line">    <span class="keyword">private</span> FixedValue CGLIB$CALLBACK_0;</span><br><span class="line">    <span class="comment">// 绑定一个静态的回调调度实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object CGLIB$CALLBACK_FILTER;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> CGLIB$STATICHOOK1() &#123;</span><br><span class="line">        CGLIB$THREAD_CALLBACKS = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 对 test(String) 的方法的增强</span></span><br><span class="line"><span class="comment">      */</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">test</span><span class="params">(String var1)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在方法块中拿到 Callback 实例</span></span><br><span class="line">        FixedValue var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        <span class="comment">// 为空则尝试获取</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.CGLIB$CALLBACK_0 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发回调实例的方法获得返回值</span></span><br><span class="line">        <span class="keyword">return</span> (String)var10000.loadObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 由于此次增强只声明了一个 Callback</span></span><br><span class="line"><span class="comment">      * 因此所有方法的增强都相同, 都是调用这个回调方法获取</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> </span>&#123;</span><br><span class="line">        FixedValue var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.CGLIB$CALLBACK_0 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object var2 = var10000.loadObject();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 但是，此处会尝试强制转型</span></span><br><span class="line"><span class="comment">         * 同时在最终执行失败的时候直接抛出运行时异常</span></span><br><span class="line"><span class="comment">         * 毕竟上面增强的时候返回固定值 "Hello, cglib!"</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> var2 == <span class="keyword">null</span> ? <span class="keyword">false</span> : (Boolean)var2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FixedValue var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.CGLIB$CALLBACK_0 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (String)var10000.loadObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FixedValue var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.CGLIB$CALLBACK_0 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object var1 = var10000.loadObject();</span><br><span class="line">        <span class="keyword">return</span> var1 == <span class="keyword">null</span> ? <span class="number">0</span> : ((Number)var1).intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        FixedValue var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.CGLIB$CALLBACK_0 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var10000.loadObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SampleClass$$EnhancerByCGLIB$$<span class="number">7</span>cd64b81() &#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> CGLIB$SET_THREAD_CALLBACKS(Callback[] var0) &#123;</span><br><span class="line">        CGLIB$THREAD_CALLBACKS.set(var0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> CGLIB$SET_STATIC_CALLBACKS(Callback[] var0) &#123;</span><br><span class="line">        CGLIB$STATIC_CALLBACKS = var0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> CGLIB$BIND_CALLBACKS(Object var0) &#123;</span><br><span class="line">        SampleClass$$EnhancerByCGLIB$$<span class="number">7</span>cd64b81 var1 = (SampleClass$$EnhancerByCGLIB$$<span class="number">7</span>cd64b81)var0;</span><br><span class="line">        <span class="keyword">if</span> (!var1.CGLIB$BOUND) &#123;</span><br><span class="line">            var1.CGLIB$BOUND = <span class="keyword">true</span>;</span><br><span class="line">            Object var10000 = CGLIB$THREAD_CALLBACKS.get();</span><br><span class="line">            <span class="keyword">if</span> (var10000 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                var10000 = CGLIB$STATIC_CALLBACKS;</span><br><span class="line">                <span class="keyword">if</span> (CGLIB$STATIC_CALLBACKS == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var1.CGLIB$CALLBACK_0 = (FixedValue)((Callback[])var10000)[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(Callback[] var1)</span> </span>&#123;</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS(var1);</span><br><span class="line">        SampleClass$$EnhancerByCGLIB$$<span class="number">7</span>cd64b81 var10000 = <span class="keyword">new</span> SampleClass$$EnhancerByCGLIB$$<span class="number">7</span>cd64b81();</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS((Callback[])<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> var10000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(Callback var1)</span> </span>&#123;</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS(<span class="keyword">new</span> Callback[]&#123;var1&#125;);</span><br><span class="line">        SampleClass$$EnhancerByCGLIB$$<span class="number">7</span>cd64b81 var10000 = <span class="keyword">new</span> SampleClass$$EnhancerByCGLIB$$<span class="number">7</span>cd64b81();</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS((Callback[])<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> var10000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(Class[] var1, Object[] var2, Callback[] var3)</span> </span>&#123;</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS(var3);</span><br><span class="line">        SampleClass$$EnhancerByCGLIB$$<span class="number">7</span>cd64b81 var10000 = <span class="keyword">new</span> SampleClass$$EnhancerByCGLIB$$<span class="number">7</span>cd64b81;</span><br><span class="line">        <span class="keyword">switch</span>(var1.length) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            var10000.&lt;init&gt;();</span><br><span class="line">            CGLIB$SET_THREAD_CALLBACKS((Callback[])<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> var10000;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Constructor not found"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Callback <span class="title">getCallback</span><span class="params">(<span class="keyword">int</span> var1)</span> </span>&#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">        FixedValue var10000;</span><br><span class="line">        <span class="keyword">switch</span>(var1) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            var10000 = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var10000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCallback</span><span class="params">(<span class="keyword">int</span> var1, Callback var2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(var1) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">this</span>.CGLIB$CALLBACK_0 = (FixedValue)var2;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Callback[] getCallbacks() &#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Callback[]&#123;<span class="keyword">this</span>.CGLIB$CALLBACK_0&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCallbacks</span><span class="params">(Callback[] var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.CGLIB$CALLBACK_0 = (FixedValue)var1[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        CGLIB$STATICHOOK1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的生成类可以看出来，CGlib 所进行的增强，是在不直接对原有的方法体内容进行改造的基础上(例如上面的 test(String) 方法，没有直接改写成 <code>return &quot;Hello, cglib!</code> 的形式)，对方法执行之前入参或者方法执行之后的返回值进行一定的处理。</p><p>主要使用的形式就是将回调实例与原有方法进行绑定，并通过调用回调方法来实现方法的增强。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;此博文写作的目的: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(Core) 通过了解 CGlib Enhancer 的整个调用链，了解其对于唯一依赖的 ASM 库的调用方式。&lt;/li&gt;
&lt;li&gt;基于 Enhancer 对已有字节码进行增强的进一步理解与掌握。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="ASM" scheme="https://DorMOUSE-None.github.io/tags/ASM/"/>
    
      <category term="CGlib" scheme="https://DorMOUSE-None.github.io/tags/CGlib/"/>
    
  </entry>
  
  <entry>
    <title>Java 安全访问与权限控制</title>
    <link href="https://DorMOUSE-None.github.io/2018-07-04-JDK-Permission/"/>
    <id>https://DorMOUSE-None.github.io/2018-07-04-JDK-Permission/</id>
    <published>2018-07-03T16:00:00.000Z</published>
    <updated>2018-07-04T12:12:25.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><p><em>本文只是对 Java 安全访问与权限控制的基础性探究。</em></p><p><strong>本节与全文内容无关，如无兴趣阅读，可以跳过</strong></p><p>了解 Java 安全访问相关内容的初衷，是准备在项目中利用 Java 标准库提供的 ServiceLoader 对 SPI 实现类进行”自动发现”和加载。<br>这对于将本项目作为二方库来依赖的上层项目将更为方便，只需要</p><ol><li>在 <code>META-INF.services</code> 目录下配置被命名为 SPI 接口全限定名的文件及添加相关内容</li><li>由项目的注册管理器触发下列 Java 代码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ServiceLoader&lt;XxxPolicy&gt; xxxPolicyServiceLoader = ServiceLoader.load(XxxPolicy.class);</span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;XxxPolicy&gt; it = xxxPolicyServiceLoader.iterator(); it.hasNext(); ) &#123;</span><br><span class="line">        XxxPolicy xxxPolicy = it.next();</span><br><span class="line">        <span class="comment">// ... more code ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就可以完成一个新的 SPI 策略的注册工作。</p><p>但是，在尝试实现，了解了 ServiceLoader 源码，以及 DriverManager 和 mysql-connection-java-<version>.jar 在注册 Driver 相关的代码。<br>发现怎么也绕不开 Java 安全访问相关的内容。诸如下列这段来自 DriverManager.loadInitialDrivers() 的代码:</version></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</span><br><span class="line">        Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(driversIterator.hasNext()) &#123;</span><br><span class="line">            driversIterator.next();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Throwable t) &#123;</span><br><span class="line">                <span class="comment">// Do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>诸如 AccessController, Permission, SecurityManager 的代码始终是一个绕不开的主旋律。</p><p>为了探究这部分控制对项目中 ServiceLoader 的真正作用以及其编码意义，开始了对本文所描述的主体内容的初步了解。</p><a id="more"></a><h2 id="从现象开始…"><a href="#从现象开始…" class="headerlink" title="从现象开始…"></a>从现象开始…</h2><p>在通过 <code>java</code> 命令执行本地代码时，偶尔/经常会出现文件I/O操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(System.getSecurityManager());</span><br><span class="line"></span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"/Users/fangfeng/test.in"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> chr; (chr = fis.read()) != -<span class="number">1</span>;) &#123;</span><br><span class="line">        System.out.print((<span class="keyword">char</span>) chr);</span><br><span class="line">    &#125;</span><br><span class="line">    fis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>诸如上面这段代码，意在读取外部路径下 <code>test.in</code> 文件(不要放在项目路径下，文本内容为 <code>0123456789</code>)。当然，还包括打印 System.getSecurityManager().toString() 。</p><p>正常情况下，这都是能够执行成功，结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">null</span><br><span class="line">0123456789</span><br></pre></td></tr></table></figure><p>但是，通过在命令行 <code>java</code> 中添加选项 <code>-Djava.security.manager</code>，再次执行代码，结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java.lang.SecurityManager@4e25154f</span><br><span class="line">Exception in thread &quot;main&quot; java.security.AccessControlException: access denied (&quot;java.io.FilePermission&quot; &quot;/Users/fangfeng/test.in&quot; &quot;read&quot;)</span><br><span class="line">at java.security.AccessControlContext.checkPermission(AccessControlContext.java:472)</span><br><span class="line">at java.security.AccessController.checkPermission(AccessController.java:884)</span><br><span class="line">at java.lang.SecurityManager.checkPermission(SecurityManager.java:549)</span><br><span class="line">at java.lang.SecurityManager.checkRead(SecurityManager.java:888)</span><br><span class="line">at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:127)</span><br><span class="line">at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:93)</span><br><span class="line">at me.fangfeng.security.SecurityTest.main(SecurityTest.java:16)</span><br></pre></td></tr></table></figure><p>现在已经能够获取到 <code>System.getSecuriryManager</code> 的实例。<br>但是想要读取 <code>test.in</code> 文件却失败了，表现为 access denied（访问被拒绝）。</p><p>现在，在用户目录下(这里是 /Users/fangfeng, 不同系统不同用户请做相应修改) 添加 <code>.java.policy</code> 文件，添加下列文本:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grant &#123;</span><br><span class="line">    permission java.io.FilePermission &quot;/Users/fangfeng/test.in&quot;, &quot;read&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再次 <code>java -Djava.security.manager &lt;class&#39;s path&gt;</code>，不仅能够得到 SecurityManager 的实例，同时也读取到了文本内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.SecurityManager@3af49f1c</span><br><span class="line">0123456789</span><br></pre></td></tr></table></figure><hr><p>到此为止，应该已经能够感受到 Java 对安全访问的控制在文件I/O上的体现了。</p><h2 id="安全控制下的操作"><a href="#安全控制下的操作" class="headerlink" title="安全控制下的操作"></a>安全控制下的操作</h2><p><strong>在开始下列内容之前，需要提前了解一个前提:</strong><br><strong>Java 对操作权限的控制是通过检查当前线程操作上下文的代码是否存在要求的操作权限实现的(除了特权的声明以及其它还需要控制别的线程上下文权限的情况)</strong></p><p>上一节演示了权限控制下本地代码对本地资源的访问。但是，安全控制真的有必要吗？</p><ul><li>就本地程序而言，不必要。事实上，Java 也确实是这么做的。平时在本地利用 <code>java</code> 命令执行程序，都不会受到任何限制。Java 启动时默认不会装载 SecurityManager，也就不会触发对各种操作的权限验证。</li><li>可如果程序运行与网络上其它程序交互，甚至直接加载来自网络的字节码。那么，权限控制确实是有必要的。至少，如果不存在权限控制，来自网络的恶意代码访问整台机器的任意资源都将畅通无阻。</li></ul><h3 id="SecurityManager"><a href="#SecurityManager" class="headerlink" title="SecurityManager"></a>SecurityManager</h3><p>SecurityManager 是整个访问控制的管理器和基本入口。所有涉及到权限控制的代码，都会类似地存在下列这般的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SecurityManager security = System.getSecurityManager();</span><br><span class="line"><span class="comment">// 如果系统存在安全管理器</span></span><br><span class="line"><span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用 SecurityManager 中以 check 开头的方法</span></span><br><span class="line">    security.checkXxx(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>security.checkXxx(...)</code> 是没有返回值的(除了 checkTopLevelWindow)；对于没有操作权限的代码，直接抛出异常</p><p>至于到底在 check 什么，Java 中定义了包括文件(File)、套接字(Socket)、网络(Net)、安全性(Security)、运行时(Runtime)、属性(Property)、AWT、反射(Reflect)和可序列化(Serializable) 九类权限。</p><p>通常，security.checkXxx(…) 方法将构造一个 XxxPermission(…) 对象来调用 SecurityManager 提供的统一方法 checkPermission(Permission) 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以 checkRead(name) 为例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkRead</span><span class="params">(String file)</span> </span>&#123;</span><br><span class="line">    checkPermission(<span class="keyword">new</span> FilePermission(file, SecurityConstants.FILE_READ_ACTION));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 checkPermission(Permission) 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkPermission</span><span class="params">(Permission perm)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接调用 访问控制器 来对权限进行鉴别</span></span><br><span class="line">    java.security.AccessController.checkPermission(perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AccessController"><a href="#AccessController" class="headerlink" title="AccessController"></a>AccessController</h3><p>AccessController 用于与访问控制相关的操作和决定。</p><blockquote><p>AccessController 类用于以下三个目的：</p><p>基于当前生效的安全策略决定是允许还是拒绝对关键系统资源的访问<br>将代码标记为享有“特权”，从而影响后续访问决定，以及<br>获取当前调用上下文的“快照”，这样便可以相对于已保存的上下文作出其他上下文的访问控制决定</p></blockquote><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>总的来说，Java 的访问控制就是通过针对不同的操作构建不同的 Permission 对象，然后通过与 AccessControllerContent 持有的各代码的权限进行比对，<br>从而判断代码是否存在相应的访问权限。</p><p><em>所谓的Permission判断将是对当前线程的调用栈的每个调用者逐一倒序递归，判断是否拥有权限。如果其中的某个代码被声明为 Privileged，则直接认为是拥有权限</em></p><p><strong>更多的关于 checkPermission(…) 调用相关的内容，可以自行查阅资料进行学习，在此不做过多陈述。:)</strong></p><h2 id="为操作赋权"><a href="#为操作赋权" class="headerlink" title="为操作赋权"></a>为操作赋权</h2><p>上一节讲完了如果对当前项目配置了 SecurityManager ，将对各种敏感操作进行访问控制，并且将根据整个调用链被赋予的权限来决定是允许执行还是抛出 access denied。</p><p>但是，究竟怎么才能够给 code 赋予权限呢？</p><p>回顾前一节的内容，在基本探究中，其实一个能够看到<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grant &#123;</span><br><span class="line">    permission java.io.FilePermission <span class="string">"/Users/fangfeng/test.in"</span>, <span class="string">"read"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这就是一种赋权的操作。</p><p>通过在指定的文件中写入符合特定规则的代码，来完成对 code 的赋权。<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/PolicyFiles.html" target="_blank" rel="noopener">Default Policy Implementation and Policy File Syntax</a></p><p>在项目启动的时候，默认就会读取 $JAVA_HOME/jre/lib/security/java.policy 以及 ${user.home}/.java.policy 两个文件的赋权内容，并做缓存给后面代码使用。</p><p>当然，Java 也提供指定自定义的赋权文件，通过 -Djava.security.policy=<policy file=""> 或者 -Djava.security.policy==<policy file=""> 。</policy></policy></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1]. Java Document - Security. <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/security/index.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;绪论&quot;&gt;&lt;a href=&quot;#绪论&quot; class=&quot;headerlink&quot; title=&quot;绪论&quot;&gt;&lt;/a&gt;绪论&lt;/h2&gt;&lt;p&gt;&lt;em&gt;本文只是对 Java 安全访问与权限控制的基础性探究。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本节与全文内容无关，如无兴趣阅读，可以跳过&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;了解 Java 安全访问相关内容的初衷，是准备在项目中利用 Java 标准库提供的 ServiceLoader 对 SPI 实现类进行”自动发现”和加载。&lt;br&gt;这对于将本项目作为二方库来依赖的上层项目将更为方便，只需要&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 &lt;code&gt;META-INF.services&lt;/code&gt; 目录下配置被命名为 SPI 接口全限定名的文件及添加相关内容&lt;/li&gt;
&lt;li&gt;由项目的注册管理器触发下列 Java 代码&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ServiceLoader&amp;lt;XxxPolicy&amp;gt; xxxPolicyServiceLoader = ServiceLoader.load(XxxPolicy.class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (Iterator&amp;lt;XxxPolicy&amp;gt; it = xxxPolicyServiceLoader.iterator(); it.hasNext(); ) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        XxxPolicy xxxPolicy = it.next();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// ... more code ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;就可以完成一个新的 SPI 策略的注册工作。&lt;/p&gt;
&lt;p&gt;但是，在尝试实现，了解了 ServiceLoader 源码，以及 DriverManager 和 mysql-connection-java-&lt;version&gt;.jar 在注册 Driver 相关的代码。&lt;br&gt;发现怎么也绕不开 Java 安全访问相关的内容。诸如下列这段来自 DriverManager.loadInitialDrivers() 的代码:&lt;/version&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;AccessController.doPrivileged(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; PrivilegedAction&amp;lt;Void&amp;gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Void &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ServiceLoader&amp;lt;Driver&amp;gt; loadedDrivers = ServiceLoader.load(Driver.class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Iterator&amp;lt;Driver&amp;gt; driversIterator = loadedDrivers.iterator();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(driversIterator.hasNext()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            driversIterator.next();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt;(Throwable t) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// Do nothing&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;诸如 AccessController, Permission, SecurityManager 的代码始终是一个绕不开的主旋律。&lt;/p&gt;
&lt;p&gt;为了探究这部分控制对项目中 ServiceLoader 的真正作用以及其编码意义，开始了对本文所描述的主体内容的初步了解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://DorMOUSE-None.github.io/tags/Java/"/>
    
      <category term="Security" scheme="https://DorMOUSE-None.github.io/tags/Security/"/>
    
      <category term="Permission" scheme="https://DorMOUSE-None.github.io/tags/Permission/"/>
    
  </entry>
  
  <entry>
    <title>ASM-VerifyError错误信息解决</title>
    <link href="https://DorMOUSE-None.github.io/2018-06-28-ASM-VerifyError/"/>
    <id>https://DorMOUSE-None.github.io/2018-06-28-ASM-VerifyError/</id>
    <published>2018-06-27T16:00:00.000Z</published>
    <updated>2018-06-28T10:46:48.114Z</updated>
    
    <content type="html"><![CDATA[<h2 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.VerifyError: <span class="class"><span class="keyword">class</span> <span class="title">net</span>.<span class="title">sf</span>.<span class="title">cglib</span>.<span class="title">core</span>.<span class="title">DebuggingClassWriter</span> <span class="title">overrides</span> <span class="title">final</span> <span class="title">method</span> <span class="title">visit</span>.(<span class="title">IILjava</span>/<span class="title">lang</span>/<span class="title">String</span></span>;Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;)V</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>项目依赖的 </p><ul><li>CGlib 版本是 2.2.2</li><li>ASM 版本是 3.3.1</li></ul><h2 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h2><p>前两天刚粗略通读了 ASM ，结果就遇上这样一个问题。</p><p>从 <code>net.sf.cglib.core.DebuggingClassWriter</code> 看，这是 CGlib 的一个实现类</p><p>从描述 <code>overrides final method visit.(IILjava/lang/String;Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;)V</code><br>以及 DebuggingClassWriter 类的字节码反编译结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DebuggingClassWriter</span> <span class="keyword">extends</span> <span class="title">ClassWriter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> version, <span class="keyword">int</span> access, String name, String signature, String superName, String[] interfaces)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.className = name.replace(<span class="string">'/'</span>, <span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">this</span>.superName = superName.replace(<span class="string">'/'</span>, <span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">super</span>.visit(version, access, name, signature, superName, interfaces);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至少应该是 visit(…) 方法要重载的父类的被声明为 final 的 ClassWriter.visit(…) 才导致的问题。</p><p>但是从 ASM 3.3.1 版本的 ClassWriter 类可以看到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> var1, <span class="keyword">int</span> var2, String var3, String var4, String var5, String[] var6)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>visit 方法并没有被声明为 final 。</p><p>但是，结合一定的背景知识，ASM 项目在加入了 OW2 组织后的新版本(asm-3.3.1 是未加入 OW2 前的最后一个版本)，<br>ClassWriter 类的所有 visitXxx(…) 方法都被添加了 <code>final</code> 限制。</p><p>因此，怀疑是项目实际依赖了高版本的 asm (asm 4.x 及以上)</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>经过确认，由于整个项目依赖关系复杂，有其它项目引入了 asm-4.1.jar。<br>而且由于使用 MAVEN 进行项目依赖管理，asm-4.1.jar 与依赖树根的深度更浅，<br>因此，最终打包的 war 里面确实引入了 asm-4.1.jar 。导致了这个问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;报错信息&quot;&gt;&lt;a href=&quot;#报错信息&quot; class=&quot;headerlink&quot; title=&quot;报错信息&quot;&gt;&lt;/a&gt;报错信息&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;java.lang.VerifyError: &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;net&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;sf&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;cglib&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;core&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;DebuggingClassWriter&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;overrides&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;visit&lt;/span&gt;.(&lt;span class=&quot;title&quot;&gt;IILjava&lt;/span&gt;/&lt;span class=&quot;title&quot;&gt;lang&lt;/span&gt;/&lt;span class=&quot;title&quot;&gt;String&lt;/span&gt;&lt;/span&gt;;Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;)V&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://DorMOUSE-None.github.io/tags/Java/"/>
    
      <category term="ASM" scheme="https://DorMOUSE-None.github.io/tags/ASM/"/>
    
      <category term="CGlib" scheme="https://DorMOUSE-None.github.io/tags/CGlib/"/>
    
  </entry>
  
  <entry>
    <title>ASM 核心包基本内容漫谈</title>
    <link href="https://DorMOUSE-None.github.io/2018-06-25-ASM-Core/"/>
    <id>https://DorMOUSE-None.github.io/2018-06-25-ASM-Core/</id>
    <published>2018-06-24T16:00:00.000Z</published>
    <updated>2018-06-25T10:16:37.866Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文描述的 ASM 指的是 OW2 ASM</p></blockquote><h2 id="ASM-Core-的结构"><a href="#ASM-Core-的结构" class="headerlink" title="ASM-Core 的结构"></a>ASM-Core 的结构</h2><p><em>首先是一些概述性的内容。</em></p><p>由于 ASM 操作的 JAVA 字节码有严格的格式规定，且即使随着 JVM 标准的升级也极少出现重大调整。<br>因此适用面狭窄的访问者模式在该项目中被大量地使用，并且已经到了丧心病狂的程度:)</p><p>从核心包声明的类来看，主要包括:</p><ol><li><p>ClassReader - 作为结构化对象，将接收(accept)访问者的访问</p></li><li><p>几种访问者抽象类以及相应的实现类</p></li></ol><ul><li>AnnotationVisitor -&gt; AnnotationWriter</li><li>ClassVisitor -&gt; ClassWriter</li><li>FieldVisitor -&gt; FieldWriter</li><li>MethodVisitor -&gt; MethodWriter</li><li>ModuleVisitor -&gt; ModuleWriter</li></ul><ol start="3"><li><p>Opcodes &amp; Constants - ClassFile 中描述的大量常量符号与值</p></li><li><p>其它一些辅助的类</p></li></ol><ul><li>Attribute - 用于处理非标准化的属性(ClassFile 允许<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html" target="_blank" rel="noopener">JVMS</a> 中未定义的 Attribute)</li><li>ByteArray - 动态可自适应的 byte[] (字节数组)</li><li>Context - ClassReader 在被解析(被访问)过程中用于表示“累积状态”的一个类/对象</li><li>Symbol - 用于表示 ClassFile 中描述的 Constant 的基类</li><li>SymbolTable - 用于存储常量池对象</li><li>其它内容省略</li></ul><a id="more"></a><h2 id="ClassFile-文件格式"><a href="#ClassFile-文件格式" class="headerlink" title="ClassFile 文件格式"></a>ClassFile 文件格式</h2><p>本节的内容可以参阅 <a href="https://dormouse-none.github.io/2018-06-11-ASM-ClassReader/">ClassFile 文件格式</a></p><p>ClassFile 是 ASM 操作字节码的基础与前提。在 JVMS 定义了 .class 文件格式之后，ASM 才在此基础上进行了对 ClassFile 的字节码操作。</p><p>因此，无论如何，个人认为在真正开始了解 ASM 之前，通读一遍 ClassFile 文件格式是完全有必要的。并且，在基本了解 ClassFile 内容的基础上，<br>尝试对某个 .class 文件进行手工解析也不失为一种加深理解的途径。</p><h2 id="Visitor-Pattern"><a href="#Visitor-Pattern" class="headerlink" title="Visitor Pattern"></a>Visitor Pattern</h2><p>由于 ASM 的实现采用了偏门的访问者模式。因此，了解访问者模式也是一个必不可少的重要环节。同时在了解后也将为源码阅读者提供更清晰的解读思路。</p><p>《设计模式：可复用面向对象软件的基础》一书的“5.11 VISITOR(访问者)——对象行为型模式”提供了很详尽的解释。</p><p>本人对这方面的不甚了解，推荐自行查找资料。</p><h2 id="ClassReader"><a href="#ClassReader" class="headerlink" title="ClassReader"></a>ClassReader</h2><p>ClassReader 是解析现有的 .class 文件的基本工具。同时，ClassReader 也作为一个内容的持有者，与 SymboleTable 配合，来满足访问者基本的访问需求。</p><p>刨除大量的内部私有方法，ClassReader 对外开放的接口相当简单。最核心的方法仅包括 ClassReader(…) 以及 accetp(…)</p><h3 id="ClassReader-…-构造方法"><a href="#ClassReader-…-构造方法" class="headerlink" title="ClassReader(…) 构造方法"></a>ClassReader(…) 构造方法</h3><p>顾名思义，构造方法用于实例化 ClassReader 对象，包括一些必须的变量的初始化。</p><p>在构造函数中完成的初始化内容包括:</p><ul><li>校验版本号</li><li>存储每个常量池项目的起始偏移量 cpInfoOffsets</li><li>存储每个引导方法的起始偏移量 bootstrapMethodOffsets</li><li>存储最长字符串常量的大小 maxStringLength</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">ClassReader(<span class="keyword">final</span> <span class="keyword">byte</span>[] classFileBuffer, <span class="keyword">final</span> <span class="keyword">int</span> classFileOffset, <span class="keyword">final</span> <span class="keyword">boolean</span> checkClassVersion) &#123;</span><br><span class="line">  <span class="keyword">this</span>.b = classFileBuffer;   <span class="comment">// .class 文件缓存</span></span><br><span class="line">  <span class="comment">// 检查主版本号, 第6,7个字节(从0字节开始计数)</span></span><br><span class="line">  <span class="keyword">if</span> (checkClassVersion &amp;&amp; readShort(classFileOffset + <span class="number">6</span>) &gt; Opcodes.V11) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">        <span class="string">"Unsupported class file major version "</span> + readShort(classFileOffset + <span class="number">6</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建常量池数组，常量池长度的定义 constant_pool_count 在第8,9字节</span></span><br><span class="line">  <span class="keyword">int</span> constantPoolCount = readUnsignedShort(classFileOffset + <span class="number">8</span>);     <span class="comment">// 读取无符号short, 即读取连续两字节作为一个short值</span></span><br><span class="line">  cpInfoOffsets = <span class="keyword">new</span> <span class="keyword">int</span>[constantPoolCount];                         <span class="comment">// 每个常量的偏移位置</span></span><br><span class="line">  cpInfoValues = <span class="keyword">new</span> Object[constantPoolCount];                       <span class="comment">// 每个常量的实例对象</span></span><br><span class="line">  <span class="keyword">int</span> currentCpInfoIndex = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> currentCpInfoOffset = classFileOffset + <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> currentMaxStringLength = <span class="number">0</span>;                                     <span class="comment">// 最长字符串常量</span></span><br><span class="line">  <span class="keyword">while</span> (currentCpInfoIndex &lt; constantPoolCount) &#123;</span><br><span class="line">    cpInfoOffsets[currentCpInfoIndex++] = currentCpInfoOffset + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cpInfoSize;</span><br><span class="line">    <span class="keyword">switch</span> (classFileBuffer[currentCpInfoOffset]) &#123;</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_FIELDREF_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_METHODREF_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_INTERFACE_METHODREF_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_INTEGER_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_FLOAT_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_NAME_AND_TYPE_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_DYNAMIC_TAG:</span><br><span class="line">        cpInfoSize = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_LONG_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_DOUBLE_TAG:</span><br><span class="line">        cpInfoSize = <span class="number">9</span>;</span><br><span class="line">        currentCpInfoIndex++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_UTF8_TAG:</span><br><span class="line">        cpInfoSize = <span class="number">3</span> + readUnsignedShort(currentCpInfoOffset + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (cpInfoSize &gt; currentMaxStringLength) &#123;</span><br><span class="line">          <span class="comment">// The size in bytes of this CONSTANT_Utf8 structure provides a conservative estimate</span></span><br><span class="line">          <span class="comment">// of the length in characters of the corresponding string, and is much cheaper to</span></span><br><span class="line">          <span class="comment">// compute than this exact length.</span></span><br><span class="line">          currentMaxStringLength = cpInfoSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_METHOD_HANDLE_TAG:</span><br><span class="line">        cpInfoSize = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_CLASS_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_STRING_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_METHOD_TYPE_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_PACKAGE_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_MODULE_TAG:</span><br><span class="line">        cpInfoSize = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    currentCpInfoOffset += cpInfoSize;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.maxStringLength = currentMaxStringLength;</span><br><span class="line">  <span class="comment">// The Classfile's access_flags field is just after the last constant pool entry.</span></span><br><span class="line">  <span class="keyword">this</span>.header = currentCpInfoOffset;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取 BootstrapMethods 属性(如果存在)</span></span><br><span class="line">  <span class="keyword">int</span> currentAttributeOffset = getFirstAttributeOffset();</span><br><span class="line">  <span class="keyword">int</span>[] currentBootstrapMethodOffsets = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = readUnsignedShort(currentAttributeOffset - <span class="number">2</span>); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="comment">// 读取每个 attribute_info 的属性名和属性长度</span></span><br><span class="line">    String attributeName = readUTF8(currentAttributeOffset, <span class="keyword">new</span> <span class="keyword">char</span>[maxStringLength]);</span><br><span class="line">    <span class="keyword">int</span> attributeLength = readInt(currentAttributeOffset + <span class="number">2</span>);</span><br><span class="line">    currentAttributeOffset += <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 如果当前属性名为 BootstrapMethods ，则进入处理逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (Constants.BOOTSTRAP_METHODS.equals(attributeName)) &#123;</span><br><span class="line">      <span class="comment">// Read the num_bootstrap_methods field and create an array of this size.</span></span><br><span class="line">      currentBootstrapMethodOffsets = <span class="keyword">new</span> <span class="keyword">int</span>[readUnsignedShort(currentAttributeOffset)];</span><br><span class="line">      <span class="comment">// Compute and store the offset of each 'bootstrap_methods' array field entry.</span></span><br><span class="line">      <span class="keyword">int</span> currentBootstrapMethodOffset = currentAttributeOffset + <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; currentBootstrapMethodOffsets.length; ++j) &#123;</span><br><span class="line">        currentBootstrapMethodOffsets[j] = currentBootstrapMethodOffset;</span><br><span class="line">        <span class="comment">// Skip the bootstrap_method_ref and num_bootstrap_arguments fields (2 bytes each),</span></span><br><span class="line">        <span class="comment">// as well as the bootstrap_arguments array field (of size num_bootstrap_arguments * 2).</span></span><br><span class="line">        currentBootstrapMethodOffset +=</span><br><span class="line">            <span class="number">4</span> + readUnsignedShort(currentBootstrapMethodOffset + <span class="number">2</span>) * <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    currentAttributeOffset += attributeLength;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.bootstrapMethodOffsets = currentBootstrapMethodOffsets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，ClassReader 已经解析了包括 magic, minor version, major version, constant pool 。<br>但是，诸如 field_info, method_info, attribute_info 等仍然没有得到处理。</p><h3 id="accept-…"><a href="#accept-…" class="headerlink" title="accept(…)"></a>accept(…)</h3><p>访问者模式的核心操作就是结构化对象接受(accept)访问者对象实例的访问，并将结构化内容完全暴露给访问者。</p><p>从抽象的方法角度看，可以理解成:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// --- 结构化对象的 accept() 方法 ---</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">  visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 访问者对象的 visit() 方法 ---</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Xxx <span class="title">visit</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 若干关于 element 的读操作 + 其它操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> ClassVisitor classVisitor,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> Attribute[] attributePrototypes,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> <span class="keyword">int</span> parsingOptions)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义 Context 作为辅助类，暂存被访问过程的“累积状态”</span></span><br><span class="line">    Context context = <span class="keyword">new</span> Context();</span><br><span class="line">    context.attributePrototypes = attributePrototypes;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析选项: </span></span><br><span class="line"><span class="comment">     * 1. SKIP_CODE - 不解析 CODE 属性 </span></span><br><span class="line"><span class="comment">     * 2. SKIP_DEBUG - 不解析 DEBUG 相关的属性(例如SourceFile, SourceDebugExtension, LocalVariableTable, LocalVariableTypeTable, LineNumberTable)</span></span><br><span class="line"><span class="comment">     * 4. SKIP_FRAMES - 跳过对 StackMap 和 StackMapTable 属性的解析</span></span><br><span class="line"><span class="comment">     * ...</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    context.parsingOptions = parsingOptions;</span><br><span class="line">    <span class="comment">// 从常量池读取常量所使用的缓冲数字</span></span><br><span class="line">    context.charBuffer = <span class="keyword">new</span> <span class="keyword">char</span>[maxStringLength];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read the access_flags, this_class, super_class, interface_count and interfaces fields.</span></span><br><span class="line">    <span class="comment">// 解析访问控制, 当前类, 父类, 接口数量与接口值等</span></span><br><span class="line">    <span class="keyword">char</span>[] charBuffer = context.charBuffer;</span><br><span class="line">    <span class="keyword">int</span> currentOffset = header;</span><br><span class="line">    <span class="keyword">int</span> accessFlags = readUnsignedShort(currentOffset);</span><br><span class="line">    String thisClass = readClass(currentOffset + <span class="number">2</span>, charBuffer);</span><br><span class="line">    String superClass = readClass(currentOffset + <span class="number">4</span>, charBuffer);</span><br><span class="line">    String[] interfaces = <span class="keyword">new</span> String[readUnsignedShort(currentOffset + <span class="number">6</span>)];</span><br><span class="line">    currentOffset += <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interfaces.length; ++i) &#123;</span><br><span class="line">      interfaces[i] = readClass(currentOffset, charBuffer);</span><br><span class="line">      currentOffset += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read the class attributes (the variables are ordered as in Section 4.7 of the JVMS).</span></span><br><span class="line">    <span class="comment">// Attribute offsets exclude the attribute_name_index and attribute_length fields.</span></span><br><span class="line">    <span class="comment">// - The offset of the InnerClasses attribute, or 0.</span></span><br><span class="line">    <span class="keyword">int</span> innerClassesOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// - The offset of the EnclosingMethod attribute, or 0.</span></span><br><span class="line">    <span class="keyword">int</span> enclosingMethodOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// - The string corresponding to the Signature attribute, or null.</span></span><br><span class="line">    String signature = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// - The string corresponding to the SourceFile attribute, or null.</span></span><br><span class="line">    String sourceFile = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// - The string corresponding to the SourceDebugExtension attribute, or null.</span></span><br><span class="line">    String sourceDebugExtension = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// - The offset of the RuntimeVisibleAnnotations attribute, or 0.</span></span><br><span class="line">    <span class="keyword">int</span> runtimeVisibleAnnotationsOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// - The offset of the RuntimeInvisibleAnnotations attribute, or 0.</span></span><br><span class="line">    <span class="keyword">int</span> runtimeInvisibleAnnotationsOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.</span></span><br><span class="line">    <span class="keyword">int</span> runtimeVisibleTypeAnnotationsOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.</span></span><br><span class="line">    <span class="keyword">int</span> runtimeInvisibleTypeAnnotationsOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// - The offset of the Module attribute, or 0.</span></span><br><span class="line">    <span class="keyword">int</span> moduleOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// - The offset of the ModulePackages attribute, or 0.</span></span><br><span class="line">    <span class="keyword">int</span> modulePackagesOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// - The string corresponding to the ModuleMainClass attribute, or null.</span></span><br><span class="line">    String moduleMainClass = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// - The string corresponding to the NestHost attribute, or null.</span></span><br><span class="line">    String nestHostClass = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// - The offset of the NestMembers attribute, or 0.</span></span><br><span class="line">    <span class="keyword">int</span> nestMembersOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// - The non standard attributes (linked with their &#123;@link Attribute#nextAttribute&#125; field).</span></span><br><span class="line">    <span class="comment">//   This list in the &lt;i&gt;reverse order&lt;/i&gt; or their order in the ClassFile structure.</span></span><br><span class="line">    Attribute attributes = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 Class 持有的属性</span></span><br><span class="line">    <span class="keyword">int</span> currentAttributeOffset = getFirstAttributeOffset();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = readUnsignedShort(currentAttributeOffset - <span class="number">2</span>); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">      <span class="comment">// Read the attribute_info's attribute_name and attribute_length fields.</span></span><br><span class="line">      String attributeName = readUTF8(currentAttributeOffset, charBuffer);</span><br><span class="line">      <span class="keyword">int</span> attributeLength = readInt(currentAttributeOffset + <span class="number">2</span>);</span><br><span class="line">      currentAttributeOffset += <span class="number">6</span>;</span><br><span class="line">      <span class="comment">// The tests are sorted in decreasing frequency order (based on frequencies observed on</span></span><br><span class="line">      <span class="comment">// typical classes).</span></span><br><span class="line">      <span class="keyword">if</span> (Constants.SOURCE_FILE.equals(attributeName)) &#123;</span><br><span class="line">        sourceFile = readUTF8(currentAttributeOffset, charBuffer);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.INNER_CLASSES.equals(attributeName)) &#123;</span><br><span class="line">        innerClassesOffset = currentAttributeOffset;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.ENCLOSING_METHOD.equals(attributeName)) &#123;</span><br><span class="line">        enclosingMethodOffset = currentAttributeOffset;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.NEST_HOST.equals(attributeName)) &#123;</span><br><span class="line">        nestHostClass = readClass(currentAttributeOffset, charBuffer);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.NEST_MEMBERS.equals(attributeName)) &#123;</span><br><span class="line">        nestMembersOffset = currentAttributeOffset;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.SIGNATURE.equals(attributeName)) &#123;</span><br><span class="line">        signature = readUTF8(currentAttributeOffset, charBuffer);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) &#123;</span><br><span class="line">        runtimeVisibleAnnotationsOffset = currentAttributeOffset;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) &#123;</span><br><span class="line">        runtimeVisibleTypeAnnotationsOffset = currentAttributeOffset;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.DEPRECATED.equals(attributeName)) &#123;</span><br><span class="line">        accessFlags |= Opcodes.ACC_DEPRECATED;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.SYNTHETIC.equals(attributeName)) &#123;</span><br><span class="line">        accessFlags |= Opcodes.ACC_SYNTHETIC;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.SOURCE_DEBUG_EXTENSION.equals(attributeName)) &#123;</span><br><span class="line">        sourceDebugExtension =</span><br><span class="line">            readUTF(currentAttributeOffset, attributeLength, <span class="keyword">new</span> <span class="keyword">char</span>[attributeLength]);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) &#123;</span><br><span class="line">        runtimeInvisibleAnnotationsOffset = currentAttributeOffset;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) &#123;</span><br><span class="line">        runtimeInvisibleTypeAnnotationsOffset = currentAttributeOffset;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.MODULE.equals(attributeName)) &#123;</span><br><span class="line">        moduleOffset = currentAttributeOffset;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.MODULE_MAIN_CLASS.equals(attributeName)) &#123;</span><br><span class="line">        moduleMainClass = readClass(currentAttributeOffset, charBuffer);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.MODULE_PACKAGES.equals(attributeName)) &#123;</span><br><span class="line">        modulePackagesOffset = currentAttributeOffset;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.BOOTSTRAP_METHODS.equals(attributeName)) &#123;</span><br><span class="line">        <span class="comment">// This attribute is read in the constructor.</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Attribute attribute =</span><br><span class="line">            readAttribute(</span><br><span class="line">                attributePrototypes,</span><br><span class="line">                attributeName,</span><br><span class="line">                currentAttributeOffset,</span><br><span class="line">                attributeLength,</span><br><span class="line">                charBuffer,</span><br><span class="line">                -<span class="number">1</span>,</span><br><span class="line">                <span class="keyword">null</span>);</span><br><span class="line">        attribute.nextAttribute = attributes;</span><br><span class="line">        attributes = attribute;</span><br><span class="line">      &#125;</span><br><span class="line">      currentAttributeOffset += attributeLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个 .visit() 。让 ClassVisitor 的实现类处理当前类的版本号, 访问控制标志, 当前类, 结构, 父类, 接口</span></span><br><span class="line">    <span class="comment">// 具体 visit() 由实现类随意定制。例如，针对于那些有打印功能的访问者实现类，直接打印也不失为一种有效的访问操作</span></span><br><span class="line">    <span class="comment">// Visit the class declaration. The minor_version and major_version fields start 6 bytes before</span></span><br><span class="line">    <span class="comment">// the first constant pool entry, which itself starts at cpInfoOffsets[1] - 1 (by definition).</span></span><br><span class="line">    classVisitor.visit(</span><br><span class="line">        readInt(cpInfoOffsets[<span class="number">1</span>] - <span class="number">7</span>), accessFlags, thisClass, signature, superClass, interfaces);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问 SourceFile 和 SourceDebugExtenstion 属性</span></span><br><span class="line">    <span class="comment">// Visit the SourceFile and SourceDebugExtenstion attributes.</span></span><br><span class="line">    <span class="keyword">if</span> ((parsingOptions &amp; SKIP_DEBUG) == <span class="number">0</span></span><br><span class="line">        &amp;&amp; (sourceFile != <span class="keyword">null</span> || sourceDebugExtension != <span class="keyword">null</span>)) &#123;</span><br><span class="line">      classVisitor.visitSource(sourceFile, sourceDebugExtension);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Visit the Module, ModulePackages and ModuleMainClass attributes.</span></span><br><span class="line">    <span class="keyword">if</span> (moduleOffset != <span class="number">0</span>) &#123;</span><br><span class="line">      readModule(classVisitor, context, moduleOffset, modulePackagesOffset, moduleMainClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Visit the NestHost attribute.</span></span><br><span class="line">    <span class="keyword">if</span> (nestHostClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">      classVisitor.visitNestHostExperimental(nestHostClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Visit the EnclosingMethod attribute.</span></span><br><span class="line">    <span class="keyword">if</span> (enclosingMethodOffset != <span class="number">0</span>) &#123;</span><br><span class="line">      String className = readClass(enclosingMethodOffset, charBuffer);</span><br><span class="line">      <span class="keyword">int</span> methodIndex = readUnsignedShort(enclosingMethodOffset + <span class="number">2</span>);</span><br><span class="line">      String name = methodIndex == <span class="number">0</span> ? <span class="keyword">null</span> : readUTF8(cpInfoOffsets[methodIndex], charBuffer);</span><br><span class="line">      String type = methodIndex == <span class="number">0</span> ? <span class="keyword">null</span> : readUTF8(cpInfoOffsets[methodIndex] + <span class="number">2</span>, charBuffer);</span><br><span class="line">      classVisitor.visitOuterClass(className, name, type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Visit the RuntimeVisibleAnnotations attribute.</span></span><br><span class="line">    <span class="keyword">if</span> (runtimeVisibleAnnotationsOffset != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);</span><br><span class="line">      <span class="keyword">int</span> currentAnnotationOffset = runtimeVisibleAnnotationsOffset + <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">while</span> (numAnnotations-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Parse the type_index field.</span></span><br><span class="line">        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</span><br><span class="line">        currentAnnotationOffset += <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// Parse num_element_value_pairs and element_value_pairs and visit these values.</span></span><br><span class="line">        currentAnnotationOffset =</span><br><span class="line">            readElementValues(</span><br><span class="line">                classVisitor.visitAnnotation(annotationDescriptor, <span class="comment">/* visible = */</span> <span class="keyword">true</span>),</span><br><span class="line">                currentAnnotationOffset,</span><br><span class="line">                <span class="comment">/* named = */</span> <span class="keyword">true</span>,</span><br><span class="line">                charBuffer);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Visit the RuntimeInvisibleAnnotations attribute.</span></span><br><span class="line">    <span class="keyword">if</span> (runtimeInvisibleAnnotationsOffset != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);</span><br><span class="line">      <span class="keyword">int</span> currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">while</span> (numAnnotations-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Parse the type_index field.</span></span><br><span class="line">        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</span><br><span class="line">        currentAnnotationOffset += <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// Parse num_element_value_pairs and element_value_pairs and visit these values.</span></span><br><span class="line">        currentAnnotationOffset =</span><br><span class="line">            readElementValues(</span><br><span class="line">                classVisitor.visitAnnotation(annotationDescriptor, <span class="comment">/* visible = */</span> <span class="keyword">false</span>),</span><br><span class="line">                currentAnnotationOffset,</span><br><span class="line">                <span class="comment">/* named = */</span> <span class="keyword">true</span>,</span><br><span class="line">                charBuffer);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Visit the RuntimeVisibleTypeAnnotations attribute.</span></span><br><span class="line">    <span class="keyword">if</span> (runtimeVisibleTypeAnnotationsOffset != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);</span><br><span class="line">      <span class="keyword">int</span> currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">while</span> (numAnnotations-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Parse the target_type, target_info and target_path fields.</span></span><br><span class="line">        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);</span><br><span class="line">        <span class="comment">// Parse the type_index field.</span></span><br><span class="line">        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</span><br><span class="line">        currentAnnotationOffset += <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// Parse num_element_value_pairs and element_value_pairs and visit these values.</span></span><br><span class="line">        currentAnnotationOffset =</span><br><span class="line">            readElementValues(</span><br><span class="line">                classVisitor.visitTypeAnnotation(</span><br><span class="line">                    context.currentTypeAnnotationTarget,</span><br><span class="line">                    context.currentTypeAnnotationTargetPath,</span><br><span class="line">                    annotationDescriptor,</span><br><span class="line">                    <span class="comment">/* visible = */</span> <span class="keyword">true</span>),</span><br><span class="line">                currentAnnotationOffset,</span><br><span class="line">                <span class="comment">/* named = */</span> <span class="keyword">true</span>,</span><br><span class="line">                charBuffer);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Visit the RuntimeInvisibleTypeAnnotations attribute.</span></span><br><span class="line">    <span class="keyword">if</span> (runtimeInvisibleTypeAnnotationsOffset != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);</span><br><span class="line">      <span class="keyword">int</span> currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">while</span> (numAnnotations-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Parse the target_type, target_info and target_path fields.</span></span><br><span class="line">        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);</span><br><span class="line">        <span class="comment">// Parse the type_index field.</span></span><br><span class="line">        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</span><br><span class="line">        currentAnnotationOffset += <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// Parse num_element_value_pairs and element_value_pairs and visit these values.</span></span><br><span class="line">        currentAnnotationOffset =</span><br><span class="line">            readElementValues(</span><br><span class="line">                classVisitor.visitTypeAnnotation(</span><br><span class="line">                    context.currentTypeAnnotationTarget,</span><br><span class="line">                    context.currentTypeAnnotationTargetPath,</span><br><span class="line">                    annotationDescriptor,</span><br><span class="line">                    <span class="comment">/* visible = */</span> <span class="keyword">false</span>),</span><br><span class="line">                currentAnnotationOffset,</span><br><span class="line">                <span class="comment">/* named = */</span> <span class="keyword">true</span>,</span><br><span class="line">                charBuffer);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问非标准的属性</span></span><br><span class="line">    <span class="comment">// Visit the non standard attributes.</span></span><br><span class="line">    <span class="keyword">while</span> (attributes != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Copy and reset the nextAttribute field so that it can also be used in ClassWriter.</span></span><br><span class="line">      Attribute nextAttribute = attributes.nextAttribute;</span><br><span class="line">      attributes.nextAttribute = <span class="keyword">null</span>;</span><br><span class="line">      classVisitor.visitAttribute(attributes);</span><br><span class="line">      attributes = nextAttribute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Visit the NestedMembers attribute.</span></span><br><span class="line">    <span class="keyword">if</span> (nestMembersOffset != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> numberOfNestMembers = readUnsignedShort(nestMembersOffset);</span><br><span class="line">      <span class="keyword">int</span> currentNestMemberOffset = nestMembersOffset + <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">while</span> (numberOfNestMembers-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        classVisitor.visitNestMemberExperimental(readClass(currentNestMemberOffset, charBuffer));</span><br><span class="line">        currentNestMemberOffset += <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Visit the InnerClasses attribute.</span></span><br><span class="line">    <span class="keyword">if</span> (innerClassesOffset != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> numberOfClasses = readUnsignedShort(innerClassesOffset);</span><br><span class="line">      <span class="keyword">int</span> currentClassesOffset = innerClassesOffset + <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">while</span> (numberOfClasses-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        classVisitor.visitInnerClass(</span><br><span class="line">            readClass(currentClassesOffset, charBuffer),</span><br><span class="line">            readClass(currentClassesOffset + <span class="number">2</span>, charBuffer),</span><br><span class="line">            readUTF8(currentClassesOffset + <span class="number">4</span>, charBuffer),</span><br><span class="line">            readUnsignedShort(currentClassesOffset + <span class="number">6</span>));</span><br><span class="line">        currentClassesOffset += <span class="number">8</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问字段和方法</span></span><br><span class="line">    <span class="comment">// Visit the fields and methods.</span></span><br><span class="line">    <span class="keyword">int</span> fieldsCount = readUnsignedShort(currentOffset);</span><br><span class="line">    currentOffset += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (fieldsCount-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      currentOffset = readField(classVisitor, context, currentOffset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> methodsCount = readUnsignedShort(currentOffset);</span><br><span class="line">    currentOffset += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (methodsCount-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      currentOffset = readMethod(classVisitor, context, currentOffset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Visit the end of the class.</span></span><br><span class="line">    classVisitor.visitEnd();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>其实，将整个 ClassReader 理解成一个对 .class 字节文件的解析器不失为一种可行的认知。</p><ol><li>在构造方法中完成对 .class 文件 minor_version, major_version 的确认。</li><li>继而完成对整个 Constants_pool 的解析</li><li>以及 BootstarpMethod 属性的定位</li><li>之后在 accept(…) 方法中逐一调用相应的访问者实现类实现对不同内容的访问。</li></ol><p>但是，要注意的是，ClassReader 绝对不会涉及到对其解析的 .class 文件内容的写操作。<br>所有的写操作都基于不同的目的，在 ClassVisitor 中实现。</p><h2 id="ClassVisitor"><a href="#ClassVisitor" class="headerlink" title="ClassVisitor"></a>ClassVisitor</h2><p>Java .class 的访问者，按照严格的顺序规范逐一调用 </p><p>visit<br>[ visitSource ] [ visitModule ][ visitNestHost ][ visitOuterClass ]<br>( visitAnnotation | visitTypeAnnotation | visitAttribute )<em><br>( visitNestMember | visitInnerClass | visitField | visitMethod )</em><br>visitEnd.</p><p>各个 visitXXX 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassVisitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 访问类的首部</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> version, <span class="keyword">final</span> <span class="keyword">int</span> access, <span class="keyword">final</span> String name, <span class="keyword">final</span> String signature, <span class="keyword">final</span> String superName, <span class="keyword">final</span> String[] interfaces)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 访问类的源文件名等</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitSource</span><span class="params">(<span class="keyword">final</span> String source, <span class="keyword">final</span> String debug)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 访问与类关联的模块</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModuleVisitor <span class="title">visitModule</span><span class="params">(<span class="keyword">final</span> String name, <span class="keyword">final</span> <span class="keyword">int</span> access, <span class="keyword">final</span> String version)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitOuterClass</span><span class="params">(<span class="keyword">final</span> String owner, <span class="keyword">final</span> String name, <span class="keyword">final</span> String descriptor)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> AnnotationVisitor <span class="title">visitAnnotation</span><span class="params">(<span class="keyword">final</span> String descriptor, <span class="keyword">final</span> <span class="keyword">boolean</span> visible)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> AnnotationVisitor <span class="title">visitTypeAnnotation</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> <span class="keyword">int</span> typeRef, <span class="keyword">final</span> TypePath typePath, <span class="keyword">final</span> String descriptor, <span class="keyword">final</span> <span class="keyword">boolean</span> visible)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitAttribute</span><span class="params">(<span class="keyword">final</span> Attribute attribute)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitInnerClass</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> String name, <span class="keyword">final</span> String outerName, <span class="keyword">final</span> String innerName, <span class="keyword">final</span> <span class="keyword">int</span> access)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 访问类的变量</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FieldVisitor <span class="title">visitField</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> <span class="keyword">int</span> access,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> String name,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> String descriptor,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> String signature,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> Object value)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 访问类的方法</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> <span class="keyword">int</span> access,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> String name,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> String descriptor,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> String signature,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> String[] exceptions)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitEnd</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随着 visitXxx() 方法的逐一执行，ClassVisitor 将对当前的 .class 文件越来越熟悉，并逐渐补全常量池(由 SymbolTable 持有并维护)</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到此为止，对整个 ClassReader &amp; ClassVisitor 将有一个基础而简单的印象。</p><p>ClassReader 通过对 .class 文件字节码的解析而获得对这个类的具体印象(更多的偏向是随意访问 .class 的各种细节)。</p><p>ClassVisitor 通过 visitXxx(…) 方法，由其它对象(可以是 ClassReader, 也可以直接是 Coder)逐渐对其开放一些 .class 的细节，<br>但需要 ClassVisitor 自行维护获得的内容(如果有必要的话)。由此得到对 .class 全部内容的了解(当然，如果本身 visitXxx() 得到的内容不全，则了解的自然有限)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文描述的 ASM 指的是 OW2 ASM&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;ASM-Core-的结构&quot;&gt;&lt;a href=&quot;#ASM-Core-的结构&quot; class=&quot;headerlink&quot; title=&quot;ASM-Core 的结构&quot;&gt;&lt;/a&gt;ASM-Core 的结构&lt;/h2&gt;&lt;p&gt;&lt;em&gt;首先是一些概述性的内容。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;由于 ASM 操作的 JAVA 字节码有严格的格式规定，且即使随着 JVM 标准的升级也极少出现重大调整。&lt;br&gt;因此适用面狭窄的访问者模式在该项目中被大量地使用，并且已经到了丧心病狂的程度:)&lt;/p&gt;
&lt;p&gt;从核心包声明的类来看，主要包括:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;ClassReader - 作为结构化对象，将接收(accept)访问者的访问&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;几种访问者抽象类以及相应的实现类&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;AnnotationVisitor -&amp;gt; AnnotationWriter&lt;/li&gt;
&lt;li&gt;ClassVisitor -&amp;gt; ClassWriter&lt;/li&gt;
&lt;li&gt;FieldVisitor -&amp;gt; FieldWriter&lt;/li&gt;
&lt;li&gt;MethodVisitor -&amp;gt; MethodWriter&lt;/li&gt;
&lt;li&gt;ModuleVisitor -&amp;gt; ModuleWriter&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;&lt;p&gt;Opcodes &amp;amp; Constants - ClassFile 中描述的大量常量符号与值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其它一些辅助的类&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Attribute - 用于处理非标准化的属性(ClassFile 允许&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JVMS&lt;/a&gt; 中未定义的 Attribute)&lt;/li&gt;
&lt;li&gt;ByteArray - 动态可自适应的 byte[] (字节数组)&lt;/li&gt;
&lt;li&gt;Context - ClassReader 在被解析(被访问)过程中用于表示“累积状态”的一个类/对象&lt;/li&gt;
&lt;li&gt;Symbol - 用于表示 ClassFile 中描述的 Constant 的基类&lt;/li&gt;
&lt;li&gt;SymbolTable - 用于存储常量池对象&lt;/li&gt;
&lt;li&gt;其它内容省略&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://DorMOUSE-None.github.io/tags/Java/"/>
    
      <category term="ASM" scheme="https://DorMOUSE-None.github.io/tags/ASM/"/>
    
      <category term="Visitor Pattern" scheme="https://DorMOUSE-None.github.io/tags/Visitor-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>java-memory-model</title>
    <link href="https://DorMOUSE-None.github.io/2018-06-21-java-memory-model/"/>
    <id>https://DorMOUSE-None.github.io/2018-06-21-java-memory-model/</id>
    <published>2018-06-20T16:00:00.000Z</published>
    <updated>2018-07-11T01:56:37.148Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM-运行时数据区"><a href="#JVM-运行时数据区" class="headerlink" title="JVM 运行时数据区"></a>JVM 运行时数据区</h2><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ft5osi6it1j31kw0ql78e.jpg" alt=""><br><a id="more"></a></p><h3 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h3><p>与操作系统中的PC寄存器功能基本一致。毕竟 JVM 建立的初衷就是模拟一台机器。<br>指向存储在<strong>方法区</strong>的字节码methods_info部分的内存地址。</p><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p><strong>虚拟机栈</strong>用于存储<strong>栈帧</strong></p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>用于支持 native 方法的执行</p><h3 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h3><p>存储在<strong>虚拟机栈</strong>中，主要包括<strong>局部变量表</strong>和<strong>操作数栈</strong>(又称<strong>当前栈帧的操作数栈</strong>)以及<strong>运行时常量池的引用</strong>。</p><p><em>仍然有必要区别两个概念: 操作数 &amp; 指令</em><br><em>指令指使操作数进行相关操作的基本命令</em><br><em>操作数通常指整数、浮点数以及类型引用等</em></p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p><strong>方法区</strong>是多个线程共享的一块区域，主要用于存储I/O操作中读入的类/接口的字节码(ClassFile 文件)<br>包括有 constant_pool, field_info, method_info, attribute_info 等</p><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>用于存储各种类的实例对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JVM-运行时数据区&quot;&gt;&lt;a href=&quot;#JVM-运行时数据区&quot; class=&quot;headerlink&quot; title=&quot;JVM 运行时数据区&quot;&gt;&lt;/a&gt;JVM 运行时数据区&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNc79gy1ft5osi6it1j31kw0ql78e.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://DorMOUSE-None.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://DorMOUSE-None.github.io/tags/JVM/"/>
    
      <category term="Memory Model" scheme="https://DorMOUSE-None.github.io/tags/Memory-Model/"/>
    
  </entry>
  
  <entry>
    <title>ASM - ClassReader 与 Java ClassFile 文件格式</title>
    <link href="https://DorMOUSE-None.github.io/2018-06-11-ASM-ClassReader/"/>
    <id>https://DorMOUSE-None.github.io/2018-06-11-ASM-ClassReader/</id>
    <published>2018-06-10T16:00:00.000Z</published>
    <updated>2018-06-22T08:26:20.743Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-ClassFile-文件格式"><a href="#Java-ClassFile-文件格式" class="headerlink" title="Java ClassFile 文件格式"></a>Java ClassFile 文件格式</h2><p>读了将近一周的时间，勉强算是把 ClassFile 的文件格式给简单的梳理了个脉络。<br><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" target="_blank" rel="noopener">The class File Format(Java SE 8)</a> </p><blockquote><p>u1, u2, u4 分别表示无符号的一字节、二字节、四字节数据(以大端存储)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic;                                   <span class="comment">// 魔数(magic) 固定为 0xCAFEBABE</span></span><br><span class="line">    u2             minor_version;                           <span class="comment">// 次版本号</span></span><br><span class="line">    u2             major_version;                           <span class="comment">// 主版本号</span></span><br><span class="line">    u2             constant_pool_count;                     <span class="comment">// 常量池 constant_pool 的数量 + 1, 最大为 (2&lt;&lt;16 - 1) = 65535</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count<span class="number">-1</span>];    <span class="comment">// 常量池 取值下标为 [1, constant_pool_count)</span></span><br><span class="line">    u2             access_flags;                            <span class="comment">// 对类 or 接口的访问权限和属性的标志的掩码</span></span><br><span class="line">    u2             this_class;                              <span class="comment">// 值为 constant_pool 的有效下标(且 constant_pool[this_class] 的类型为 CONSTANT_Class_info)</span></span><br><span class="line">    u2             super_class;                             <span class="comment">// 值为 0 或者 constant_pool 的有效下标(同上), 如果是 interface, 则该值一定为有效下标</span></span><br><span class="line">    u2             interfaces_count;                        <span class="comment">// 直接父接口的数量</span></span><br><span class="line">    u2             interfaces[interfaces_count];            <span class="comment">// 值必须是 constant_pool 的有效下标, 且 interfaces[i](0≤i&lt;interfaces_count), 指向的类型为 CONSTANT_Class_info)</span></span><br><span class="line">    u2             fields_count;                            <span class="comment">// 字段数量, 统计所有字段, 包括 class variables(静态变量) 和 instance variables(实例变量)</span></span><br><span class="line">    field_info     fields[fields_count];                    <span class="comment">// 字段的详细声明, 不包含继承来的字段</span></span><br><span class="line">    u2             methods_count;                           <span class="comment">// 方法数量</span></span><br><span class="line">    method_info    methods[methods_count];                  <span class="comment">// 方法的详细声明, 不包括继承来的方法</span></span><br><span class="line">    u2             attributes_count;                        <span class="comment">// 属性数量</span></span><br><span class="line">    attribute_info attributes[attributes_count];            <span class="comment">// 属性的详细声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>通过 <code>javac Xxx.java</code> 命令得到的 <code>Xxx.class</code> 文件严格按照定义的 ClassFile 文件格式以8比特的字节为单位进行存储。</p><p><strong>下面的例子都将通过 Trie.java (实际代码见本文最后) 以及其经编译后的文件 Trie.class 做基本的介绍。</strong></p><h3 id="magic-minor-verion-amp-major-version"><a href="#magic-minor-verion-amp-major-version" class="headerlink" title="magic, minor_verion &amp; major_version"></a>magic, minor_verion &amp; major_version</h3><p>通过命令 <code>xxd Trie.class</code> 查看 Trie.class 的十六进制编码，前16字节的内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000000: cafe babe 0000 0034 008f 0a00 2400 4b09  .......4....$.K.</span><br></pre></td></tr></table></figure></p><p>可以看到前4字节的内容 <code>0xcafebabe</code>，没有实际意义，但是作为其是能否被JVM(Java Virtual Machine, Java虚拟机)接收的Class文件的一个校验。</p><p>紧接着的4个字节包括<code>次版本号</code> 和 <code>主版本号</code>，暂时不做深入。</p><h3 id="常量池-constant-pool"><a href="#常量池-constant-pool" class="headerlink" title="常量池 constant_pool"></a>常量池 constant_pool</h3><p>从第10个字节开始(从第0字节开始计数)，连续的两个字节表示常量池中各种 CONSTANT 的总个数+1 (constant_pool_count)。constant_pool_count 只有2字节也就意味着: 常量池的最大常量数量为 (2&lt;&lt;16 - 1) = 65535 (当然，貌似在这个量级上，也从没见过有谁能够维护这样一个大JAVA类文件了)。</p><p>可以看到 constant_pool_count 的内容为 <code>0x008f = 143</code> ，即对于常量池的声明可以认为是 <code>cp_info constant_pool[142]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u1 info[]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用 JDK 自带的 <code>javap</code> 来查看 <code>Trie.class</code> 文件(<code>javap -v Trie.class</code>)，可以对 cp_info 的格式有一个粗浅但形象化的认识(结果见<strong>附录2</strong>)<br>其中第一列的内容 <code>#? = ?</code> <code>#?</code>表示id，<code>= ?</code>表示一个 cp_info 的实际类型，有 <code>cp_info.tag</code> 指定，具体映射表为</p><table><thead><tr><th>Constant Type</th><th>Value</th></tr></thead><tbody><tr><td><code>CONSTANT_Class</code></td><td>7</td></tr><tr><td><code>CONSTANT_Fieldref</code></td><td>9</td></tr><tr><td><code>CONSTANT_Methodref</code></td><td>10</td></tr><tr><td><code>CONSTANT_InterfaceMethodref</code></td><td>11</td></tr><tr><td><code>CONSTANT_String</code></td><td>8</td></tr><tr><td><code>CONSTANT_Integer</code></td><td>3</td></tr><tr><td><code>CONSTANT_Float</code></td><td>4</td></tr><tr><td><code>CONSTANT_Long</code></td><td>5</td></tr><tr><td><code>CONSTANT_Double</code></td><td>6</td></tr><tr><td><code>CONSTANT_NameAndType</code></td><td>12</td></tr><tr><td><code>CONSTANT_Utf8</code></td><td>1</td></tr><tr><td><code>CONSTANT_MethodHandle</code></td><td>15</td></tr><tr><td><code>CONSTANT_MethodType</code></td><td>16</td></tr><tr><td><code>CONSTANT_InvokeDynamic</code></td><td>18</td></tr><tr><td><code>CONSTANT_Module</code></td><td>19</td></tr><tr><td><code>CONSTANT_Package</code></td><td>20</td></tr></tbody></table><p>在 Java ClassFile 的格式定义中，同时定义了每种 <code>CONSTANT</code> 的长度与格式。<br>例如:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Class_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 name_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Fieldref_info &#123;</span><br><span class="line">     u1 tag;</span><br><span class="line">     u2 class_index;</span><br><span class="line">     u2 name_and_type_index;</span><br><span class="line">&#125;</span><br><span class="line">CONSTANT_Methodref_info &#123;</span><br><span class="line">  u1 tag;</span><br><span class="line">  u2 class_index;</span><br><span class="line">  u2 name_and_type_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多的 <code>CONSTANT_XXX</code> 的格式定义见 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4" target="_blank" rel="noopener">ClassFile CONSTANT_XXX 结构</a></p><p>简单解析一下 cp_info[1]。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000: cafe babe 0000 0034 008f 0a00 2400 4b09  .......4....$.K.</span><br><span class="line"></span><br><span class="line">#1 = Methodref          #36.#75       // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br></pre></td></tr></table></figure></p><p><code>cp_info[1].tag = 0x0a = 10</code>，即 cp_info[1] 的类型为 Methodref 。<br>之后就直接套用 <code>CONSTANT_Methodref_info</code> 的数据结构定义的格式<br><code>cp_info[1].class_index = 0x0024 = 36</code>，即 cp_info[1].class_index 表示的类名指向常量池第 36 个元素表示的类<br><code>cp_info[1].name_and_type_index = 0x004b = 75</code>。表示指向的是常量池第 75 个元素表示的 NameAndType 结构</p><p>对于这部分内容的理解，如果觉得有能够阅读英文文档，可以参考 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" target="_blank" rel="noopener">The Java® Virtual Machine Specification Chap 4.</a><br>否则，可以选择 <a href="http://icyfenix.iteye.com/blog/1256329" target="_blank" rel="noopener">Java 虚拟机规范(Java SE 7 版) 第四章</a><br>并尝试根据经编译后.class文件的二进制码进行人工解析，以加深对此的理解。</p><h3 id="more…"><a href="#more…" class="headerlink" title="more…"></a>more…</h3><p>更多内容于此基本类似，均属于已经被严格预定义的规范化格式，对此进行解析即可得到相应的内容。</p><h2 id="ASM-概览"><a href="#ASM-概览" class="headerlink" title="ASM 概览"></a>ASM 概览</h2><h3 id="包结构"><a href="#包结构" class="headerlink" title="包结构"></a>包结构</h3><p>asm, asm-analysis, asm-commons, asm-tree, asm-util, asm-xml 模块基于 Maven 的组织形式，并包含有单元测试的内容。</p><p>asm-test 实现了对上述模块的单元测试的整合。</p><p>benchmarks 定义了一些基本的 JMH 基准测试来衡量ASM的表现</p><p>gradle 包含了一些 Gradle 包装器，来辅助 Linux or Windows 脚本的调用请求</p><p>tools 包含两个 Gradle 项目来帮助 ASM 生成 Artifacts 。</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1frywra01upj308g0akmxr.jpg" alt="ASM Structure"></p><h3 id="代码组织形式"><a href="#代码组织形式" class="headerlink" title="代码组织形式"></a>代码组织形式</h3><p><img src="http://asm.ow2.io/asm-package-dependencies.svg" alt="Code Organization"></p><ul><li>org.objectweb.asm 作为核心包，定义了 ASM 访问者 API 以及两个核心类 ClassReader &amp; ClassWriter 来读写编译后的 Java 类。该包不依赖于其他包，且可单独使用</li><li>org.objectweb.asm.signature 提供了读写泛型签名的 API</li><li>org.objectweb.asm.tree 提供了类 DOM API 与类 SAX API。</li><li>org.objectweb.asm.tree.analysis 基于 .tree 提供了静态字节码分析框架</li><li>org.objectweb.asm.commons 提供了一些基于 core 和 tree 包的类适配器。</li><li>org.objectweb.asm.util 提供了一些用于 DEBUG 的访问者类与适配器类</li><li>org.objectweb.asm.xml 目前已经被 @Deprecated 。提供了类文件与 XML 互相转换的能力</li></ul><p>综上，asm 核心包是最为复杂的一个模块，而其它诸如 tree, util, xml 等都只是提供了将 JAVA 类从一种高级表示形态转换为另一种的能力。signature 也相当简单，提供了解析和打印简单语法的能力。</p><h3 id="主要数据结构"><a href="#主要数据结构" class="headerlink" title="主要数据结构"></a>主要数据结构</h3><p>核心包由 28 个类(接口) 组成。如果不考虑 Opcodes 接口, 5 个抽象访问者类(AnnotationVistitor, ClassVisitor, FieldVisitor, MethodVisitor and ModuleVisitor), 6 个工具类(ConstantDynamic, Contants, Handle, Type, TypePath and TypeReference), 剩下 16 个类的由下图提供一个粗略的展示。</p><p><img src="http://asm.ow2.io/asm-package-overview.svg" alt=""></p><p>编译类到访问事件的转换只由一个类 ClassReader 以及辅助类 Context 完成。其逆过程由以 ClassWriter 为核心的其它 14 个类完成。</p><h3 id="ClassReader"><a href="#ClassReader" class="headerlink" title="ClassReader"></a>ClassReader</h3><p>ClassReader 作为 ASM 核心包解析现有 .class 的唯一工具，组织形式相当简单。</p><ul><li>在构造函数中完成对常量池和引导方法的解析<ul><li>存储每个常量池项目的起始偏移量 cpInfoOffsets</li><li>存储每个引导方法的起始偏移量 bootstrapMethodOffsets</li><li>存储最长字符串常量的大小 maxStringLength</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">ClassReader(<span class="keyword">final</span> <span class="keyword">byte</span>[] classFileBuffer, <span class="keyword">final</span> <span class="keyword">int</span> classFileOffset, <span class="keyword">final</span> <span class="keyword">boolean</span> checkClassVersion) &#123;</span><br><span class="line">  <span class="keyword">this</span>.b = classFileBuffer;   <span class="comment">// .class 文件缓存</span></span><br><span class="line">  <span class="comment">// 检查主版本号, 第6,7个字节(从0字节开始计数)</span></span><br><span class="line">  <span class="keyword">if</span> (checkClassVersion &amp;&amp; readShort(classFileOffset + <span class="number">6</span>) &gt; Opcodes.V11) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">        <span class="string">"Unsupported class file major version "</span> + readShort(classFileOffset + <span class="number">6</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建常量池数组，常量池长度的定义 constant_pool_count 在第8,9字节</span></span><br><span class="line">  <span class="keyword">int</span> constantPoolCount = readUnsignedShort(classFileOffset + <span class="number">8</span>);     <span class="comment">// 读取无符号short, 即读取连续两字节作为一个short值</span></span><br><span class="line">  cpInfoOffsets = <span class="keyword">new</span> <span class="keyword">int</span>[constantPoolCount];                         <span class="comment">// 每个常量的偏移位置</span></span><br><span class="line">  cpInfoValues = <span class="keyword">new</span> Object[constantPoolCount];                       <span class="comment">// 每个常量的实例对象</span></span><br><span class="line">  <span class="keyword">int</span> currentCpInfoIndex = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> currentCpInfoOffset = classFileOffset + <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> currentMaxStringLength = <span class="number">0</span>;                                     <span class="comment">// 最长字符串常量</span></span><br><span class="line">  <span class="keyword">while</span> (currentCpInfoIndex &lt; constantPoolCount) &#123;</span><br><span class="line">    cpInfoOffsets[currentCpInfoIndex++] = currentCpInfoOffset + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cpInfoSize;</span><br><span class="line">    <span class="keyword">switch</span> (classFileBuffer[currentCpInfoOffset]) &#123;</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_FIELDREF_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_METHODREF_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_INTERFACE_METHODREF_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_INTEGER_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_FLOAT_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_NAME_AND_TYPE_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_DYNAMIC_TAG:</span><br><span class="line">        cpInfoSize = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_LONG_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_DOUBLE_TAG:</span><br><span class="line">        cpInfoSize = <span class="number">9</span>;</span><br><span class="line">        currentCpInfoIndex++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_UTF8_TAG:</span><br><span class="line">        cpInfoSize = <span class="number">3</span> + readUnsignedShort(currentCpInfoOffset + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (cpInfoSize &gt; currentMaxStringLength) &#123;</span><br><span class="line">          <span class="comment">// The size in bytes of this CONSTANT_Utf8 structure provides a conservative estimate</span></span><br><span class="line">          <span class="comment">// of the length in characters of the corresponding string, and is much cheaper to</span></span><br><span class="line">          <span class="comment">// compute than this exact length.</span></span><br><span class="line">          currentMaxStringLength = cpInfoSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_METHOD_HANDLE_TAG:</span><br><span class="line">        cpInfoSize = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_CLASS_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_STRING_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_METHOD_TYPE_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_PACKAGE_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_MODULE_TAG:</span><br><span class="line">        cpInfoSize = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    currentCpInfoOffset += cpInfoSize;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.maxStringLength = currentMaxStringLength;</span><br><span class="line">  <span class="comment">// The Classfile's access_flags field is just after the last constant pool entry.</span></span><br><span class="line">  <span class="keyword">this</span>.header = currentCpInfoOffset;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取 BootstrapMethods 属性(如果存在)</span></span><br><span class="line">  <span class="keyword">int</span> currentAttributeOffset = getFirstAttributeOffset();</span><br><span class="line">  <span class="keyword">int</span>[] currentBootstrapMethodOffsets = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = readUnsignedShort(currentAttributeOffset - <span class="number">2</span>); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="comment">// 读取每个 attribute_info 的属性名和属性长度</span></span><br><span class="line">    String attributeName = readUTF8(currentAttributeOffset, <span class="keyword">new</span> <span class="keyword">char</span>[maxStringLength]);</span><br><span class="line">    <span class="keyword">int</span> attributeLength = readInt(currentAttributeOffset + <span class="number">2</span>);</span><br><span class="line">    currentAttributeOffset += <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 如果当前属性名为 BootstrapMethods ，则进入处理逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (Constants.BOOTSTRAP_METHODS.equals(attributeName)) &#123;</span><br><span class="line">      <span class="comment">// Read the num_bootstrap_methods field and create an array of this size.</span></span><br><span class="line">      currentBootstrapMethodOffsets = <span class="keyword">new</span> <span class="keyword">int</span>[readUnsignedShort(currentAttributeOffset)];</span><br><span class="line">      <span class="comment">// Compute and store the offset of each 'bootstrap_methods' array field entry.</span></span><br><span class="line">      <span class="keyword">int</span> currentBootstrapMethodOffset = currentAttributeOffset + <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; currentBootstrapMethodOffsets.length; ++j) &#123;</span><br><span class="line">        currentBootstrapMethodOffsets[j] = currentBootstrapMethodOffset;</span><br><span class="line">        <span class="comment">// Skip the bootstrap_method_ref and num_bootstrap_arguments fields (2 bytes each),</span></span><br><span class="line">        <span class="comment">// as well as the bootstrap_arguments array field (of size num_bootstrap_arguments * 2).</span></span><br><span class="line">        currentBootstrapMethodOffset +=</span><br><span class="line">            <span class="number">4</span> + readUnsignedShort(currentBootstrapMethodOffset + <span class="number">2</span>) * <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    currentAttributeOffset += attributeLength;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.bootstrapMethodOffsets = currentBootstrapMethodOffsets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，ClassReader 已经解析了包括 magic, minor version, major version, constant pool 。<br>但是，诸如 field_info, method_info, attribute_info 等仍然没有得到处理。</p><p>这部分的内容在 accept(…) 和 readXXX(…) 中将得到解析。</p><p>主要流程类似:</p><ol><li>读取当前内容的偏移量(相较于整个 byte[])</li><li>解析当前的内容</li><li>调用 visitXXX 方法</li><li>在 visitXXX 方法中进行相关的处理</li><li>visitEnd</li></ol><h2 id="附录1-Trie-java"><a href="#附录1-Trie-java" class="headerlink" title="附录1 Trie.java"></a>附录1 Trie.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.fangfeng.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fangfeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/5/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_ITEM = <span class="number">700000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> AVG_LENGTH = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_NODE = MAX_ITEM * AVG_LENGTH;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> CHAR_NUM = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] nxt = <span class="keyword">new</span> <span class="keyword">int</span>[MAX_NODE][CHAR_NUM];</span><br><span class="line">    <span class="keyword">boolean</span>[] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[MAX_NODE];</span><br><span class="line">    <span class="keyword">int</span> trieIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">long</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmpIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;number != <span class="number">0</span>;number /= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nxt[tmpIndex][(<span class="keyword">int</span>) (number % <span class="number">10</span>)] == <span class="number">0</span>) &#123;</span><br><span class="line">                nxt[tmpIndex][(<span class="keyword">int</span>) (number % <span class="number">10</span>)] = ++trieIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            tmpIndex = nxt[tmpIndex][(<span class="keyword">int</span>) (number % <span class="number">10</span>)];</span><br><span class="line">        &#125;</span><br><span class="line">        flag[tmpIndex] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">query</span><span class="params">(<span class="keyword">long</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmpIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;number != <span class="number">0</span>;number /= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nxt[tmpIndex][(<span class="keyword">int</span>) (number % <span class="number">10</span>)] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tmpIndex = nxt[tmpIndex][(<span class="keyword">int</span>) (number % <span class="number">10</span>)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag[tmpIndex];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> <span class="keyword">throws</span> FileNotFoundException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        String ruleFilePath = args[<span class="number">0</span>];</span><br><span class="line">        String sendFilePath = args[<span class="number">1</span>];</span><br><span class="line">        String outFilePath = args[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        BufferedReader ruleReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(ruleFilePath)));</span><br><span class="line">        BufferedReader sendReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(sendFilePath)));</span><br><span class="line"></span><br><span class="line">        BufferedWriter outWriter = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(outFilePath)));</span><br><span class="line"></span><br><span class="line">        Trie trie = <span class="keyword">new</span> Trie();</span><br><span class="line">        String mobile;</span><br><span class="line">        <span class="keyword">while</span>((mobile = ruleReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            trie.insert(Long.parseLong(mobile));</span><br><span class="line">        &#125;</span><br><span class="line">        ruleReader.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>((mobile = sendReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(trie.query(Long.parseLong(mobile)) == <span class="keyword">false</span>) &#123;</span><br><span class="line">                outWriter.write(mobile);</span><br><span class="line">                outWriter.newLine();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sendReader.close();</span><br><span class="line"></span><br><span class="line">        outWriter.flush();</span><br><span class="line">        outWriter.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(String.format(<span class="string">"exec success! used %d ms"</span>, end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附录2-Constant-pool"><a href="#附录2-Constant-pool" class="headerlink" title="附录2 Constant pool"></a>附录2 Constant pool</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">    #1 = Methodref          #36.#75       // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">    #2 = Fieldref           #23.#76       // me/fangfeng/filter/Trie.MAX_NODE:I</span><br><span class="line">    #3 = Fieldref           #23.#77       // me/fangfeng/filter/Trie.CHAR_NUM:I</span><br><span class="line">    #4 = Class              #49           // &quot;[[I&quot;</span><br><span class="line">    #5 = Fieldref           #23.#78       // me/fangfeng/filter/Trie.nxt:[[I</span><br><span class="line">    #6 = Fieldref           #23.#79       // me/fangfeng/filter/Trie.flag:[Z</span><br><span class="line">    #7 = Fieldref           #23.#80       // me/fangfeng/filter/Trie.trieIndex:I</span><br><span class="line">    #8 = Long               10l</span><br><span class="line">   #10 = Methodref          #81.#82       // java/lang/System.currentTimeMillis:()J</span><br><span class="line">   #11 = Class              #83           // java/io/BufferedReader</span><br><span class="line">   #12 = Class              #84           // java/io/InputStreamReader</span><br><span class="line">   #13 = Class              #85           // java/io/FileInputStream</span><br><span class="line">   #14 = Methodref          #13.#86       // java/io/FileInputStream.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="line">   #15 = Methodref          #12.#87       // java/io/InputStreamReader.&quot;&lt;init&gt;&quot;:(Ljava/io/InputStream;)V</span><br><span class="line">   #16 = Methodref          #11.#88       // java/io/BufferedReader.&quot;&lt;init&gt;&quot;:(Ljava/io/Reader;)V</span><br><span class="line">   #17 = Class              #89           // java/io/BufferedWriter</span><br><span class="line">   #18 = Class              #90           // java/io/OutputStreamWriter</span><br><span class="line">   #19 = Class              #91           // java/io/FileOutputStream</span><br><span class="line">   #20 = Methodref          #19.#86       // java/io/FileOutputStream.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="line">   #21 = Methodref          #18.#92       // java/io/OutputStreamWriter.&quot;&lt;init&gt;&quot;:(Ljava/io/OutputStream;)V</span><br><span class="line">   #22 = Methodref          #17.#93       // java/io/BufferedWriter.&quot;&lt;init&gt;&quot;:(Ljava/io/Writer;)V</span><br><span class="line">   #23 = Class              #94           // me/fangfeng/filter/Trie</span><br><span class="line">   #24 = Methodref          #23.#75       // me/fangfeng/filter/Trie.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #25 = Methodref          #11.#95       // java/io/BufferedReader.readLine:()Ljava/lang/String;</span><br><span class="line">   #26 = Methodref          #96.#97       // java/lang/Long.parseLong:(Ljava/lang/String;)J</span><br><span class="line">   #27 = Methodref          #23.#98       // me/fangfeng/filter/Trie.insert:(J)V</span><br><span class="line">   #28 = Methodref          #11.#99       // java/io/BufferedReader.close:()V</span><br><span class="line">   #29 = Methodref          #23.#100      // me/fangfeng/filter/Trie.query:(J)Z</span><br><span class="line">   #30 = Methodref          #17.#101      // java/io/BufferedWriter.write:(Ljava/lang/String;)V</span><br><span class="line">   #31 = Methodref          #17.#102      // java/io/BufferedWriter.newLine:()V</span><br><span class="line">   #32 = Methodref          #17.#103      // java/io/BufferedWriter.flush:()V</span><br><span class="line">   #33 = Methodref          #17.#99       // java/io/BufferedWriter.close:()V</span><br><span class="line">   #34 = Fieldref           #81.#104      // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #35 = String             #105          // exec success! used %d ms</span><br><span class="line">   #36 = Class              #106          // java/lang/Object</span><br><span class="line">   #37 = Methodref          #96.#107      // java/lang/Long.valueOf:(J)Ljava/lang/Long;</span><br><span class="line">   #38 = Methodref          #108.#109     // java/lang/String.format:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;</span><br><span class="line">   #39 = Methodref          #110.#111     // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #40 = Integer            700000</span><br><span class="line">   #41 = Fieldref           #23.#112      // me/fangfeng/filter/Trie.MAX_ITEM:I</span><br><span class="line">   #42 = Fieldref           #23.#113      // me/fangfeng/filter/Trie.AVG_LENGTH:I</span><br><span class="line">   #43 = Utf8               MAX_ITEM</span><br><span class="line">   #44 = Utf8               I</span><br><span class="line">   #45 = Utf8               AVG_LENGTH</span><br><span class="line">   #46 = Utf8               MAX_NODE</span><br><span class="line">   #47 = Utf8               CHAR_NUM</span><br><span class="line">   #48 = Utf8               nxt</span><br><span class="line">   #49 = Utf8               [[I</span><br><span class="line">   #50 = Utf8               flag</span><br><span class="line">   #51 = Utf8               [Z</span><br><span class="line">   #52 = Utf8               trieIndex</span><br><span class="line">   #53 = Utf8               &lt;init&gt;</span><br><span class="line">   #54 = Utf8               ()V</span><br><span class="line">   #55 = Utf8               Code</span><br><span class="line">   #56 = Utf8               LineNumberTable</span><br><span class="line">   #57 = Utf8               insert</span><br><span class="line">   #58 = Utf8               (J)V</span><br><span class="line">   #59 = Utf8               StackMapTable</span><br><span class="line">   #60 = Utf8               query</span><br><span class="line">   #61 = Utf8               (J)Z</span><br><span class="line">   #62 = Utf8               main</span><br><span class="line">   #63 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">   #64 = Class              #114          // &quot;[Ljava/lang/String;&quot;</span><br><span class="line">   #65 = Class              #115          // java/lang/String</span><br><span class="line">   #66 = Class              #83           // java/io/BufferedReader</span><br><span class="line">   #67 = Class              #89           // java/io/BufferedWriter</span><br><span class="line">   #68 = Class              #94           // me/fangfeng/filter/Trie</span><br><span class="line">   #69 = Utf8               Exceptions</span><br><span class="line">   #70 = Class              #116          // java/io/FileNotFoundException</span><br><span class="line">   #71 = Class              #117          // java/io/IOException</span><br><span class="line">   #72 = Utf8               &lt;clinit&gt;</span><br><span class="line">   #73 = Utf8               SourceFile</span><br><span class="line">   #74 = Utf8               Trie.java</span><br><span class="line">   #75 = NameAndType        #53:#54       // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #76 = NameAndType        #46:#44       // MAX_NODE:I</span><br><span class="line">   #77 = NameAndType        #47:#44       // CHAR_NUM:I</span><br><span class="line">   #78 = NameAndType        #48:#49       // nxt:[[I</span><br><span class="line">   #79 = NameAndType        #50:#51       // flag:[Z</span><br><span class="line">   #80 = NameAndType        #52:#44       // trieIndex:I</span><br><span class="line">   #81 = Class              #118          // java/lang/System</span><br><span class="line">   #82 = NameAndType        #119:#120     // currentTimeMillis:()J</span><br><span class="line">   #83 = Utf8               java/io/BufferedReader</span><br><span class="line">   #84 = Utf8               java/io/InputStreamReader</span><br><span class="line">   #85 = Utf8               java/io/FileInputStream</span><br><span class="line">   #86 = NameAndType        #53:#121      // &quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="line">   #87 = NameAndType        #53:#122      // &quot;&lt;init&gt;&quot;:(Ljava/io/InputStream;)V</span><br><span class="line">   #88 = NameAndType        #53:#123      // &quot;&lt;init&gt;&quot;:(Ljava/io/Reader;)V</span><br><span class="line">   #89 = Utf8               java/io/BufferedWriter</span><br><span class="line">   #90 = Utf8               java/io/OutputStreamWriter</span><br><span class="line">   #91 = Utf8               java/io/FileOutputStream</span><br><span class="line">   #92 = NameAndType        #53:#124      // &quot;&lt;init&gt;&quot;:(Ljava/io/OutputStream;)V</span><br><span class="line">   #93 = NameAndType        #53:#125      // &quot;&lt;init&gt;&quot;:(Ljava/io/Writer;)V</span><br><span class="line">   #94 = Utf8               me/fangfeng/filter/Trie</span><br><span class="line">   #95 = NameAndType        #126:#127     // readLine:()Ljava/lang/String;</span><br><span class="line">   #96 = Class              #128          // java/lang/Long</span><br><span class="line">   #97 = NameAndType        #129:#130     // parseLong:(Ljava/lang/String;)J</span><br><span class="line">   #98 = NameAndType        #57:#58       // insert:(J)V</span><br><span class="line">   #99 = NameAndType        #131:#54      // close:()V</span><br><span class="line">  #100 = NameAndType        #60:#61       // query:(J)Z</span><br><span class="line">  #101 = NameAndType        #132:#121     // write:(Ljava/lang/String;)V</span><br><span class="line">  #102 = NameAndType        #133:#54      // newLine:()V</span><br><span class="line">  #103 = NameAndType        #134:#54      // flush:()V</span><br><span class="line">  #104 = NameAndType        #135:#136     // out:Ljava/io/PrintStream;</span><br><span class="line">  #105 = Utf8               exec success! used %d ms</span><br><span class="line">  #106 = Utf8               java/lang/Object</span><br><span class="line">  #107 = NameAndType        #137:#138     // valueOf:(J)Ljava/lang/Long;</span><br><span class="line">  #108 = Class              #115          // java/lang/String</span><br><span class="line">  #109 = NameAndType        #139:#140     // format:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;</span><br><span class="line">  #110 = Class              #141          // java/io/PrintStream</span><br><span class="line">  #111 = NameAndType        #142:#121     // println:(Ljava/lang/String;)V</span><br><span class="line">  #112 = NameAndType        #43:#44       // MAX_ITEM:I</span><br><span class="line">  #113 = NameAndType        #45:#44       // AVG_LENGTH:I</span><br><span class="line">  #114 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #115 = Utf8               java/lang/String</span><br><span class="line">  #116 = Utf8               java/io/FileNotFoundException</span><br><span class="line">  #117 = Utf8               java/io/IOException</span><br><span class="line">  #118 = Utf8               java/lang/System</span><br><span class="line">  #119 = Utf8               currentTimeMillis</span><br><span class="line">  #120 = Utf8               ()J</span><br><span class="line">  #121 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  #122 = Utf8               (Ljava/io/InputStream;)V</span><br><span class="line">  #123 = Utf8               (Ljava/io/Reader;)V</span><br><span class="line">  #124 = Utf8               (Ljava/io/OutputStream;)V</span><br><span class="line">  #125 = Utf8               (Ljava/io/Writer;)V</span><br><span class="line">  #126 = Utf8               readLine</span><br><span class="line">  #127 = Utf8               ()Ljava/lang/String;</span><br><span class="line">  #128 = Utf8               java/lang/Long</span><br><span class="line">  #129 = Utf8               parseLong</span><br><span class="line">  #130 = Utf8               (Ljava/lang/String;)J</span><br><span class="line">  #131 = Utf8               close</span><br><span class="line">  #132 = Utf8               write</span><br><span class="line">  #133 = Utf8               newLine</span><br><span class="line">  #134 = Utf8               flush</span><br><span class="line">  #135 = Utf8               out</span><br><span class="line">  #136 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #137 = Utf8               valueOf</span><br><span class="line">  #138 = Utf8               (J)Ljava/lang/Long;</span><br><span class="line">  #139 = Utf8               format</span><br><span class="line">  #140 = Utf8               (Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;</span><br><span class="line">  #141 = Utf8               java/io/PrintStream</span><br><span class="line">  #142 = Utf8               println</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1]: <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a> “Java Virtual Machine Specification”<br>[2]: <a href="http://icyfenix.iteye.com/blog/1256329" target="_blank" rel="noopener">http://icyfenix.iteye.com/blog/1256329</a> “Java虚拟机规范（Java SE 7 中文版）”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java-ClassFile-文件格式&quot;&gt;&lt;a href=&quot;#Java-ClassFile-文件格式&quot; class=&quot;headerlink&quot; title=&quot;Java ClassFile 文件格式&quot;&gt;&lt;/a&gt;Java ClassFile 文件格式&lt;/h2&gt;&lt;p&gt;读了将近一周的时间，勉强算是把 ClassFile 的文件格式给简单的梳理了个脉络。&lt;br&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/html/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The class File Format(Java SE 8)&lt;/a&gt; &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;u1, u2, u4 分别表示无符号的一字节、二字节、四字节数据(以大端存储)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ClassFile &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u4             magic;                                   &lt;span class=&quot;comment&quot;&gt;// 魔数(magic) 固定为 0xCAFEBABE&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u2             minor_version;                           &lt;span class=&quot;comment&quot;&gt;// 次版本号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u2             major_version;                           &lt;span class=&quot;comment&quot;&gt;// 主版本号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u2             constant_pool_count;                     &lt;span class=&quot;comment&quot;&gt;// 常量池 constant_pool 的数量 + 1, 最大为 (2&amp;lt;&amp;lt;16 - 1) = 65535&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cp_info        constant_pool[constant_pool_count&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;];    &lt;span class=&quot;comment&quot;&gt;// 常量池 取值下标为 [1, constant_pool_count)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u2             access_flags;                            &lt;span class=&quot;comment&quot;&gt;// 对类 or 接口的访问权限和属性的标志的掩码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u2             this_class;                              &lt;span class=&quot;comment&quot;&gt;// 值为 constant_pool 的有效下标(且 constant_pool[this_class] 的类型为 CONSTANT_Class_info)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u2             super_class;                             &lt;span class=&quot;comment&quot;&gt;// 值为 0 或者 constant_pool 的有效下标(同上), 如果是 interface, 则该值一定为有效下标&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u2             interfaces_count;                        &lt;span class=&quot;comment&quot;&gt;// 直接父接口的数量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u2             interfaces[interfaces_count];            &lt;span class=&quot;comment&quot;&gt;// 值必须是 constant_pool 的有效下标, 且 interfaces[i](0≤i&amp;lt;interfaces_count), 指向的类型为 CONSTANT_Class_info)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u2             fields_count;                            &lt;span class=&quot;comment&quot;&gt;// 字段数量, 统计所有字段, 包括 class variables(静态变量) 和 instance variables(实例变量)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    field_info     fields[fields_count];                    &lt;span class=&quot;comment&quot;&gt;// 字段的详细声明, 不包含继承来的字段&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u2             methods_count;                           &lt;span class=&quot;comment&quot;&gt;// 方法数量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    method_info    methods[methods_count];                  &lt;span class=&quot;comment&quot;&gt;// 方法的详细声明, 不包括继承来的方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u2             attributes_count;                        &lt;span class=&quot;comment&quot;&gt;// 属性数量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    attribute_info attributes[attributes_count];            &lt;span class=&quot;comment&quot;&gt;// 属性的详细声明&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>区块链技术概述</title>
    <link href="https://DorMOUSE-None.github.io/2018-03-01-%E5%8C%BA%E5%9D%97%E9%93%BE%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
    <id>https://DorMOUSE-None.github.io/2018-03-01-区块链简单介绍/</id>
    <published>2018-02-28T16:00:00.000Z</published>
    <updated>2018-06-14T01:24:24.421Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fs8oc4ri7qj30mq055aap.jpg" alt="区块链简单结构"></p><center><small>图1. 区块链简单结构</small></center><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1foxcpmmpfhj31kw107n2e.jpg" alt="Merkle tree"></p><center><small>图2. 单个区块的抽象结构</small></center><a id="more"></a><h2 id="基本工作流程"><a href="#基本工作流程" class="headerlink" title="基本工作流程"></a>基本工作流程</h2><h3 id="新交易发起流程"><a href="#新交易发起流程" class="headerlink" title="新交易发起流程"></a>新交易发起流程</h3><ol><li>用户通过公/私钥与区块链网络进行交互</li><li>处理用户交易的节点向网络邻节点广播用户交易</li><li>邻节点验证交易的有效性；可信，继续向其它邻节点广播；不可信，丢弃。</li></ol><h3 id="新区块产生流程"><a href="#新区块产生流程" class="headerlink" title="新区块产生流程"></a>新区块产生流程</h3><ol><li>矿工尝试将一个时间区间内的交易进行打包形成新区块（怎么打包，看下文）</li><li>生产出新区块的矿工节点向网络广播新区块</li><li>收到新区块的网络节点验证该区块的有效性</li></ol><p><a href="https://blockchain.info/zh-cn" target="_blank" rel="noopener">比特币区块浏览器</a>      更多<a href="https://en.wikipedia.org/wiki/Metric_prefix" target="_blank" rel="noopener">国际单位制前缀</a></p><h2 id="网络共识"><a href="#网络共识" class="headerlink" title="网络共识"></a>网络共识</h2><p>所有区块链网络节点需要对交易以及其在新区块里面的顺序达成一致（交易的有效性以及交易的打包顺序）。</p><p>可能出现：</p><ul><li>女巫攻击——单一实体以多重身份重复对新区块结果进行表决（少数人抓住了网络的投票权）</li><li><a href="https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">拜占庭将军问题</a>——分布式对等网络的通信容错问题<ul><li>不同的计算机通过通讯交换信息达成共识而按照同一套协作策略行动<ul><li>成员计算机可能出错而发送错误信息</li><li>网络的不可靠性</li><li>从而影响网络共识的达成，破坏一致性。</li></ul></li><li>不解决的话可能导致——区块链分叉</li></ul></li></ul><p>解决方案：</p><ul><li>工作量证明（proof-of-work, PoW），权益证明(proof-of-stake, PoS)，白名单机制（仅适用于私有网络）等</li><li>实用拜占庭容错算法</li></ul><h3 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h3><p>网络共识机制的实现导致了：</p><ol><li>交易吞吐量</li><li>更高的交易时延。交易确认时间（只有打包的新区块中才交易才会被承认）。</li></ol><p>共识机制的伸缩可以一定程度上解决上述问题</p><h2 id="资产交易"><a href="#资产交易" class="headerlink" title="资产交易"></a>资产交易</h2><p>简单交易状态描述，以集中式数据库为例</p><p>假设初始状态为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-------------------------</span><br><span class="line">| 资产类型 | 所有者 | 数量 |</span><br><span class="line">-------------------------</span><br><span class="line">|   CNY   |  防风  |  10 |</span><br><span class="line">-------------------------</span><br><span class="line">|   CNY   |  红薯  |  0  |</span><br><span class="line">-------------------------</span><br></pre></td></tr></table></figure><p>防风 向 红薯 转账 2 CNY </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-------------------------</span><br><span class="line">| 资产类型 | 所有者 | 数量 |</span><br><span class="line">-------------------------</span><br><span class="line">|   CNY   |  防风  |  8  |</span><br><span class="line">-------------------------</span><br><span class="line">|   CNY   |  红薯  |  2  |</span><br><span class="line">-------------------------</span><br></pre></td></tr></table></figure><p>数据库中相应记录的更改完成了资产的交易过程。</p><p>在区块链中，仍然将分布式链看作是一个达成共识的集中式数据库</p><p>那么现在的初始状态可以表示成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---------------------------------</span><br><span class="line">| 资产类型 |     所有者     | 数量 |</span><br><span class="line">---------------------------------</span><br><span class="line">|   IOTA  |  防风 pub_key  | 10  |</span><br><span class="line">---------------------------------</span><br></pre></td></tr></table></figure><p>现在的所有者由公钥表示，想要修改记录必须提供对应的密钥。</p><p>例如，防风 向 红薯 转账 2 IOTA ，需要提供防风的私钥和红薯的公钥。交易记录修改结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---------------------------------</span><br><span class="line">| 资产类型 |     所有者     | 数量 |</span><br><span class="line">---------------------------------</span><br><span class="line">                                 被删除了         |   IOTA  |  防风 pub_key  | 10  |</span><br><span class="line">---------------------------------</span><br><span class="line">|   IOTA  |  红薯 pub_key  |  2  |</span><br><span class="line">---------------------------------</span><br><span class="line">|   IOTA  |  防风 pub_key  |  8  |</span><br></pre></td></tr></table></figure><p>交易的概念流程：</p><ol><li>定位防风所有的资产记录行</li><li>删除该行前验证密钥</li><li>确认该记录没有被别的交易使用（双花问题，双重交易）</li><li>写入新的正确的记录（红薯获得的资产 &amp; 防风剩余的资产），确保交易前与交易后资产总额不变</li></ol><p>上面的模型 —— 基于比特币的交易模型(UTXO <em>model</em>)</p><p><strong>适合于数字标记资产的传输与追踪</strong></p><ul><li>概念：UTXO (unspent transaction outputs) 未花费的交易输出：数据库现有的记录</li></ul><p>-——————————–</p><p>另一种模型常用于智能合约 —— 基于账号的模型(account-based <em>model</em>)</p><p><strong>提供了建立多步骤执行的基本机制</strong> </p><h3 id="资产如何产生"><a href="#资产如何产生" class="headerlink" title="资产如何产生"></a>资产如何产生</h3><ul><li>比特币：<ul><li>矿工节点允许在挖出的新节点中加入一种 coinbase 类型的交易（不存在交易输入，新资产数额有比特币链提前定义）</li></ul></li><li>在创始新代币的时候全额发行</li><li>其它机制</li></ul><h2 id="区块链特性"><a href="#区块链特性" class="headerlink" title="区块链特性"></a>区块链特性</h2><ol><li>一种健壮的、真正的分布式对等系统，它能容忍节点故障。</li><li>能够识别冲突和分叉并自动解决的网络，以便收敛到单一的、公认的唯一状态。（区块链永远选择最长的分支来达成网络上的共识）</li><li>网络活动的透明性、可验证性、可审计性。我们能获取可验证的过程，无论它们是否交换和跟踪数字资产，还是数据驱动的交互。每一个行为，都存有公开的与网络交互的记录，并以此来消除人为的矛盾。</li><li>这是一种可以标记不同信息的触发者的方法，并且能够在没有中央权威的情况下强制执行。</li><li>这是一个使得不信任双方根据可预测的、确定性的方式交互的系统。</li></ol><h2 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h2><p>自动化地执行一系列合约条款的交易协议</p><p>智能合约是存储在区块链中的脚本（认识上可以与关系型数据库的存储过程类似）。</p><p>以基于账号的模型为例对合约执行进行描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">假设定义一个合约，包括三个方法</span><br><span class="line"></span><br><span class="line">(1) “存储”——合约的“存款”功能允许 防风（通过防风的密钥验证）将若干单位的X存入合约中；</span><br><span class="line">(2) “交易”——“交易”功能允许任何人向合约发送5单位Y，并从合约持有的X中返回1单位给交易方；</span><br><span class="line">(3) “撤销”——“撤销”功能允许 防风 取出合约中存有的所有资产。</span><br><span class="line"></span><br><span class="line">请注意，上述“存款”和“撤销”功能被限制为只允许被 防风（实际上是防风的私钥）调用。当然，这只有由于上述合约由防风制定。若人为的制定一个所有人都能调用任何功能的合约也是允许的（虽然这在事实上没有意义）。</span><br></pre></td></tr></table></figure><p>那么在基于账户的模型下，可以认为 拥有“存储”、“交易”、“撤销”方法的合约持有一个单独的账户（与用户所持有的账户等价）。</p><p>在上述合约下，这个账户将可能持有一定数量的资产。除了只能按照预定的合约步骤对资产进行处置之外，其它与用户持有的账户别无二致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __</span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _</span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tKfTcgy1fs8oc4ri7qj30mq055aap.jpg&quot; alt=&quot;区块链简单结构&quot;&gt;&lt;/p&gt;
&lt;center&gt;&lt;small&gt;图1. 区块链简单结构&lt;/small&gt;&lt;/center&gt;



&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tNc79gy1foxcpmmpfhj31kw107n2e.jpg&quot; alt=&quot;Merkle tree&quot;&gt;&lt;/p&gt;
&lt;center&gt;&lt;small&gt;图2. 单个区块的抽象结构&lt;/small&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="BlockChain" scheme="https://DorMOUSE-None.github.io/tags/BlockChain/"/>
    
      <category term="Smart Contract" scheme="https://DorMOUSE-None.github.io/tags/Smart-Contract/"/>
    
  </entry>
  
  <entry>
    <title>Spring JDBC 源码学习</title>
    <link href="https://DorMOUSE-None.github.io/2018-01-15-Spring-JDBC-Code-Reading/"/>
    <id>https://DorMOUSE-None.github.io/2018-01-15-Spring-JDBC-Code-Reading/</id>
    <published>2018-01-14T16:00:00.000Z</published>
    <updated>2018-06-14T01:24:16.070Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>在学习 Spring-JDBC 之前，我们有必要从 Java 原生提供的 JDBC 开始，对 JDBC 操作的一整套完整的流程有一个清晰的概念。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * copied from https://www.tutorialspoint.com/jdbc/jdbc-sample-code.htm</span></span><br><span class="line"><span class="comment"> * updated by DorMOUSENone</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//STEP 1. 引入必须的包</span></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line"><span class="comment">// JDBC 驱动名 与 DB URL </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String JDBC_DRIVER = <span class="string">"com.mysql.jdbc.Driver"</span>;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DB_URL = <span class="string">"jdbc:mysql://&lt;host&gt;:&lt;port&gt;/&lt;dbName&gt;"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数据库登录验证 (用户名、密码等)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String USER = <span class="string">"username"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String PASS = <span class="string">"password"</span>;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">Statement stmt = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//STEP 2: 注册驱动(注册到驱动管理器 DriverManager 类中)</span></span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//STEP 3: 创建一个连接</span></span><br><span class="line">          System.out.println(<span class="string">"Connecting to database..."</span>);</span><br><span class="line">          conn = DriverManager.getConnection(DB_URL,USER,PASS);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//STEP 4: 执行一个查询</span></span><br><span class="line">          System.out.println(<span class="string">"Creating statement..."</span>);</span><br><span class="line">          stmt = conn.createStatement();</span><br><span class="line">          String sql;</span><br><span class="line">          sql = <span class="string">"SELECT id, first, last, age FROM Employees"</span>;</span><br><span class="line">          ResultSet rs = stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//STEP 5: 将结果从结果集(ResultSet)中取出</span></span><br><span class="line">          <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">             <span class="comment">//根据列名逐一取出数据</span></span><br><span class="line">             <span class="keyword">int</span> id  = rs.getInt(<span class="string">"id"</span>);</span><br><span class="line">             <span class="keyword">int</span> age = rs.getInt(<span class="string">"age"</span>);</span><br><span class="line">             String first = rs.getString(<span class="string">"first"</span>);</span><br><span class="line">             String last = rs.getString(<span class="string">"last"</span>);</span><br><span class="line"></span><br><span class="line">             <span class="comment">//展示结果</span></span><br><span class="line">             System.out.print(<span class="string">"ID: "</span> + id);</span><br><span class="line">             System.out.print(<span class="string">", Age: "</span> + age);</span><br><span class="line">             System.out.print(<span class="string">", First: "</span> + first);</span><br><span class="line">             System.out.println(<span class="string">", Last: "</span> + last);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//STEP 6: 清理环境</span></span><br><span class="line">          rs.close();</span><br><span class="line">          stmt.close();</span><br><span class="line">          conn.close();</span><br><span class="line">       &#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">          <span class="comment">//处理 JDBC 错误</span></span><br><span class="line">          se.printStackTrace();</span><br><span class="line">       &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">          <span class="comment">//处理 Class.forName() 引起的错误</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">       &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">          <span class="comment">// finally 代码库来关闭资源</span></span><br><span class="line">          <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(stmt!=<span class="keyword">null</span>)</span><br><span class="line">                stmt.close();</span><br><span class="line">          &#125;<span class="keyword">catch</span>(SQLException se2)&#123;</span><br><span class="line">          &#125;<span class="comment">// 不做任何处理</span></span><br><span class="line">          <span class="keyword">try</span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(conn!=<span class="keyword">null</span>)</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">               se.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">"Goodbye!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的通用 JDBC 代码可以看到，利用 Java 原生提供的 java.sql.* 包可以完成注册驱动，创建连接，执行查询，处理结果等一系列一整套操作。</p><p>而 Spring-JDBC 对于 Java 原生提供的 JDBC ，对一系列数据及操作进行了整合：</p><ol><li>实现了 DataSource 接口，用于整合数据源配置，将各种零散的属性值（诸如 URL、用户名、 密码等）整合成完整的一个对象，便于重用；也实现了 getConnection(…) 接口，便于直接通过 DataSource 获取连接。</li><li>对执行查询的流程进行了封装。</li><li>对结果集的处理提供了多种接口，针对不同的应用场景可自由选择所必须的实现类。例如直接通过 JDBC 获得 Bean ，而无需如上例 39-42 行所示，逐一编码进行提取。</li></ol><p>本节提供对《Spring-JDBC 源码学习》完整学习过程的一个梳理：</p><ol><li><a href="http://blog.csdn.net/dormousenone/article/details/79035440" target="_blank" rel="noopener">JdbcTemplate</a> 一节作为学习 Spring-jdbc 的切入点，是 org.springframework.jdbc.core 包中的核心类，是一个提供不同场景下数据库操作的模板类。主要描述其持有的属性 DataSource 等以及其实现的方法。</li><li><a href="http://blog.csdn.net/dormousenone/article/details/79037012" target="_blank" rel="noopener">DataSource</a> 一节承接 JdbcTemplate 一节，提供 Spring-jdbc 对数据源的一个包装与应用。同时描述其核心方法 getConnection(…) 的实现。</li><li><a href="http://blog.csdn.net/dormousenone/article/details/79042212" target="_blank" rel="noopener">DriverManager</a> 描述其对不同数据库供应商提供的驱动的管理与使用方法。同时简单描述通过具体驱动获得一个连接的实现。</li><li><a href="http://blog.csdn.net/dormousenone/article/details/79046865" target="_blank" rel="noopener">PreparedStatement &amp; CallableStatement</a> 一节主要表述 Spring-jdbc 如何对执行查询的流程进行了封装。特别是对于 PreparedStatement 与 CallableStatement 这类预置可变 SQL 语句，在执行前必须对其中可变参数进行补全的 Statement 。</li><li><a href="http://blog.csdn.net/dormousenone/article/details/79062275" target="_blank" rel="noopener">ResultSet</a> 描述 Spring-jdbc 如何对结果集进行处理，提供了多种不同的接口实现不同的处理逻辑。这种封装后的操作可以极大地简化直接使用 Java 原生 JDBC 所必须的硬编码提取数据的问题。</li></ol><h2 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h2><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fn90ghu9ufj30ki0jm75t.jpg" alt=""></p><p>JdbcTemplate 类作为 org.springframework.core 包下的核心类，对 Java 实现的 JDBC 进行了一定程度的封装，可以简化 JDBC 的使用，同时避免许多常见的错误。由该类来执行 JDBC 工作流，应用程序只需要提供 SQL 语句就可以获得 DB 执行结果（😀，当然实际操作上没有描述的这么简单）。</p><p><strong>使用 JdbcTemplate 类只需要实现两个回调接口 PreparedStatementCreator (创建一个 PreparedStatement，给定连接，提供 SQL 语句以及必要的参数), ResultSetExtractor (用于花式获取结果集)。当然，不实现上述两个接口也可以进行简单的数据库操作，比如只通过 JdbcTemplate 获取一个连接(Connection) 或者执行一个静态 SQL Update。</strong></p><p><em>看不懂无所谓，先继续向下看，会做更详细的讲解。</em></p><h3 id="JdbcAccessor"><a href="#JdbcAccessor" class="headerlink" title="JdbcAccessor"></a>JdbcAccessor</h3><p>首先了解 JdbcTemplate 的实现，JdbcTemplate 继承了 JdbcAccessor 抽象类，该抽象类有两个主要属性—— <strong>DataSource dataSource</strong> &amp; <strong>SQLExceptionTranslator exceptionTranslator</strong> ，以及一个懒加载标识符 <strong>lazyInit</strong> 。</p><p>其中，</p><ul><li>DataSource 可以认为是一个存储有与数据库相关的属性实例，主要方法包括 <code>Connection getConnection()</code> &amp; <code>Connection getConnection(String username, String password)</code> 。</li><li>SQLExceptionTranslator 利用策略模式将 Java 定义的 SQLException 转换成 Spring 声明的 DataAccessException。</li></ul><p>JdbcAccessor 实现的 InitializingBean 接口，InitializingBean 接口为 Bean 提供了一个初始化实例的方法 —— afterPropertiesSet() 方法，凡是继承该接口的类，一般都在类构造方法中执行该方法。同样的，声明初始化实例调用的方法还可采用 <code>&lt;bean id=&quot;&quot; class=&quot;&quot; init-method=&quot;myInitMethod&quot;/&gt;</code> 在初始化 bean 时执行 myInitMethod() 方法。具体执行顺序为 ：</p><ol><li>bean 的属性注入</li><li>调用 afterPropertiesSet() 方法</li><li>执行 myInitMethod() 方法</li></ol><p>此处继承该接口是为了实现 DataSource 验证以及 SQLExceptionTranslator 的懒加载 OR NOT 的选择。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (getDataSource() == <span class="keyword">null</span>) &#123;<span class="comment">// 判断是否注入了 DataSource</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Property 'dataSource' is required"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!isLazyInit()) &#123;<span class="comment">// 根据懒加载标识符选择执行与否</span></span><br><span class="line">getExceptionTranslator();<span class="comment">// 获取一个 SQLExceptionTranslator 实例</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法在 BeanFactory 完成该 bean 的依赖注入后执行，将首先判断 DataSource 是否已经被注入，再根据懒加载标识符来决定是否实例化一个 SQLExceptionTranslator 。</p><h3 id="JdbcOperations"><a href="#JdbcOperations" class="headerlink" title="JdbcOperations"></a>JdbcOperations</h3><p>同时，JdbcTemplate 类实现了 JdbcOperations 接口，该接口定义了基本的 JDBC 操作。基本方法如下：</p><ol><li><code>&lt;T&gt; T execute(ConnectionCallback&lt;T&gt; action);</code></li><li><code>&lt;T&gt; T execute(StatementCallback&lt;T&gt; action);</code></li><li><code>&lt;T&gt; T execute(PreparedStatementCreator psc, PreparedStatementCallback&lt;T&gt; action);</code></li><li><code>&lt;T&gt; T execute(CallableStatementCreator csc, CallableStatementCallback&lt;T&gt; action);</code></li></ol><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fncp2ncqd6j31j00au0uv.jpg" alt=""></p><p>其它的 execute(…) , query(…), update(…) 等最终都将调用上述 4 种方法其一来完成目的。</p><p>详细观察上述方法的入参， ConnectionCallback, StatementCallback, PreparedStatementCallback 和 CallableStatementCallback 四个 Callback 接口，分别都是函数式接口，其中的唯一方法 doInXXX() 将在 execute() 中被调用，以此实现获得 ResultSet 并返回 Result 。execute 中调用 doInXXX() 的通用代码如下 （以 Statement 为例）：</p><p><em>对于不理解<strong>回调</strong>的同学，请自行了解概念</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(StatementCallback&lt;T&gt; action)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line"><span class="comment">// 通过工具类 DataSourceUtils 获取一个连接</span></span><br><span class="line">  Connection con = DataSourceUtils.getConnection(obtainDataSource());</span><br><span class="line">  <span class="comment">// 一个 Statement 空实例，PreparedStatement, CallableStatement 类似</span></span><br><span class="line">Statement stmt = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">stmt = con.createStatement();<span class="comment">// 通过连接(Connection)获取一个 Statement</span></span><br><span class="line">applyStatementSettings(stmt);<span class="comment">// 配置 Statement 参数</span></span><br><span class="line">      <span class="comment">// 回调执行 doInXXX() 方法, 并获得 result</span></span><br><span class="line">T result = action.doInStatement(stmt);</span><br><span class="line">handleWarnings(stmt);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line"><span class="comment">// Release Connection early, to avoid potential connection pool deadlock</span></span><br><span class="line"><span class="comment">// in the case when the exception translator hasn't been initialized yet.</span></span><br><span class="line">String sql = getSql(action);</span><br><span class="line">JdbcUtils.closeStatement(stmt);</span><br><span class="line">stmt = <span class="keyword">null</span>;</span><br><span class="line">DataSourceUtils.releaseConnection(con, getDataSource());</span><br><span class="line">con = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">throw</span> translateException(<span class="string">"StatementCallback"</span>, sql, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">JdbcUtils.closeStatement(stmt);</span><br><span class="line">DataSourceUtils.releaseConnection(con, getDataSource());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 Statement, PreparedStatement, CallableStatement 的区别，首先下图表现了三个接口的继承关系。</p><ul><li>Statement 可以支持静态 SQL 语句</li><li>PreparedStatement 支持可变参数的 SQL 语句</li><li>CallableStatement 支持可变参数的 SQL 语句，并且支持定制 DB 的输出结果</li></ul><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fncpaec17yj30ew0hcdh7.jpg" alt=""></p><h2 id="DataSource"><a href="#DataSource" class="headerlink" title="DataSource"></a>DataSource</h2><p>上一节在粗略地了解了 JdbcTemplate 提供的方法之后，下面先来对 DataSource 做一点了解。</p><h3 id="Java-提供的-DataSource-定义"><a href="#Java-提供的-DataSource-定义" class="headerlink" title="Java 提供的 DataSource 定义"></a>Java 提供的 DataSource 定义</h3><p>DataSource 是 Java 核心库提供的接口。位于 javax.sql package 下。</p><p>DataSource 接口可以被视作是一个提供物理 DB 实例连接(Connection) 的工厂，通过 DataSource 持有的各种属性（包括 DB Url, Username, Password 等）来获取一个连接(Connection) 。DataSource 接口有三种不同的实现方案：</p><ol><li>最基本的实现——生产一个标准连接(Connection) 对象</li><li>连接池方案——生产会被自动添加到连接池的对象</li><li>分布式事物实现——生产一个可以支持分布式事物，并默认被添加到连接池的连接对象</li></ol><p>包括两个对外提供连接(Connection) 对象的方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="function">Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure><p>其父接口 CommonDataSource 提供设置/获取 LogWriter，登录 DB 超时时间和获取父 Logger 的方法。</p><h3 id="Spring-JDBC-扩展的-DataSource-定义"><a href="#Spring-JDBC-扩展的-DataSource-定义" class="headerlink" title="Spring-JDBC 扩展的 DataSource 定义"></a>Spring-JDBC 扩展的 DataSource 定义</h3><p>在 Spring-jdbc 下，DataSources 最顶级的类是 AbstractDataSource ，对 DataSource 的所有父接口方法做了实现。但保留 getConnection() 方法由子类实现。</p><p>在 AbstractDriverBasedDataSource 中，定义了大量的参数，诸如 url, username 等，这些都被用来定位并定义与数据库实例的连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDriverBasedDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> String catalog;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> String schema;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="comment">// 可以看到此处有一个 Properties 类</span></span><br><span class="line">   <span class="keyword">private</span> Properties connectionProperties;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 省略若干方法</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">      <span class="comment">// 调用内部方法 getConnectionFromDriver()</span></span><br><span class="line"><span class="keyword">return</span> getConnectionFromDriver(getUsername(), getPassword());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">      <span class="comment">// 调用内部方法 getConnectionFromDriver()</span></span><br><span class="line"><span class="keyword">return</span> getConnectionFromDriver(username, password);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 定义了一个获取 Connection 的方法，由 getConnection() 方法调用，</span></span><br><span class="line">   <span class="comment">// 此方法主要是将属性做了一个整合</span></span><br><span class="line">   <span class="comment">// 具体获取 Connection 的逻辑仍然下放到子类实现 见 40 行</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> Connection <span class="title">getConnectionFromDriver</span><span class="params">(@Nullable String username, @Nullable String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">Properties mergedProps = <span class="keyword">new</span> Properties();</span><br><span class="line">Properties connProps = getConnectionProperties();</span><br><span class="line"><span class="keyword">if</span> (connProps != <span class="keyword">null</span>) &#123;</span><br><span class="line">mergedProps.putAll(connProps);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (username != <span class="keyword">null</span>) &#123;</span><br><span class="line">mergedProps.setProperty(<span class="string">"user"</span>, username);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (password != <span class="keyword">null</span>) &#123;</span><br><span class="line">mergedProps.setProperty(<span class="string">"password"</span>, password);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 获取 Connection 逻辑下放</span></span><br><span class="line">Connection con = getConnectionFromDriver(mergedProps);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.catalog != <span class="keyword">null</span>) &#123;</span><br><span class="line">con.setCatalog(<span class="keyword">this</span>.catalog);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.schema != <span class="keyword">null</span>) &#123;</span><br><span class="line">con.setSchema(<span class="keyword">this</span>.schema);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> con;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 该类中获取 Connection 的方法是抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Connection <span class="title">getConnectionFromDriver</span><span class="params">(Properties props)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整合方案为将除 url 外的所有参数整合在同一个 Properties 对象中 (其中，Properties 可以被认为是一个线程安全的 Hash Map) 。最终调用 <code>Connection getConnectionFromDriver(Properties props)</code> 获取连接。</p><p>AbstractDriverBasedDataSource 抽象类的两个子类 DriverManagerDataSource 和 SimpleDriverDataSource 都以不同方式获得了连接(Connection)，但总结而言，获取连接(Connection) 的任务被委托给了 Driver 来实现（其中，Driver 有 Java 定义接口，并由各数据库提供商提供，例如 MySQL 提供了 mysql-connector-java-XXX.jar 来完成针对相应数据库的具体实现）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ----------------------------</span></span><br><span class="line"><span class="comment">// SimpleDriverDataSource 的实现</span></span><br><span class="line"><span class="comment">// ----------------------------</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Connection <span class="title">getConnectionFromDriver</span><span class="params">(Properties props)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">Driver driver = getDriver();</span><br><span class="line">String url = getUrl();</span><br><span class="line">Assert.notNull(driver, <span class="string">"Driver must not be null"</span>);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Creating new JDBC Driver Connection to ["</span> + url + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 哈哈，重点在这... driver 在该类中被预先注入</span></span><br><span class="line"><span class="keyword">return</span> driver.connect(url, props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------</span></span><br><span class="line"><span class="comment">// DriverManagerDataSource 的实现</span></span><br><span class="line"><span class="comment">// -----------------------------</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Connection <span class="title">getConnectionFromDriver</span><span class="params">(Properties props)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">String url = getUrl();</span><br><span class="line">Assert.state(url != <span class="keyword">null</span>, <span class="string">"'url' not set"</span>);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Creating new JDBC DriverManager Connection to ["</span> + url + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 调了个内部函数</span></span><br><span class="line"><span class="keyword">return</span> getConnectionFromDriverManager(url, props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Connection <span class="title">getConnectionFromDriverManager</span><span class="params">(String url, Properties props)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// 委托给 DriverManager 类来获取连接</span></span><br><span class="line">    <span class="comment">// DriverManager 的主要操作是遍历在该管理类中注册的 Driver</span></span><br><span class="line">    <span class="comment">// 每个 Driver 实例都去尝试一下，能不能获得一个连接</span></span><br><span class="line">    <span class="comment">// 第一次在某个 Driver 中拿到一个连接即返回连接 (Connection)</span></span><br><span class="line"><span class="keyword">return</span> DriverManager.getConnection(url, props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简要的类图如下：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fncrgqcjqoj31es15ajxj.jpg" alt=""></p><h2 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h2><p>上面提到 DataSource 获取连接(Connection) 的操作实质上将委托具体的 Driver 来提供 Connection 。有两种不同的方式，包括经由 DriverManager 遍历所有处于管理下的 Driver 尝试获取连接，或者在 DataSource 实例中直接声明一个特定的 Driver 来获取连接。</p><p>对于获取连接的具体操作，挖坑-待填。只描述简单的数据库供应商提供的 Driver 如何与 java 相联系。</p><p>###在 DriverManager 中注册 Driver 实例</p><p>通常在与数据库交互逻辑的 Java 代码中，都会有 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code> (此处以 MySQL 提供的 mysql-connector-java-XXX.jar 为例，下同）的代码块，加载指定的 com.mysql.jdbc.Driver 为 java.lang.Class 类。</p><p><em>当然，在 JDBC 4.0 标准下，可以不必再显示声明 <code>Class.forName(&quot;&quot;)</code> 语句，Driver 也同样会在 DriverManager 初始化时自动注册。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Class 类中对于 forName(String className) 的方法</span></span><br><span class="line"><span class="comment">// 作用为返回一个 java.lang.Class 实例。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;...&#125;</span><br></pre></td></tr></table></figure><p>同时， JVM 在加载类的过程中会执行类中的 static 代码块。下述 row 10 ~ 16 的代码片段将被执行。唯一的逻辑就是 new 一个 com.mysql.jdbc.Driver 实例，并将实例注册(registerDriver) 到 <strong>java.sql.DriverManager</strong> 中。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mysql.jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">extends</span> <span class="title">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">sql</span>.<span class="title">Driver</span> </span>&#123;</span><br><span class="line"><span class="comment">// ~ Static fields/initializers</span></span><br><span class="line"><span class="comment">// ---------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Register ourselves with the DriverManager</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't register driver!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ~ Constructors</span></span><br><span class="line"><span class="comment">// -----------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Construct a new driver and register it with DriverManager</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment"> *             if a database error occurs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="comment">// Required for Class.forName().newInstance()</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面再来看一下 DriverManager 中的 registerDriver() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DriverManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// DriverManager 维护一个线程安全的 Driver 列表</span></span><br><span class="line">  <span class="comment">// 此处的 DriverInfo 里面即包装了 Driver </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = </span><br><span class="line">      <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在 DriverManager 中注册 Driver</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">registerDriver</span><span class="params">(java.sql.Driver driver)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        registerDriver(driver, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">registerDriver</span><span class="params">(java.sql.Driver driver,</span></span></span><br><span class="line"><span class="function"><span class="params">            DriverAction da)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 如果当前 Driver 不在列表中，即添加到列表。 */</span></span><br><span class="line">        <span class="keyword">if</span>(driver != <span class="keyword">null</span>) &#123;</span><br><span class="line">            registeredDrivers.addIfAbsent(<span class="keyword">new</span> DriverInfo(driver, da));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// This is for compatibility with the original DriverManager</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"registerDriver: "</span> + driver);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过-DriverManager-获取连接-Connection"><a href="#通过-DriverManager-获取连接-Connection" class="headerlink" title="通过 DriverManager 获取连接(Connection)"></a>通过 DriverManager 获取连接(Connection)</h3><p>上一节有提到过可以通过 DriverManager 来遍历获取连接，也可以直接声明具体 Driver 并获取连接。下面代码展示的是通过 DriverManager 获取连接的操作。 <del>哈哈哈，反正最后都是由具体驱动实现获取连接。</del></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DriverManager</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取连接的 public 接口 (1)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(String url,</span></span></span><br><span class="line"><span class="function"><span class="params">java.util.Properties info)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取连接的 public 接口 (2)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(String url,</span></span></span><br><span class="line"><span class="function"><span class="params">        String user, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        java.util.Properties info = <span class="keyword">new</span> java.util.Properties();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">            info.put(<span class="string">"user"</span>, user);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (password != <span class="keyword">null</span>) &#123;</span><br><span class="line">            info.put(<span class="string">"password"</span>, password);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 获取连接的 public 接口 (3)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(String url)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        java.util.Properties info = <span class="keyword">new</span> java.util.Properties();</span><br><span class="line">        <span class="keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 获取连接的内部逻辑实现</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        String url, java.util.Properties info, Class&lt;?&gt; caller)</span> </span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * When callerCl is null, we should check the application's</span></span><br><span class="line"><span class="comment">         * (which is invoking this class indirectly)</span></span><br><span class="line"><span class="comment">         * classloader, so that the JDBC driver class outside rt.jar</span></span><br><span class="line"><span class="comment">         * can be loaded from here.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ClassLoader callerCL = caller != <span class="keyword">null</span> ? caller.getClassLoader() : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span>(DriverManager.class) &#123;</span><br><span class="line">            <span class="comment">// synchronize loading of the correct classloader.</span></span><br><span class="line">            <span class="keyword">if</span> (callerCL == <span class="keyword">null</span>) &#123;</span><br><span class="line">                callerCL = Thread.currentThread().getContextClassLoader();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// url 是定位 DBMS 最重要的参数，不能为空</span></span><br><span class="line">        <span class="keyword">if</span>(url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"The url cannot be null"</span>, <span class="string">"08001"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"DriverManager.getConnection(\""</span> + url + <span class="string">"\")"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 遍历所有注册的 Driver ，并都尝试获取连接(Connection)</span></span><br><span class="line">        SQLException reason = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(DriverInfo aDriver : registeredDrivers) &#123;</span><br><span class="line">          <span class="comment">// 判断注册的 Driver 是否由 ClassLoader callerCL 加载，不是则跳过</span></span><br><span class="line">            <span class="keyword">if</span>(isDriverAllowed(aDriver.driver, callerCL)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    println(<span class="string">"    trying "</span> + aDriver.driver.getClass().getName());</span><br><span class="line">                    <span class="comment">// 获取连接，:) 还是由 driver 实例自行提供</span></span><br><span class="line">                  Connection con = aDriver.driver.connect(url, info);</span><br><span class="line">                    <span class="keyword">if</span> (con != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// Success!</span></span><br><span class="line">                        println(<span class="string">"getConnection returning "</span> + </span><br><span class="line">                                aDriver.driver.getClass().getName());</span><br><span class="line">                        <span class="keyword">return</span> (con);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (reason == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        reason = ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                println(<span class="string">"    skipping: "</span> + aDriver.getClass().getName());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果运行到下列代码，则表明获取连接失败，抛出错误</span></span><br><span class="line">        <span class="keyword">if</span> (reason != <span class="keyword">null</span>)    &#123;</span><br><span class="line">            println(<span class="string">"getConnection failed: "</span> + reason);</span><br><span class="line">            <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"getConnection: no suitable driver found for "</span>+ url);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"No suitable driver found for "</span>+ url, <span class="string">"08001"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>简单的提一嘴，Connection 仍然只是一个针对 Java -&gt; DB Server 的上层接口，如果想要更深层次地了解 Connection 与 DB Server 的交互，可以尝试去看一下 com.mysql.jdbc.MysqlIO 类，MySQL 实现的 JDBC4Connection 类也是在使用该类来实现对 DB Server 交互。（哈哈，只看过 MySQL 提供的 Driver 包）。</em></p><h2 id="PreparedStatement-amp-CallableStatement"><a href="#PreparedStatement-amp-CallableStatement" class="headerlink" title="PreparedStatement &amp; CallableStatement"></a>PreparedStatement &amp; CallableStatement</h2><p>在了解了 DataSource 获取连接(Connection) 的实质以及 JdbcTemplate 的通用接口之后，使用 Spring-jdbc 进行数据库相关的操作可以直截了当的利用如下代码进行实现（此处仅展示通过 Java 硬编码的形式进行实现，XML 配置方法类似）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 定义数据源</span></span><br><span class="line">DriverManagerDataSource dataSource = <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">  <span class="comment">// 配置参数</span></span><br><span class="line">dataSource.setUrl(<span class="string">"jdbc:mysql://&lt;host&gt;:&lt;port&gt;/&lt;dbName&gt;?&lt;props&gt;"</span>);</span><br><span class="line">   dataSource.setUsername(<span class="string">"&lt;username&gt;"</span>);</span><br><span class="line">    dataSource.setPassword(<span class="string">"&lt;passwd&gt;"</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 实例化一个 JDBC 工具类</span></span><br><span class="line">  JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">  <span class="comment">// 执行相关 CRUD 操作</span></span><br><span class="line">  jdbcTemplate.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回顾第一节所讲的 JdbcTemplate 的 4 个基础方法：</p><ol><li><code>&lt;T&gt; T execute(ConnectionCallback&lt;T&gt; action);</code></li><li><code>&lt;T&gt; T execute(StatementCallback&lt;T&gt; action);</code></li><li><code>&lt;T&gt; T execute(PreparedStatementCreator psc, PreparedStatementCallback&lt;T&gt; action);</code></li><li><code>&lt;T&gt; T execute(CallableStatementCreator csc, CallableStatementCallback&lt;T&gt; action);</code></li></ol><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fndsm5tl7aj30zg0byq47.jpg" alt=""></p><p>四个基础方法都有一个特定的回调函数将通过预配置的 DataSource 得到的 Connection 或 更进一步的 Statement or PreparedStatement or CallableStatement 作为入参来执行定义的唯一方法。</p><p>以 <code>&lt;T&gt; T execute(StatementCallback&lt;T&gt; action);</code> 为例来了解一下方法的核心逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(StatementCallback&lt;T&gt; action)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line"><span class="comment">// 通过工具类 DataSourceUtils 获取一个连接</span></span><br><span class="line">  Connection con = DataSourceUtils.getConnection(obtainDataSource());</span><br><span class="line">  <span class="comment">// 一个 Statement 空实例，PreparedStatement, CallableStatement 类似</span></span><br><span class="line">Statement stmt = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">stmt = con.createStatement();<span class="comment">// 通过连接(Connection)获取一个 Statement</span></span><br><span class="line">applyStatementSettings(stmt);<span class="comment">// 配置 Statement 参数</span></span><br><span class="line">      <span class="comment">// 回调执行 doInXXX() 方法, 并获得 result</span></span><br><span class="line">T result = action.doInStatement(stmt);</span><br><span class="line">handleWarnings(stmt);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span>() &#123;</span><br><span class="line">      </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，对于 PreparedStatement 和 CallableStatement 而言，获取一个 <em>XXX</em>Statement 的方式就有所不同了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 Statement 实例</span></span><br><span class="line">Statement stmt = con.createStatement();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 PreparedStatement 实例</span></span><br><span class="line"><span class="comment">// psc 是一个 PreparedStatementCreator 接口实现的实例</span></span><br><span class="line">PreparedStatement ps = psc.createPreparedStatement(con);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 CallableStatement 实例</span></span><br><span class="line"><span class="comment">// csc 是一个 CallableStatementCreator 接口实现的实例</span></span><br><span class="line">CallableStatement cs = csc.createCallableStatement(con);</span><br></pre></td></tr></table></figure><p>可以看到 Statement 直接通过 Connection 获取实例，但是 PreparedStatement 和 CallableStatement 就有所不同，其区别就在于 PreparedStatement 和 CallableStatement 两个 Statement 都是可以定制入参的，更甚者， CallableStatement 可以定制 DB 执行结果的出参。当然，核心还是 <code>con.prepareStatement() OR con.prepareCall()</code> 方法，只不过是将获取 XXXStatement 的操作下放给 XXXStatementCreator 实例类实现，给予使用者重复的自主权，同时也是逻辑解耦的一种操作。</p><p>例如：</p><p>SimplePreparedStatementCreator 这个 PreparedStatementCreator 接口的实现类，只是简单的调用了 <code>con.prepareStatement(sql)</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePreparedStatementCreator</span> </span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">PreparedStatementCreator</span>, <span class="title">SqlProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String sql;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">createPreparedStatement</span><span class="params">(Connection con)</span> </span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> con.prepareStatement(<span class="keyword">this</span>.sql);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于 PreparedStatementCreatorImpl ，在 createPreparedStatement(Connection con) 的实现上，又添加了更多的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PreparedStatementCreatorImpl</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">PreparedStatementCreator</span>, <span class="title">PreparedStatementSetter</span>, <span class="title">SqlProvider</span>, <span class="title">ParameterDisposer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String actualSql;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;?&gt; parameters;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">createPreparedStatement</span><span class="params">(Connection con)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">PreparedStatement ps;</span><br><span class="line"><span class="keyword">if</span> (generatedKeysColumnNames != <span class="keyword">null</span> || returnGeneratedKeys) &#123;</span><br><span class="line"><span class="keyword">if</span> (generatedKeysColumnNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// 获取一个 PreparedStatement 实例，下同</span></span><br><span class="line">ps = con.prepareStatement(<span class="keyword">this</span>.actualSql, </span><br><span class="line">                                          generatedKeysColumnNames);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ps = con.prepareStatement(<span class="keyword">this</span>.actualSql, </span><br><span class="line">                                         PreparedStatement.RETURN_GENERATED_KEYS);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (resultSetType == ResultSet.TYPE_FORWARD_ONLY </span><br><span class="line">                 &amp;&amp; !updatableResults) &#123;</span><br><span class="line">ps = con.prepareStatement(<span class="keyword">this</span>.actualSql);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ps = con.prepareStatement(<span class="keyword">this</span>.actualSql, resultSetType,</span><br><span class="line">updatableResults ? ResultSet.CONCUR_UPDATABLE : </span><br><span class="line">                                      ResultSet.CONCUR_READ_ONLY);</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">// 将可变 SQL (例如 SELECT * FROM msg WHERE id = ?) 的 ? 用实际参数替换</span></span><br><span class="line">setValues(ps);</span><br><span class="line"><span class="keyword">return</span> ps;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述两种 PreparedStatementCreator 接口的不同实现，也可以从另一种角度理解到，函数式接口将获取目标出参的具体逻辑交给使用者定义，给予了使用者充分的自主权，同时也是一种业务逻辑的解耦。</p><p>在上面代码 PreparedStatementCreatorImpl 类的实现中，我们看到第 32 行代码 <code>setValue(ps)</code> 。此处的方法是由接口 PreparedStatementSetter 定义的。主要目的是将可变 SQL 中的 ? 参数用实际参数进行一个替换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以 SQL (SELECT * FROM msg WHERE id = ? AND day = ?) 为例</span></span><br><span class="line"><span class="comment">/** 纯 Java 核心库的实现 PreparedStatement 参数注入 */</span></span><br><span class="line">ps.setInt(<span class="number">1</span>, <span class="number">1763</span>);</span><br><span class="line">ps.setString(<span class="number">2</span>, <span class="string">"2018-01-01"</span>);</span><br><span class="line">ps.executeQuery();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 以 Spring-jdbc 实现 PreparedStatement 参数注入 */</span></span><br><span class="line"><span class="comment">// setValues() 由接口 PreparedStatementSetter 定义，封装了注入参数的具体实现逻辑</span></span><br><span class="line"><span class="comment">// 可以由使用者自行定义</span></span><br><span class="line">setValues(ps);</span><br><span class="line">ps.executeQuery();</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fndyybh4q1j31kw0u3afx.jpg" alt=""></p><p>上面类图表示了 PreparedStatementSetter 及其实现类的相关依赖。</p><p>Setter 的主要目标即为对 SQL 中的 ? 参数进行注入。</p><p><del>个人精力有限，对Spring-jdbc在Statement上对参数注入的回调理解有限。</del></p><h2 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h2><p>在前几节已经提到讲了数据源、驱动管理器以及 Statement 之后，利用 JDBC 的最重要的目的就是对 DB 进行操作，并获得预期结果。对于查询语句而言，结果应该是若干记录行；就更新语句而言，结果可能是影响的行数。而 Spring-jdbc 对 ResultSet 额外进行的封装，即是将原本散乱的结果进行一个整合，例如整合成一个(一组)完整的 Bean 来进行展示。</p><p>在 JdbcTemplate 中，四个基本方法入参都包括一个回调接口，而在执行回调获得 ResultSet 之后，方法并不是直接返回，而是进行了一定的操作。</p><p>以一个 PreparedStatementCallback 的实例类为例，在 doInPreparedStatement() 方法中，获得了 ResultSet ，但是仍通过 rse.extractData(rs) 语句进行了处理后再返回结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">doInPreparedStatement</span><span class="params">(PreparedStatement ps)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">// 声明一个 ResultSet </span></span><br><span class="line">ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (pss != <span class="keyword">null</span>) &#123;<span class="comment">// setValues() 方法填充 PreparedStatement 中的可变参数 ? </span></span><br><span class="line">pss.setValues(ps);</span><br><span class="line">&#125;</span><br><span class="line">rs = ps.executeQuery();<span class="comment">// 执行查询 sql ，获取结果</span></span><br><span class="line"><span class="keyword">return</span> rse.extractData(rs);<span class="comment">// 重点... 该语句一定是对结果进行了一些操作.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">JdbcUtils.closeResultSet(rs);</span><br><span class="line"><span class="keyword">if</span> (pss <span class="keyword">instanceof</span> ParameterDisposer) &#123;</span><br><span class="line">((ParameterDisposer) pss).cleanupParameters();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在来看一下究竟在返回结果前进行了什么操作。</p><p>由于是一个回调接口的实现类，rse 应该在外部方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">query</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">PreparedStatementCreator psc, @Nullable <span class="keyword">final</span> PreparedStatementSetter pss, </span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">final</span> ResultSetExtractor&lt;T&gt; rse)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> execute(psc, <span class="keyword">new</span> PreparedStatementCallback&lt;T&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">doInPreparedStatement</span><span class="params">(PreparedStatement ps)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">...</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 rse 是一个 ResultSetExtractor<t> 的实例。从名称上可以看出 Extractor 即为提取器，结果集提取器。</t></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 函数式接口，提供的唯一方法为 extractData(...) */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResultSetExtractor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">T <span class="title">extractData</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException, DataAccessException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fndzz0pqnrj31a60i676v.jpg" alt=""></p><p>Spring-jdbc 中现有的实现有三个类，其中 RowCallbackHandlerResultSetExtractor 和 RowMapperResultSetExtractor 两个类从上面类图及命名即可看出，两个是作为一个适配器而存在的，将 extractData() 进行转换，分别由 RowCallbackHandler 和 RowMapper 实例进行具体操作。而 AbstractLobStreamingResultSetExtractor 类从名称上看，也是一个类似流操作的实现类(其中的 Lob 指的是 DB 中的 BLOB 与 CLOB 类型，在 Spring-jdbc 中也加入了额外的支持) 。</p><h3 id="RowCallbackHandler"><a href="#RowCallbackHandler" class="headerlink" title="RowCallbackHandler"></a>RowCallbackHandler</h3><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fnh2uw3a0aj30h20jeta4.jpg" alt=""></p><p>从名称上看，这是一个与 ResultSet 结果集行相关的回调接口。processRow(ResultSet rs) 方法将处理行相关的逻辑。</p><p>从它的一个实现类 RowCountCallbackHandler 来说，其最主要的私有属性 rowCount 即是统计 ResultSet 的结果行数。下面是一个具体使用的该类的案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">    DriverManagerDataSource dataSource = <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">    dataSource.setUrl(<span class="string">"jdbc:mysql://&lt;host&gt;:&lt;port&gt;/&lt;dbName&gt;"</span>);</span><br><span class="line">    dataSource.setUsername(<span class="string">"&lt;username&gt;"</span>);</span><br><span class="line">    dataSource.setPassword(<span class="string">"&lt;password&gt;"</span>);</span><br><span class="line"></span><br><span class="line">    JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    RowCountCallbackHandler rcch = <span class="keyword">new</span> RowCountCallbackHandler();</span><br><span class="line"></span><br><span class="line">    jdbcTemplate.query(<span class="string">"SELECT * FROM info WHERE id='2018'"</span>, (RowCallbackHandler) rcch);</span><br><span class="line"></span><br><span class="line">  System.out.println(rcch.getRowCount());<span class="comment">//获取结果集行数</span></span><br><span class="line">    System.out.println(rcch.getColumnCount());<span class="comment">// 获取结果集列数</span></span><br><span class="line">    <span class="keyword">for</span> (String arg : rcch.getColumnNames()) &#123;<span class="comment">// 打印结果集每一列名称</span></span><br><span class="line">        System.out.println(<span class="string">"ColumnNames : "</span> + arg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : rcch.getColumnTypes()) &#123;<span class="comment">// 打印结果集每一列类型(Types 为枚举类)</span></span><br><span class="line">        System.out.println(<span class="string">"ColumnTypes : "</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体查看 RowCountCallbackHandler 类的 processRow() 方法可以看到，其获取列相关信息都来自于 ResultSetMetaData 。而结果行数来源于 Iterator 迭代。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processRow</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.rowCount == <span class="number">0</span>) &#123;</span><br><span class="line">ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line"><span class="keyword">this</span>.columnCount = rsmd.getColumnCount();</span><br><span class="line"><span class="keyword">this</span>.columnTypes = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.columnCount];</span><br><span class="line"><span class="keyword">this</span>.columnNames = <span class="keyword">new</span> String[<span class="keyword">this</span>.columnCount];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.columnCount; i++) &#123;</span><br><span class="line"><span class="keyword">this</span>.columnTypes[i] = rsmd.getColumnType(i + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">this</span>.columnNames[i] = JdbcUtils.lookupColumnName(rsmd, i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// could also get column names</span></span><br><span class="line">&#125;</span><br><span class="line">processRow(rs, <span class="keyword">this</span>.rowCount++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RowMapper"><a href="#RowMapper" class="headerlink" title="RowMapper"></a>RowMapper</h3><p>上面 RowCallbackHandler 接口从逻辑上划分是用于处理 ResultSet 元数据信息的。而 RowMapper 较上一个接口而言，有更高的实用性。</p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fnh3h739kaj30z60nago4.jpg" alt=""></p><p>特别是其实现类 BeanPropertyRowMapper<t> 可以将散乱的 ResultSet 的结果数据整理成一个个 Object Bean 作为返回结果。而省去了对逐一读取 ResultSet 行记录并填充 Bean 属性的麻烦。</t></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line"></span><br><span class="line">BeanPropertyRowMapper&lt;Model&gt; rowMapper = <span class="keyword">new</span> BeanPropertyRowMapper&lt;&gt;(Model.class);</span><br><span class="line">List&lt;Model&gt; list = jdbcTemplate.query(<span class="string">"SELECT * FROM info WHERE id = '2018'"</span>, rowMapper);</span><br><span class="line"><span class="comment">/** 获得的 Model list 的对应属性将通过 Java 的反射机制进行填充</span></span><br><span class="line"><span class="comment"> *List&lt;Model&gt; list 即结果</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>当然，要求是 Model 类中的属性与 DB table 中的列名保持一致（大小写无要求）。</p><p>而其它两个类的实现也是基于反射机制，实现其相应的业务逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;在学习 Spring-JDBC 之前，我们有必要从 Java 原生提供的 JDBC 开始，对 JDBC 操作的一整套完整的流程有一个清晰的概念。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="https://DorMOUSE-None.github.io/tags/Spring/"/>
    
      <category term="JDBC" scheme="https://DorMOUSE-None.github.io/tags/JDBC/"/>
    
  </entry>
  
</feed>
