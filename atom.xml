<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Utop&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://DorMOUSE-None.github.io/"/>
  <updated>2019-04-10T13:42:03.667Z</updated>
  <id>https://DorMOUSE-None.github.io/</id>
  
  <author>
    <name>Utop</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>理解 Linux Kernel(10) - Context of Execution</title>
    <link href="https://DorMOUSE-None.github.io/2019-04-10-understand-Kernel-10/"/>
    <id>https://DorMOUSE-None.github.io/2019-04-10-understand-Kernel-10/</id>
    <published>2019-04-09T16:00:00.000Z</published>
    <updated>2019-04-10T13:42:03.667Z</updated>
    
    <content type="html"><![CDATA[<p>在进行<a href="https://www.ffutop.com/2018-10-12-understand-Kernel-4/" target="_blank" rel="noopener">第四篇(任务调度)</a>行文描述时，就一直闹不清内核所谓的<code>task</code>的概念。之前一直将其与进程(process)的概念等同视之。但这又导致了线程的概念无处安置（毕竟在计算机科学的概念中，线程作为进程的子集存在，负责程序执行）。不过，现在这个疑惑总算得到了合理的解释：<strong>我们错误地将理论和实践不加区分地混淆了</strong>。内核开发社区与学术界的合作在整个内核开发历史上并没有想象中的频繁，正相反，学术界对内核代码的贡献不到1%[1]。如果想要将进程/线程的思想代入内核，并逐一印证，那么过程将非常痛苦并最终一无所获。所谓进程/线程，在内核中只有一个概念——执行的上下文(Context of Execution)，任何想要对进程/线程概念进行区分的行为都将是作茧自缚[2]。同时，<code>task</code> 也就是 <code>Context of Execution</code> 概念在实现上的表征。</p><a id="more"></a><p>执行的上下文(Context of Execution, COE)，记录了所有程序执行中的状态，包括：CPU状态（寄存器信息等）、MMU状态（页映射）、权限状态（uid、gid等）和一些公共属性（打开的文件、信号处理函数等）。对比理论上的进程/线程概念，粗略地讲就是同一线程组的线程各自持有CPU状态而共享其它状态，而认为两进程不共享任何状态。当然，在内核的概念里，进程/线程只是COE共享部分状态中的一个特例。</p><h2 id="fork-clone"><a href="#fork-clone" class="headerlink" title="fork, clone"></a>fork, clone</h2><p>如果用进程/线程的概念来看，内核提供了 <code>fork</code> 来完成进程的复制，提供了 <code>clone</code> 来处理线程的拷贝，另外还有 <code>vfork</code> , <code>kernel_thread</code> 等。</p><p><strong>syscall fork</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">int</span> <span class="title">sys_fork</span><span class="params">(struct pt_regs regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> do_fork(SIGCHLD, regs.esp, &amp;regs, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>syscall clone</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">int</span> <span class="title">sys_clone</span><span class="params">(struct pt_regs regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> newsp;</span><br><span class="line">    <span class="keyword">int</span> __user *parent_tidptr, *child_tidptr;</span><br><span class="line">    </span><br><span class="line">    clone_flags = regs.ebx;</span><br><span class="line">    newsp = regs.ecx;</span><br><span class="line">    parent_tidptr = (<span class="keyword">int</span> __user *)regs.edx;</span><br><span class="line">    child_tidptr = (<span class="keyword">int</span> __user *)regs.edi;</span><br><span class="line">    <span class="keyword">if</span> (!newsp)</span><br><span class="line">        newsp = regs.esp;</span><br><span class="line">    <span class="keyword">return</span> do_fork(clone_flags, newsp, &amp;regs, <span class="number">0</span>, parent_tidptr, child_tidptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>syscall vfork</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">int</span> <span class="title">sys_vfork</span><span class="params">(struct pt_regs regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, regs.esp, &amp;regs, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>kernel function: kernel_thread</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kernel_thread</span><span class="params">(<span class="keyword">int</span> (*fn)(<span class="keyword">void</span> *), <span class="keyword">void</span> * arg, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> do_fork(flags | CLONE_VM | CLONE_UNTRACED, <span class="number">0</span>, &amp;regs, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>fork</code>, <code>clone</code>, <code>vfork</code> 的入参怎么和日常使用的系统调用入参不同？且看：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">.macro PTREGSCALL label, func, arg</span><br><span class="line">.globl \label</span><br><span class="line">\label:</span><br><span class="line">leaq \func(%rip),%rax</span><br><span class="line">leaq -ARGOFFSET+<span class="number">8</span>(%rsp),\arg<span class="comment">/* 8 for return address */</span></span><br><span class="line">jmp  ia32_ptregs_common</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line">CFI_STARTPROC32</span><br><span class="line"></span><br><span class="line">PTREGSCALL stub32_rt_sigreturn, sys32_rt_sigreturn, %rdi</span><br><span class="line">PTREGSCALL stub32_sigreturn, sys32_sigreturn, %rdi</span><br><span class="line">PTREGSCALL stub32_sigaltstack, sys32_sigaltstack, %rdx</span><br><span class="line">PTREGSCALL stub32_sigsuspend, sys32_sigsuspend, %rcx</span><br><span class="line">PTREGSCALL stub32_execve, sys32_execve, %rcx</span><br><span class="line">PTREGSCALL stub32_fork, sys_fork, %rdi</span><br><span class="line">PTREGSCALL stub32_clone, sys32_clone, %rdx</span><br><span class="line">PTREGSCALL stub32_vfork, sys_vfork, %rdi</span><br><span class="line">PTREGSCALL stub32_iopl, sys_iopl, %rsi</span><br><span class="line">PTREGSCALL stub32_rt_sigsuspend, sys_rt_sigsuspend, %rdx</span><br><span class="line"></span><br><span class="line">ENTRY(ia32_ptregs_common)</span><br><span class="line">popq %r11</span><br><span class="line">CFI_ENDPROC</span><br><span class="line">CFI_STARTPROC32simple</span><br><span class="line">CFI_SIGNAL_FRAME</span><br><span class="line">CFI_DEF_CFArsp,SS+<span class="number">8</span>-ARGOFFSET</span><br><span class="line">CFI_REL_OFFSETrax,RAX-ARGOFFSET</span><br><span class="line">CFI_REL_OFFSETrcx,RCX-ARGOFFSET</span><br><span class="line">CFI_REL_OFFSETrdx,RDX-ARGOFFSET</span><br><span class="line">CFI_REL_OFFSETrsi,RSI-ARGOFFSET</span><br><span class="line">CFI_REL_OFFSETrdi,RDI-ARGOFFSET</span><br><span class="line">CFI_REL_OFFSETrip,RIP-ARGOFFSET</span><br><span class="line"><span class="comment">/*CFI_REL_OFFSETcs,CS-ARGOFFSET*/</span></span><br><span class="line"><span class="comment">/*CFI_REL_OFFSETrflags,EFLAGS-ARGOFFSET*/</span></span><br><span class="line">CFI_REL_OFFSETrsp,RSP-ARGOFFSET</span><br><span class="line"><span class="comment">/*CFI_REL_OFFSETss,SS-ARGOFFSET*/</span></span><br><span class="line">SAVE_REST</span><br><span class="line">call *%rax</span><br><span class="line">RESTORE_REST</span><br><span class="line">jmp  ia32_sysret<span class="comment">/* misbalances the return cache */</span></span><br><span class="line">CFI_ENDPROC</span><br><span class="line">END(ia32_ptregs_common)</span><br></pre></td></tr></table></figure><p>进行系统调用时的处理逻辑统一地将这些内容进行了整合，并将CPU状态（所有通用寄存器状态）维护到 <code>struct pt_regs</code> 数据块中。总结起来，三种系统调用最终都委托给 <code>do_fork</code> 进行实现，只是在参数的选择方面做了不同的预处理。这在用户层的函数原型上就更为明显，<code>fork</code> 和 <code>vfork</code> 都不允许参数的调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* for x86-32 */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">clone</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> flags, <span class="keyword">void</span> *child_stack,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> *ptid, <span class="keyword">unsigned</span> <span class="keyword">long</span> newtls,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> *ctid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> vfork(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure><p>再看看 <code>flags</code> 有哪些值可选。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * cloning flags:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSIGNAL0x000000ff<span class="comment">/* signal mask to be sent at exit */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_VM0x00000100<span class="comment">/* set if VM shared between processes */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_FS0x00000200<span class="comment">/* set if fs info shared between processes */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_FILES0x00000400<span class="comment">/* set if open files shared between processes */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_SIGHAND0x00000800<span class="comment">/* set if signal handlers and blocked signals shared */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_PTRACE0x00002000<span class="comment">/* set if we want to let tracing continue on the child too */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_VFORK0x00004000<span class="comment">/* set if the parent wants the child to wake it up on mm_release */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_PARENT0x00008000<span class="comment">/* set if we want to have the same parent as the cloner */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_THREAD0x00010000<span class="comment">/* Same thread group? */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_NEWNS0x00020000<span class="comment">/* New namespace group? */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_SYSVSEM0x00040000<span class="comment">/* share system V SEM_UNDO semantics */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_SETTLS0x00080000<span class="comment">/* create a new TLS for the child */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_PARENT_SETTID0x00100000<span class="comment">/* set the TID in the parent */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_CHILD_CLEARTID0x00200000<span class="comment">/* clear the TID in the child */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_DETACHED0x00400000<span class="comment">/* Unused, ignored */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_UNTRACED0x00800000<span class="comment">/* set if the tracing process can't force CLONE_PTRACE on this clone */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_CHILD_SETTID0x01000000<span class="comment">/* set the TID in the child */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_STOPPED0x02000000<span class="comment">/* Start in stopped state */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_NEWUTS0x04000000<span class="comment">/* New utsname group? */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_NEWIPC0x08000000<span class="comment">/* New ipcs */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_NEWUSER0x10000000<span class="comment">/* New user namespace */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_NEWPID0x20000000<span class="comment">/* New pid namespace */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_NEWNET0x40000000<span class="comment">/* New network namespace */</span></span></span><br></pre></td></tr></table></figure><p><code>xxx shared between processes</code> ，描述即将被创建的新任务将进行哪些状态/资源的共享，而哪些状态需要进行拷贝。</p><h3 id="do-fork"><a href="#do-fork" class="headerlink" title="do_fork"></a><code>do_fork</code></h3><p>先看看核心的 <code>do_fork</code> 的逻辑。</p><p><em>Hint: 下列代码经过大量的删减</em><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">do_fork</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_start,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct pt_regs *regs,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_size,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> __user *parent_tidptr,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> __user *child_tidptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = copy_process(clone_flags, stack_start, regs, stack_size, child_tidptr, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!IS_ERR(p)) &#123;</span><br><span class="line">        nr = (clone_flags &amp; CLONE_NEWPID) ?</span><br><span class="line">            task_pid_nr_ns(p, current-&gt;nsproxy-&gt;pid_ns) :</span><br><span class="line">                task_pid_vnr(p);</span><br><span class="line">        <span class="keyword">if</span> (!(clone_flags &amp; CLONE_STOPPED))</span><br><span class="line">            wake_up_new_task(p, clone_flags);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p-&gt;state = TASK_STOPPED;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nr = PTR_ERR(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct task_struct *<span class="title">copy_process</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_start,</span></span></span><br><span class="line"><span class="function"><span class="params">                    struct pt_regs *regs,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> __user *child_tidptr,</span></span></span><br><span class="line"><span class="function"><span class="params">                    struct pid *pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 预分配 task_struct 数据结构空间 */</span></span><br><span class="line">    retval = security_task_create(clone_flags);</span><br><span class="line">    <span class="comment">/* 复制 current 的 task_struct 数据结构 */</span></span><br><span class="line">    p = dup_task_struct(current);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nr_threads &gt;= max_threads)</span><br><span class="line">    <span class="keyword">goto</span> bad_fork_cleanup_count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 针对多核CPU，为新任务分配CPU */</span></span><br><span class="line">    sched_fork(p, clone_flags);</span><br><span class="line">    <span class="comment">/* 复制 thread_info 数据结构及线程栈 */</span></span><br><span class="line">    retval = copy_thread(<span class="number">0</span>, clone_flags, stack_start, stack_size, p, regs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 分配新的 pid */</span></span><br><span class="line">    p-&gt;pid = pid_nr(pid);</span><br><span class="line">    <span class="comment">/* thread group id = new pid */</span></span><br><span class="line">    p-&gt;tgid = p-&gt;pid;</span><br><span class="line">    <span class="comment">/* 如果标志是 CLONE_THREAD，tgid = 父任务id */</span></span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_THREAD)</span><br><span class="line">    p-&gt;tgid = current-&gt;tgid;</span><br><span class="line"></span><br><span class="line">    p-&gt;set_child_tid = (clone_flags &amp; CLONE_CHILD_SETTID) ? child_tidptr : <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;clear_child_tid = (clone_flags &amp; CLONE_CHILD_CLEARTID) ? child_tidptr: <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * sigaltstack should be cleared when sharing the same VM</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((clone_flags &amp; (CLONE_VM|CLONE_VFORK)) == CLONE_VM)</span><br><span class="line">    p-&gt;sas_ss_sp = p-&gt;sas_ss_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ok, now we should be set up.. */</span></span><br><span class="line">    p-&gt;exit_signal = (clone_flags &amp; CLONE_THREAD) ? <span class="number">-1</span> : (clone_flags &amp; CSIGNAL);</span><br><span class="line">    p-&gt;pdeath_signal = <span class="number">0</span>;</span><br><span class="line">    p-&gt;exit_state = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ok, make it visible to the rest of the system.</span></span><br><span class="line"><span class="comment">     * We dont wake it up yet.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    p-&gt;group_leader = p;</span><br><span class="line">    INIT_LIST_HEAD(&amp;p-&gt;thread_group);</span><br><span class="line">    INIT_LIST_HEAD(&amp;p-&gt;ptrace_children);</span><br><span class="line">    INIT_LIST_HEAD(&amp;p-&gt;ptrace_list);</span><br><span class="line"></span><br><span class="line">    p-&gt;cpus_allowed = current-&gt;cpus_allowed;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!cpu_isset(task_cpu(p), p-&gt;cpus_allowed) ||</span><br><span class="line">    !cpu_online(task_cpu(p))))</span><br><span class="line">    set_task_cpu(p, smp_processor_id());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CLONE_PARENT re-uses the old parent */</span></span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; (CLONE_PARENT|CLONE_THREAD))</span><br><span class="line">    p-&gt;real_parent = current-&gt;real_parent;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    p-&gt;real_parent = current;</span><br><span class="line">    p-&gt;parent = p-&gt;real_parent;</span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_THREAD) &#123;</span><br><span class="line">    p-&gt;group_leader = current-&gt;group_leader;</span><br><span class="line">    list_add_tail_rcu(&amp;p-&gt;thread_group, &amp;p-&gt;group_leader-&gt;thread_group);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cputime_eq(current-&gt;signal-&gt;it_virt_expires,</span><br><span class="line">    cputime_zero) ||</span><br><span class="line">        !cputime_eq(current-&gt;signal-&gt;it_prof_expires,</span><br><span class="line">    cputime_zero) ||</span><br><span class="line">        current-&gt;signal-&gt;rlim[RLIMIT_CPU].rlim_cur != RLIM_INFINITY ||</span><br><span class="line">        !list_empty(&amp;current-&gt;signal-&gt;cpu_timers[<span class="number">0</span>]) ||</span><br><span class="line">        !list_empty(&amp;current-&gt;signal-&gt;cpu_timers[<span class="number">1</span>]) ||</span><br><span class="line">        !list_empty(&amp;current-&gt;signal-&gt;cpu_timers[<span class="number">2</span>])) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Have child wake up on its first tick to check</span></span><br><span class="line"><span class="comment">     * for process CPU timers.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    p-&gt;it_prof_expires = jiffies_to_cputime(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (likely(p-&gt;pid)) &#123;</span><br><span class="line">    add_parent(p);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(p-&gt;ptrace &amp; PT_PTRACED))</span><br><span class="line">    __ptrace_link(p, current-&gt;parent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (thread_group_leader(p)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_NEWPID)</span><br><span class="line">    p-&gt;nsproxy-&gt;pid_ns-&gt;child_reaper = p;</span><br><span class="line"></span><br><span class="line">    p-&gt;signal-&gt;tty = current-&gt;signal-&gt;tty;</span><br><span class="line">    set_task_pgrp(p, task_pgrp_nr(current));</span><br><span class="line">    set_task_session(p, task_session_nr(current));</span><br><span class="line">    attach_pid(p, PIDTYPE_PGID, task_pgrp(current));</span><br><span class="line">    attach_pid(p, PIDTYPE_SID, task_session(current));</span><br><span class="line">    list_add_tail_rcu(&amp;p-&gt;tasks, &amp;init_task.tasks);</span><br><span class="line">    __get_cpu_var(process_counts)++;</span><br><span class="line">    &#125;</span><br><span class="line">    attach_pid(p, PIDTYPE_PID, pid);</span><br><span class="line">    nr_threads++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    total_forks++;</span><br><span class="line">    spin_unlock(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line">    write_unlock_irq(&amp;tasklist_lock);</span><br><span class="line">    proc_fork_connector(p);</span><br><span class="line">    cgroup_post_fork(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据入参配置的 <code>flags</code> ，<code>copy_process</code> 确定了新任务与父任务共享的状态，以及一些需要拷贝的状态。</p><ul><li><code>fork</code> 产生一个新的任务，与父任务不存在任何资源共享的情况。</li><li><code>clone</code> 可高度定制化的系统调用，几乎可以自由组合定制新的任务</li><li><code>vfork</code> 历史原因而存在的系统调用，设计目的在于一般 <code>fork</code> 之后都将调用 <code>execve</code> 来执行全新的任务，也就导致了 <code>fork</code> 所做的拷贝全部白费，因此搞了个轻量级的 <code>vfork</code> 来避免做内存的拷贝。</li></ul><blockquote><p><strong>VFORK</strong><br>Historic description<br>Under Linux, fork(2) is implemented using copy-on-write pages, so the only penalty incurred by fork(2) is the time and memory required to duplicate the  parent’s page tables, and to create a unique task structure for the child.  However, in the bad old days a fork(2) would require making a complete copy of the caller’s data space, often needlessly, since usually immediately afterward an exec(3) is done.  Thus, for greater efficiency, BSD introduced  the  vfork() system call, which did not fully copy the address space of the parent process, but borrowed the parent’s memory and thread of control until a call to execve(2) or an exit occurred.  The parent process was suspended while the child was using its resources.   The  use  of vfork() was tricky: for example, not modifying data in the parent process depended on knowing which variables were held in a register.</p></blockquote><h2 id="pid-tgid"><a href="#pid-tgid" class="headerlink" title="pid, tgid"></a>pid, tgid</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 分配新的 pid */</span></span><br><span class="line">p-&gt;pid = pid_nr(pid);</span><br><span class="line"><span class="comment">/* thread group id = new pid */</span></span><br><span class="line">p-&gt;tgid = p-&gt;pid;</span><br><span class="line"><span class="comment">/* 如果标志是 CLONE_THREAD，tgid = 父任务id */</span></span><br><span class="line"><span class="keyword">if</span> (clone_flags &amp; CLONE_THREAD)</span><br><span class="line">p-&gt;tgid = current-&gt;tgid;</span><br></pre></td></tr></table></figure><p><code>pid</code> 作为每个 <code>task</code> 的唯一标识符存在。<code>tgid</code> 用于指代线程组id，从代码上看也就是进程主线程id。（请原谅我又用了进程/线程的表述）</p><p>看着没有问题？当然不可能。这段代码可是意味着 <code>pid</code> 唯一啊，这可不符合日常表述啊。对于系统的终端用户来讲，一个进程可以有一个或多个线程。<code>pid</code> 可是一直被翻译成进程ID(process id)。难道？</p><p>这就是本质实现与表面功夫的差别啦。<code>pid_t getpid(void);</code>, <code>pid_t gettid(void);</code> 两个系统调用分别被用来提供进程ID和线程ID（请仔细思考下代码实现和对外展示的差距）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sys_getpid - return the thread group id of the current process</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note, despite the name, this returns the tgid not the pid.  The tgid and</span></span><br><span class="line"><span class="comment"> * the pid are identical unless CLONE_THREAD was specified on clone() in</span></span><br><span class="line"><span class="comment"> * which case the tgid is the same in all threads of the same group.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is SMP safe as current-&gt;tgid does not change.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_getpid</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> task_tgid_vnr(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Thread ID - the internal kernel "pid" */</span></span><br><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_gettid</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> task_pid_vnr(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就好懂多了吧。用户态通过系统调用取到的 <code>pid</code>, <code>tid</code> 已经经过了一层加工，分别映射着内核实现的 <code>tgid</code>, <code>pid</code> 。</p><p><em>额外地：想通过 <code>ps</code> 查看进程/线程可以使用 <code>ps -eLf</code></em></p><h2 id="schedule"><a href="#schedule" class="headerlink" title="schedule"></a>schedule</h2><p>再来回顾下任务调度是如何实现的。与<a href="https://www.ffutop.com/2018-10-12-understand-Kernel-4/" target="_blank" rel="noopener">第四篇 任务调度</a>描述的并无太大不同。要说最大的区分，就是早期版本与时下版本顺时的演进。当然，还有就是多核CPU下的SMP调度。</p><p>至于多核下的所谓进程/线程如何调度。内核根本认识不到进程/线程的概念，唯一的只有任务(task, or COE)。而每个用户所认为的线程在内核的认识下也是一个任务。因此，所谓用户认识到的多线程并发执行在多核CPU下也就完全是可行的。</p><h2 id="concept-of-Thread"><a href="#concept-of-Thread" class="headerlink" title="concept of Thread"></a>concept of Thread</h2><p>且不论Linux内核没有线程概念的前提，线程的定义总是存在的，而满足其定义的实现，也就可以被称为“线程”。哪些要素组成了线程呢？</p><ol><li>线程是与其它代码共享进程地址空间的最小执行流</li><li>诸如栈、寄存器信息、本地线程数据需要保持独立</li><li>互斥锁(Mutex)、条件变量(Condition Variable)、线程间同步管理的支持</li><li>…</li></ol><p>既然都说了Linux内核没有线程概念，现在却又开始提，这不是打脸嘛？OK，具体情况是：内核本身不支持线程，甚至没有线程概念。但其通过GLIBC的NPTL(Native POSIX Thread Library)支持了线程。</p><blockquote><p>在Linux内核2.6出现之前任务是(最小)可调度的对象，当时的Linux不真正支持线程。但是Linux内核有一个系统调用指令<code>clone()</code>，这个指令将产生一个调用方任务的拷贝，而且这个拷贝可以与原任务使用同一地址空间。LinuxThreads计划使用这个系统调用来提供一个内核级别的线程支持。但是这个解决方法与真正的POSIX标准有一些不兼容的地方，尤其是在信号处理、进程调度和进程间同步原语方面。<br><em>Copied From <a href="https://en.wikipedia.org/wiki/Native_POSIX_Thread_Library" target="_blank" rel="noopener">Wikipedia NPTL</a></em></p></blockquote><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g1x9mjuahnj31400u0doi.jpg" alt="Linux 架构"></p><h2 id="Thread-Model"><a href="#Thread-Model" class="headerlink" title="Thread Model"></a>Thread Model</h2><p>最后，聊聊线程模型。相信各位不管懂或不懂，至少都听说过 1:1, N:1, M:N 线程模型。至于究竟这些模型是怎么回事呢？且看：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g1xhulou5bj30go08zglv.jpg" alt="Thread Model"></p><h3 id="1-1-Model"><a href="#1-1-Model" class="headerlink" title="1:1 Model"></a>1:1 Model</h3><p>最简单的线程模型，也是内核通过NPTL最容易实现的一种模型。每个通过 <code>clone</code> 产生的新任务（当然，至少要符合共享内存等线程定义）对应用程序来说就是一个新线程。所谓的用户级线程和内核级线程，在 1:1 模型中就是同一个任务，只是新任务在被内核 <code>clone</code> 之后，又由NPTL做了进一步的管理，因此在形式上看似有用户级/内核级之分。</p><h3 id="N-1-Model"><a href="#N-1-Model" class="headerlink" title="N:1 Model"></a>N:1 Model</h3><p>N:1 线程模型又称为“用户级线程模型”。在这种模型下，线程的概念由用户态代码进行支持，包括用来管理线程的用户空间调度器以及以非阻塞模式捕捉和处理I/O机制。使用N:1模型的好处在于其上下文切换的代价几乎为零，毕竟这是纯用户态的。当然，缺点也比较明显：由于对内核来说，认为这只是单个任务，也就无法充分利用多核CPU的特性。</p><h3 id="M-N-Model"><a href="#M-N-Model" class="headerlink" title="M:N Model"></a>M:N Model</h3><p>有没有方式整合1:1模型和N:1模型，让内核意识到有几个任务，但又存在更多的线程在用户级执行呢？当然也是可行，但如何协调调度又是费事费力的实现了。</p><h2 id="Threads-vs-Events"><a href="#Threads-vs-Events" class="headerlink" title="Threads vs Events"></a>Threads vs Events</h2><p>线程怎么又和事件扯上关系了呢？先来回顾下任务调度的几种模式：</p><ol><li>串行，每个任务依次执行，不存在任务调度</li><li>抢占式，通过时钟中断决定是否切换任务</li><li>协作式，只有当任务主动放弃对CPU的占用，才能轮到下一个任务。</li></ol><p>对于用户级线程来说，内核无法意识到这些线程的存在，硬件发起的所有中断又都被内核捕获。因此，想要实现抢占式是不可能完成的任务（至少以本人目前所知是不可能的）。故协作式线程调度是用户级线程的唯一选择。而协作式就意味着是由线程硬编码主动放弃任务执行（<code>yield</code> / <code>schedule</code> / etc.）。如此这般，与事件驱动下，不同代码片之间的调度又是何其相似。当然，只是开个玩笑，如果都一样了，直接用事件驱动不就OK了。线程之所以是线程，有其独特的定义在。不过不再细说，可以参考 <a href="http://courses.cs.vt.edu/cs5204/fall09-kafura/Presentations/Threads-VS-Events.pdf" target="_blank" rel="noopener">Threads vs Events</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1]. Mauerer W. Professional Linux kernel architecture[M]. John Wiley &amp; Sons, 2010.<br>[2]. <a href="http://lkml.iu.edu/hypermail/linux/kernel/9608/0191.html" target="_blank" rel="noopener">Linus Torvalds. Re: proc fs and shared pids</a>[EL/OL]. Aug 6th, 1996.<br>[3]. <a href="https://randu.org/tutorials/threads/" target="_blank" rel="noopener">Multithreaded Programming (POSIX pthreads Tutorial)</a>[EL/OL].<br>[4]. <a href="https://blog.csdn.net/u012432778/article/details/47378321" target="_blank" rel="noopener">线程模型</a>[EL/OL].<br>[5]. <a href="https://www.evanjones.ca/software/threading.html" target="_blank" rel="noopener">Implementing a Thread Library on Linux</a>[EL/OL]. Dec 10th, 2003.</p><h2 id="用户级线程资料参考"><a href="#用户级线程资料参考" class="headerlink" title="用户级线程资料参考"></a>用户级线程资料参考</h2><p>[1]. <code>man makecontext</code> &amp; <code>man swapcontext</code><br>[2]. <a href="https://github.com/brianwatling/libfiber" target="_blank" rel="noopener">Libfiber</a><br>[3]. <a href="https://github.com/dramesh/GTThreads" target="_blank" rel="noopener"><strong>所谓的</strong>抢占式用户线程实现</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在进行&lt;a href=&quot;https://www.ffutop.com/2018-10-12-understand-Kernel-4/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;第四篇(任务调度)&lt;/a&gt;行文描述时，就一直闹不清内核所谓的&lt;code&gt;task&lt;/code&gt;的概念。之前一直将其与进程(process)的概念等同视之。但这又导致了线程的概念无处安置（毕竟在计算机科学的概念中，线程作为进程的子集存在，负责程序执行）。不过，现在这个疑惑总算得到了合理的解释：&lt;strong&gt;我们错误地将理论和实践不加区分地混淆了&lt;/strong&gt;。内核开发社区与学术界的合作在整个内核开发历史上并没有想象中的频繁，正相反，学术界对内核代码的贡献不到1%[1]。如果想要将进程/线程的思想代入内核，并逐一印证，那么过程将非常痛苦并最终一无所获。所谓进程/线程，在内核中只有一个概念——执行的上下文(Context of Execution)，任何想要对进程/线程概念进行区分的行为都将是作茧自缚[2]。同时，&lt;code&gt;task&lt;/code&gt; 也就是 &lt;code&gt;Context of Execution&lt;/code&gt; 概念在实现上的表征。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://DorMOUSE-None.github.io/tags/Linux/"/>
    
      <category term="Kernel" scheme="https://DorMOUSE-None.github.io/tags/Kernel/"/>
    
      <category term="COE" scheme="https://DorMOUSE-None.github.io/tags/COE/"/>
    
  </entry>
  
  <entry>
    <title>如何获取运行时进程堆栈</title>
    <link href="https://DorMOUSE-None.github.io/2019-03-25-mem-dump/"/>
    <id>https://DorMOUSE-None.github.io/2019-03-25-mem-dump/</id>
    <published>2019-03-24T16:00:00.000Z</published>
    <updated>2019-03-25T01:28:42.233Z</updated>
    
    <content type="html"><![CDATA[<p>前些天看了关于在密码学应用中使用<code>java.lang.String</code>与<code>byte[]</code>的相关讨论，不推荐使用<code>java.lang.String</code>的重点就是其将在JVM中驻留，从而可能被窃取。但是，如何从内存中获取这些内容？JVM当然提供了一些机制，但是个人更喜欢从内核的角度来看看这个问题。</p><h2 id="proc-pid-maps"><a href="#proc-pid-maps" class="headerlink" title="/proc/${pid}/maps"></a>/proc/${pid}/maps</h2><p>首先当然是确定进程堆栈在物理内存的位置啦。很遗憾，没有找到相关的方案。毕竟进程记录的都是虚拟线性地址，而通过内核分段、分页机制最终映射到物理内存。不过，从<code>/proc</code>虚拟文件系统中，提供了进程虚拟地址映射。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">address                   perm offset   dev   inode                      pathname</span><br><span class="line">556566cb5000-556566cb6000 r-xp 00000000 fc:01 2496598                    /root/ffTrace/run</span><br><span class="line">556566eb5000-556566eb6000 r--p 00000000 fc:01 2496598                    /root/ffTrace/run</span><br><span class="line">556566eb6000-556566eb7000 rw-p 00001000 fc:01 2496598                    /root/ffTrace/run</span><br><span class="line">55656814f000-556568170000 rw-p 00000000 00:00 0                          [heap]</span><br><span class="line">7f2a95f91000-7f2a96178000 r-xp 00000000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so</span><br><span class="line">7f2a96178000-7f2a96378000 ---p 001e7000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so</span><br><span class="line">7f2a96378000-7f2a9637c000 r--p 001e7000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so</span><br><span class="line">7f2a9637c000-7f2a9637e000 rw-p 001eb000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so</span><br><span class="line">7f2a9637e000-7f2a96382000 rw-p 00000000 00:00 0</span><br><span class="line">7f2a96382000-7f2a963a9000 r-xp 00000000 fc:01 1835410                    /lib/x86_64-linux-gnu/ld-2.27.so</span><br><span class="line">7f2a965a0000-7f2a965a2000 rw-p 00000000 00:00 0</span><br><span class="line">7f2a965a9000-7f2a965aa000 r--p 00027000 fc:01 1835410                    /lib/x86_64-linux-gnu/ld-2.27.so</span><br><span class="line">7f2a965aa000-7f2a965ab000 rw-p 00028000 fc:01 1835410                    /lib/x86_64-linux-gnu/ld-2.27.so</span><br><span class="line">7f2a965ab000-7f2a965ac000 rw-p 00000000 00:00 0</span><br><span class="line">7ffe2cf5e000-7ffe2cf7f000 rw-p 00000000 00:00 0                          [stack]</span><br><span class="line">7ffe2cfed000-7ffe2cff0000 r--p 00000000 00:00 0                          [vvar]</span><br><span class="line">7ffe2cff0000-7ffe2cff2000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line">ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]</span><br></pre></td></tr></table></figure><a id="more"></a><p><code>/proc/${pid}/maps</code> 记录了当前进程虚拟内存区域的分配以及其访问控制。</p><ul><li>前三行表述的是当前进程ELF文件在虚拟内存中的地址（这里使用的ELF文件名为 <code>run</code> ）<ul><li>第一行 <code>r-xp</code> 表示其将配合<code>Code Segment Register (CS)</code> 作为CPU执行指令的直接依据。</li><li>第二三行分别用作可读、可写数据区，将配合 <code>Data Segment Register (DS), ES, FS, GS</code> 等使用</li></ul></li><li>第四行直截了当，就是分配给堆的地址空间。当然，如果不够，可以不断地向上扩张。</li><li><code>xxx.so</code> 文件描述的是C共享库在虚拟内存中的地址。</li><li>最后才是栈内存，将以倒序的方式下内存低地址扩张。</li><li>至于之后的内容，不了解，不表。</li></ul><h2 id="ptrace"><a href="#ptrace" class="headerlink" title="ptrace"></a>ptrace</h2><p>拿到了进程虚拟内存分布，又如何获取其中的内容。<code>ptrace</code> 总算是派上用场了。之前在阅读内核源码的时候，任务数据结构 <code>struct task</code> 专门为此预留了一些字段来加以描述，但始终找不到其用途。现在总算对其有了初步的了解。</p><p>一般来说，进程彼此之间应该相互独立，虽然运行在同一台机器上，但应该是相互间不知道其他进程的存在。那又如何能够通过一个进程的代码来获取另一个进程的堆栈数据呢？<code>ptrace</code> 提供的就是这么一种可能性。通过 <code>PTRACE_ATTACH</code> 和 <code>PTRACE_DETACH</code>，A进程会使得目标进程B陷入Sleeping状态，而等待A继续通过其他命令来获取其数据。至于为什么会是陷入Sleeping呢？一旦B进程的在运行，数据等随时可能改变，显然不适合读取数据啊。</p><p>如何读取？<code>PTRACE_PEEKTEXT</code> 就是这样一个实现进程间交互的好工具。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ptrace(PTRACE_ATTACH, options.pid, <span class="literal">NULL</span>, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"ptract attach failed. %s(errno: %d)\n"</span>, strerror(errno), errno);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"attach to %d success!\n"</span>, options.pid);</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">peek</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> maps[<span class="number">17</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(maps, <span class="string">"/proc/%d/maps"</span>, options.pid);</span><br><span class="line">    FILE *fd = fopen(maps, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"open /proc/%d/maps failed. %s(errno: %d)\n"</span>, strerror(errno), errno);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">map</span> *<span class="title">map</span> = (<span class="title">struct</span> <span class="title">map</span> *) <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">map</span> *));</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> word;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fscanf</span>(fd, <span class="string">"%llx-%llx %s %lx %*s %*s%*[^\n]"</span>, &amp;<span class="built_in">map</span>-&gt;start_addr, &amp;<span class="built_in">map</span>-&gt;end_addr, <span class="built_in">map</span>-&gt;op_flag, &amp;<span class="built_in">map</span>-&gt;offset) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">map</span>-&gt;op_flag[<span class="number">0</span>] == <span class="string">'-'</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"peek from [%llx-%llx]\n"</span>, <span class="built_in">map</span>-&gt;start_addr, <span class="built_in">map</span>-&gt;end_addr);</span><br><span class="line">        <span class="keyword">long</span> mem_len = <span class="built_in">map</span>-&gt;end_addr - <span class="built_in">map</span>-&gt;start_addr;</span><br><span class="line">        <span class="keyword">char</span> *data = <span class="built_in">malloc</span>(mem_len + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> cursor = <span class="built_in">map</span>-&gt;start_addr;cursor &lt; <span class="built_in">map</span>-&gt;end_addr;cursor += <span class="keyword">sizeof</span>(<span class="keyword">long</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((word = ptrace(PTRACE_PEEKTEXT, options.pid, cursor, <span class="literal">NULL</span>)) == <span class="number">-1</span> &amp;&amp; errno)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"peek failed. %s(errno: %d)\n"</span>, strerror(errno), errno);</span><br><span class="line">                <span class="built_in">free</span>(data);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memcpy</span>(data+cursor-<span class="built_in">map</span>-&gt;start_addr, &amp;word, <span class="keyword">sizeof</span>(word));</span><br><span class="line">        &#125;</span><br><span class="line">        dump(data, mem_len);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">map</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">detach</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ptrace(PTRACE_DETACH, options.pid, <span class="literal">NULL</span>, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="string">"ptract detach failed. %s(errno: %d)\n"</span>, strerror(errno), errno);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"detach from %d success!"</span>, options.pid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    attach();</span><br><span class="line">    peek();</span><br><span class="line">    detach();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处的代码片段就能完成dump堆栈的工作了（当然，由于没有对其它内容进行处理，同时会dump下ELF数据等）。<a href="https://github.com/DorMOUSE-None/ffDump" target="_blank" rel="noopener">完整代码</a></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>当然，之后才发现 GDB 的实现借用的也正是这样一套机制。同时也意味着上面这段代码的实现在 GDB 中有现成的工具了:&lt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前些天看了关于在密码学应用中使用&lt;code&gt;java.lang.String&lt;/code&gt;与&lt;code&gt;byte[]&lt;/code&gt;的相关讨论，不推荐使用&lt;code&gt;java.lang.String&lt;/code&gt;的重点就是其将在JVM中驻留，从而可能被窃取。但是，如何从内存中获取这些内容？JVM当然提供了一些机制，但是个人更喜欢从内核的角度来看看这个问题。&lt;/p&gt;
&lt;h2 id=&quot;proc-pid-maps&quot;&gt;&lt;a href=&quot;#proc-pid-maps&quot; class=&quot;headerlink&quot; title=&quot;/proc/${pid}/maps&quot;&gt;&lt;/a&gt;/proc/${pid}/maps&lt;/h2&gt;&lt;p&gt;首先当然是确定进程堆栈在物理内存的位置啦。很遗憾，没有找到相关的方案。毕竟进程记录的都是虚拟线性地址，而通过内核分段、分页机制最终映射到物理内存。不过，从&lt;code&gt;/proc&lt;/code&gt;虚拟文件系统中，提供了进程虚拟地址映射。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;address                   perm offset   dev   inode                      pathname&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;556566cb5000-556566cb6000 r-xp 00000000 fc:01 2496598                    /root/ffTrace/run&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;556566eb5000-556566eb6000 r--p 00000000 fc:01 2496598                    /root/ffTrace/run&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;556566eb6000-556566eb7000 rw-p 00001000 fc:01 2496598                    /root/ffTrace/run&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55656814f000-556568170000 rw-p 00000000 00:00 0                          [heap]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7f2a95f91000-7f2a96178000 r-xp 00000000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7f2a96178000-7f2a96378000 ---p 001e7000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7f2a96378000-7f2a9637c000 r--p 001e7000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7f2a9637c000-7f2a9637e000 rw-p 001eb000 fc:01 1835434                    /lib/x86_64-linux-gnu/libc-2.27.so&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7f2a9637e000-7f2a96382000 rw-p 00000000 00:00 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7f2a96382000-7f2a963a9000 r-xp 00000000 fc:01 1835410                    /lib/x86_64-linux-gnu/ld-2.27.so&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7f2a965a0000-7f2a965a2000 rw-p 00000000 00:00 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7f2a965a9000-7f2a965aa000 r--p 00027000 fc:01 1835410                    /lib/x86_64-linux-gnu/ld-2.27.so&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7f2a965aa000-7f2a965ab000 rw-p 00028000 fc:01 1835410                    /lib/x86_64-linux-gnu/ld-2.27.so&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7f2a965ab000-7f2a965ac000 rw-p 00000000 00:00 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7ffe2cf5e000-7ffe2cf7f000 rw-p 00000000 00:00 0                          [stack]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7ffe2cfed000-7ffe2cff0000 r--p 00000000 00:00 0                          [vvar]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7ffe2cff0000-7ffe2cff2000 r-xp 00000000 00:00 0                          [vdso]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://DorMOUSE-None.github.io/tags/Linux/"/>
    
      <category term="Kernel" scheme="https://DorMOUSE-None.github.io/tags/Kernel/"/>
    
      <category term="dump" scheme="https://DorMOUSE-None.github.io/tags/dump/"/>
    
  </entry>
  
  <entry>
    <title>认证与授权·简述</title>
    <link href="https://DorMOUSE-None.github.io/2019-03-19-JANUS/"/>
    <id>https://DorMOUSE-None.github.io/2019-03-19-JANUS/</id>
    <published>2019-03-18T16:00:00.000Z</published>
    <updated>2019-03-21T11:27:55.521Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>在大多数系统中，都或多或少需要认证授权模型/系统的支持。</p></blockquote><p>认证/授权是什么？最简单的，我们的系统要求用户必须在“登录”之后才允许进行一些操作。“登录”的过程就是认证；而区别与未登录状态，只允许登录用户进行一些操作，这就是授权。认证与授权相互独立，有协同配合，共同支撑起系统对安全的基本要求。</p><a id="more"></a><h2 id="认证与授权"><a href="#认证与授权" class="headerlink" title="认证与授权"></a>认证与授权</h2><p>认证的目的在于认出用户。日常生活中，我们通过视觉、声音等因素认出一个人。但是就网络应用而言，应用最多只能够认识到发起请求的浏览器、手机APP、物联网设备等用户代理(User Agent)，也无法直接地将用户与用户代理进行绑定。因此，向应用证明操作这些用户代理的实体就成了至关重要的步骤。你需要通过密码、手机验证码、人脸识别或其它形式凭证来完成“登录”操作，即认证。</p><p>当然了，我们也认识到，不是所有的操作都需要一个这般复制“登录”流程的，即使这些操作逻辑上也需要认出背后的用户是谁。这部分所使用到的技术就是“会话管理”了。在一定的有效期范围内，用户无需重复证明自己的身份，而用户-应用间保持最基本的信任。当然，一般来说，修改密码等危险操作还是需要再次进行认证。</p><p>总而言之，无论是“登录”认证抑或是“会话”认证，其目的都是为了认出用户。</p><p>完成认证之后，就要启用授权了。授权负责的是控制用户能干什么。管理员和普通员工所能进行的操作肯定是有所差别的。借助于前置认证提供用户身份信息，授权将对用户的操作进行决断。</p><h2 id="访问控制（权限控制）"><a href="#访问控制（权限控制）" class="headerlink" title="访问控制（权限控制）"></a>访问控制（权限控制）</h2><p>授权旨在界定用户能够进行哪些操作，而访问控制正是进行授权界定的措施、手段。该如何实施访问控制呢？看人下菜是最简单、最容易被接受的方式——为每个用户独立地分配权限。但是，就Web应用而言，如此行事的代价将是及其巨大的。动辄几十万、上百万…的用户量，又如何维护得起这般细致的控制呢。而且，每个用户独立设置权限，同时也意味着每个权限需要直接对接百十万的用户。</p><p>撇开可行性，访问控制做的就是这种活计——控制主体（用户）对客体（系统、API等）的操作。</p><p>主要的访问控制技术分为三类：自主访问控制、强制访问控制、基于角色的访问控制</p><h3 id="自主访问控制-Discretionary-Access-Control，DAC"><a href="#自主访问控制-Discretionary-Access-Control，DAC" class="headerlink" title="自主访问控制(Discretionary Access Control，DAC)"></a>自主访问控制(Discretionary Access Control，DAC)</h3><ul><li>每个客体都独立维护一张访问控制表(Access Control List, ACL)</li><li>每个客体都有一个所有者</li><li>所有者可以将其负责的客体访问权限分配给其它用户</li><li>每次主体对客体的访问都面向ACL做确认后执行</li><li>强依赖于所有者对安全要求的认知</li></ul><h3 id="强制访问控制-Mandatory-Access-Control-MAC"><a href="#强制访问控制-Mandatory-Access-Control-MAC" class="headerlink" title="强制访问控制(Mandatory Access Control, MAC)"></a>强制访问控制(Mandatory Access Control, MAC)</h3><ul><li>预置相应的密级，例如绝密级、机密级和普通级。密级有强弱关系</li><li>每个主体/客体都分配一个密级</li><li>每次主体对客体的操作，判定主体密级 &gt;= 客体密级即允许访问</li></ul><h3 id="基于角色的访问控制-Role-Based-Access-Control-RBAC"><a href="#基于角色的访问控制-Role-Based-Access-Control-RBAC" class="headerlink" title="基于角色的访问控制(Role-Based Access Control, RBAC)"></a>基于角色的访问控制(Role-Based Access Control, RBAC)</h3><ul><li>角色作为一系列有较强相关性权限的持有者</li><li>用户通过被分配一系列角色，从而间接地拥有权限集</li></ul><p><em>一般来说，DAC、MAC都不太适合于Web应用的访问控制。因此，后续的讨论都将基于RBAC进行。</em></p><h2 id="控制粒度"><a href="#控制粒度" class="headerlink" title="控制粒度"></a>控制粒度</h2><p>如何定义一个客体，就涉及到控制粒度了。就Web应用而言，比较粗略的有数据粒度、方法粒度、URL粒度、系统粒度等等。任意粒度，都可以作为访问控制的组成部分，作为授权的一部分。但是，粒度的控制也会导致一些相当致命的问题。</p><p>越权问题就是一种粒度控制下的问题。</p><p><strong>纵向访问控制</strong></p><p>顾名思义，纵向访问控制所控制的权限拥有一定的优先级概念，例如管理员操作与普通用户操作。特别适合于使用强制访问控制的解决方案，使用RBAC也并不困难，基本上只要定义两类角色也能解决。业内对于这类问题的解决方案相当成熟，需要的只是根据不同的业务场景进行适配。</p><p><strong>横向访问控制</strong></p><p>对于横向访问控制，问题就不再那么的简单。在方法粒度下的RBAC模型，很容易就会导致A用户事实上访问了B用户数据的问题发生，也就是横向越权。而想要实现数据粒度的通用模型，却又不可避免地将对业务代码进行侵入。</p><p>控制粒度的取舍，就很大程度上取决于Web应用的实际需求。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>认证、授权的基本目的在于满足对安全的基本要求，其涉及的知识相当广泛。本篇的目的，仅仅在于阐释认证、授权两个术语的基本定义，并对访问控制技术做概要式的介绍。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在大多数系统中，都或多或少需要认证授权模型/系统的支持。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;认证/授权是什么？最简单的，我们的系统要求用户必须在“登录”之后才允许进行一些操作。“登录”的过程就是认证；而区别与未登录状态，只允许登录用户进行一些操作，这就是授权。认证与授权相互独立，有协同配合，共同支撑起系统对安全的基本要求。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Authenticate" scheme="https://DorMOUSE-None.github.io/tags/Authenticate/"/>
    
      <category term="Authorize" scheme="https://DorMOUSE-None.github.io/tags/Authorize/"/>
    
  </entry>
  
  <entry>
    <title>理解 Linux Kernel (9) - IO Multiplexing</title>
    <link href="https://DorMOUSE-None.github.io/2019-03-05-understand-Kernel-9/"/>
    <id>https://DorMOUSE-None.github.io/2019-03-05-understand-Kernel-9/</id>
    <published>2019-03-04T16:00:00.000Z</published>
    <updated>2019-03-05T00:58:05.350Z</updated>
    
    <content type="html"><![CDATA[<p><a href="./2019-01-15-understand-Kernel-8/">前一篇</a>已经对 Linux 内核网络相关的内容进行了基础性的介绍。数据从到达网卡，到最终被用户进程获取，最少经过了三个进程/硬中断的配合：网络中断负责将网络接收到的数据读取到内存并添加到 softnet_data 队列，并设置软中断通知内核进程 ksoftirqd；内核进程 ksoftirqd 被调度并处于运行状态，处理位于 softnet_data 中的 <code>struct sock</code> 对象，将其逐级从网络接口层逐级提升到网络层、传输层…最终添加到接收队列 <code>sk_receive_queue</code> 中；用户进程通过 <code>read</code>、<code>recv</code>、<code>recvfrom</code> 等命令检查并获取 <code>sk_receive_queue</code> 中的数据。</p><p>整个流程从概述上可以很轻松地配合进行网络数据交互，但如果要监控多个网络套接字呢？处理流程将变得复杂。我们无法预知哪个套接字能优先接收到数据。因此，最直接的办法就是轮询，在用户程序硬编码，通过设置超时时间的方式尝试获取数据。当然，这个效率就相当低下了。每次试探都需要触发系统调用（要知道这代价可是相当大的），另外超时时间的设置也是一个硬性的阻塞式消耗。</p><p>那么，有没有解决方案呢？当然有。通过用户程序硬编码式的轮询显然是陷入性能瓶颈的根源。因此内核主动提供了轮询式的系统调用（<code>select</code>, <code>poll</code>, <code>epoll</code>）。通过将轮询逻辑下沉到内核态，系统调用就只会有一次，而且超时时间的设置也显得统一。本篇就要就 <code>select</code> 和 <code>epoll</code> 两类系统调用的实现进行探究。</p><a id="more"></a><h2 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h2><p><code>select</code> 是一种比较古老的系统调用方式，存在着许多的调用限制。当然，相对的也就比较容易理解。</p><p><code>select</code> 系统调用最初的逻辑就是对超时时间的相关操作，完成从用户数据段到内核数据段的数据拷贝工作，而使用 <code>copy_from_user</code> 的目的，虽然看似比较晦涩，不如大家在用户程序中普通调用的memcpy，但究其原因，是为了处理MMU相关的问题。将内核复制的数据timeval做一定的取整操作（因为硬件中断的精度可能达不到timeval所描述的粒度，故根据HZ做取整，恰好为时钟中断周期的整数倍）。调用 <code>core_sys_select</code> 进行真正的轮询操作（当然，好像也算不上真正的逻辑，还有一层核心的调用呢）。结束后的操作当然是准备更新timeval。因为进行轮询的结果有两种，一种是因为超时而结束 <code>core_sys_select</code> 函数调用；另一种是得到了一个或多个准备就绪的数据，才结束调用并返回。显然，因为第二种结果而更新timeval有着一定的实际意义——到底等待了多久。不过这里需要注意的是，不是所有的Linux系统都支持对timeval做更新。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_select</span><span class="params">(<span class="keyword">int</span> n, fd_set __user *inp, fd_set __user *outp,</span></span></span><br><span class="line"><span class="function"><span class="params">fd_set __user *<span class="built_in">exp</span>, struct timeval __user *tvp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">s64 timeout = <span class="number">-1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果设置了超时时间 */</span></span><br><span class="line"><span class="keyword">if</span> (tvp) &#123;</span><br><span class="line"><span class="keyword">if</span> (copy_from_user(&amp;tv, tvp, <span class="keyword">sizeof</span>(tv)))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 计时器不能设置为负数 */</span></span><br><span class="line"><span class="keyword">if</span> (tv.tv_sec &lt; <span class="number">0</span> || tv.tv_usec &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Cast to u64 to make GCC stop complaining */</span></span><br><span class="line">        <span class="comment">/* 对 timeout 做一定的处理，根据时钟周期对 usec 进行取整 */</span></span><br><span class="line"><span class="keyword">if</span> ((u64)tv.tv_sec &gt;= (u64)MAX_INT64_SECONDS)</span><br><span class="line">timeout = <span class="number">-1</span>;<span class="comment">/* 无限等待 */</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">timeout = DIV_ROUND_UP(tv.tv_usec, USEC_PER_SEC/HZ);</span><br><span class="line">timeout += tv.tv_sec * HZ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 核心的 select 实现逻辑 */</span></span><br><span class="line">ret = core_sys_select(n, inp, outp, <span class="built_in">exp</span>, &amp;timeout);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果设置了超时时间 */</span></span><br><span class="line"><span class="keyword">if</span> (tvp) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">rtv</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (current-&gt;personality &amp; STICKY_TIMEOUTS)</span><br><span class="line"><span class="keyword">goto</span> sticky;</span><br><span class="line">rtv.tv_usec = jiffies_to_usecs(do_div((*(u64*)&amp;timeout), HZ));</span><br><span class="line">rtv.tv_sec = timeout;</span><br><span class="line"><span class="keyword">if</span> (timeval_compare(&amp;rtv, &amp;tv) &gt;= <span class="number">0</span>)</span><br><span class="line">rtv = tv;</span><br><span class="line">        <span class="comment">/* 内核数据-&gt;用户数据的拷贝，更新距离超时剩余的时间间隔 */</span></span><br><span class="line"><span class="keyword">if</span> (copy_to_user(tvp, &amp;rtv, <span class="keyword">sizeof</span>(rtv))) &#123;</span><br><span class="line">sticky:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 如果应用程序把timeval放在只读内存中，内核就无需特别的更新它</span></span><br><span class="line"><span class="comment"> * If an application puts its timeval in read-only</span></span><br><span class="line"><span class="comment"> * memory, we don't want the Linux-specific update to</span></span><br><span class="line"><span class="comment"> * the timeval to cause a fault after the select has</span></span><br><span class="line"><span class="comment"> * completed successfully. However, because we're not</span></span><br><span class="line"><span class="comment"> * updating the timeval, we can't restart the system</span></span><br><span class="line"><span class="comment"> * call.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (ret == -ERESTARTNOHAND)</span><br><span class="line">ret = -EINTR;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>core_sys_select</code> 也没有太多核心操作，完全是在为三个位图——输入、输出、错误从用户数据段到内核数据段的拷贝工作，以及在结束 <code>do_select</code> 调用后的反向拷贝操作。不过，无论是 <code>sys_select</code> 还是 <code>core_sys_select</code> 都将各自需要完成的工作分割得非常清晰，一个完成timeval的处理工作，另一个完成位图的处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 内核数据-位图的准备，调用do_select完成核心的逻辑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">core_sys_select</span><span class="params">(<span class="keyword">int</span> n, fd_set __user *inp, fd_set __user *outp,</span></span></span><br><span class="line"><span class="function"><span class="params">   fd_set __user *<span class="built_in">exp</span>, s64 *timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fd_set_bits fds;</span><br><span class="line"><span class="keyword">void</span> *bits;</span><br><span class="line"><span class="keyword">int</span> ret, max_fds;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span>;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 在栈中定义较小的数组，减少堆内存的占用，同时可以更快；</span></span><br><span class="line"><span class="comment">     * SELECT_STACK_ALLOC = 256</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">long</span> stack_fds[SELECT_STACK_ALLOC/<span class="keyword">sizeof</span>(<span class="keyword">long</span>)];</span><br><span class="line"></span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out_nofds;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* max_fds can increase, so grab it once to avoid race */</span></span><br><span class="line">    <span class="comment">/* max_fds 可能同时在增加，所以提前获取一份固定的拷贝避免竞争 */</span></span><br><span class="line">rcu_read_lock();</span><br><span class="line">    <span class="comment">/* 获取当前任务的文件描述符表 */</span></span><br><span class="line">fdt = files_fdtable(current-&gt;files);</span><br><span class="line">max_fds = fdt-&gt;max_fds;</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"><span class="keyword">if</span> (n &gt; max_fds)</span><br><span class="line">n = max_fds;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We need 6 bitmaps (in/out/ex for both incoming and outgoing),</span></span><br><span class="line"><span class="comment"> * since we used fdset we need to allocate memory in units of</span></span><br><span class="line"><span class="comment"> * long-words.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">size = FDS_BYTES(n);</span><br><span class="line">bits = stack_fds;</span><br><span class="line"><span class="keyword">if</span> (size &gt; <span class="keyword">sizeof</span>(stack_fds) / <span class="number">6</span>) &#123;</span><br><span class="line"><span class="comment">/* Not enough space in on-stack array; must use kmalloc */</span></span><br><span class="line">        <span class="comment">/* 栈数组大小不足；使用 kmalloc 获取新的空间 */</span></span><br><span class="line">ret = -ENOMEM;</span><br><span class="line">bits = kmalloc(<span class="number">6</span> * size, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!bits)</span><br><span class="line"><span class="keyword">goto</span> out_nofds;</span><br><span class="line">&#125;</span><br><span class="line">fds.in      = bits;</span><br><span class="line">fds.out     = bits +   size;</span><br><span class="line">fds.ex      = bits + <span class="number">2</span>*size;</span><br><span class="line">fds.res_in  = bits + <span class="number">3</span>*size;</span><br><span class="line">fds.res_out = bits + <span class="number">4</span>*size;</span><br><span class="line">fds.res_ex  = bits + <span class="number">5</span>*size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 用户数据段的数据 inp、outp、exp 往内核数据段 fds.xxx 拷贝 */</span></span><br><span class="line"><span class="keyword">if</span> ((ret = get_fd_set(n, inp, fds.in)) ||</span><br><span class="line">    (ret = get_fd_set(n, outp, fds.out)) ||</span><br><span class="line">    (ret = get_fd_set(n, <span class="built_in">exp</span>, fds.ex)))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">    <span class="comment">/* fds.res_xxx 作为 do_select 的执行结果，预置为0，表示每一位相应的fd都未准备就绪 */</span></span><br><span class="line">zero_fd_set(n, fds.res_in);</span><br><span class="line">zero_fd_set(n, fds.res_out);</span><br><span class="line">zero_fd_set(n, fds.res_ex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 交由 do_select 完成真正核心的操作 */</span></span><br><span class="line">ret = do_select(n, &amp;fds, timeout);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">ret = -ERESTARTNOHAND;</span><br><span class="line"><span class="keyword">if</span> (signal_pending(current))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将结果集拷贝回用户数据段的 inp、outp、exp 中 */</span></span><br><span class="line"><span class="keyword">if</span> (set_fd_set(n, inp, fds.res_in) ||</span><br><span class="line">    set_fd_set(n, outp, fds.res_out) ||</span><br><span class="line">    set_fd_set(n, <span class="built_in">exp</span>, fds.res_ex))</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="keyword">if</span> (bits != stack_fds)</span><br><span class="line">kfree(bits);</span><br><span class="line">out_nofds:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于是核心的逻辑了，逐一地将当前任务挂到相应文件的等待队列上，并等待调用 <code>poll</code> 函数被唤醒</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_select</span><span class="params">(<span class="keyword">int</span> n, fd_set_bits *fds, s64 *timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> <span class="title">table</span>;</span></span><br><span class="line">poll_table *wait;</span><br><span class="line"><span class="keyword">int</span> retval, i;</span><br><span class="line"></span><br><span class="line">rcu_read_lock();</span><br><span class="line">    <span class="comment">/* 确认fds.xxx所需轮询的fd全部全部处于打开状态，同时返回最大的fd */</span></span><br><span class="line">retval = max_select_fd(n, fds);</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">n = retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 把当前任务放入自己的等待队列中 */</span></span><br><span class="line">poll_initwait(&amp;table);</span><br><span class="line">wait = &amp;table.pt;</span><br><span class="line">    <span class="comment">/* 如果超时时间为0，即无需等待 */</span></span><br><span class="line"><span class="keyword">if</span> (!*timeout)</span><br><span class="line">wait = <span class="literal">NULL</span>;</span><br><span class="line">retval = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 无限循环 */</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *rinp, *routp, *rexp, *inp, *outp, *<span class="built_in">exp</span>;</span><br><span class="line"><span class="keyword">long</span> __timeout;</span><br><span class="line"></span><br><span class="line">set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line"></span><br><span class="line">inp = fds-&gt;in; outp = fds-&gt;out; <span class="built_in">exp</span> = fds-&gt;ex;</span><br><span class="line">rinp = fds-&gt;res_in; routp = fds-&gt;res_out; rexp = fds-&gt;res_ex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++rinp, ++routp, ++rexp) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> in, out, ex, all_bits, bit = <span class="number">1</span>, mask, j;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> res_in = <span class="number">0</span>, res_out = <span class="number">0</span>, res_ex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">f_op</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">in = *inp++; out = *outp++; ex = *<span class="built_in">exp</span>++;</span><br><span class="line">all_bits = in | out | ex;</span><br><span class="line"><span class="keyword">if</span> (all_bits == <span class="number">0</span>) &#123;</span><br><span class="line">i += __NFDBITS;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 对 unsigned long 的每一位进行确认 */</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; __NFDBITS; ++j, ++i, bit &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> fput_needed;</span><br><span class="line">                <span class="comment">/* 超过需检测的最大的文件描述符 */</span></span><br><span class="line"><span class="keyword">if</span> (i &gt;= n)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">/* 该 fd 无需检测，直接下一个 */</span></span><br><span class="line"><span class="keyword">if</span> (!(bit &amp; all_bits))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">/* 获取相应的文件实例 */</span></span><br><span class="line">file = fget_light(i, &amp;fput_needed);</span><br><span class="line"><span class="keyword">if</span> (file) &#123;</span><br><span class="line">f_op = file-&gt;f_op;</span><br><span class="line">mask = DEFAULT_POLLMASK;</span><br><span class="line">                    <span class="comment">/* 对于套接字，调用的是sock_poll，在poll成功时将唤醒wait队列的任务（即把当前任务唤醒）*/</span></span><br><span class="line"><span class="keyword">if</span> (f_op &amp;&amp; f_op-&gt;poll)</span><br><span class="line">mask = (*f_op-&gt;poll)(file, retval ? <span class="literal">NULL</span> : wait);</span><br><span class="line">fput_light(file, fput_needed);</span><br><span class="line"><span class="keyword">if</span> ((mask &amp; POLLIN_SET) &amp;&amp; (in &amp; bit)) &#123;</span><br><span class="line">res_in |= bit;</span><br><span class="line">retval++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((mask &amp; POLLOUT_SET) &amp;&amp; (out &amp; bit)) &#123;</span><br><span class="line">res_out |= bit;</span><br><span class="line">retval++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((mask &amp; POLLEX_SET) &amp;&amp; (ex &amp; bit)) &#123;</span><br><span class="line">res_ex |= bit;</span><br><span class="line">retval++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">                <span class="comment">/* 主动让出CPU片，等待重新调度（提前设置了最高优先级PREEMPT_ACTIVE）*/</span></span><br><span class="line">cond_resched();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (res_in)</span><br><span class="line">*rinp = res_in;</span><br><span class="line"><span class="keyword">if</span> (res_out)</span><br><span class="line">*routp = res_out;</span><br><span class="line"><span class="keyword">if</span> (res_ex)</span><br><span class="line">*rexp = res_ex;</span><br><span class="line">&#125;</span><br><span class="line">wait = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (retval || !*timeout || signal_pending(current))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>(table.error) &#123;</span><br><span class="line">retval = table.error;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/* Wait indefinitely */</span></span><br><span class="line">__timeout = MAX_SCHEDULE_TIMEOUT;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlikely(*timeout &gt;= (s64)MAX_SCHEDULE_TIMEOUT - <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="comment">/* Wait for longer than MAX_SCHEDULE_TIMEOUT. Do it in a loop */</span></span><br><span class="line">__timeout = MAX_SCHEDULE_TIMEOUT - <span class="number">1</span>;</span><br><span class="line">*timeout -= __timeout;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">__timeout = *timeout;</span><br><span class="line">*timeout = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">/* 进入延时唤醒状态，待定预定的超时时间 */</span></span><br><span class="line">__timeout = schedule_timeout(__timeout);</span><br><span class="line"><span class="keyword">if</span> (*timeout &gt;= <span class="number">0</span>)</span><br><span class="line">*timeout += __timeout;</span><br><span class="line">&#125;</span><br><span class="line">__set_current_state(TASK_RUNNING);</span><br><span class="line"></span><br><span class="line">poll_freewait(&amp;table);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结来看，<code>select</code> 完全能够支持IO多路复用。至少比用户程序自行实现轮询优秀得多。但是，也存在着一些明显的缺陷：</p><ol><li>支持的文件描述符存在上限，默认是1024。</li><li>每次陷入内核态 <code>select</code> 函数之后，都需要按位遍历所有的文件描述符（无论该fd是否存在），max(fd)越大，开销越大。</li><li>每次调用 <code>select</code> 都需要将fd集合从用户态复制到内核态，max(fd)越大，开销越大。</li></ol><h2 id="EPOLL"><a href="#EPOLL" class="headerlink" title="EPOLL"></a>EPOLL</h2><p>简单地描述过 <code>select</code> 系统调用之后，我们着重来聊一聊 <code>epoll</code> 的实现。毕竟 <code>select</code> 和 <code>poll</code> 的复杂度是 $O(N)$，而 <code>epoll</code> 只是 $O(\log{N})$ （当然，这里对时间复杂度的比较维度不同，稍候细讲）。<code>epoll</code> 区别于传统I/O复用模型的最大特色在于：它将创建并维护一个 <code>eventpoll</code> 实例，并通过注册请 <code>epoll</code> 对新的文件描述符进行监听，这意味着数据从用户数据区到内核数据区的拷贝只有一次；相对的，传统方式在每次轮询时，都需要全量地将数据从用户数据区拷贝到内核数据区。 </p><h3 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a><code>epoll_create</code></h3><p><code>epoll_create</code> 负责创建一个新的 <code>eventpoll</code> 实例。这里的size并没有实际意义（由于历史原因而存在），传入的参数将被忽略。看源码总是件有意思的事，这个size被描述成了检查精神健全的标志…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> error, fd = <span class="number">-1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line"></span><br><span class="line">DNPRINTK(<span class="number">3</span>, (KERN_INFO <span class="string">"[%p] eventpoll: sys_epoll_create(%d)\n"</span>,</span><br><span class="line">     current, size));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 精神健全检测(size)；同时建立内部数据结构 struct eventpoll</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">error = -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (size &lt;= <span class="number">0</span> || (error = ep_alloc(&amp;ep)) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> error_return;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 创建一个新的文件描述符，文件数据结构和i节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">error = anon_inode_getfd(&amp;fd, &amp;inode, &amp;file, <span class="string">"[eventpoll]"</span>,</span><br><span class="line"> &amp;eventpoll_fops, ep);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">goto</span> error_free;</span><br><span class="line"></span><br><span class="line">DNPRINTK(<span class="number">3</span>, (KERN_INFO <span class="string">"[%p] eventpoll: sys_epoll_create(%d) = %d\n"</span>,</span><br><span class="line">     current, size, fd));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fd;</span><br><span class="line"></span><br><span class="line">error_free:</span><br><span class="line">ep_free(ep);</span><br><span class="line">error_return:</span><br><span class="line">DNPRINTK(<span class="number">3</span>, (KERN_INFO <span class="string">"[%p] eventpoll: sys_epoll_create(%d) = %d\n"</span>,</span><br><span class="line">     current, size, error));</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g0qi7lrtgzj31eu0u075i.jpg" alt="Epoll Create | Model"></p><h3 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a><code>epoll_ctl</code></h3><p><code>epoll_ctl</code> 顾名思义——<code>epoll</code>控制器，用于增加、修改、删除监听的事件。这里 <code>epfd</code> 用于找到 <code>eventpoll</code> 实例，<code>fd</code> 表示需要监听的文件描述符，<code>op</code> 区分增删改，<code>event</code> 表示监听的具体事件描述。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd,</span></span></span><br><span class="line"><span class="function"><span class="params">      struct epoll_event __user *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> error;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>, *<span class="title">tfile</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epds</span>;</span></span><br><span class="line"></span><br><span class="line">DNPRINTK(<span class="number">3</span>, (KERN_INFO <span class="string">"[%p] eventpoll: sys_epoll_ctl(%d, %d, %d, %p)\n"</span>,</span><br><span class="line">     current, epfd, op, fd, event));</span><br><span class="line"></span><br><span class="line">error = -EFAULT;</span><br><span class="line">    <span class="comment">/* 如果是增改操作，需要把事件描述拷贝到内核数据区; 删除操作不需要 */</span></span><br><span class="line"><span class="keyword">if</span> (ep_op_has_event(op) &amp;&amp;</span><br><span class="line">    copy_from_user(&amp;epds, event, <span class="keyword">sizeof</span>(struct epoll_event)))</span><br><span class="line"><span class="keyword">goto</span> error_return;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the "struct file *" for the eventpoll file */</span></span><br><span class="line">error = -EBADF;</span><br><span class="line">file = fget(epfd);</span><br><span class="line"><span class="keyword">if</span> (!file)</span><br><span class="line"><span class="keyword">goto</span> error_return;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the "struct file *" for the target file */</span></span><br><span class="line">tfile = fget(fd);</span><br><span class="line"><span class="keyword">if</span> (!tfile)</span><br><span class="line"><span class="keyword">goto</span> error_fput;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 需要监听的文件描述符必须支持文件操作 poll */</span></span><br><span class="line">error = -EPERM;</span><br><span class="line"><span class="keyword">if</span> (!tfile-&gt;f_op || !tfile-&gt;f_op-&gt;poll)</span><br><span class="line"><span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 需要确保不能把epfd作为被监听的fd加入 */</span></span><br><span class="line">error = -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (file == tfile || !is_file_epoll(file))</span><br><span class="line"><span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 这里的文件描述符一定是指eventpoll实例对应的文件描述符</span></span><br><span class="line"><span class="comment">     * 因此直接从中拿私有数据--预定义的*eventpoll</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">ep = file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;ep-&gt;mtx);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 从RB树中查找已经维护起来的监听事件</span></span><br><span class="line"><span class="comment">     * 当然，必须先把这个RB树结构锁定，防止查找时结构改变</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">epi = ep_find(ep, tfile, fd);</span><br><span class="line"></span><br><span class="line">error = -EINVAL;</span><br><span class="line"><span class="keyword">switch</span> (op) &#123;</span><br><span class="line"><span class="keyword">case</span> EPOLL_CTL_ADD:     <span class="comment">// 新增监听</span></span><br><span class="line"><span class="keyword">if</span> (!epi) &#123;</span><br><span class="line">epds.events |= POLLERR | POLLHUP;</span><br><span class="line"></span><br><span class="line">error = ep_insert(ep, &amp;epds, tfile, fd);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">error = -EEXIST;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EPOLL_CTL_DEL:     <span class="comment">// 删除监听</span></span><br><span class="line"><span class="keyword">if</span> (epi)</span><br><span class="line">error = ep_remove(ep, epi);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">error = -ENOENT;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EPOLL_CTL_MOD:     <span class="comment">// 修改监听</span></span><br><span class="line"><span class="keyword">if</span> (epi) &#123;</span><br><span class="line">epds.events |= POLLERR | POLLHUP;</span><br><span class="line">error = ep_modify(ep, epi, &amp;epds);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">error = -ENOENT;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">mutex_unlock(&amp;ep-&gt;mtx);</span><br><span class="line"></span><br><span class="line">error_tgt_fput:</span><br><span class="line">fput(tfile);</span><br><span class="line">error_fput:</span><br><span class="line">fput(file);</span><br><span class="line">error_return:</span><br><span class="line">DNPRINTK(<span class="number">3</span>, (KERN_INFO <span class="string">"[%p] eventpoll: sys_epoll_ctl(%d, %d, %d, %p) = %d\n"</span>,</span><br><span class="line">     current, epfd, op, fd, event, error));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的核心操作，就是往 <code>eventpoll</code> 实例中增删改监听的事件。以 <code>ep_insert</code> 为例，先看看怎么新增监听。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 实例化 epitem */</span></span><br><span class="line"><span class="keyword">if</span> (!(epi = kmem_cache_alloc(epi_cache, GFP_KERNEL)))</span><br><span class="line">    <span class="keyword">goto</span> error_return;</span><br><span class="line"><span class="comment">/* 对 epitem 实例进行初始化数据 */</span></span><br><span class="line">ep_rb_initnode(&amp;epi-&gt;rbn);</span><br><span class="line">INIT_LIST_HEAD(&amp;epi-&gt;rdllink);</span><br><span class="line">INIT_LIST_HEAD(&amp;epi-&gt;fllink);</span><br><span class="line">INIT_LIST_HEAD(&amp;epi-&gt;pwqlist);</span><br><span class="line">epi-&gt;ep = ep;</span><br><span class="line"><span class="comment">/* 构建struct epoll_filefd，作为rb_tree比较不同的key */</span></span><br><span class="line">ep_set_ffd(&amp;epi-&gt;ffd, tfile, fd);</span><br><span class="line">epi-&gt;event = *event;</span><br><span class="line">epi-&gt;nwait = <span class="number">0</span>;</span><br><span class="line">epi-&gt;next = EP_UNACTIVE_PTR;</span><br></pre></td></tr></table></figure><p>接下来要接触的就是一段比较烧脑的逻辑。</p><p><code>poll_table</code> 是在 VFS 实现中相当重要的一个数据结构，用来与<code>poll</code>配合（这里的<code>poll</code>是指文件操作中的，而不是<code>poll()</code>系统调用）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_struct</span> &#123;</span></span><br><span class="line">poll_queue_proc _qproc;</span><br><span class="line">&#125; poll_table;</span><br></pre></td></tr></table></figure><p>其中<code>poll_queue_proc</code>是一个函数指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*poll_queue_proc)</span><span class="params">(struct file *, <span class="keyword">wait_queue_head_t</span> *, struct poll_table_struct *)</span></span>;</span><br></pre></td></tr></table></figure><p>为了让 <code>epitem</code> 更方便地追踪 <code>poll_queue_proc</code>，<code>epoll_ctl</code> 中使用了一个 <code>ep_pqueue</code> 的数据结构来包装 <code>poll_table</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 使用 queue 回调函数初始化 poll table */</span></span><br><span class="line">epq.epi = epi;</span><br><span class="line">init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g0qwphhnz0j30xa0o6aan.jpg" alt=""></p><p>之后就是把这个 <code>poll_table</code> 作为钩子方法挂载到被监控的文件上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">revents = tfile-&gt;f_op-&gt;poll(tfile, &amp;epq.pt);</span><br></pre></td></tr></table></figure><p>这里以 <code>tcp_poll</code> 为例，先看看这段逻辑怎么实现的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sock_poll</span><span class="params">(struct file *file, poll_table *wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">    <span class="comment">/* 获取 struct sock 内核套接字数据结构 */</span></span><br><span class="line">    sock = file-&gt;private_data;</span><br><span class="line">    <span class="keyword">return</span> sock-&gt;ops-&gt;poll(file, sock, wait);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">tcp_poll</span><span class="params">(struct file *file, struct socket *sock, poll_table *wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> mask;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = <span class="title">sock</span>-&gt;<span class="title">sk</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> = <span class="title">tcp_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这里将调用 poll_table *wait 维护的回调函数</span></span><br><span class="line"><span class="comment">     * 将持有 eventpoll 实例的进程注册到 sk 的等待队列中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">poll_wait(file, sk-&gt;sk_sleep, wait);</span><br><span class="line"><span class="keyword">if</span> (sk-&gt;sk_state == TCP_LISTEN)</span><br><span class="line"><span class="keyword">return</span> inet_csk_listen_poll(sk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这里省略了部分逻辑，主要是负责处理 struct sock 接收到的事件</span></span><br><span class="line"><span class="comment">     * 处理成 mask 并返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">poll_wait</span><span class="params">(struct file * filp, <span class="keyword">wait_queue_head_t</span> * wait_address, poll_table *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &amp;&amp; wait_address)</span><br><span class="line">        p-&gt;qproc(filp, wait_address, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看epoll定义的回调函数的实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ep_ptable_queue_proc</span><span class="params">(struct file *file, <span class="keyword">wait_queue_head_t</span> *whead,</span></span></span><br><span class="line"><span class="function"><span class="params"> poll_table *pt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span> = <span class="title">ep_item_from_epqueue</span>(<span class="title">pt</span>);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eppoll_entry</span> *<span class="title">pwq</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (epi-&gt;nwait &gt;= <span class="number">0</span> &amp;&amp; (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) &#123;</span><br><span class="line">init_waitqueue_func_entry(&amp;pwq-&gt;wait, ep_poll_callback);</span><br><span class="line">pwq-&gt;whead = whead;</span><br><span class="line">pwq-&gt;base = epi;</span><br><span class="line">        <span class="comment">/* 添加到 struct sock 等待队列队首 */</span></span><br><span class="line">add_wait_queue(whead, &amp;pwq-&gt;wait);</span><br><span class="line">list_add_tail(&amp;pwq-&gt;llink, &amp;epi-&gt;pwqlist);</span><br><span class="line">epi-&gt;nwait++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* We have to signal that an error occurred */</span></span><br><span class="line">epi-&gt;nwait = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，<code>ep_insert</code> 核心的逻辑已经介绍完毕。主要就是将当前的 <code>eventpoll</code> 实例注册到监听目标（文件描述符）的等待队列上，并注册<code>ep_poll_callback</code>作为回调函数。回调函数实现是怎样呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_poll_callback</span><span class="params">(<span class="keyword">wait_queue_t</span> *wait, <span class="keyword">unsigned</span> mode, <span class="keyword">int</span> sync, <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pwake = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="comment">/* 获取 wait 结构维护的 epitem 实例 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span> = <span class="title">ep_item_from_wait</span>(<span class="title">wait</span>);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span> = <span class="title">epi</span>-&gt;<span class="title">ep</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... code omitted...</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 把当前的 epitem 实例添加到 eventpoll 实例的就绪队列中 </span></span><br><span class="line"><span class="comment">     * 这是显然的，毕竟此回调函数只有在fd准备就绪后被回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line"></span><br><span class="line">is_linked:</span><br><span class="line">    <span class="comment">/* 如果 wait 结构维护的进程处于Sleeping状态，则将其唤醒并加入任务就绪队列 */</span></span><br><span class="line"><span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">__wake_up_locked(&amp;ep-&gt;wq, TASK_UNINTERRUPTIBLE |</span><br><span class="line"> TASK_INTERRUPTIBLE);</span><br><span class="line"><span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">pwake++;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We have to call this outside the lock */</span></span><br><span class="line"><span class="keyword">if</span> (pwake)</span><br><span class="line">ep_poll_safewake(&amp;psw, &amp;ep-&gt;poll_wait);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a><code>epoll_wait</code></h3><p>处理完所有的监听事件的维护，用户程序需要通过 <code>epoll_wait</code> 与 <code>eventpoll</code> 实例进行交互，并被告知所有正在监听中的事件是否发生。由于 <code>epoll_wait</code> 的整个逻辑基本上都是在进行错误检测，此处不表。我们只关注其中的核心逻辑，即调用的 <code>ep_poll</code> 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_poll</span><span class="params">(struct eventpoll *ep, struct epoll_event __user *events,</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">int</span> maxevents, <span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res, eavail;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"><span class="keyword">long</span> jtimeout;</span><br><span class="line"><span class="keyword">wait_queue_t</span> wait;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Calculate the timeout by checking for the "infinite" value ( -1 )</span></span><br><span class="line"><span class="comment"> * and the overflow condition. The passed timeout is in milliseconds,</span></span><br><span class="line"><span class="comment"> * that why (t * HZ) / 1000.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jtimeout = (timeout &lt; <span class="number">0</span> || timeout &gt;= EP_MAX_MSTIMEO) ?</span><br><span class="line">MAX_SCHEDULE_TIMEOUT : (timeout * HZ + <span class="number">999</span>) / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 如果 eventpoll 实例的就绪队列为空，表明有没任何监听的事件发生。</span></span><br><span class="line"><span class="comment">     * 主动让进程陷入Sleeping状态，知道被 ep_poll_callback() 唤醒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (list_empty(&amp;ep-&gt;rdllist)) &#123;</span><br><span class="line">init_waitqueue_entry(&amp;wait, current);</span><br><span class="line">wait.flags |= WQ_FLAG_EXCLUSIVE;</span><br><span class="line">__add_wait_queue(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We don't want to sleep if the ep_poll_callback() sends us</span></span><br><span class="line"><span class="comment"> * a wakeup in between. That's why we set the task state</span></span><br><span class="line"><span class="comment"> * to TASK_INTERRUPTIBLE before doing the checks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line"><span class="keyword">if</span> (!list_empty(&amp;ep-&gt;rdllist) || !jtimeout)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">res = -EINTR;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line">            <span class="comment">/* 主动陷入Sleeping状态 */</span></span><br><span class="line">jtimeout = schedule_timeout(jtimeout);</span><br><span class="line">spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">__remove_wait_queue(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line"></span><br><span class="line">set_current_state(TASK_RUNNING);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Is it worth to try to dig for events ? */</span></span><br><span class="line">eavail = !list_empty(&amp;ep-&gt;rdllist);</span><br><span class="line"></span><br><span class="line">spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 将监听到的事件拷贝到用户空间。如果没有事件就绪且还没超时，就再抱着</span></span><br><span class="line"><span class="comment">     * 希望试一次。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!res &amp;&amp; eavail &amp;&amp;</span><br><span class="line">    !(res = ep_send_events(ep, events, maxevents)) &amp;&amp; jtimeout)</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>这部分的数据结构配合着一些胶水代码比较难以理解，最好配合着类图看看（个人使用，不一定适合各位）</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1g0rmx65dzhj324y0t8di4.jpg" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>Linux Kernel 2.6.24</li><li><a href="https://idndx.com/2014/09/01/the-implementation-of-epoll-1/" target="_blank" rel="noopener">The Implementation of epoll(1)</a></li><li><a href="https://idndx.com/2014/09/02/the-implementation-of-epoll-2/" target="_blank" rel="noopener">The Implementation of epoll(2)</a></li><li><a href="https://idndx.com/2014/09/22/the-implementation-of-epoll-3/" target="_blank" rel="noopener">The Implementation of epoll(3)</a></li><li><a href="https://idndx.com/2015/07/08/the-implementation-of-epoll-4/" target="_blank" rel="noopener">The Implementation of epoll(4)</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;./2019-01-15-understand-Kernel-8/&quot;&gt;前一篇&lt;/a&gt;已经对 Linux 内核网络相关的内容进行了基础性的介绍。数据从到达网卡，到最终被用户进程获取，最少经过了三个进程/硬中断的配合：网络中断负责将网络接收到的数据读取到内存并添加到 softnet_data 队列，并设置软中断通知内核进程 ksoftirqd；内核进程 ksoftirqd 被调度并处于运行状态，处理位于 softnet_data 中的 &lt;code&gt;struct sock&lt;/code&gt; 对象，将其逐级从网络接口层逐级提升到网络层、传输层…最终添加到接收队列 &lt;code&gt;sk_receive_queue&lt;/code&gt; 中；用户进程通过 &lt;code&gt;read&lt;/code&gt;、&lt;code&gt;recv&lt;/code&gt;、&lt;code&gt;recvfrom&lt;/code&gt; 等命令检查并获取 &lt;code&gt;sk_receive_queue&lt;/code&gt; 中的数据。&lt;/p&gt;
&lt;p&gt;整个流程从概述上可以很轻松地配合进行网络数据交互，但如果要监控多个网络套接字呢？处理流程将变得复杂。我们无法预知哪个套接字能优先接收到数据。因此，最直接的办法就是轮询，在用户程序硬编码，通过设置超时时间的方式尝试获取数据。当然，这个效率就相当低下了。每次试探都需要触发系统调用（要知道这代价可是相当大的），另外超时时间的设置也是一个硬性的阻塞式消耗。&lt;/p&gt;
&lt;p&gt;那么，有没有解决方案呢？当然有。通过用户程序硬编码式的轮询显然是陷入性能瓶颈的根源。因此内核主动提供了轮询式的系统调用（&lt;code&gt;select&lt;/code&gt;, &lt;code&gt;poll&lt;/code&gt;, &lt;code&gt;epoll&lt;/code&gt;）。通过将轮询逻辑下沉到内核态，系统调用就只会有一次，而且超时时间的设置也显得统一。本篇就要就 &lt;code&gt;select&lt;/code&gt; 和 &lt;code&gt;epoll&lt;/code&gt; 两类系统调用的实现进行探究。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://DorMOUSE-None.github.io/tags/Linux/"/>
    
      <category term="Kernel" scheme="https://DorMOUSE-None.github.io/tags/Kernel/"/>
    
      <category term="IO Model" scheme="https://DorMOUSE-None.github.io/tags/IO-Model/"/>
    
  </entry>
  
  <entry>
    <title>【Java】API 参数误定义的后果</title>
    <link href="https://DorMOUSE-None.github.io/2019-02-27-Java-Fatal-API/"/>
    <id>https://DorMOUSE-None.github.io/2019-02-27-Java-Fatal-API/</id>
    <published>2019-02-26T16:00:00.000Z</published>
    <updated>2019-02-27T22:55:02.662Z</updated>
    
    <content type="html"><![CDATA[<p>工程项目中，定义 API 总是一个慎之又慎的操作。不能少，不满足调用方的需求就惨了；也不能多，不然就乱套了，自己维护困难，调用方也开始了自我发挥。虽然足够慎重，但绝大多数都逃不过最终不得不“改” API 的情况。今天要讨论的是在同一个类内同方法名不同参数（入参/出参）的情况。</p><p>想要做到同方法名不同入参，很简单，就是“重载（Overload）”，日常都在使用。不再赘述！</p><p>想要做到同方法名不同出参，答案就不再那么肯定了。当然，如果问把<code>void add(int)</code> API 改写成 <code>int add(int)</code>，可能得到的大多数回答都是可以。</p><a id="more"></a><h2 id="看山是山"><a href="#看山是山" class="headerlink" title="看山是山"></a>看山是山</h2><p>首先举一个具体点的例子来描述（为了方便，就不定义<code>CountService</code>的接口类了）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ffutop.signature;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fangfeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019-02-26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CountService countService = <span class="keyword">new</span> CountService();</span><br><span class="line">        countService.add(<span class="number">1</span>);</span><br><span class="line">        System.out.println(String.format(<span class="string">"currentValue = %d"</span>, countService.getCurrentValue()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ffutop.signature;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fangfeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019-02-26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentValue = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请把 add(int) 理解成 API</span></span><br><span class="line"><span class="comment">     * 虽然已经做了实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> addend)</span> </span>&#123;</span><br><span class="line">        currentValue += addend;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCurrentValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在已经有 <code>void add(int)</code> 方法，完成的工作是累加。现在要把 API 改成 <code>int add(int)</code>，是否可以呢？看似本来没有返回值，现在只是加上一个返回值，对于原来的代码没有任何问题，而新代码又能拿到int类型的返回值，皆大欢喜啊。</p><h2 id="看山不是山"><a href="#看山不是山" class="headerlink" title="看山不是山"></a>看山不是山</h2><p>先给大家执行下代码吧！（请严格按照顺序，且避免使用IDE，否则将得不到预想的结果）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> # 准备好两个类的代码（CountService的API是 `void add(int)`）</span><br><span class="line"><span class="meta">$</span> # 编译Main类</span><br><span class="line"><span class="meta">$</span> javac com/ffutop/signature/Main.java</span><br><span class="line"><span class="meta">$</span>  </span><br><span class="line"><span class="meta">$</span> # 修改CountService的API为`int add(int)`</span><br><span class="line"><span class="meta">$</span> # 编译 CountService 类</span><br><span class="line"><span class="meta">$</span> javac com/ffutop/signature/CountService.java</span><br><span class="line"><span class="meta">$</span> </span><br><span class="line"><span class="meta">$</span> # 执行主程序</span><br><span class="line"><span class="meta">$</span> java com.ffutop.signature.Main</span><br><span class="line">Exception in thread "main" java.lang.NoSuchMethodError: com.ffutop.signature.CountService.add(I)V</span><br><span class="line">at com.ffutop.signature.Main.main(Main.java:11)</span><br></pre></td></tr></table></figure><p>很遗憾，执行失败了，报了个Error（没有这样的方法）。方法写的是 <code>com.ffutop.signature.CountService.add(I)V</code> 。简单的翻译一下就是需要<code>类名+方法名=x.y.CountService.add</code>，且入参为int，出参为void的方法（想了解更多请优先学习<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.4" target="_blank" rel="noopener">Java ClassFile Format</a>）。</p><p>那么，现在得到的结论是不行。</p><h2 id="看山还是山"><a href="#看山还是山" class="headerlink" title="看山还是山"></a>看山还是山</h2><p>那么，就一定不行吗？都是同名方法，不同参数。凭什么改个入参是可以的，改个出参就不行了。</p><p>从 Java 的角度来说，一定不行。“同一类中不能存在两个名字及描述符完全相同的方法”</p><p>但是，如果从 JVM 的角度来说，完全是可行的。“在class文件中，两个方法可以拥有完全相同的特征签名，前提是返回值不能相同”</p><p>什么意思呢？我们都知道建立在 JVM 之上的语言不只有 Java。像 Groovy、Kotlin 等语言都实现了各自的区别于 Java 独有的特征。这些特征的实现都是依赖于 JVM，但为什么 Java 没有呢？只能说 Java 语言的规范是 JVM 的子集（好像这话有点不严谨啊）</p><p>通过直接操作字节码，就能够达到在同一个类中建立两个同名、相同入参，但返回值不同的方法。<br>先通过<code>javap</code>命令看看最终提供的<code>CountService.class</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> javap com.ffutop.signature.CountService</span><br><span class="line">public class com.ffutop.signature.CountService &#123;</span><br><span class="line">  public int add(int);</span><br><span class="line">  public com.ffutop.signature.CountService();</span><br><span class="line">  public void add(int);</span><br><span class="line">  public int getCurrentValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有两个同名的方法<code>add(int)</code>，至于执行，也会相当顺利。</p><p>还是写个程序来说明，在原有 <code>Main.java</code> 的基础上，再创建一个全限定名为 <code>com.ffutop.signature.other.Main2</code> 的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ffutop.signature.other;</span><br><span class="line"><span class="keyword">import</span> com.ffutop.signature.CountService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fangfeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019-02-27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CountService countService = <span class="keyword">new</span> CountService();</span><br><span class="line">        System.out.println(String.format(<span class="string">"currentValue = %d"</span>, countService.add(<span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与 Main.java 比较，很明显的就是一个调用了 <code>CountService</code> 的 <code>int add(int)</code> 方法，而另一个调用 <code>void add(int)</code> 方法。</p><p>那么是否有效呢？先来验证一下（这里要模拟的一个场景是，CountService 类(只有 <code>void add(int)</code> 方法)作为二方库C.jar version 1.0 的主要服务类。CountService 类(同时有 <code>void add(int)</code> 和 <code>int add(int)</code> 方法)作为二方库C.jar version 2.0 的主要服务类。Main 类根据 C.jar version 1.0 做的编译，而 Main2 类根据 C.jar version 2.0 做的编译。在 Main 和 Main2 类运行时只提供 C.jar version 2.0）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> # 编译 Main 类和 CountService 类</span><br><span class="line"><span class="meta">$</span> javac com/ffutop/signature/Main.java</span><br><span class="line"><span class="meta">$</span></span><br><span class="line"><span class="meta">$</span> # 操作 CountService.class 字节码，增加方法 `int add(int)` </span><br><span class="line"><span class="meta">$</span> # 通过 ASM 实现，详见附录源码 com/ffutop/signature/support/Generator.java</span><br><span class="line"><span class="meta">$</span> </span><br><span class="line"><span class="meta">$</span> # 编译 Main2 类 (提供 classpath，即根据 CountService.class 编译)</span><br><span class="line"><span class="meta">$</span> javac com/ffutop/signature/other/Main2.java -classpath .</span><br><span class="line"><span class="meta">$</span></span><br><span class="line"><span class="meta">$</span> # 验证</span><br><span class="line"><span class="meta">$</span> java com.ffutop.signature.Main</span><br><span class="line">currentValue = 1</span><br><span class="line"><span class="meta">$</span> java com.ffutop.signature.other.Main2</span><br><span class="line">currentValue = 1</span><br><span class="line"><span class="meta">$</span> # OK，验证通过</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一旦 API 定义错误，并已经作为二方库提供给调用方。后果必然是灾难性的。至少，只能重新定义 API 。如果对于入参定义错误，Java 语言级别也能够支持。但如果是返回值，如果非要保持方法名一致，那就不得不下沉到 JVM 级别来进行处理了。当然，在工程项目中是否应该直接操作字节码？至少个人还没直接接触过。</p><p>做个记录，未来可以翻一翻，至少是一种可行的解决方案。</p><p>Update: 如果直接操作字节码为添加了不同返回值的同名同参数方法，可能引起调用方静态编译失败。此操作需慎之又慎。也许提供类加载器加载时的字节码操作能更加完美地解决这个问题。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://raw.githubusercontent.com/DorMOUSE-None/Repo/master/signature.zip" target="_blank" rel="noopener">源码.zip</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工程项目中，定义 API 总是一个慎之又慎的操作。不能少，不满足调用方的需求就惨了；也不能多，不然就乱套了，自己维护困难，调用方也开始了自我发挥。虽然足够慎重，但绝大多数都逃不过最终不得不“改” API 的情况。今天要讨论的是在同一个类内同方法名不同参数（入参/出参）的情况。&lt;/p&gt;
&lt;p&gt;想要做到同方法名不同入参，很简单，就是“重载（Overload）”，日常都在使用。不再赘述！&lt;/p&gt;
&lt;p&gt;想要做到同方法名不同出参，答案就不再那么肯定了。当然，如果问把&lt;code&gt;void add(int)&lt;/code&gt; API 改写成 &lt;code&gt;int add(int)&lt;/code&gt;，可能得到的大多数回答都是可以。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://DorMOUSE-None.github.io/tags/Java/"/>
    
      <category term="API" scheme="https://DorMOUSE-None.github.io/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>字符集与字符编码</title>
    <link href="https://DorMOUSE-None.github.io/2019-02-02-unicode/"/>
    <id>https://DorMOUSE-None.github.io/2019-02-02-unicode/</id>
    <published>2019-02-01T16:00:00.000Z</published>
    <updated>2019-02-02T06:32:39.666Z</updated>
    
    <content type="html"><![CDATA[<div class="row"><iframe src="https://drive.google.com/file/d/1MuBNtZPMWCt9kGlpqiAtG3i3Al2MaknY/preview" style="width:100%; height:550px"></iframe></div>]]></content>
    
    <summary type="html">
    
      
      
        

	&lt;div class=&quot;row&quot;&gt;
		&lt;iframe src=&quot;https://drive.google.com/file/d/1MuBNtZPMWCt9kGlpqiAtG3i3Al2MaknY/preview&quot; style=&quot;width:100%; height:550
      
    
    </summary>
    
    
      <category term="Unicode" scheme="https://DorMOUSE-None.github.io/tags/Unicode/"/>
    
      <category term="Character Encoding" scheme="https://DorMOUSE-None.github.io/tags/Character-Encoding/"/>
    
  </entry>
  
  <entry>
    <title>理解 Linux Kernel (8) - 网络</title>
    <link href="https://DorMOUSE-None.github.io/2019-01-15-understand-Kernel-8/"/>
    <id>https://DorMOUSE-None.github.io/2019-01-15-understand-Kernel-8/</id>
    <published>2019-01-14T16:00:00.000Z</published>
    <updated>2019-01-15T06:05:20.845Z</updated>
    
    <content type="html"><![CDATA[<div class="row"><iframe src="https://drive.google.com/file/d/1l5Vjrs8vKy6b9EvZFP7c7hOblv2kHgNx/preview" style="width:100%; height:550px"></iframe></div>]]></content>
    
    <summary type="html">
    
      
      
        

	&lt;div class=&quot;row&quot;&gt;
		&lt;iframe src=&quot;https://drive.google.com/file/d/1l5Vjrs8vKy6b9EvZFP7c7hOblv2kHgNx/preview&quot; style=&quot;width:100%; height:550
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://DorMOUSE-None.github.io/tags/Linux/"/>
    
      <category term="Kernel" scheme="https://DorMOUSE-None.github.io/tags/Kernel/"/>
    
      <category term="Network" scheme="https://DorMOUSE-None.github.io/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>理解 Linux Kernel (7) - 字符设备</title>
    <link href="https://DorMOUSE-None.github.io/2018-12-28-understand-Kernel-7/"/>
    <id>https://DorMOUSE-None.github.io/2018-12-28-understand-Kernel-7/</id>
    <published>2018-12-27T16:00:00.000Z</published>
    <updated>2018-12-27T23:47:28.308Z</updated>
    
    <content type="html"><![CDATA[<p>相比较于块设备，字符设备无论从物理认知上，抑或是理论理解上，都存在着相当大的入门门槛。特别是在将字符设备与控制台、命令行终端混淆的时候，就更加难以进行分辨了。</p><p>回到字符设备本身，字符设备与块设备最主要的区别就在于块设备可以随机读写，而字符设备只能够顺序读，顺序写。</p><p>那么，常见的字符设备有什么？显示器、键盘、鼠标。</p><a id="more"></a><h2 id="宏观概览"><a href="#宏观概览" class="headerlink" title="宏观概览"></a>宏观概览</h2><p>通常在我们的认识中，命令行终端就被认为是与一套字符设备相配合来使用的。很正常嘛。我们打开一个 Shell ，通过键盘输入一些字符，配合显示器把这些经过加工的字符展示出来。</p><p>那么，是不是就意味着 Shell 作为一个任务(进程)，以键盘设备作为标准输入，以显示设备作为标准输出?</p><p>看看一个 1 号任务 <code>/bin/bash</code> 的文件描述符说明吧。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ls -al</span><br><span class="line">total 0</span><br><span class="line">dr-x------ 2 root root  0 Dec 13 23:20 .</span><br><span class="line">dr-xr-xr-x 9 root root  0 Dec 13 23:20 ..</span><br><span class="line">lrwx------ 1 root root 64 Dec 13 23:20 0 -&gt; /dev/pts/0</span><br><span class="line">lrwx------ 1 root root 64 Dec 13 23:20 1 -&gt; /dev/pts/0</span><br><span class="line">lrwx------ 1 root root 64 Dec 13 23:20 2 -&gt; /dev/pts/0</span><br><span class="line">lrwx------ 1 root root 64 Dec 25 01:09 255 -&gt; /dev/pts/0</span><br></pre></td></tr></table></figure><p>这里文件描述符 0, 1, 2 分别表示任务的标准输入、标准输出、标准错误。这些内容在表现形式上做了一个链接。</p><p>那么，<code>/dev/pts/0</code> 是什么? </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crw--w---- 1 root tty 136, 0 Dec 13 23:20 /dev/pts/0</span><br></pre></td></tr></table></figure><p>一个字符设备。到此为止，似乎和最初预想的有比较大的区别。至少在假象中，至少是一个输入(键盘)，一个输出(显示器)。怎么就混成了一个呢？</p><p>本来是怎么都想不通的，但后来配合”Unix一切皆文件”的信条，总算是有点明白了。</p><p>相信大家都有这这样的经历，某个程序是以键盘输入作为标准输入的。其实就和上面👆展示的一样 <code>0 -&gt; /dev/pts/0</code> 。那么，有没有考虑过这整套流程是怎么协作的呢？</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fyjvtjiu0zj31980oqmxe.jpg" alt=""></p><p>对于程序来说，我们还是普通的调用 <code>read</code>, <code>write</code> 等经过封装的函数，来读取一个所谓的文件。</p><p>但对于文件是字符设备时，最终调用的就是 <code>tty_read</code>, <code>tty_write</code> 了。通俗的讲，大概率的就是键盘作为输入，显示器作为输出了。</p><h2 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h2><h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><p>这部分上一篇已经介绍过了，不做过多说明。</p><p>简单回顾下 <code>sys_read</code> 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_read</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> fd,<span class="keyword">char</span> * buf,<span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">file</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fd&gt;=NR_OPEN || count&lt;<span class="number">0</span> || !(file=current-&gt;filp[fd]))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (!count)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">verify_area(buf,count);</span><br><span class="line">inode = file-&gt;f_inode;</span><br><span class="line"><span class="keyword">if</span> (inode-&gt;i_pipe)</span><br><span class="line"><span class="keyword">return</span> (file-&gt;f_mode&amp;<span class="number">1</span>)?read_pipe(inode,buf,count):-EIO;</span><br><span class="line">    <span class="comment">/* 确认到i节点描述的是字符设备 */</span></span><br><span class="line"><span class="keyword">if</span> (S_ISCHR(inode-&gt;i_mode)) </span><br><span class="line"><span class="keyword">return</span> rw_char(READ,inode-&gt;i_zone[<span class="number">0</span>],buf,count,&amp;file-&gt;f_pos);</span><br><span class="line"><span class="keyword">if</span> (S_ISBLK(inode-&gt;i_mode))</span><br><span class="line"><span class="keyword">return</span> block_read(inode-&gt;i_zone[<span class="number">0</span>],&amp;file-&gt;f_pos,buf,count);</span><br><span class="line"><span class="keyword">if</span> (S_ISDIR(inode-&gt;i_mode) || S_ISREG(inode-&gt;i_mode)) &#123;</span><br><span class="line"><span class="keyword">if</span> (count+file-&gt;f_pos &gt; inode-&gt;i_size)</span><br><span class="line">count = inode-&gt;i_size - file-&gt;f_pos;</span><br><span class="line"><span class="keyword">if</span> (count&lt;=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> file_read(inode,file,buf,count);</span><br><span class="line">&#125;</span><br><span class="line">printk(<span class="string">"(Read)inode-&gt;i_mode=%06o\n\r"</span>,inode-&gt;i_mode);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>S_ISCHR()</code> 就是在对i节点的类型进行判别，从而进行不同的分发。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> crw_ptr crw_table[]=&#123;</span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">/* nodev */</span></span><br><span class="line">rw_memory,<span class="comment">/* /dev/mem etc */</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">/* /dev/fd */</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">/* /dev/hd */</span></span><br><span class="line">rw_ttyx,<span class="comment">/* /dev/ttyx */</span></span><br><span class="line">rw_tty,<span class="comment">/* /dev/tty */</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">/* /dev/lp */</span></span><br><span class="line"><span class="literal">NULL</span>&#125;;<span class="comment">/* unnamed pipes */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这段还是涉及到分发，由不同的设备号(dev) 来确定执行函数 (ttyx, 串口终端; tty, 控制台终端; mem, /dev/mem 等)</span></span><br><span class="line"><span class="comment"> * crw_ptr 是 C 语言中常见的函数指针。由dev号来确定调用哪个函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rw_char</span><span class="params">(<span class="keyword">int</span> rw,<span class="keyword">int</span> dev, <span class="keyword">char</span> * buf, <span class="keyword">int</span> count, <span class="keyword">off_t</span> * pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">crw_ptr call_addr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (MAJOR(dev)&gt;=NRDEVS)</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line"><span class="keyword">if</span> (!(call_addr=crw_table[MAJOR(dev)]))</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line"><span class="keyword">return</span> call_addr(rw,MINOR(dev),buf,count,pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行到 <code>rw_tty</code>, <code>rw_ttyx</code> 两个函数，就将对读/写进行区分，并由特定的函数进行处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rw_ttyx</span><span class="params">(<span class="keyword">int</span> rw,<span class="keyword">unsigned</span> minor,<span class="keyword">char</span> * buf,<span class="keyword">int</span> count,<span class="keyword">off_t</span> * pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ((rw==READ)?tty_read(minor,buf,count):</span><br><span class="line">tty_write(minor,buf,count));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rw_tty</span><span class="params">(<span class="keyword">int</span> rw,<span class="keyword">unsigned</span> minor,<span class="keyword">char</span> * buf,<span class="keyword">int</span> count, <span class="keyword">off_t</span> * pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (current-&gt;tty&lt;<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line"><span class="keyword">return</span> rw_ttyx(rw,current-&gt;tty,buf,count,pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，应该能够基本了解了字符设备，作为 Linux 的文件，所应该有的读写的相关支持。</p><p>但是，究竟读、写的内容在哪呢？比如正规文件，都很容易地可以理解到，就是从磁盘中取出某个/某几个盘块的内容即可。字符设备的IO要从哪里取(往哪里送)数据呢?</p><h3 id="字符设备驱动"><a href="#字符设备驱动" class="headerlink" title="字符设备驱动"></a>字符设备驱动</h3><p>对于设备驱动这个概念，至今没有搞清楚。不过，这不妨碍对代码的理解。反正对于字符设备驱动来说，也就是 Linux 内核中的一些软件层面的代码，与普通代码的唯一区别，就是对外设硬件做了相应的交互支持。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fykyc6lo9pj31i40u0ac8.jpg" alt=""></p><p>承接操作系统的字符设备接口，<code>tty_read</code>、<code>tty_write</code> 负责读入和写出。</p><p>从哪里读？<code>secondary</code> 数据队列；往哪里写？<code>write_q</code> 数据队列。</p><p>同时，也可以看到，与这些队列直接相关的，就是我们熟知的键盘和显示器了。是不是有了点豁然开朗的感觉。</p><p>好，我们先来看看这里描述的三个队列究竟是怎么工作的。这里就不得不先看看内存中抽象出来的描述终端的数据结构 <code>tty_struct</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * copied from include/linux/tty.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">termios</span>;</span>     <span class="comment">/* terminal IO conf */</span></span><br><span class="line"><span class="keyword">int</span> pgrp;                   <span class="comment">/* 所属进程组 */</span></span><br><span class="line"><span class="keyword">int</span> stopped;                <span class="comment">/* 停止标志 */</span></span><br><span class="line"><span class="keyword">void</span> (*write)(struct tty_struct * tty); <span class="comment">/* 终端写函数指针 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_queue</span> <span class="title">read_q</span>;</span>    <span class="comment">/* 终端读队列 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_queue</span> <span class="title">write_q</span>;</span>   <span class="comment">/* 终端写队列 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_queue</span> <span class="title">secondary</span>;</span> <span class="comment">/* 终端辅助队列 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * copied from include/termios.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">termios</span> &#123;</span>                <span class="comment">/* terminal IO 属性 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> c_iflag;<span class="comment">/* input mode flags */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> c_oflag;<span class="comment">/* output mode flags */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> c_cflag;<span class="comment">/* control mode flags */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> c_lflag;<span class="comment">/* local mode flags */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> c_line;<span class="comment">/* line discipline */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> c_cc[NCCS];<span class="comment">/* control characters */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * copied from include/linux/tty.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_queue</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> data;         <span class="comment">/* 字符行数量 | 串口终端则存储端口号 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> head;         <span class="comment">/* 头指针 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> tail;         <span class="comment">/* 尾指针 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">proc_list</span>;</span> <span class="comment">/* 等待该终端的任务队列 */</span></span><br><span class="line"><span class="keyword">char</span> buf[TTY_BUF_SIZE];     <span class="comment">/* 队列的缓冲区 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于任何任务需要读写字符设备(这里指终端设备)，最终直接读取/写入到的就是 <code>secondary</code> 和 <code>write_q</code>。</p><hr><p>这里可能有个小小的疑问? 为什么读终端设备不是读 <code>read_q</code> 呢？</p><p>其实也比较好解释，相信日常在操作命令行的时候，我们在键盘上敲击的键位与显示器上实际展示的内容是不相匹配的。最普通的，我们键入了 <strong>delete(删除键)</strong>，为什么不是一个 <strong>delete</strong> 对应的 ascii (当然，这里请先忽视非打印字符的问题)，而是删除了最后一个字符呢？完全可以想象，反正任何键位与驱动交互的时候都是传入一串二进制码嘛。</p><p>这里的 <code>secondary</code> 完成的就是怎么一个工作，<code>read_q</code> 存储的是所有的外设(这里是键盘)的输入，并原样存储。而到了 <code>secondary</code> 就是经过相应的加工，诸如控制字符之类的都展现了各自的意义，并完成一些加工工作，而不再仅仅只是普通地展示了。</p><hr><p>另外，可能还有一个问题。虽然我们已经习惯了在命令行交互时，所有的输入都将直接在显示器上进行展示，好像我们在直接往显示器上写内容。但是，前面我们描述的内容都是，键盘设备作为输入，是要写到 <code>read_q</code> 乃至 <code>secondary</code> 并最终作为进程的输入的。在显示器上显示并不是它本来应该干的事情 (比较显示器上展示的应该是 <code>write_q</code> 的内容，也就是进程的标准输出)</p><p>事实上，这仅仅只是一个回显，将 <code>secondary</code> 队列的内容复制了一份到写队列，也就呈现出让显示器打印相应键盘输入的效果了。</p><p>同时，这也就能够直接解释为什么我们在使用 <code>passwd</code>, <code>su</code>, <code>sudo</code> 等命令时，要求输入密码都是不在显示器上回显的。实现也相当简单了嘛。把 tty_struct.termios 的相应控制属性 (ECHO) 重置，就可以实现不回显的效果了。</p><h3 id="终端设备交互"><a href="#终端设备交互" class="headerlink" title="终端设备交互"></a>终端设备交互</h3><p>最后一部分，应该也是最关心的了。外设如何与操作系统完成交互。其实也能够想得到了——中断。</p><p>在操作系统初始化时，就把中断描述符表的中断表项配置得当。之后的事情就是等待键盘等外设输入的中断信号了。</p><p>又看回到了 <code>init/main.c</code> 程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">trap_init();</span><br><span class="line">blk_dev_init();</span><br><span class="line">chr_dev_init(); <span class="comment">/* 块设备相关初始化, 方法体是空的，没有实现 */</span></span><br><span class="line">tty_init();     <span class="comment">/* tty 终端设备初始化 */</span></span><br><span class="line">time_init();</span><br><span class="line">sched_init();</span><br><span class="line">buffer_init(buffer_memory_end);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Copied from kernel/chr_drv/tty_io.c</span><br><span class="line"> * 终端设备初识化</span><br><span class="line"> */</span><br><span class="line">void tty_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    /** 串口设备初始化 */</span><br><span class="line">rs_init();</span><br><span class="line">    /** 控制台设备初始化 */</span><br><span class="line">con_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于为什么有两种初始化方式。这来源于终端又区分为控制台终端与串口终端，区别就是一个是直接建立在主机上，串口终端是通过串行接口连接到主机的。当然，这都是古老的方式了，细节就不太清楚了。</p><p>下面来看看 <code>con_init()</code> 做了哪些工作(<code>rs_init()</code> 的内容请自行了解)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">con_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> a;</span><br><span class="line"><span class="keyword">char</span> *display_desc = <span class="string">"????"</span>;</span><br><span class="line"><span class="keyword">char</span> *display_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取 setup.s 程序预处理的内容</span></span><br><span class="line"><span class="comment">     * 包括显示器的各种配置参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">video_num_columns = ORIG_VIDEO_COLS;</span><br><span class="line">video_size_row = video_num_columns * <span class="number">2</span>;</span><br><span class="line">video_num_lines = ORIG_VIDEO_LINES;</span><br><span class="line">video_page = ORIG_VIDEO_PAGE;</span><br><span class="line">video_erase_char = <span class="number">0x0720</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取显示器的配置并进行相关设置 (省略代码)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">origin= video_mem_start;</span><br><span class="line">scr_end= video_mem_start + video_num_lines * video_size_row;</span><br><span class="line">top= <span class="number">0</span>;</span><br><span class="line">bottom= video_num_lines;</span><br><span class="line"></span><br><span class="line">gotoxy(ORIG_X,ORIG_Y);</span><br><span class="line">    <span class="comment">/** 设置陷阱门 */</span></span><br><span class="line">set_trap_gate(<span class="number">0x21</span>,&amp;keyboard_interrupt);</span><br><span class="line">outb_p(inb_p(<span class="number">0x21</span>)&amp;<span class="number">0xfd</span>,<span class="number">0x21</span>);</span><br><span class="line">a=inb_p(<span class="number">0x61</span>);</span><br><span class="line">outb_p(a|<span class="number">0x80</span>,<span class="number">0x61</span>);</span><br><span class="line">outb(a,<span class="number">0x61</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该能够看到最重要的内容就是<strong>设置键盘中断陷阱门</strong>了。</p><p>之后只有静静地等待键位敲击，也就能够产生硬件中断，从而让 <code>read_q</code> 获得到相应的字符输入。</p><p>至于键盘中断的相应处理流程，这里不再详述。简述一些步骤:</p><ol><li><p>产生硬中断 <code>keyboard_interrupt</code>，由程序 <code>Keyboard.s</code> 的汇编代码进行处理</p></li><li><p>根据不同的键盘(US 键盘、德式键盘等等)将获得的键位信号进行相应的字符转换(查转换表)</p></li><li><p>调用 <code>do_tty_interrupt</code> 处理函数 (确认是给哪个终端的信号)</p></li><li><p>调用 <code>copy_to_cooked(tty)</code> ，即完成 <code>read_q</code> 到 <code>secondary</code> 的相关加工。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相比较于块设备，字符设备无论从物理认知上，抑或是理论理解上，都存在着相当大的入门门槛。特别是在将字符设备与控制台、命令行终端混淆的时候，就更加难以进行分辨了。&lt;/p&gt;
&lt;p&gt;回到字符设备本身，字符设备与块设备最主要的区别就在于块设备可以随机读写，而字符设备只能够顺序读，顺序写。&lt;/p&gt;
&lt;p&gt;那么，常见的字符设备有什么？显示器、键盘、鼠标。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://DorMOUSE-None.github.io/tags/Linux/"/>
    
      <category term="Kernel" scheme="https://DorMOUSE-None.github.io/tags/Kernel/"/>
    
      <category term="Char Dev" scheme="https://DorMOUSE-None.github.io/tags/Char-Dev/"/>
    
  </entry>
  
  <entry>
    <title>SQL 注入</title>
    <link href="https://DorMOUSE-None.github.io/2018-12-15-sql-injection/"/>
    <id>https://DorMOUSE-None.github.io/2018-12-15-sql-injection/</id>
    <published>2018-12-14T16:00:00.000Z</published>
    <updated>2018-12-15T03:00:14.679Z</updated>
    
    <content type="html"><![CDATA[<p>说实话此前对 SQL 注入的理解仅仅只是皮毛。当然，目前也是，只是有了一定程度的理解。</p><p>最近好像工具用得有些过头了，需要停下来整理下工具的实现原理。</p><p>更好地理解了工具实现，才能更加心安理得地使用工具。毕竟等别人怼的时候，还能够比较安心地回道: “我用不用现成的工具只是取决于我想不想自己再写一套”</p><p>当然，毕竟成熟的工具有更多的优化，这就不是短时间内我想不想自己写的问题了，哈哈。</p><a id="more"></a><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>SQL 注入漏洞究竟会产生怎么样的危害性，仅仅只是绕过某些登录账号密码的验证? 只是绕过某些访问限制实现特权内容的访问?</p><p>此前我的认识也仅仅只是停留在这里。可谁曾想，SQL SELECT 语句真的是功能强大啊。通过各种各样的字符串拼接，最终能达到的目的，可以说把整个数据库的内容拖下来也不为过。当然，这也是限定在没有实现分库分表，数据库查询账号的权限过大的前提下。</p><p>不过，这也就够了。只有真正认识到问题的严重性，最终才会想着去做出一些改善。</p><h2 id="SQL-注入技术"><a href="#SQL-注入技术" class="headerlink" title="SQL 注入技术"></a>SQL 注入技术</h2><h3 id="基于布尔的注入"><a href="#基于布尔的注入" class="headerlink" title="基于布尔的注入"></a>基于布尔的注入</h3><p>最早接触到 SQL 注入问题，还是两个月前。操作的内容也相当简单，猜解某账号的密码。</p><p>某接口提供了查询账号的功能，后台的拼接 SQL 可以简单理解成 <code>SELECT * FROM users WHERE username = &#39;${}&#39;</code> 。其中 <code>${}</code> 就是直接使用的接口请求参数。</p><p>而接口的请求结果会根据 SQL 查询的结果，有或没有记录呈现两个不同的页面。</p><p>这算是最简单容易的 SQL 注入了，也是凭借个人能力直接能够想到注入点的问题了。</p><p>最先做的就是猜解存储密码字段的字段名究竟是什么? 很好，符合常理的设计，直接就是 <code>passwd</code> 。</p><p>下面就是苦力工作，利用 SQL LIKE 操作符，逐一去猜每一位。<code>${}</code> 的注入内容就类似 <code>admin&#39; AND passwd LIKE &#39;?%</code> 这里的问号就是逐一猜解的内容(1-9a-zA-Z + 特殊符号)</p><p>至于为什么利用 LIKE 操作符，很明确，减少猜解的次数。否则，在密码未知的情况下，即使六位密码也有猜解百万次。而 LIKE 操作符能将猜解次数降为线性，<code>密码长度 * 字符集数</code> 次</p><p>这里仅仅用了 <code>AND</code>，但熟悉了一个，其它就基本类似了。</p><p>如果登录也能够注入，认证 SQL 类似 <code>SELECT * FROM users WHERE username = &#39;${}&#39; AND passwd = &#39;${}&#39;</code>，那么直接在第一个 <code>${}</code> 处注入 <code>admin&#39; OR 1=1; --</code></p><h3 id="基于时间的注入"><a href="#基于时间的注入" class="headerlink" title="基于时间的注入"></a>基于时间的注入</h3><p>绝大多数时候，注入绝对没有这么简单。也许注入点背后的拼接 SQL 并不对返回值产生影响。例如仅仅只是为了从 DB 查询用户信息，并打一条日志，返回的永远是静态日志（当然，我知道这个例子不恰当，无奈目前只能想到这个）。</p><p>既然拼接 SQL 总是存在，但没法给我们一个直观的注入成功 OR 失败的提示。那么，时间就成了一个最好的判断。毕竟是阻塞式的执行。</p><p>还是以 <code>SELECT * FROM users WHERE username = &#39;${}&#39;</code> 为例，使用类似 <code>admin&#39; AND IF(passwd LIKE &#39;5%&#39;, SLEEP(5), 1);--</code> 的 PAYLOAD ，当满足 <code>passwd</code> 以 5 开始时，则 IF 判断进入 <code>SLEEP(5)</code> ，根据网页的响应时长就可以进行相应的判断。</p><h3 id="基于报错的注入"><a href="#基于报错的注入" class="headerlink" title="基于报错的注入"></a>基于报错的注入</h3><p>这应该也算一种比较容易自动化的注入方式了。其实在猜解存储密码字段的字段名时，前面也是这样用的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT * FROM users WHERE password ='1';</span><br><span class="line">ERROR 1054 (42S22): Unknown column 'password' in 'where clause'</span><br></pre></td></tr></table></figure><p>如果程序不做任何处理，对 SQL 错误直接抛出，那么，通过这个就能获得相当多的信息。</p><p>由于这部分接触不深，仅仅给出 sqlmap 提的 PAYLOAD</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AND (SELECT [RANDNUM] FROM(SELECT COUNT(*),CONCAT(&apos;[DELIMITER_START]&apos;,([QUERY]),&apos;[DELIMITER_STOP]&apos;,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a)</span><br></pre></td></tr></table></figure><p>很标准的 PAYLOAD，而且完全可以。<code>INFORMATION_SCHEMA</code> 库的表对所有用户都可查，因此不存在授权的问题。而且表中数据至少大于等于 3 条。</p><p>这个 PAYLOAD 一定导致报错的主因，就是对 <code>RAND()</code> 与 <code>GROUP BY</code> 的配合应用。</p><blockquote><p>Use of a column with RAND() values in an ORDER BY or GROUP BY clause may yield unexpected results because for either clause a RAND() expression can be evaluated multiple times for the same row, each time returning a different result. If the goal is to retrieve rows in random order, you can use a statement like this:</p></blockquote><p>而真正想要得到的内容，通过 <code>CONCAT(&#39;[DELIMITER_START]&#39;,([QUERY]),&#39;[DELIMITER_STOP]&#39;,FLOOR(RAND(0)*2))x</code> 得到，<code>[QUERY]</code> 就是真正想要注入的完整SQL串。</p><p>而这里的 <code>DELIMITER_START</code> <code>DELIMITER_STOP</code> 作为界定符，帮助程序提取 <code>[QUERY]</code> 得到的结果。否则，直接对请求返回的结果进行过滤可真是太困难了。</p><h3 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h3><p>联合查询，应该算是最顾名思义的注入方式。使用 <code>UNION</code> 在原 SQL 已经限定了查询表的前提下，获得数据库其它库表的信息。</p><p>LIKE: <code>1&#39; UNION SELECT * FROM users;--</code> 这样的 PAYLOAD。</p><h3 id="堆查询注入"><a href="#堆查询注入" class="headerlink" title="堆查询注入"></a>堆查询注入</h3><p>我想这应该是最让人摸不着头脑的命名方式了。</p><p>形象化的，我们利用 PAYLOAD 来进行说明。<code>1&#39;; INSERT INTO users (user, passwd) VALUES (&#39;aaa&#39;, &#39;aaa&#39;);--</code></p><p>看起来和 UNION 挺像的哈，都是补充上一个 OR 多个 SQL 。当然，也是有区别的，否则为什么会出现这样一种技术呢。</p><p>最大的区别，就是堆查询注入能够完成 <code>UPDATE</code>, <code>INSERT</code>, <code>DELETE</code> 等操作，毕竟，UNION 联合的只能是作为查询了（可能说法不太恰当，但姑且这样吧）</p><h3 id="另类注入"><a href="#另类注入" class="headerlink" title="另类注入"></a>另类注入</h3><p>之前的几种，我们都是利用了 <code>SELECT</code> 完成的注入，那么对于 <code>INSERT</code>, <code>UPDATE</code> 之类的语句是否有注入的可能呢。当然也是存在可能的。</p><p>不过，精力有限，而且目前看来也不需要做到这一步。暂时挖个坑吧。不填</p><h2 id="SQLMAP"><a href="#SQLMAP" class="headerlink" title="SQLMAP"></a>SQLMAP</h2><p>简单的了解了几种注入原理之后，还是要看看 SQL 注入神器的——<code>SQLMAP</code></p><p>也算是尝试了好久才真正了解它的强大之处。此处强烈推荐 DVWA，<code>Damn Vulnerable Web Application</code>，一个用来合法攻击的工具。</p><p>部署方式也是开箱可用，只要有 docker，直接 <code>docker run --rm -it -p 80:80 vulnerables/web-dvwa</code> 即可完成部署。</p><p>对于将 DVWA 安全级别设置为 low 时，仅仅只需要执行下列命令就可以获取到 DB 里几乎完整的信息。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sqlmap -u http://127.0.0.1/vulnerabilities/sqli/\?id\=1\&amp;Submit\=Submit\<span class="comment"># --cookie="PHPSESSID=jhton35qahj78l3unjea9k2lf7;security=low" -v 3 --banner</span></span><br></pre></td></tr></table></figure><p>当然，换一下相关获取的内容，例如把 <code>--banner</code> 换成 <code>--dump</code> ，我们借此来简单看看 SQL 注入漏洞的可怕之处</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[10:41:39] [INFO] using default dictionary</span><br><span class="line"><span class="keyword">do</span> you want to use common password suffixes? (slow!) [y/N]</span><br><span class="line">[10:41:40] [INFO] starting dictionary-based cracking (md5_generic_passwd)</span><br><span class="line">[10:41:40] [INFO] starting 8 processes</span><br><span class="line">[10:41:42] [INFO] cracked password <span class="string">'abc123'</span> <span class="keyword">for</span> <span class="built_in">hash</span> <span class="string">'e99a18c428cb38d5f260853678922e03'</span></span><br><span class="line">[10:41:44] [INFO] cracked password <span class="string">'charley'</span> <span class="keyword">for</span> <span class="built_in">hash</span> <span class="string">'8d3533d75ae2c3966d7e0d4fcc69216b'</span></span><br><span class="line">[10:41:47] [INFO] cracked password <span class="string">'letmein'</span> <span class="keyword">for</span> <span class="built_in">hash</span> <span class="string">'0d107d09f5bbe40cade3de5c71e9e9b7'</span></span><br><span class="line">[10:41:49] [INFO] cracked password <span class="string">'password'</span> <span class="keyword">for</span> <span class="built_in">hash</span> <span class="string">'5f4dcc3b5aa765d61d8327deb882cf99'</span></span><br><span class="line">[10:41:53] [DEBUG] post-processing table dump</span><br><span class="line">Database: dvwa</span><br><span class="line">Table: users</span><br><span class="line">[5 entries]</span><br><span class="line">+---------+-----------------------------+---------+---------------------------------------------+-----------+------------+---------------------+--------------+</span><br><span class="line">| user_id | avatar                      | user    | password                                    | last_name | first_name | last_login          | failed_login |</span><br><span class="line">+---------+-----------------------------+---------+---------------------------------------------+-----------+------------+---------------------+--------------+</span><br><span class="line">| 1       | /hackable/users/admin.jpg   | admin   | 5f4dcc3b5aa765d61d8327deb882cf99 (password) | admin     | admin      | 2018-12-15 00:42:31 | 0            |</span><br><span class="line">| 2       | /hackable/users/gordonb.jpg | gordonb | e99a18c428cb38d5f260853678922e03 (abc123)   | Brown     | Gordon     | 2018-12-15 00:42:31 | 0            |</span><br><span class="line">| 3       | /hackable/users/1337.jpg    | 1337    | 8d3533d75ae2c3966d7e0d4fcc69216b (charley)  | Me        | Hack       | 2018-12-15 00:42:31 | 0            |</span><br><span class="line">| 4       | /hackable/users/pablo.jpg   | pablo   | 0d107d09f5bbe40cade3de5c71e9e9b7 (letmein)  | Picasso   | Pablo      | 2018-12-15 00:42:31 | 0            |</span><br><span class="line">| 5       | /hackable/users/smithy.jpg  | smithy  | 5f4dcc3b5aa765d61d8327deb882cf99 (password) | Smith     | Bob        | 2018-12-15 00:42:31 | 0            |</span><br><span class="line">+---------+-----------------------------+---------+---------------------------------------------+-----------+------------+---------------------+--------------+</span><br></pre></td></tr></table></figure><p>这里就可以看到 <code>dvwa.users</code> 表的全部内容，甚至连简单密码都帮你完成了爆破。</p><p>更多内容可以自行尝试，说真的，这个工具相当强大。如果仅仅说我针对某型数据库(例如 MySQL)完成诸如基于报错的注入，在不考虑鲁棒性的情况下，完全可以做到。但是支持超10余种数据库，且自动完成注入的全过程…</p><h2 id="预编译-SQL"><a href="#预编译-SQL" class="headerlink" title="预编译 SQL"></a>预编译 SQL</h2><p>提了这么多，究竟 SQL 注入就不能够预防吗? 当然可以，不然整个网络环境下的WEB应用不得都完蛋了。有釜底抽薪的处理方式吗，也有。</p><p>预编译 SQL 就是一个超级 OK 的解决方案。同时在使用上也能够明显提升 DB 查询效率</p><p>我相信预编译 SQL 很多人写过，毕竟借助例如 MyBatis 框架，能够快速实现 SQL 预编译语句的编写。同时在求学过程中估计也都用过 Java 原生 JDBC 的 <code>PreparedStatement</code> 。</p><p>那么，与 MySQL 交互时的预编译 SQL 是怎么样地填上了占位符呢? 先来看看再说</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; prepare &#123;name&#125; from 'SELECT * FROM users WHERE user=? AND passwd=?'; # 这里的 &#123;name&#125; 可以自定义命名，无需 &#123;&#125;</span><br><span class="line"></span><br><span class="line">mysql&gt; set @a='admin', @b='password';     # 声明变量，并赋值</span><br><span class="line"></span><br><span class="line">mysql&gt; execute &#123;name&#125; using @a, @b;     # 提供变量并执行预编译 SQL</span><br></pre></td></tr></table></figure><p>我想看到这里应该就应该能够明白了吧，MySQL 对于预编译 SQL 的每一个占位符，都已经认定了是单一的元素，也就不可能存在允许打破已有预编译结果的内容了。</p><p>即使真的注入了 <code>admin OR 1=1</code> 之类的内容，也是会被认为这是一个完整的字符串，用来替代 <code>user</code> 字段或 <code>passwd</code> 字段，根本不可能重新拆解。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说实话此前对 SQL 注入的理解仅仅只是皮毛。当然，目前也是，只是有了一定程度的理解。&lt;/p&gt;
&lt;p&gt;最近好像工具用得有些过头了，需要停下来整理下工具的实现原理。&lt;/p&gt;
&lt;p&gt;更好地理解了工具实现，才能更加心安理得地使用工具。毕竟等别人怼的时候，还能够比较安心地回道: “我用不用现成的工具只是取决于我想不想自己再写一套”&lt;/p&gt;
&lt;p&gt;当然，毕竟成熟的工具有更多的优化，这就不是短时间内我想不想自己写的问题了，哈哈。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Security" scheme="https://DorMOUSE-None.github.io/tags/Security/"/>
    
      <category term="SQL" scheme="https://DorMOUSE-None.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式指数爆炸</title>
    <link href="https://DorMOUSE-None.github.io/2018-11-16-regex-exponential-explosion/"/>
    <id>https://DorMOUSE-None.github.io/2018-11-16-regex-exponential-explosion/</id>
    <published>2018-11-15T16:00:00.000Z</published>
    <updated>2018-11-16T07:22:56.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>昨天接触到一个很有意思的问题, 公司测试环境一台机器 CPU 跑到了 400%，导致该机器上的所有服务都挂掉了。</p><p>最后查到的原因竟然是正则表达式所引起的，大大出乎意料啊。虽然早就知道正则效率很差，但绝对没有想到会导致整个机器上服务崩溃的情况。</p><p>先简单展示下问题正则:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String regex = <span class="string">"(\\w+,?)+"</span>;</span><br><span class="line">String val = <span class="string">"abcdefghijklmno,abcdefghijklmno+"</span>;</span><br><span class="line">System.out.println(val.matches(regex));</span><br></pre></td></tr></table></figure><p>最终的执行时间是 17s 左右。</p><p>相反，如果改成 <code>String val = &quot;abcdefghijklmno,abcdefghijklmno&quot;</code> ，实际执行时间 1ms 左右。</p><p>哈哈，完全不是一个量级的结果。</p><p>最后，当然是要找原因了:&lt; 当然，有其它重要的事在耽搁，没时间去看 Java Regex 源码。不过，从正则本身下手反而是个好事情。毕竟几乎所有的编程语言都有对正则的支持。而同样的，都存在着这样的问题。那就可以大胆猜想其实是和语言本身无关，而在于正则规范本身了。</p><p>先给个结果，罪魁祸首就是<code>指数爆炸</code></p><a id="more"></a><h2 id="追本溯源"><a href="#追本溯源" class="headerlink" title="追本溯源"></a>追本溯源</h2><p>这里并不准备一步一步地阐述正则的，如果真的是零基础的话，推荐先看一下 <a href="https://github.com/ziishaned/learn-regex/blob/master/README-cn.md" target="_blank" rel="noopener">学习正则</a></p><p>就事论事，还是以 <code>regex ::= (\w+,?)+</code> 作为示例来进行说明。</p><p>首先需要了解的是 <code>val.matches(regex)</code> 所要进行的工作是判断 <code>val</code> 全串是否符合 <code>regex</code> 正则模式。而正则所要做的工作就是尝试所有的匹配可能性(当然，对于 <code>val</code> 这个串来说，最后匹配到 <code>abcd..,abcd..mno+</code> 的 <code>+</code> 的时候一定是失败的，因为 <code>regex</code> 并不匹配 <code>+</code>)</p><p>简单扩展一下对<code>尝试所有匹配可能性</code>这句话的描述:</p><p>我们以 <code>()</code> 对应 <code>regex</code> 中的一组 <code>(\w+,?)</code> ，而最后一个 <code>+</code> 表示一个或多个(即允许存在多个<code>()</code>)</p><p>对 <code>val</code> 串的匹配可能性有</p><ul><li><p>(abcdefghijklmno,)(abcdefghijklmno)+</p></li><li><p>(abcd)(efghijklmno,)(abcdefghijklmno)+</p></li><li><p>(abcdefghijklmno,)(abcdef)(ghijklmno)+</p></li><li><p>(abc)(defghijklmno,)(abcde)(fg)(hijklmno)+</p></li><li><p>…</p></li></ul><p>有相当多的匹配可能，不再一一详述(事实上，光靠个人手工根本列举不完。</p><p>那么到底会有多少中匹配可能性呢?</p><p>下面我们就来简单计算一下:</p><p>首先，我们把 <code>(\w+,?)+</code> 这个正则扩展一下，它与下列这些串都是等价的 <code>(\w+,|\w+)+</code>, <code>(\w+,)?(\w+)?(\w+,?)+</code>, <code>(\w+,)?(\w+)?(\w+)?(\w+,?)+</code> …</p><p>也就是说，我们能够至少把 <code>abcdefghijklmno,abcdefghijklmno+</code> 按照匹配串划分出1组，2组，3组…30组(因为每个组至少需要一个<code>\w</code> )</p><p>不过这个按照1组，2组…去计算可能性的话实在是费力不讨好的事情。用组合数学来考虑这个问题</p><p>首先，整个 <code>abcdefghijklmno,abcdefghijklmno+</code> 的开始应该有一个左括号 <code>(</code>，即 <code>(abcdefghijklmno,abcdefghijklmno+</code></p><p>其次，到 <code>,</code> 为止至少应该有一个右左括号 <code>)(</code>，即 <code>(abcdefghijklmno,)(abcdefghijklmno+</code></p><p>再次，由于到 <code>o+</code> 为止一定匹配失败，因此，<code>+</code> 之前应该有一个 <code>)</code>, 即 <code>(abcdefghijklmno,)(abcdefghijklmno)+</code></p><p>至于其他字符间的空隙，除了 <code>o,</code> 之间不能存在右左括号 <code>)(</code> ，其他字符间都可以随意插入 <code>)(</code> (至于为什么是右左括号，表示前一个组的结束与新的组的开始)</p><p>那么总共有多少种可能? </p><ul><li><p>插入零个右左括号 <code>)(</code> , $C_{28}^0$ = 1 种可行方案</p></li><li><p>插入一个右左括号 <code>)(</code> , $C_{28}^1$ = 28 种可行方案 (总共 28 个可用字符间隙)</p></li><li><p>插入两个右左括号 <code>)(</code> , $C_{28}^2$ 种可行方案</p></li><li><p>…</p></li><li><p>插入28个右左括号 <code>)(</code> , $C_{28}^{28}$ 种可行方案</p></li></ul><p>累加的结果为 $C_{28}^1 + C_{28}^2 + C_{28}^3 + … + C_{28}^{28} = 2^{28}$</p><p>可想而知为什么会花 17s 了吧。毕竟达到了 2500 万以上的计算量级，加上 regex 本身就是偏慢的。</p><p>至于为什么把 <code>abcdefghijklmno,abcdefghijklmno+</code> 串的 <code>+</code> 去掉就变快了？理由也很简单，<code>matches(regex)</code> 在正则串与原串匹配上之后就会快速结束，因为结果只需要告知某次匹配成功了即可。而失败的匹配会不断地尝试所有的可能性。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>至于解决方案，从上面的原因就可以看到，拒绝在贪婪组模式下(<code>(...)+</code>) 的组内多模式匹配可能。即 <code>(a+a+)+</code> 是不能被允许的，而 <code>(a+b+)+</code> 是可靠的。</p><p>写得仓促，如有根源性错误，欢迎指正。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.regular-expressions.info/catastrophic.html" target="_blank" rel="noopener">Catastrophic Backtracking(灾难性回溯)</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;昨天接触到一个很有意思的问题, 公司测试环境一台机器 CPU 跑到了 400%，导致该机器上的所有服务都挂掉了。&lt;/p&gt;
&lt;p&gt;最后查到的原因竟然是正则表达式所引起的，大大出乎意料啊。虽然早就知道正则效率很差，但绝对没有想到会导致整个机器上服务崩溃的情况。&lt;/p&gt;
&lt;p&gt;先简单展示下问题正则:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;String regex = &lt;span class=&quot;string&quot;&gt;&quot;(\\w+,?)+&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String val = &lt;span class=&quot;string&quot;&gt;&quot;abcdefghijklmno,abcdefghijklmno+&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(val.matches(regex));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最终的执行时间是 17s 左右。&lt;/p&gt;
&lt;p&gt;相反，如果改成 &lt;code&gt;String val = &amp;quot;abcdefghijklmno,abcdefghijklmno&amp;quot;&lt;/code&gt; ，实际执行时间 1ms 左右。&lt;/p&gt;
&lt;p&gt;哈哈，完全不是一个量级的结果。&lt;/p&gt;
&lt;p&gt;最后，当然是要找原因了:&amp;lt; 当然，有其它重要的事在耽搁，没时间去看 Java Regex 源码。不过，从正则本身下手反而是个好事情。毕竟几乎所有的编程语言都有对正则的支持。而同样的，都存在着这样的问题。那就可以大胆猜想其实是和语言本身无关，而在于正则规范本身了。&lt;/p&gt;
&lt;p&gt;先给个结果，罪魁祸首就是&lt;code&gt;指数爆炸&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="regular expression" scheme="https://DorMOUSE-None.github.io/tags/regular-expression/"/>
    
      <category term="指数爆炸" scheme="https://DorMOUSE-None.github.io/tags/%E6%8C%87%E6%95%B0%E7%88%86%E7%82%B8/"/>
    
  </entry>
  
  <entry>
    <title>理解 Linux Kernel (6) - read &amp; write</title>
    <link href="https://DorMOUSE-None.github.io/2018-11-11-understand-Kernel-6/"/>
    <id>https://DorMOUSE-None.github.io/2018-11-11-understand-Kernel-6/</id>
    <published>2018-11-10T16:00:00.000Z</published>
    <updated>2018-11-11T02:42:26.367Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://dormouse-none.github.io/2018-10-14-understand-Kernel-5/">前一篇</a>已经描述对文件系统进行了宏观性的描述，这一篇，将以特定的文件读写操作为示例，串联对整个文件系统的基本操作。</p><p>首先先来看看平台相关的文件读写操作的 C 代码是怎样一个调用方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">panic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s (errno=%d)\n"</span>, strerror(errno), errno);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 打开文件 frw.txt (以可读写 | 若不存在则新建的形式) */</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/root/frw.txt"</span>, O_RDWR | O_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> panic();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 向文件写入 Hello World! 共计 12 个字符 */</span></span><br><span class="line">    <span class="keyword">ssize_t</span> wsize = write(fd, <span class="string">"Hello World!"</span>, <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">if</span> (wsize == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> panic();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 重定位文件读写指针 */</span></span><br><span class="line">    <span class="keyword">off_t</span> off = lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    <span class="keyword">if</span> (off == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> panic();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* buf = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(wsize);</span><br><span class="line">    <span class="comment">/* 读取文件内容 */</span></span><br><span class="line">    <span class="keyword">ssize_t</span> rsize = read(fd, buf, wsize);</span><br><span class="line">    <span class="keyword">if</span> (rsize == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> panic();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buf);</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">    <span class="comment">/* 关闭文件 */</span></span><br><span class="line">    <span class="keyword">int</span> stat = close(fd);</span><br><span class="line">    <span class="keyword">if</span> (stat == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> panic();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="高速缓冲区初始化"><a href="#高速缓冲区初始化" class="headerlink" title="高速缓冲区初始化"></a>高速缓冲区初始化</h2><p>上一篇已经描述过了，文件系统的结构、包括数据，都是持久化地存储在存储设备中的。</p><p>但是，我们应该也隐约的了解另一个事实，文件读写操作并不会直接操作存储设备上的数据，而是先经过一个称之为高速缓冲的内存区域。</p><p>那么，高速缓冲是什么? 究竟承担什么工作? 先来看看它的初始化流程吧。</p><p>首先回到 <code>main.c</code> (内核代码的主函数)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> ROOT_DEV = ORIG_ROOT_DEV;</span><br><span class="line"> drive_info = DRIVE_INFO;</span><br><span class="line">memory_end = (<span class="number">1</span>&lt;&lt;<span class="number">20</span>) + (EXT_MEM_K&lt;&lt;<span class="number">10</span>);</span><br><span class="line">memory_end &amp;= <span class="number">0xfffff000</span>;</span><br><span class="line"><span class="keyword">if</span> (memory_end &gt; <span class="number">16</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">memory_end = <span class="number">16</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">if</span> (memory_end &gt; <span class="number">12</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">buffer_memory_end = <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (memory_end &gt; <span class="number">6</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">buffer_memory_end = <span class="number">2</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">buffer_memory_end = <span class="number">1</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">main_memory_start = buffer_memory_end;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RAMDISK</span></span><br><span class="line">main_memory_start += rd_init(main_memory_start, RAMDISK*<span class="number">1024</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">mem_init(main_memory_start,memory_end);</span><br><span class="line">trap_init();</span><br><span class="line">blk_dev_init();</span><br><span class="line">chr_dev_init();</span><br><span class="line">tty_init();</span><br><span class="line">time_init();</span><br><span class="line">sched_init();                       <span class="comment">// 第四篇已经讲过，负责任务调度模块的初始化</span></span><br><span class="line">buffer_init(buffer_memory_end);     <span class="comment">// 本篇的起始，负责缓冲区的初始化</span></span><br><span class="line">hd_init();</span><br><span class="line">floppy_init();</span><br><span class="line">sti();</span><br><span class="line">move_to_user_mode();</span><br><span class="line"><span class="keyword">if</span> (!fork()) &#123;<span class="comment">/* we count on this going ok */</span></span><br><span class="line">init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(;;) pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>buffer_init(buffer_memory_end);</code> 用来初始化缓冲区。此处有几个原因:</p><ol><li><p>CPU 读写操作如果直接操作外存，速度上是一个极大的考验。毕竟内存已经较之 CPU 速度慢，外存的读写速度就更慢了。</p></li><li><p>解耦，其实读写操作并不仅仅发生在外存(块存储设备)，同样的，字符设备等等也都会需要读写操作，增加中间层可以封装变化。</p></li><li><p>更多，个人了解有限…</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> &#123;</span></span><br><span class="line"> <span class="keyword">char</span> * b_data;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">long</span> b_blocknr;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> b_dev;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> b_uptodate;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> b_dirt;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> b_count;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> b_lock;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">b_wait</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_prev</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_next</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_prev_free</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_next_free</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* from fs/buffer.c */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buffer_init</span><span class="params">(<span class="keyword">long</span> buffer_end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">h</span> = <span class="title">start_buffer</span>;</span></span><br><span class="line"><span class="keyword">void</span> * b;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (buffer_end == <span class="number">1</span>&lt;&lt;<span class="number">20</span>)</span><br><span class="line">b = (<span class="keyword">void</span> *) (<span class="number">640</span>*<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">b = (<span class="keyword">void</span> *) buffer_end;</span><br><span class="line"><span class="keyword">while</span> ( (b -= BLOCK_SIZE) &gt;= ((<span class="keyword">void</span> *) (h+<span class="number">1</span>)) ) &#123;</span><br><span class="line">h-&gt;b_dev = <span class="number">0</span>;</span><br><span class="line">h-&gt;b_dirt = <span class="number">0</span>;</span><br><span class="line">h-&gt;b_count = <span class="number">0</span>;</span><br><span class="line">h-&gt;b_lock = <span class="number">0</span>;</span><br><span class="line">h-&gt;b_uptodate = <span class="number">0</span>;</span><br><span class="line">h-&gt;b_wait = <span class="literal">NULL</span>;</span><br><span class="line">h-&gt;b_next = <span class="literal">NULL</span>;</span><br><span class="line">h-&gt;b_prev = <span class="literal">NULL</span>;</span><br><span class="line">h-&gt;b_data = (<span class="keyword">char</span> *) b;</span><br><span class="line">h-&gt;b_prev_free = h<span class="number">-1</span>;</span><br><span class="line">h-&gt;b_next_free = h+<span class="number">1</span>;</span><br><span class="line">h++;</span><br><span class="line">NR_BUFFERS++;</span><br><span class="line">        <span class="comment">/* 跳过 640K ~ 1M 的显存和 BIOS RAM 部分 */</span></span><br><span class="line"><span class="keyword">if</span> (b == (<span class="keyword">void</span> *) <span class="number">0x100000</span>)</span><br><span class="line">b = (<span class="keyword">void</span> *) <span class="number">0xA0000</span>;</span><br><span class="line">&#125;</span><br><span class="line">h--;</span><br><span class="line">free_list = start_buffer;</span><br><span class="line">free_list-&gt;b_prev_free = h;</span><br><span class="line">h-&gt;b_next_free = free_list;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;NR_HASH;i++)</span><br><span class="line">hash_table[i]=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缓冲块的所有关键信息都由 <code>buffer_head</code> 数据结构进行记录, 至于有多少个 <code>buffer_head</code>? 只能说能划分多少就划分多少。</p><p>比较直观的结构信息如下</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwy2iag1exj31kw0k1dgb.jpg" alt=""></p><p>在 <code>main.c</code> 中已经提前确认了内核程序占用内存的大小，缓冲区大小以及主内存大小。</p><p>在高速缓冲区的开始位置，都用来存储 <code>buffer_head</code> 的信息，与每个缓冲块(从缓冲区结束位置开始分配)一一对应，直到中间某个位置不足以分配缓冲块为止。</p><p>另外的信息，就是可以看到一个 <code>hash_table</code> 数据结构了。</p><p>应该都能够想象，每个缓存块与外存中的数据块相对应，通过设备号 + 数据块号进行唯一定位。但是，如何快速查找需要操作的数据块是否已经存在与高速缓存中了呢? 显然直接遍历查找是不太可靠的办法。采用开放地址法的哈希表能够协助快速定位缓冲块。</p><h2 id="挂载文件系统"><a href="#挂载文件系统" class="headerlink" title="挂载文件系统"></a>挂载文件系统</h2><p>既然高速缓冲区都准备就绪了，那么文件系统是否已经挂载了呢? 很遗憾，知道 <code>main()</code> 调用 <code>init()</code> 函数之前，文件系统依然没有挂载，也就是说，CPU 仍然只能通过基本输入输出对存储设备进行相当初级的 IO 操作。</p><p>那么，什么时候才能去挂载根目录呢?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* from init/main.c */</span></span><br><span class="line"><span class="comment">/* 由 main() 触发 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pid,i;</span><br><span class="line">    <span class="comment">/* 这是比较重要的一环了，开始挂载的起始动作 */</span></span><br><span class="line">setup((<span class="keyword">void</span> *) &amp;drive_info);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>setup</code> 函数做了什么呢？这是一个内嵌汇编，主要做的就是触发系统调用 <code>int 0x80</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">__inline__ int setup(void * BIOS) &#123; </span><br><span class="line">    long __res; </span><br><span class="line">    __asm__ volatile (</span><br><span class="line">            &quot;int $0x80&quot; </span><br><span class="line">            : &quot;=a&quot; (__res) </span><br><span class="line">            : &quot;0&quot; (0),&quot;b&quot; ((long)(BIOS))</span><br><span class="line">    ); </span><br><span class="line">    if (__res &gt;= 0) </span><br><span class="line">        return (int) __res; </span><br><span class="line">    errno = -__res; </span><br><span class="line">    return -1; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中看到给出的 <code>EAX = 0</code>, 查表(表在 <code>include/linux/sys.h</code> 里) 可以知道触发的是 <code>sys_setup</code> 函数(函数位于 <code>kernel/blk_drv/hd.c</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This may be used only once, enforced by 'static int callable' */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_setup</span><span class="params">(<span class="keyword">void</span> * BIOS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> callable = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> i,drive;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> cmos_disks;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">partition</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* setup 只允许被调用一次 */</span></span><br><span class="line"><span class="keyword">if</span> (!callable)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">callable = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 可以强制在源码中指定硬盘参数, 所以加了宏定义作判断*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HD_TYPE</span></span><br><span class="line"><span class="keyword">for</span> (drive=<span class="number">0</span> ; drive&lt;<span class="number">2</span> ; drive++) &#123;</span><br><span class="line">hd_info[drive].cyl = *(<span class="keyword">unsigned</span> <span class="keyword">short</span> *) BIOS;</span><br><span class="line">hd_info[drive].head = *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *) (<span class="number">2</span>+BIOS);</span><br><span class="line">hd_info[drive].wpcom = *(<span class="keyword">unsigned</span> <span class="keyword">short</span> *) (<span class="number">5</span>+BIOS);</span><br><span class="line">hd_info[drive].ctl = *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *) (<span class="number">8</span>+BIOS);</span><br><span class="line">hd_info[drive].lzone = *(<span class="keyword">unsigned</span> <span class="keyword">short</span> *) (<span class="number">12</span>+BIOS);</span><br><span class="line">hd_info[drive].sect = *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *) (<span class="number">14</span>+BIOS);</span><br><span class="line">BIOS += <span class="number">16</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hd_info[<span class="number">1</span>].cyl)</span><br><span class="line">NR_HD=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">NR_HD=<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;NR_HD ; i++) &#123;</span><br><span class="line">hd[i*<span class="number">5</span>].start_sect = <span class="number">0</span>;</span><br><span class="line">hd[i*<span class="number">5</span>].nr_sects = hd_info[i].head*</span><br><span class="line">hd_info[i].sect*hd_info[i].cyl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">We querry CMOS about hard disks : it could be that</span></span><br><span class="line"><span class="comment">we have a SCSI/ESDI/etc controller that is BIOS</span></span><br><span class="line"><span class="comment">compatable with ST-506, and thus showing up in our</span></span><br><span class="line"><span class="comment">BIOS table, but not register compatable, and therefore</span></span><br><span class="line"><span class="comment">not present in CMOS.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Furthurmore, we will assume that our ST-506 drives</span></span><br><span class="line"><span class="comment">&lt;if any&gt; are the primary drives in the system, and</span></span><br><span class="line"><span class="comment">the ones reflected as drive 1 or 2.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The first drive is stored in the high nibble of CMOS</span></span><br><span class="line"><span class="comment">byte 0x12, the second in the low nibble.  This will be</span></span><br><span class="line"><span class="comment">either a 4 bit drive type or 0xf indicating use byte 0x19</span></span><br><span class="line"><span class="comment">for an 8 bit type, drive 1, 0x1a for drive 2 in CMOS.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Needless to say, a non-zero value means we have</span></span><br><span class="line"><span class="comment">an AT controller hard disk for that drive.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((cmos_disks = CMOS_READ(<span class="number">0x12</span>)) &amp; <span class="number">0xf0</span>)</span><br><span class="line"><span class="keyword">if</span> (cmos_disks &amp; <span class="number">0x0f</span>)</span><br><span class="line">NR_HD = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">NR_HD = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">NR_HD = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = NR_HD ; i &lt; <span class="number">2</span> ; i++) &#123;</span><br><span class="line">hd[i*<span class="number">5</span>].start_sect = <span class="number">0</span>;</span><br><span class="line">hd[i*<span class="number">5</span>].nr_sects = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/* 更进一步设置每个盘的参数 */</span></span><br><span class="line"><span class="keyword">for</span> (drive=<span class="number">0</span> ; drive&lt;NR_HD ; drive++) &#123;</span><br><span class="line">        <span class="comment">/* 0x300 和 0x305 分别代表两个硬盘 */</span></span><br><span class="line">        <span class="comment">/* 读取每个硬盘的第一块数据 (1024B) */</span></span><br><span class="line"><span class="keyword">if</span> (!(bh = bread(<span class="number">0x300</span> + drive*<span class="number">5</span>,<span class="number">0</span>))) &#123;</span><br><span class="line">printk(<span class="string">"Unable to read partition table of drive %d\n\r"</span>,</span><br><span class="line">drive);</span><br><span class="line">panic(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">/* 判断硬盘有效性 */</span></span><br><span class="line"><span class="keyword">if</span> (bh-&gt;b_data[<span class="number">510</span>] != <span class="number">0x55</span> || (<span class="keyword">unsigned</span> <span class="keyword">char</span>)</span><br><span class="line">    bh-&gt;b_data[<span class="number">511</span>] != <span class="number">0xAA</span>) &#123;</span><br><span class="line">printk(<span class="string">"Bad partition table on drive %d\n\r"</span>,drive);</span><br><span class="line">panic(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">/* 读取分区表 (位于 引导扇区第 446 字节开始处 */</span></span><br><span class="line">p = <span class="number">0x1BE</span> + (<span class="keyword">void</span> *)bh-&gt;b_data;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;<span class="number">5</span>;i++,p++) &#123;</span><br><span class="line">hd[i+<span class="number">5</span>*drive].start_sect = p-&gt;start_sect;</span><br><span class="line">hd[i+<span class="number">5</span>*drive].nr_sects = p-&gt;nr_sects;</span><br><span class="line">&#125;</span><br><span class="line">brelse(bh);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (NR_HD)</span><br><span class="line">printk(<span class="string">"Partition table%s ok.\n\r"</span>,(NR_HD&gt;<span class="number">1</span>)?<span class="string">"s"</span>:<span class="string">""</span>);</span><br><span class="line">rd_load();              <span class="comment">/* 尝试创建并加载虚拟盘 */</span></span><br><span class="line">mount_root();           <span class="comment">/* mount 根文件系统 */</span></span><br><span class="line"><span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于到了挂载文件系统的时候了</p><p><code>mount_root</code> 用来做初级的初始化工作。同时，上一节已经描述过了，存储设备的超级块是用了记录整个文件系统最重要的结构。</p><p>那么通过将超级块的信息读取到内存，也就可以将内存与外存的文件系统相互联系起来了。</p><p>下面这段代码最重要的内容就是 <code>read_super()</code> 函数了 .</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mount_root</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,<span class="built_in">free</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">p</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">mi</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">32</span> != <span class="keyword">sizeof</span> (struct d_inode))</span><br><span class="line">panic(<span class="string">"bad i-node size"</span>);</span><br><span class="line">    <span class="comment">/* 先初始化文件表，该版本操作系统限制最大同时打开 NR_FILE(64个) 文件 */</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;NR_FILE;i++)</span><br><span class="line">        <span class="comment">/* f_count = 0 表明没有被引用 */</span></span><br><span class="line">file_table[i].f_count=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 如果引导盘是软盘的话，提示插入根文件系统盘 */</span></span><br><span class="line"><span class="keyword">if</span> (MAJOR(ROOT_DEV) == <span class="number">2</span>) &#123;</span><br><span class="line">printk(<span class="string">"Insert root floppy and press ENTER"</span>);</span><br><span class="line">wait_for_keypress();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/* 初始化内存超级块数据结构 (总共 8 个) */</span></span><br><span class="line"><span class="keyword">for</span>(p = &amp;super_block[<span class="number">0</span>] ; p &lt; &amp;super_block[NR_SUPER] ; p++) &#123;</span><br><span class="line">p-&gt;s_dev = <span class="number">0</span>;</span><br><span class="line">p-&gt;s_lock = <span class="number">0</span>;</span><br><span class="line">p-&gt;s_wait = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/* Hint: 读取超级块的信息，挂载根文件系统重要的部分(代码请往下翻) */</span></span><br><span class="line"><span class="keyword">if</span> (!(p=read_super(ROOT_DEV)))</span><br><span class="line">panic(<span class="string">"Unable to mount root"</span>);</span><br><span class="line">    <span class="comment">/* 读取文件系统的 1 号i节点 (即该设备上文件系统的根节点) */</span></span><br><span class="line"><span class="keyword">if</span> (!(mi=iget(ROOT_DEV,ROOT_INO)))</span><br><span class="line">panic(<span class="string">"Unable to read root i-node"</span>);</span><br><span class="line">mi-&gt;i_count += <span class="number">3</span> ;<span class="comment">/* NOTE! it is logically used 4 times, not 1 */</span></span><br><span class="line">p-&gt;s_isup = p-&gt;s_imount = mi;</span><br><span class="line">    <span class="comment">/* 应该还记得吧，current 指的是当前的任务(任务1)，以后所有的任务都会由任务1或任务1的子任务进行派生，也就意味着 current-&gt;root 会一直复制过去</span></span><br><span class="line"><span class="comment">     * 到这里为止，应该认为根文件系统以及被挂载了。是不是跟被耍了一样?</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">current-&gt;pwd = mi;</span><br><span class="line">current-&gt;root = mi;</span><br><span class="line"><span class="built_in">free</span>=<span class="number">0</span>;</span><br><span class="line">i=p-&gt;s_nzones;</span><br><span class="line">    <span class="comment">/* 统计还有多少空闲数据块以及多少可用i节点 (附上一张启动过程中打印的信息) */</span></span><br><span class="line"><span class="keyword">while</span> (-- i &gt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> (!set_bit(i&amp;<span class="number">8191</span>,p-&gt;s_zmap[i&gt;&gt;<span class="number">13</span>]-&gt;b_data))</span><br><span class="line"><span class="built_in">free</span>++;</span><br><span class="line">printk(<span class="string">"%d/%d free blocks\n\r"</span>,<span class="built_in">free</span>,p-&gt;s_nzones);</span><br><span class="line"><span class="built_in">free</span>=<span class="number">0</span>;</span><br><span class="line">i=p-&gt;s_ninodes+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (-- i &gt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> (!set_bit(i&amp;<span class="number">8191</span>,p-&gt;s_imap[i&gt;&gt;<span class="number">13</span>]-&gt;b_data))</span><br><span class="line"><span class="built_in">free</span>++;</span><br><span class="line">printk(<span class="string">"%d/%d free inodes\n\r"</span>,<span class="built_in">free</span>,p-&gt;s_ninodes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwz8kvvgbpj30l006i3yb.jpg" alt=""></p><p>重要要的部分，<code>read_super(int dev)</code>，用于读取超级块的数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct super_block * <span class="title">read_super</span><span class="params">(<span class="keyword">int</span> dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">s</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line"><span class="keyword">int</span> i,block;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!dev)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">check_disk_change(dev);</span><br><span class="line">    <span class="comment">/* 如果该超级块已经在内存中了，那么就直接使用 (和这里挂载根文件系统的流程无关) */</span></span><br><span class="line"><span class="keyword">if</span> (s = get_super(dev))</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">    <span class="comment">/* 设备超级块不在内存中，就先找一个空闲的内存超级块 (总共维护 8 个超级块数据结构) */</span></span><br><span class="line"><span class="keyword">for</span> (s = <span class="number">0</span>+super_block ;; s++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s &gt;= NR_SUPER+super_block)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (!s-&gt;s_dev)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">s-&gt;s_dev = dev;</span><br><span class="line">s-&gt;s_isup = <span class="literal">NULL</span>;</span><br><span class="line">s-&gt;s_imount = <span class="literal">NULL</span>;</span><br><span class="line">s-&gt;s_time = <span class="number">0</span>;</span><br><span class="line">s-&gt;s_rd_only = <span class="number">0</span>;</span><br><span class="line">s-&gt;s_dirt = <span class="number">0</span>;</span><br><span class="line">lock_super(s);</span><br><span class="line">    <span class="comment">/* 通过 block read 读取设备第一个物理块 (每个物理块 1024 B) */</span></span><br><span class="line"><span class="keyword">if</span> (!(bh = bread(dev,<span class="number">1</span>))) &#123;</span><br><span class="line">s-&gt;s_dev=<span class="number">0</span>;</span><br><span class="line">free_super(s);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/* 复制一份超级块的数据 */</span></span><br><span class="line">*((struct d_super_block *) s) =</span><br><span class="line">*((struct d_super_block *) bh-&gt;b_data);</span><br><span class="line">    <span class="comment">/* 释放缓冲区的数据 */</span></span><br><span class="line">brelse(bh);</span><br><span class="line">    <span class="comment">/* 验证魔数, 该版本操作系统只支持 1.0 版 Minix 文件系统，魔数 0x137F */</span></span><br><span class="line"><span class="keyword">if</span> (s-&gt;s_magic != SUPER_MAGIC) &#123;</span><br><span class="line">s-&gt;s_dev = <span class="number">0</span>;</span><br><span class="line">free_super(s);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/* 先清空内存中的数据 */</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;I_MAP_SLOTS;i++)</span><br><span class="line">s-&gt;s_imap[i] = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;Z_MAP_SLOTS;i++)</span><br><span class="line">s-&gt;s_zmap[i] = <span class="literal">NULL</span>;</span><br><span class="line">block=<span class="number">2</span>;</span><br><span class="line">    <span class="comment">/* 读取 i 节点位图块 */</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span> ; i &lt; s-&gt;s_imap_blocks ; i++)</span><br><span class="line"><span class="keyword">if</span> (s-&gt;s_imap[i]=bread(dev,block))</span><br><span class="line">block++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">/* 读取数据块位图 */</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span> ; i &lt; s-&gt;s_zmap_blocks ; i++)</span><br><span class="line"><span class="keyword">if</span> (s-&gt;s_zmap[i]=bread(dev,block))</span><br><span class="line">block++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (block != <span class="number">2</span>+s-&gt;s_imap_blocks+s-&gt;s_zmap_blocks) &#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;I_MAP_SLOTS;i++)</span><br><span class="line">brelse(s-&gt;s_imap[i]);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Z_MAP_SLOTS;i++)</span><br><span class="line">brelse(s-&gt;s_zmap[i]);</span><br><span class="line">s-&gt;s_dev=<span class="number">0</span>;</span><br><span class="line">free_super(s);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">s-&gt;s_imap[<span class="number">0</span>]-&gt;b_data[<span class="number">0</span>] |= <span class="number">1</span>;</span><br><span class="line">s-&gt;s_zmap[<span class="number">0</span>]-&gt;b_data[<span class="number">0</span>] |= <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* 与前面的 wait_on_super() 对应(解开lock标志) */</span></span><br><span class="line">free_super(s);</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是觉得也没什么，就这样根文件系统已经挂载了? 毫无实感是吧。</p><h2 id="Extra-普通挂载"><a href="#Extra-普通挂载" class="headerlink" title="Extra: 普通挂载"></a>Extra: 普通挂载</h2><p>既然讲过了根文件系统的挂载。那就顺带着讲讲普通文件系统的挂载吧。</p><p>相信从命令上来讲应该比较简单也比较熟悉吧。<code>mount disk.img /mnt</code> 也算是挂载到 /mnt 下了</p><p>但是，究竟是怎么实现的呢?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_mount</span><span class="params">(<span class="keyword">char</span> * dev_name, <span class="keyword">char</span> * dir_name, <span class="keyword">int</span> rw_flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">dev_i</span>, * <span class="title">dir_i</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">sb</span>;</span></span><br><span class="line"><span class="keyword">int</span> dev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 省略大部分判断逻辑, 主要就是:</span></span><br><span class="line"><span class="comment">     * 1. 判断 dev_name 所属的设备号，读取该设备上的超级块</span></span><br><span class="line"><span class="comment">     * 2. 读取 dir_name (需要挂载到的位置)，判定是否允许被挂载(比如根节点不允许挂其它设备)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置超级块的 mount 标志 */</span></span><br><span class="line">sb-&gt;s_imount=dir_i;</span><br><span class="line">    <span class="comment">/* 设置该 i 节点的 mount 标志 */</span></span><br><span class="line">dir_i-&gt;i_mount=<span class="number">1</span>;</span><br><span class="line">dir_i-&gt;i_dirt=<span class="number">1</span>;<span class="comment">/* NOTE! we don't iput(dir_i) */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">/* we do that in umount */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><p>前面讲了这么多，终于到了最关心的部分了。当然，也并不是说前面的内容不重要，事实上，相当重要，只是都隐藏在了内核引导的过程中，且调用频度低，才导致了没有存在感。但是这恰恰才是支持文件读写的基石。</p><p>不多说废话，下面就要开始文件读写的内容。</p><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>打开文件的函数原型是 <code>int open(const char * filename, int flag, ...);</code></p><p>当然，此类系统调用最终的实现都是 <code>int 0x80</code> , 明确一个调用号，然后就陷入内核态了。</p><p>内核态下调用的函数是: <code>int sys_open(const char * filename,int flag,int mode)</code> </p><p>来看看细节:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * filename,<span class="keyword">int</span> flag,<span class="keyword">int</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">f</span>;</span></span><br><span class="line"><span class="keyword">int</span> i,fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * current 是由内核数据段维护的当前任务的指针</span></span><br><span class="line"><span class="comment">     * umask 是指当前任务在新建文件时的默认掩码</span></span><br><span class="line"><span class="comment">     *   例如 Linux 默认是 022, 即新建文件被禁止了组用户与其它用户的写权限</span></span><br><span class="line"><span class="comment">     * 这里是先确定新建文件的权限</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">mode &amp;= <span class="number">0777</span> &amp; ~current-&gt;umask;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 文件描述符，每个文件单独维护一套，以数字标记</span></span><br><span class="line"><span class="comment">     * 找一个空闲的文件描述符项</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">for</span>(fd=<span class="number">0</span> ; fd&lt;NR_OPEN ; fd++)</span><br><span class="line"><span class="keyword">if</span> (!current-&gt;filp[fd])</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (fd&gt;=NR_OPEN)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 顾名思义，设置在调用 exec() 函数时主动关闭的文件</span></span><br><span class="line"><span class="comment">     * exec() 通常与 fork() 联用，fork() 负责复制一个任务，而 exec 负责替换新任务的代码和数据段(从而产生一个新的任务)</span></span><br><span class="line"><span class="comment">     * 这里的声明即是复位 fd 位置的标志，允许子任务也持有相同的文件描述符项</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">current-&gt;close_on_exec &amp;= ~(<span class="number">1</span>&lt;&lt;fd);</span><br><span class="line">f=<span class="number">0</span>+file_table;</span><br><span class="line">    <span class="comment">/* 在文件表中找一项空闲的 */</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;NR_FILE ; i++,f++)</span><br><span class="line"><span class="keyword">if</span> (!f-&gt;f_count) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (i&gt;=NR_FILE)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="comment">/* 当前任务的文件描述符项指向文件表项, 同时文件表项的引用计数+1*/</span></span><br><span class="line">(current-&gt;filp[fd]=f)-&gt;f_count++;</span><br><span class="line">    <span class="comment">/* 调用 open_namei 打开文件，如果失败则释放刚才占用的文件结构，并返回错误码 */</span></span><br><span class="line"><span class="keyword">if</span> ((i=open_namei(filename,flag,mode,&amp;inode))&lt;<span class="number">0</span>) &#123;</span><br><span class="line">current-&gt;filp[fd]=<span class="literal">NULL</span>;</span><br><span class="line">f-&gt;f_count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 对不同的文件进行不同的特殊处理, 毕竟有 "一切皆文件" 的口号嘛</span></span><br><span class="line"><span class="comment">     * 诸如字符设备等也都是文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">/* ttys are somewhat special (ttyxx major==4, tty major==5) */</span></span><br><span class="line"><span class="keyword">if</span> (S_ISCHR(inode-&gt;i_mode))</span><br><span class="line"><span class="keyword">if</span> (MAJOR(inode-&gt;i_zone[<span class="number">0</span>])==<span class="number">4</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (current-&gt;leader &amp;&amp; current-&gt;tty&lt;<span class="number">0</span>) &#123;</span><br><span class="line">current-&gt;tty = MINOR(inode-&gt;i_zone[<span class="number">0</span>]);</span><br><span class="line">tty_table[current-&gt;tty].pgrp = current-&gt;pgrp;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (MAJOR(inode-&gt;i_zone[<span class="number">0</span>])==<span class="number">5</span>)</span><br><span class="line"><span class="keyword">if</span> (current-&gt;tty&lt;<span class="number">0</span>) &#123;</span><br><span class="line">iput(inode);</span><br><span class="line">current-&gt;filp[fd]=<span class="literal">NULL</span>;</span><br><span class="line">f-&gt;f_count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Likewise with block-devices: check for floppy_change */</span></span><br><span class="line"><span class="keyword">if</span> (S_ISBLK(inode-&gt;i_mode))</span><br><span class="line">check_disk_change(inode-&gt;i_zone[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">/* 初始化内存文件结构的各个参数 */</span></span><br><span class="line">f-&gt;f_mode = inode-&gt;i_mode;</span><br><span class="line">f-&gt;f_flags = flag;</span><br><span class="line">f-&gt;f_count = <span class="number">1</span>;</span><br><span class="line">f-&gt;f_inode = inode;</span><br><span class="line">f-&gt;f_pos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> (fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在整个打开文件的过程中，除了真正去文件系统查找文件的时候用到了文件名，其它时候，都将是以文件描述符进行交互的。</p><p>再看看更细节的方面，毕竟就目前来说，我们跳过了最重要的一环 <code>open_namei</code> ，从而看似整个流程都简单了很多很多。</p><p>通常我们在编码过程中都是通过绝对地址/相对地址来唯一定位一个文件。因此，就必然存在逐级寻找文件的过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct m_inode * <span class="title">get_dir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * thisname;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line"><span class="keyword">int</span> namelen,inr,idev;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span> * <span class="title">de</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判定当前任务设定的根节点是否有效 */</span></span><br><span class="line"><span class="keyword">if</span> (!current-&gt;root || !current-&gt;root-&gt;i_count)</span><br><span class="line">panic(<span class="string">"No root inode"</span>);</span><br><span class="line">    <span class="comment">/* 判定当前路径i节点是否有效 */</span></span><br><span class="line"><span class="keyword">if</span> (!current-&gt;pwd || !current-&gt;pwd-&gt;i_count)</span><br><span class="line">panic(<span class="string">"No cwd inode"</span>);</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 这里的 get_fs_byte(..) 是宏定义，fs 指的是 FS 段寄存器</span></span><br><span class="line"><span class="comment">     * Linux 内核将 DS, ES 用于内核数据段, 用 FS 指向局部描述符表的当前任务数据段</span></span><br><span class="line"><span class="comment">     * 这里可以简单理解成取字符数组的第一个字节</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">if</span> ((c=get_fs_byte(pathname))==<span class="string">'/'</span>) &#123;</span><br><span class="line">inode = current-&gt;root;</span><br><span class="line">pathname++;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (c)</span><br><span class="line">inode = current-&gt;pwd;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">/* empty name is bad */</span></span><br><span class="line">inode-&gt;i_count++;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">thisname = pathname;</span><br><span class="line"><span class="keyword">if</span> (!S_ISDIR(inode-&gt;i_mode) || !permission(inode,MAY_EXEC)) &#123;</span><br><span class="line">iput(inode);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(namelen=<span class="number">0</span>;(c=get_fs_byte(pathname++))&amp;&amp;(c!=<span class="string">'/'</span>);namelen++)</span><br><span class="line"><span class="comment">/* nothing */</span> ;</span><br><span class="line"><span class="keyword">if</span> (!c)</span><br><span class="line"><span class="keyword">return</span> inode;</span><br><span class="line"><span class="keyword">if</span> (!(bh = find_entry(&amp;inode,thisname,namelen,&amp;de))) &#123;</span><br><span class="line">iput(inode);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">inr = de-&gt;inode;</span><br><span class="line">idev = inode-&gt;i_dev;</span><br><span class="line">brelse(bh);</span><br><span class="line">iput(inode);</span><br><span class="line"><span class="keyword">if</span> (!(inode = iget(idev,inr)))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *dir_namei()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 处理路径 pathname, 处理成i节点表示的最终一级目录+目录下文件名(也可能pathname表示的就是目录)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct m_inode * <span class="title">dir_namei</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname, <span class="keyword">int</span> * namelen, <span class="keyword">const</span> <span class="keyword">char</span> ** name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * basename;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">dir</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(dir = get_dir(pathname)))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">basename = pathname;</span><br><span class="line"><span class="keyword">while</span> (c=get_fs_byte(pathname++))</span><br><span class="line"><span class="keyword">if</span> (c==<span class="string">'/'</span>)</span><br><span class="line">basename=pathname;</span><br><span class="line">*namelen = pathname-basename<span class="number">-1</span>;</span><br><span class="line">*name = basename;</span><br><span class="line"><span class="keyword">return</span> dir;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *open_namei()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * namei for open - this is in fact almost the whole open-routine.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_namei</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname, <span class="keyword">int</span> flag, <span class="keyword">int</span> mode,</span></span></span><br><span class="line"><span class="function"><span class="params">struct m_inode ** res_inode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * basename;</span><br><span class="line"><span class="keyword">int</span> inr,dev,namelen;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">dir</span>, *<span class="title">inode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span> * <span class="title">de</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((flag &amp; O_TRUNC) &amp;&amp; !(flag &amp; O_ACCMODE))</span><br><span class="line">flag |= O_WRONLY;</span><br><span class="line">mode &amp;= <span class="number">0777</span> &amp; ~current-&gt;umask;</span><br><span class="line">mode |= I_REGULAR;</span><br><span class="line"><span class="keyword">if</span> (!(dir = dir_namei(pathname,&amp;namelen,&amp;basename)))</span><br><span class="line"><span class="keyword">return</span> -ENOENT;</span><br><span class="line">    <span class="comment">/* 如果给的 pathname 是一个目录 */</span></span><br><span class="line"><span class="keyword">if</span> (!namelen) &#123;<span class="comment">/* special case: '/usr/' etc */</span></span><br><span class="line"><span class="keyword">if</span> (!(flag &amp; (O_ACCMODE|O_CREAT|O_TRUNC))) &#123;</span><br><span class="line">*res_inode=dir;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">iput(dir);</span><br><span class="line"><span class="keyword">return</span> -EISDIR;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/* 找到目录对应的i节点的数据块 */</span></span><br><span class="line">bh = find_entry(&amp;dir,basename,namelen,&amp;de);</span><br><span class="line"><span class="keyword">if</span> (!bh) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(flag &amp; O_CREAT)) &#123;</span><br><span class="line">iput(dir);</span><br><span class="line"><span class="keyword">return</span> -ENOENT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!permission(dir,MAY_WRITE)) &#123;</span><br><span class="line">iput(dir);</span><br><span class="line"><span class="keyword">return</span> -EACCES;</span><br><span class="line">&#125;</span><br><span class="line">inode = new_inode(dir-&gt;i_dev);</span><br><span class="line"><span class="keyword">if</span> (!inode) &#123;</span><br><span class="line">iput(dir);</span><br><span class="line"><span class="keyword">return</span> -ENOSPC;</span><br><span class="line">&#125;</span><br><span class="line">inode-&gt;i_uid = current-&gt;euid;</span><br><span class="line">inode-&gt;i_mode = mode;</span><br><span class="line">inode-&gt;i_dirt = <span class="number">1</span>;</span><br><span class="line">bh = add_entry(dir,basename,namelen,&amp;de);</span><br><span class="line"><span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">inode-&gt;i_nlinks--;</span><br><span class="line">iput(inode);</span><br><span class="line">iput(dir);</span><br><span class="line"><span class="keyword">return</span> -ENOSPC;</span><br><span class="line">&#125;</span><br><span class="line">de-&gt;inode = inode-&gt;i_num;</span><br><span class="line">bh-&gt;b_dirt = <span class="number">1</span>;</span><br><span class="line">brelse(bh);</span><br><span class="line">iput(dir);</span><br><span class="line">*res_inode = inode;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">inr = de-&gt;inode;</span><br><span class="line">dev = dir-&gt;i_dev;</span><br><span class="line">brelse(bh);</span><br><span class="line">iput(dir);</span><br><span class="line"><span class="keyword">if</span> (flag &amp; O_EXCL)</span><br><span class="line"><span class="keyword">return</span> -EEXIST;</span><br><span class="line"><span class="keyword">if</span> (!(inode=iget(dev,inr)))</span><br><span class="line"><span class="keyword">return</span> -EACCES;</span><br><span class="line"><span class="keyword">if</span> ((S_ISDIR(inode-&gt;i_mode) &amp;&amp; (flag &amp; O_ACCMODE)) ||</span><br><span class="line">    !permission(inode,ACC_MODE(flag))) &#123;</span><br><span class="line">iput(inode);</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line">&#125;</span><br><span class="line">inode-&gt;i_atime = CURRENT_TIME;</span><br><span class="line"><span class="keyword">if</span> (flag &amp; O_TRUNC)</span><br><span class="line">truncate(inode);</span><br><span class="line">*res_inode = inode;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h3><p>接下来就要进行文件写入的流程了</p><p>如何陷入内核态函数就不再细说了，相信看过这么多系统调用之后，也能知道基本上系统调用在内核态对应的函数都是以 sys_<method> 形式出现的</method></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_write</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> fd,<span class="keyword">char</span> * buf,<span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">file</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 非法 fd , 抛异常 */</span></span><br><span class="line"><span class="keyword">if</span> (fd&gt;=NR_OPEN || count &lt;<span class="number">0</span> || !(file=current-&gt;filp[fd]))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="comment">/* count = 0，无需写入数据 */</span></span><br><span class="line"><span class="keyword">if</span> (!count)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">inode=file-&gt;f_inode;</span><br><span class="line">    <span class="comment">/* 针对不同的i节点类型，有不同的写入函数 */</span></span><br><span class="line"><span class="keyword">if</span> (inode-&gt;i_pipe)</span><br><span class="line"><span class="keyword">return</span> (file-&gt;f_mode&amp;<span class="number">2</span>)?write_pipe(inode,buf,count):-EIO;</span><br><span class="line"><span class="keyword">if</span> (S_ISCHR(inode-&gt;i_mode))</span><br><span class="line"><span class="keyword">return</span> rw_char(WRITE,inode-&gt;i_zone[<span class="number">0</span>],buf,count,&amp;file-&gt;f_pos);</span><br><span class="line"><span class="keyword">if</span> (S_ISBLK(inode-&gt;i_mode))</span><br><span class="line"><span class="keyword">return</span> block_write(inode-&gt;i_zone[<span class="number">0</span>],&amp;file-&gt;f_pos,buf,count);</span><br><span class="line"><span class="keyword">if</span> (S_ISREG(inode-&gt;i_mode))</span><br><span class="line"><span class="keyword">return</span> file_write(inode,file,buf,count);</span><br><span class="line">printk(<span class="string">"(Write)inode-&gt;i_mode=%06o\n\r"</span>,inode-&gt;i_mode);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看对于常规文件是怎么操作的吧。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_write</span><span class="params">(struct m_inode * inode, struct file * filp, <span class="keyword">char</span> * buf, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">off_t</span> pos;      <span class="comment">/* 偏移量 */</span></span><br><span class="line"><span class="keyword">int</span> block,c;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line"><span class="keyword">char</span> * p;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果是 Append 模式，把偏移量重置到文件末尾 */</span></span><br><span class="line"><span class="keyword">if</span> (filp-&gt;f_flags &amp; O_APPEND) </span><br><span class="line">pos = inode-&gt;i_size;</span><br><span class="line">    <span class="comment">/* 否则就使用当前文件数据结构持有的偏移量 */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        附上数据结构  file 的内容 </span></span><br><span class="line"><span class="comment">        struct file &#123;</span></span><br><span class="line"><span class="comment">        unsigned short f_mode;</span></span><br><span class="line"><span class="comment">        unsigned short f_flags;</span></span><br><span class="line"><span class="comment">        unsigned short f_count;</span></span><br><span class="line"><span class="comment">        struct m_inode * f_inode;</span></span><br><span class="line"><span class="comment">        off_t f_pos;    每个打开的文件都将持有当前的偏移值</span></span><br><span class="line"><span class="comment">        &#125;;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">pos = filp-&gt;f_pos;</span><br><span class="line">    <span class="comment">/* 逐字符向缓冲区写入数据 */</span></span><br><span class="line"><span class="keyword">while</span> (i&lt;count) &#123;</span><br><span class="line">        <span class="comment">/* 最开始当然是创建在磁盘上占用一个数据块了 (如果文件对应的块不存在的话) */</span></span><br><span class="line"><span class="keyword">if</span> (!(block = create_block(inode,pos/BLOCK_SIZE)))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/* 根据数据块获得相应的缓冲块 */</span></span><br><span class="line"><span class="keyword">if</span> (!(bh=bread(inode-&gt;i_dev,block)))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/* 在缓冲块中的偏移量 */</span></span><br><span class="line">c = pos % BLOCK_SIZE;</span><br><span class="line">        <span class="comment">/* 定位到具体的缓冲区的内存地址 */</span></span><br><span class="line">p = c + bh-&gt;b_data;</span><br><span class="line">bh-&gt;b_dirt = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/* 当前这个缓冲块还有多少字节可写 */</span></span><br><span class="line">c = BLOCK_SIZE-c;</span><br><span class="line">        <span class="comment">/* 如果需要写入的数据量少于 c */</span></span><br><span class="line"><span class="keyword">if</span> (c &gt; count-i) c = count-i;</span><br><span class="line">        <span class="comment">/* 添加偏移量计数, 更新数据结构中维护的值 */</span></span><br><span class="line">pos += c;</span><br><span class="line"><span class="keyword">if</span> (pos &gt; inode-&gt;i_size) &#123;</span><br><span class="line">inode-&gt;i_size = pos;</span><br><span class="line">inode-&gt;i_dirt = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">i += c;</span><br><span class="line">        <span class="comment">/* 向缓冲块逐字节写入数据 */</span></span><br><span class="line"><span class="keyword">while</span> (c--&gt;<span class="number">0</span>)</span><br><span class="line">*(p++) = get_fs_byte(buf++);</span><br><span class="line">        <span class="comment">/* 释放对缓冲块的占用，当然，在释放前会完成缓冲块&lt;-&gt;外存数据块的同步 */</span></span><br><span class="line">brelse(bh);</span><br><span class="line">&#125;</span><br><span class="line">inode-&gt;i_mtime = CURRENT_TIME;</span><br><span class="line"><span class="keyword">if</span> (!(filp-&gt;f_flags &amp; O_APPEND)) &#123;</span><br><span class="line">        <span class="comment">/* 非 APPEND 模式，更新文件读写指针(偏移量); APPEND 模式是使用 inode-&gt;i_size ，所有就不需要在这里更新了 */</span></span><br><span class="line">filp-&gt;f_pos = pos;</span><br><span class="line">inode-&gt;i_ctime = CURRENT_TIME;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (i?i:<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是觉得也没有什么太高大上的操作。确实如此，更多关于缓存块与文件系统数据块的同步都已经被包装到 bread(), brelse() 中了。</p><p>不过，暂时无需细究。总之到此为止，先要有一个基础的观念: 所有与外存储器(这里也包括控制台等)进行数据交互都必须经过缓冲区</p><p>缓冲区封装了对外存储器的全部操作，而提供给 CPU 更高效的 I/O 操作，当然，也更为简单快捷</p><h3 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h3><p>至于文件读取，也基本类似了，所以也就不再深入描述。</p><p>当然，要注意的就是，在本篇开始的部分提供的例程中，write &amp; read 中插入了 <code>off_t off = lseek(fd, 0, SEEK_SET);</code>  这样的代码。</p><p>原因应该也能够想到，学习 <code>sys_write(..)</code> 的时候我们已经看到，任务对同一个文件在内存中维护了一个文件读写偏移量。因此，要读取刚才写入的内容，就不得不先改动这个读写偏移量了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_read</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> fd,<span class="keyword">char</span> * buf,<span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">file</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fd&gt;=NR_OPEN || count&lt;<span class="number">0</span> || !(file=current-&gt;filp[fd]))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (!count)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">verify_area(buf,count);</span><br><span class="line">inode = file-&gt;f_inode;</span><br><span class="line"><span class="keyword">if</span> (inode-&gt;i_pipe)</span><br><span class="line"><span class="keyword">return</span> (file-&gt;f_mode&amp;<span class="number">1</span>)?read_pipe(inode,buf,count):-EIO;</span><br><span class="line"><span class="keyword">if</span> (S_ISCHR(inode-&gt;i_mode))</span><br><span class="line"><span class="keyword">return</span> rw_char(READ,inode-&gt;i_zone[<span class="number">0</span>],buf,count,&amp;file-&gt;f_pos);</span><br><span class="line"><span class="keyword">if</span> (S_ISBLK(inode-&gt;i_mode))</span><br><span class="line"><span class="keyword">return</span> block_read(inode-&gt;i_zone[<span class="number">0</span>],&amp;file-&gt;f_pos,buf,count);</span><br><span class="line"><span class="keyword">if</span> (S_ISDIR(inode-&gt;i_mode) || S_ISREG(inode-&gt;i_mode)) &#123;</span><br><span class="line"><span class="keyword">if</span> (count+file-&gt;f_pos &gt; inode-&gt;i_size)</span><br><span class="line">count = inode-&gt;i_size - file-&gt;f_pos;</span><br><span class="line"><span class="keyword">if</span> (count&lt;=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> file_read(inode,file,buf,count);</span><br><span class="line">&#125;</span><br><span class="line">printk(<span class="string">"(Read)inode-&gt;i_mode=%06o\n\r"</span>,inode-&gt;i_mode);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这篇对文件系统的代码层面的描述，仅仅只是捡了一个相当有限的片面 (常规文件读写)。从文件系统的挂载开始提供了一个读写的完整流程介绍(当然，很多细节是缺失的，不过不要着急)。</p><p>虽然平常都能够了解到一个比较模糊的前提，文件读写需要利用缓冲区，但是究竟什么是缓存区，如何使用都不会有太多的概念。本篇最大的重点，就是首先请读者们建立起一个基础性的对缓冲区的了解。事实上，这个中介在 I/O 中扮演了相当重要的角色。而且内存也为其提供了相当大的一份空间，差不多有 1/4 了。</p><p>跨了差不多半个多月来写，上下文的承接可能有些生硬了，甚至不一致了… 尴尬…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://dormouse-none.github.io/2018-10-14-understand-Kernel-5/&quot;&gt;前一篇&lt;/a&gt;已经描述对文件系统进行了宏观性的描述，这一篇，将以特定的文件读写操作为示例，串联对整个文件系统的基本操作。&lt;/p&gt;
&lt;p&gt;首先先来看看平台相关的文件读写操作的 C 代码是怎样一个调用方式&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;fcntl.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;errno.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;sys/stat.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;fprintf&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;stderr&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;%s (errno=%d)\n&quot;&lt;/span&gt;, strerror(errno), errno);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *argv[])&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* 打开文件 frw.txt (以可读写 | 若不存在则新建的形式) */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; fd = open(&lt;span class=&quot;string&quot;&gt;&quot;/root/frw.txt&quot;&lt;/span&gt;, O_RDWR | O_CREAT);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (fd == &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; panic();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* 向文件写入 Hello World! 共计 12 个字符 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;ssize_t&lt;/span&gt; wsize = write(fd, &lt;span class=&quot;string&quot;&gt;&quot;Hello World!&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (wsize == &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; panic();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* 重定位文件读写指针 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;off_t&lt;/span&gt; off = lseek(fd, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, SEEK_SET);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (off == &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; panic();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;* buf = (&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *) &lt;span class=&quot;built_in&quot;&gt;malloc&lt;/span&gt;(wsize);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* 读取文件内容 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;ssize_t&lt;/span&gt; rsize = read(fd, buf, wsize);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (rsize == &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; panic();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%s\n&quot;&lt;/span&gt;, buf);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;free&lt;/span&gt;(buf);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* 关闭文件 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; stat = close(fd);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (stat == &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; panic();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://DorMOUSE-None.github.io/tags/Linux/"/>
    
      <category term="Kernel" scheme="https://DorMOUSE-None.github.io/tags/Kernel/"/>
    
      <category term="File System" scheme="https://DorMOUSE-None.github.io/tags/File-System/"/>
    
      <category term="read &amp; write" scheme="https://DorMOUSE-None.github.io/tags/read-write/"/>
    
  </entry>
  
  <entry>
    <title>理解 Linux Kernel (5) - 文件系统(宏观描述)</title>
    <link href="https://DorMOUSE-None.github.io/2018-10-14-understand-Kernel-5/"/>
    <id>https://DorMOUSE-None.github.io/2018-10-14-understand-Kernel-5/</id>
    <published>2018-10-13T16:00:00.000Z</published>
    <updated>2018-10-28T05:01:34.567Z</updated>
    
    <content type="html"><![CDATA[<p>用惯了类 Unix 系统，应该说文件系统是日常最常接触的一个操作系统模块之一了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">Applications Network      Users        bin          data         etc          net          sbin         usr</span><br><span class="line">Library      System       Volumes      cores        dev          home         private      tmp          var</span><br></pre></td></tr></table></figure><p>但是，究竟什么是文件系统? 为什么需要文件系统? 难道文件不是简单地存储到存储设备一块连续区域的吗?</p><a id="more"></a><h2 id="文件系统的形式"><a href="#文件系统的形式" class="headerlink" title="文件系统的形式"></a>文件系统的形式</h2><p>首先我们假设文件是简单地存储在存储设备(硬盘等)某一块连续区域的。</p><p>那么如何在小则几百G，大则几十T甚至更大的存储设备上找到具体的某一文件，并读取的内存中呢?</p><p>最普通的，就只能在存储设备上一字节一字节的查找，直到找到相应的目标文件。是不是可以想象，这会很慢很慢。</p><p>有没有快一点的？很容易想到，参考类似字典的形式就可以了。</p><p><strong>目录形式</strong></p><p>文件内容可能很大，但相比之下，文件名就小了很多(就算不同目录下同名文件很多，但是记录全路径名也代价不大。当然了，如果都是小文件、空文件，那就不一样了)</p><p>通过为所有文件通过文件名编一个目录，指明每个文件在存储设备上的具体位置。这样需要扫描的内容就会小很多，也能更快地定位到文件内容。</p><p><strong>逐级目录</strong></p><p>仅仅只编制一个目录，那么层次目录又有什么实际意义吗？只是为了方便用户分类不同功能、目的的文件吗？</p><p>利用逐级目录，可以考虑对次级目录的内容编制上一级目录。通过顶级目录定位次级目录的内容，次级目录定位再次级目录，最后对应目录下的文件的内容。</p><h2 id="文件系统的组织"><a href="#文件系统的组织" class="headerlink" title="文件系统的组织"></a>文件系统的组织</h2><p>在之前的理解里，文件系统是接管了整个存储设备。似乎文件系统和存储设备就是直接关联的，两个不可分割。没有建立文件系统的硬盘就不能使用，而没有硬盘，文件系统就没有了载体。</p><p>但是，在学习 Linux 的过程中，似乎发现也并不是这么一回事。没有直接硬盘，文件系统一样可以存在。一直都有在使用 <code>.img</code> 磁盘映像文件，只是没有意识到，这意识文件系统的一种载体。同样的，没有文件系统，在操作系统启动的过程中，一样是可以加载各种内容，乃至预置的文件信息。</p><p>在 Linux 中，最常见的文件系统就是 ext2, ext3, ext4 之流了。偶尔也有听过用过，比如说准备接入新的硬盘的时候。但是，真正里面是什么样的。还真不了解，ext2,3,4 的区别，也根本不知道。</p><p>当然了，本次也并不会对这些内容进行描述。由于一直在学习 Linux 0.11 版本的源码，接下来要描述的文件系统，也就是 0.11 版本直接使用的 minix 文件系统了。</p><p>最开始，当然是应该有一个感官的印象，才能更方便地来理解文件系统的组织形式啦!</p><h3 id="创建文件系统"><a href="#创建文件系统" class="headerlink" title="创建文件系统"></a>创建文件系统</h3><p>这里我们创建一个 512 KB 大小的文件系统</p><p><code>mkfs</code> 应该是最简单的方式了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch disk.img            <span class="comment"># 磁盘映像文件 (由于没有额外的磁盘，就以此作为新创建的 minix 文件系统的载体)</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> dd <span class="keyword">if</span>=/dev/zero of=disk.img bs=1024 count=512     <span class="comment"># 先将文件的大小扩展到 512 KB ，否则在创建文件系统的时候会失败</span></span></span><br><span class="line">512+0 records in</span><br><span class="line">512+0 records out</span><br><span class="line">524288 bytes (524 kB, 512 KiB) copied, 0.00216049 s, 243 MB/s</span><br><span class="line"><span class="meta">$</span><span class="bash"> mkfs.minix disk.img 512   <span class="comment"># 创建文件系统</span></span></span><br><span class="line">192 inodes                  # inodes - 应该很熟悉吧。每个文件都占用一个 inode</span><br><span class="line">512 blocks                  # 总共 512 个磁盘块</span><br><span class="line">Firstdatazone=10 (10)       # 第 10 个磁盘块开始是真正的数据块。前面是什么? 大部分是目录占用的</span><br><span class="line">Zonesize=1024               # 每个磁盘块的大小为 1024 B</span><br><span class="line">Maxsize=268966912           # 单一文件的最大大小</span><br></pre></td></tr></table></figure><p>先来看看目前 disk.img 里面的内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexdump disk.img</span></span><br><span class="line">0000000 0000 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">*                                                   # * 表示这段数据全为 0</span><br><span class="line">0000400 00c0 0200 0001 0001 000a 0000 1c00 1008</span><br><span class="line">0000410 138f 0001 0000 0000 0000 0000 0000 0000</span><br><span class="line">0000420 0000 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">*</span><br><span class="line">0000800 0003 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">0000810 0000 0000 0000 0000 fffe ffff ffff ffff</span><br><span class="line">0000820 ffff ffff ffff ffff ffff ffff ffff ffff</span><br><span class="line">*                                                   # * 表示这段数据全为 ff ( * 总是表示与前一段数据一致的省略)</span><br><span class="line">0000c00 0003 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">0000c10 0000 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">*</span><br><span class="line">0000c30 0000 0000 0000 0000 0000 0000 0000 ff80</span><br><span class="line">0000c40 ffff ffff ffff ffff ffff ffff ffff ffff</span><br><span class="line">*</span><br><span class="line">0001000 41ed 0000 0040 0000 cf12 5bd3 0200 000a</span><br><span class="line">0001010 0000 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">*</span><br><span class="line">0002800 0001 002e 0000 0000 0000 0000 0000 0000</span><br><span class="line">0002810 0000 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">0002820 0001 2e2e 0000 0000 0000 0000 0000 0000</span><br><span class="line">0002830 0000 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">0002840 0000 622e 6461 6c62 636f 736b 0000 0000</span><br><span class="line">0002850 0000 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">*</span><br><span class="line">0080000                                             # 截止字节，0x80000 = 512 KB 并不存在</span><br></pre></td></tr></table></figure><p>似乎并没有太多的感觉，现在我们往 disk.img 这个磁盘映像文件中添些内容再来看看。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mount disk.img /mnt   <span class="comment"># 把 disk.img 挂载到 /mnt 目录下</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /mnt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"#include &lt;stdio.h&gt;"</span> &gt; hello.c       <span class="comment"># 创建 hello.c 文件，并写入 #include &lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> umount /mnt           <span class="comment"># 解挂 disk.img</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexdump -C disk.img</span></span><br><span class="line">00000000  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">*</span><br><span class="line">00000400  c0 00 00 02 01 00 01 00  0a 00 00 00 00 1c 08 10  |................|</span><br><span class="line">00000410  8f 13 01 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00000420  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">*</span><br><span class="line">00000800  07 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00000810  00 00 00 00 00 00 00 00  fe ff ff ff ff ff ff ff  |................|</span><br><span class="line">00000820  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|</span><br><span class="line">*</span><br><span class="line">00000c00  07 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00000c10  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">*</span><br><span class="line">00000c30  00 00 00 00 00 00 00 00  00 00 00 00 00 00 80 ff  |................|</span><br><span class="line">00000c40  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|</span><br><span class="line">*</span><br><span class="line">00001000  ed 41 00 00 60 00 00 00  e5 0d d4 5b 00 02 0a 00  |.A..`......[....|</span><br><span class="line">00001010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00001020  a4 81 00 00 13 00 00 00  e5 0d d4 5b 00 01 0b 00  |...........[....|</span><br><span class="line">00001030  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">*</span><br><span class="line">00002800  01 00 2e 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00002810  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00002820  01 00 2e 2e 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00002830  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00002840  02 00 68 65 6c 6c 6f 2e  63 00 00 00 00 00 00 00  |..hello.c.......|</span><br><span class="line">00002850  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">*</span><br><span class="line">00002c00  23 69 6e 63 6c 75 64 65  20 3c 73 74 64 69 6f 2e  |#include &lt;stdio.|</span><br><span class="line">00002c10  68 3e 0a 00 00 00 00 00  00 00 00 00 00 00 00 00  |h&gt;..............|</span><br><span class="line">00002c20  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">*</span><br><span class="line">00080000</span><br></pre></td></tr></table></figure><p>很明显，我们看到了 <code>#include &lt;stdio.h&gt;</code> 字样的内容，同时也出现了 <code>hello.c</code> 的文件名。</p><p>需要注意，文件名和文件内容是相互割裂的，并没有直接存储在一起。</p><h3 id="文件系统存储结构"><a href="#文件系统存储结构" class="headerlink" title="文件系统存储结构"></a>文件系统存储结构</h3><p>那么，配合着上面的内容来看看文件系统的组织结构。</p><p>首先可以注意到的是，每一段非零的数据的开始地址，基本都是在 <code>0x0000, 0x0400, 0x0800, 0x0c00, 0x1000</code> 。间隔了 0x0400 = 1KB，这就是最基本的块的大小。</p><p>Minix 文件系统将 1024 B 作为基本块的大小。<code>disk.img</code> 这个 512 KB 的磁盘映像文件，也就恰好被分割成 512 块。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkfs.minix disk.img 512   <span class="comment"># 创建文件系统</span></span></span><br><span class="line">192 inodes                  # inodes - 应该很熟悉吧。每个文件都占用一个 inode</span><br><span class="line">512 blocks                  # 总共 512 个磁盘块</span><br><span class="line">Firstdatazone=10 (10)       # 第 10 个磁盘块开始是真正的数据块。前面是什么? 大部分是目录占用的</span><br><span class="line">Zonesize=1024               # 每个磁盘块的大小为 1024 B</span><br><span class="line">Maxsize=268966912           # 单一文件的最大大小</span><br></pre></td></tr></table></figure><p>在回过头来看看前面创建文件系统的时候的信息，相信也就能够看懂一部分了。</p><p><strong>块的作用划分</strong></p><p>那么，每个块如何进行使用呢？</p><p>首先，最开始的一个块并不会直接使用。我们知道引导程序应该出现在引导盘最开始 512 B。但是，有些盘有引导程序，有些盘又没有，如何处理呢？</p><p>文件系统结构中，默认地不对第一个 1024 B 的块进行操作，即原本是什么数据就是什么数据，与文件系统并不相干。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwnnc753epj31kw04tq35.jpg" alt=""></p><p>除了引导块，之后还有超级块，inode 位图，逻辑块位图，inode 区块，数据区块</p><p><strong>超级块</strong></p><p>真正对 MINIX 文件系统起着统领性作用的，是超级块(第二个块)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> &#123;</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> s_ninodes;          <span class="comment">/* i 节点的数量 */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> s_nzones;           <span class="comment">/* 总区块数量 */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> s_imap_blocks;      <span class="comment">/* i 节点位图的数量 */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> s_zmap_blocks;      <span class="comment">/* 区块位图的数量 */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> s_firstdatazone;    <span class="comment">/* 第一个数据块的编号 */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> s_log_zone_size;    <span class="comment">/* log2(磁盘块大小 / 逻辑块大小) */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">long</span> s_max_size;          <span class="comment">/* 单文件的最大长度 */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> s_magic;            <span class="comment">/* 文件系统的魔数 */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 下面的内容是在内存中使用的，并不会在磁盘上进行读写 */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">s_imap</span>[8];</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">s_zmap</span>[8];</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> s_dev;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">s_isup</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">s_imount</span>;</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">long</span> s_time;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">s_wait</span>;</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> s_lock;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> s_rd_only;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> s_dirt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结合着 <code>disk.img</code> 的数据来看看。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00000400  c0 00 00 02 01 00 01 00  0a 00 00 00 00 1c 08 10  |................|</span><br><span class="line">00000410  8f 13 01 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line"></span><br><span class="line">0x00c0  -&gt; 192 个 i 节点</span><br><span class="line">0x0200  -&gt; 512 个逻辑块</span><br><span class="line">0x0001  -&gt; 一个i节点位图</span><br><span class="line">0x0001  -&gt; 一个逻辑块位图</span><br><span class="line">0x000a  -&gt; 第一个数据块编号为 10 </span><br><span class="line">0x0000  -&gt; log2(磁盘块大小 / 逻辑块大小) = 0 ，即磁盘块大小 = 逻辑块大小 = 1024 B</span><br><span class="line">0x10081c00 -&gt; 单文件最大 268966912 B</span><br></pre></td></tr></table></figure><p><strong>inode 位图</strong></p><p>inode 位图的数据比较简单，是通过设置比特位 0、1 的方式，来直接表明相应编号的 i 节点是否存在。<br>默认 i 节点从 1 号开始编号，0 号节点在 inode 位图上一定设置为 1 </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000800  07 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00000810  00 00 00 00 00 00 00 00  fe ff ff ff ff ff ff ff  |................|</span><br><span class="line">00000820  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|</span><br></pre></td></tr></table></figure><p>总共 192 个 i 节点，加上 0 号节点总计需占用 193 位 ( = 193 / 8 = 24 字节 + 1 位)</p><p>其余多余的位，全部置位为 1 。</p><p>位图存储的最初数据 0x07 (注意，小端存储法) = 0b111</p><p>由此，总共有1号和2号i节点。</p><p><strong>逻辑块位图</strong></p><p>类似的，逻辑块位图是为了表明第n个逻辑块存储有数据，或处于空闲状态。</p><p><strong>inode 区块</strong></p><p>参照前面讲过的字典目录的形式，inode 就是一种分级编排后的目录。</p><p>当然，说目录可能还会引发误解。这里无论是对于操作系统下的目录或是文件，每一个都对应着一个独特的 inode</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">d_inode</span> &#123;</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> i_mode;     <span class="comment">/* 文件类型和属性 (rwx 位) */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> i_uid;      <span class="comment">/* 文件所有者 id */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">long</span> i_size;      <span class="comment">/* 文件大小 */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">long</span> i_time;      <span class="comment">/* 修改时间 */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> i_gid;       <span class="comment">/* 文件所在组 id */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> i_nlinks;    <span class="comment">/* 有多少个链接数 (有多少个文件目录项指向该 i 节点) */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> i_zone[<span class="number">9</span>];  <span class="comment">/* 文件数据所占用数据盘的指针 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个i节点的数据分别 32 字节</p><p>同样的，结合 <code>disk.img</code> 的数据来看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">00001000  ed 41 00 00 60 00 00 00  e5 0d d4 5b 00 02 0a 00  |.A..`......[....|</span><br><span class="line">00001010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00001020  a4 81 00 00 13 00 00 00  e5 0d d4 5b 00 01 0b 00  |...........[....|</span><br><span class="line">00001030  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line"></span><br><span class="line">0x41ed  -&gt; </span><br><span class="line">0x0000  -&gt;  文件所有者为 0 即 root</span><br><span class="line">0x00000060  -&gt;  文件大小为 96 B</span><br><span class="line">0x5bd40de5  -&gt;  文件最后修改时间为 Unix TimeStamp 1540623845 =&gt; 2018/10/27 15:4:5</span><br><span class="line">0x00    -&gt;  文件所在组 id</span><br><span class="line">0x02    -&gt;  有两个文件目录项指向1号i节点</span><br><span class="line">0x000a  -&gt;  1 号 i 节点指向的第0块数据为第10个逻辑块(即第1个数据块)</span><br><span class="line">0x0000  =&gt;  由于数据比较小，后面的 i_zone[1] ~ i_zone[8] 均为 0</span><br></pre></td></tr></table></figure><p>i_zone 指向的是数据实际存储的数据块的位置。</p><p>但是，仅仅只有 9 个指针，每个数据块能存储 1024 B ，是远远达不到之前所描述的单文件 <code>0x10081c00 = 268966912 B</code> 的上限的。</p><p>事实上，minix 在实际处理的过程中，把前7个指针作为直接数据块指针，最多存储 7168 B 数据。</p><p>i_zone[7] 表示一次间接指针，指向某一个数据块，但是该数据块每2字节作为一个指针，指向真正的数据块。</p><p>i_zone[8] 表示二次间接指针。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwnu3zrwuij310y0m6abj.jpg" alt=""><br><small>Copied from Linux 内核完全注释V3.0</small></p><p><strong>数据块</strong></p><p>最后，我们看看数据块的内容，也希望能够更好地来理解 Linux 目录和文件的异同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00002800  01 00 2e 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00002810  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00002820  01 00 2e 2e 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00002830  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00002840  02 00 68 65 6c 6c 6f 2e  63 00 00 00 00 00 00 00  |..hello.c.......|</span><br><span class="line">00002850  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">*</span><br><span class="line">00002c00  23 69 6e 63 6c 75 64 65  20 3c 73 74 64 69 6f 2e  |#include &lt;stdio.|</span><br><span class="line">00002c10  68 3e 0a 00 00 00 00 00  00 00 00 00 00 00 00 00  |h&gt;..............|</span><br><span class="line">00002c20  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br></pre></td></tr></table></figure><p>在i节点区块上，我们看到有1号i节点和2号i节点已经被使用了。</p><p>0x2800 ~ 0x2860 的位置表示的就是 1 号i节点的数据。事实上这是一个目录(当然，怎么区分目录还是文件，在i节点区块的 i_mode 字段已经描述过了)</p><p>对于目录文件，当然是用来记载目录项的，每个目录项占用 32 字节。</p><blockquote><p>这里需要进行说明，MINIX 1.0 版本的文件系统似乎是对每个目录项占用 16 字节的。</p><p>这里提供一个 Linux 0.11 版本的仿真运行结果以供证明<br><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwnuexcwx7j30nw0c8745.jpg" alt=""></p><p>上面描述的 <code>disk.img</code> 是在 Ubuntu 16.04 LTS 下跑出来的结果，所有确实出现了一些差别。<br>至于具体的一个规范，目前还没有找到，所有这部分只能做模糊处理了，勿怪。</p></blockquote><p>前2个字节用来表示该目录项所对应的 i 节点编号。之后的30个字节用来描述该目录项的名字。</p><p>因此，对 0x2800 ~ 0x2860 的数据进行重建的结果就是 <code>. .. hello.c</code> 三个目录项了。其中，由于是根目录，<code>.</code> 和 <code>..</code> 所指向的i节点的相同的，都是1号i节点。</p><p>而 hello.c 文件指向的是 2 号i节点。</p><p>哈哈，2号i节点的数据内容就在 0x2c00 开始的位置。通过右侧的 ASCII 结果我们也可以看到。</p><p>当然，之前说过每个数据块是 1024 B ，那么数据块多余的部分，就是留空咯，而不会被其它i节点占用(除非该文件or目录被完全移除了)</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到此为止，文件系统宏观的描述就已经完结了。</p><p>下一节将对操作系统如何使用文件系统进行描述。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用惯了类 Unix 系统，应该说文件系统是日常最常接触的一个操作系统模块之一了。&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; ls&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Applications Network      Users        bin          data         etc          net          sbin         usr&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Library      System       Volumes      cores        dev          home         private      tmp          var&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是，究竟什么是文件系统? 为什么需要文件系统? 难道文件不是简单地存储到存储设备一块连续区域的吗?&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://DorMOUSE-None.github.io/tags/Linux/"/>
    
      <category term="Kernel" scheme="https://DorMOUSE-None.github.io/tags/Kernel/"/>
    
      <category term="File System" scheme="https://DorMOUSE-None.github.io/tags/File-System/"/>
    
  </entry>
  
  <entry>
    <title>理解 Linux Kernel (4) - 任务调度</title>
    <link href="https://DorMOUSE-None.github.io/2018-10-12-understand-Kernel-4/"/>
    <id>https://DorMOUSE-None.github.io/2018-10-12-understand-Kernel-4/</id>
    <published>2018-10-12T01:36:23.239Z</published>
    <updated>2018-10-13T02:22:59.351Z</updated>
    
    <content type="html"><![CDATA[<p>前面几节已经描述过，对于单核 CPU 来说。CPU 就处于不断地执行指令的过程(或者通过 <code>hlt</code> 指令直接停止工作)。</p><p>针对于每一个程序来说，这个程序执行流程是通过 CPU 中几组寄存器(通用寄存器、段寄存器、控制寄存器等) 和存储在内存中的代码和数据协作完成的。</p><p>如果要达到单核多任务的目的，首先要做的就是完成对几组寄存器中当前值的保存(我称之为保存现场)。而对于内存来说，多个任务的代码、数据同时存在内存是完全合理且可行的。毕竟相较于有限的寄存器，内存实在是太大了(相对而言)。</p><a id="more"></a><h2 id="任务调度的宏观描述"><a href="#任务调度的宏观描述" class="headerlink" title="任务调度的宏观描述"></a>任务调度的宏观描述</h2><p>从宏观上来说，操作系统维护了若干个任务(假设有 0, 1, 5, 6)。</p><p>下面以一个假象的例子来对任务调度做一些形象的说明:</p><ol><li><p>假设当前任务是任务 5 ，操作系统分配给它的 CPU 使用时间是 30ms。</p></li><li><p>每 10ms 计时器(Intel 8253, 可编程计数器/定时器) 向 CPU 发起一个时钟中断。</p></li><li><p>CPU 开始处理时钟中断(此时是<strong>内核态</strong>)。当前任务剩余可用时间 -10ms。</p></li><li><p>检查当前任务的剩余时间片，有剩余 -&gt; 步骤 5 ; 否则 -&gt; 步骤 6 </p></li><li><p>直接退出对时钟中断的处理函数(回到 <strong>用户态</strong>), 重复步骤 1 </p></li><li><p>根据每个任务的优先级及其它一些因素确定把接下来的一段时间分配给哪个任务。(假设分配给任务 6 ，30ms 的 CPU 使用时间) -&gt; 重复步骤 2 。</p></li></ol><p>当然，上面的描述中忽略了很多的因素。</p><h2 id="任务调度准备阶段"><a href="#任务调度准备阶段" class="headerlink" title="任务调度准备阶段"></a>任务调度准备阶段</h2><p>这里都将以 Linux 0.11 版本代码作为实例。当然，其中一些代码为了适应现在的 GCC 做了一些修改，另外还可能直接摆出 GCC 编译后的汇编代码来解释说明。</p><p>首先，内核代码在经过一系列的准备流程(包括设置一些寄存器以及在内存中暂存某些值，读取计算机的硬件配置等)。真正开始出现任务 0 始于下列这段代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 来自 Linux0.11 init/main.c */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">sched_init();       <span class="comment">/* schedule, 顾名思义就是时间安排咯 */</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">sti();</span><br><span class="line">move_to_user_mode();</span><br><span class="line"><span class="keyword">if</span> (!fork()) &#123;</span><br><span class="line">init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(;;) pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在操作系统的主函数中，开始对任务调度进行一定的准备工作。看看具体代码吧</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这里给出的是 Linux0.11 kernel/sched.c 经过预编译的函数(里面有一些内联汇编) */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> * <span class="title">p</span>;</span>    <span class="comment">/* 声明一个描述符指针 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">sizeof</span>(struct sigaction) != <span class="number">16</span>)</span><br><span class="line">        panic(<span class="string">"Struct sigaction MUST be 16 bytes"</span>);</span><br><span class="line">    __asm__ (                           <span class="comment">/* 这段是为了设置全局描述符表GDT的第4项，是一个 0 号任务(当前任务)的任务调用门*/</span></span><br><span class="line">            <span class="string">"movw $104,%1\n\t"</span> </span><br><span class="line">            <span class="string">"movw %%ax,%2\n\t"</span> </span><br><span class="line">            <span class="string">"rorl $16,%%eax\n\t"</span> </span><br><span class="line">            <span class="string">"movb %%al,%3\n\t"</span> </span><br><span class="line">            <span class="string">"movb $"</span> <span class="string">"0x89"</span> <span class="string">",%4\n\t"</span> </span><br><span class="line">            <span class="string">"movb $0x00,%5\n\t"</span> </span><br><span class="line">            <span class="string">"movb %%ah,%6\n\t"</span> </span><br><span class="line">            <span class="string">"rorl $16,%%eax"</span> </span><br><span class="line">            ::<span class="string">"a"</span> (&amp;(init_task.task.tss)), <span class="string">"m"</span> (*(((<span class="keyword">char</span> *) (gdt+<span class="number">4</span>)))), <span class="string">"m"</span> (*(((<span class="keyword">char</span> *) (gdt+<span class="number">4</span>))+<span class="number">2</span>)), <span class="string">"m"</span> (*(((<span class="keyword">char</span> *) (gdt+<span class="number">4</span>))+<span class="number">4</span>)), <span class="string">"m"</span> (*(((<span class="keyword">char</span> *) (gdt+<span class="number">4</span>))+<span class="number">5</span>)), <span class="string">"m"</span> (*(((<span class="keyword">char</span> *) (gdt+<span class="number">4</span>))+<span class="number">6</span>)), <span class="string">"m"</span> (*(((<span class="keyword">char</span> *) (gdt+<span class="number">4</span>))+<span class="number">7</span>)) </span><br><span class="line">            );</span><br><span class="line">    __asm__ (                           <span class="comment">/* 这里设置全局描述符表的第5项，0号任务的局部描述符表基址选择符 */</span></span><br><span class="line">            <span class="string">"movw $104,%1\n\t"</span> </span><br><span class="line">            <span class="string">"movw %%ax,%2\n\t"</span> </span><br><span class="line">            <span class="string">"rorl $16,%%eax\n\t"</span> </span><br><span class="line">            <span class="string">"movb %%al,%3\n\t"</span> </span><br><span class="line">            <span class="string">"movb $"</span> <span class="string">"0x82"</span> <span class="string">",%4\n\t"</span> </span><br><span class="line">            <span class="string">"movb $0x00,%5\n\t"</span> </span><br><span class="line">            <span class="string">"movb %%ah,%6\n\t"</span> </span><br><span class="line">            <span class="string">"rorl $16,%%eax"</span> </span><br><span class="line">            ::<span class="string">"a"</span> (&amp;(init_task.task.ldt)), <span class="string">"m"</span> (*(((<span class="keyword">char</span> *) (gdt+(<span class="number">4</span> +<span class="number">1</span>))))), <span class="string">"m"</span> (*(((<span class="keyword">char</span> *) (gdt+(<span class="number">4</span> +<span class="number">1</span>)))+<span class="number">2</span>)), <span class="string">"m"</span> (*(((<span class="keyword">char</span> *) (gdt+(<span class="number">4</span> +<span class="number">1</span>)))+<span class="number">4</span>)), <span class="string">"m"</span> (*(((<span class="keyword">char</span> *) (gdt+(<span class="number">4</span> +<span class="number">1</span>)))+<span class="number">5</span>)), <span class="string">"m"</span> (*(((<span class="keyword">char</span> *) (gdt+(<span class="number">4</span> +<span class="number">1</span>)))+<span class="number">6</span>)), <span class="string">"m"</span> (*(((<span class="keyword">char</span> *) (gdt+(<span class="number">4</span> +<span class="number">1</span>)))+<span class="number">7</span>)) </span><br><span class="line">            );</span><br><span class="line">    p = gdt+<span class="number">2</span>+<span class="number">4</span>;        <span class="comment">/* 描述符指针指向 GDT 第6项。因为前面已经占用了第4，5项。由内核占用了 0，1，2，3。*/</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">64</span>;i++) &#123;         <span class="comment">/* 循环 63 次，这是 Linux0.11 最大支持 64 个任务同时存在。当前任务已经占了一个任务了*/</span></span><br><span class="line">        task[i] = ((<span class="keyword">void</span> *) <span class="number">0</span>); <span class="comment">/* 63个任务指针全部值为 NULL */</span></span><br><span class="line">        p-&gt;a=p-&gt;b=<span class="number">0</span>;            <span class="comment">/* GDT 累积 126 项(126 * 8 字节)全部置为 0 。每个任务占用 GDT 两项，一为任务门，一为局部描述符表选择符*/</span></span><br><span class="line">        p++;</span><br><span class="line">        p-&gt;a=p-&gt;b=<span class="number">0</span>;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __asm__(<span class="string">"pushfl ; andl $0xffffbfff,(%esp) ; popfl"</span>);</span><br><span class="line">    __asm__(<span class="string">"ltr %%ax"</span>::<span class="string">"a"</span> (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) <span class="number">0</span>)&lt;&lt;<span class="number">4</span>)+(<span class="number">4</span>&lt;&lt;<span class="number">3</span>))));           <span class="comment">/* load Task Register TR 记录当前任务门为 gdt 第4项 */</span></span><br><span class="line">    __asm__(<span class="string">"lldt %%ax"</span>::<span class="string">"a"</span> (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) <span class="number">0</span>)&lt;&lt;<span class="number">4</span>)+((<span class="number">4</span> +<span class="number">1</span>)&lt;&lt;<span class="number">3</span>))));     <span class="comment">/* load Local Descriptor Table Register LDTR 记录当前选择符为 gdt 第5项 */</span></span><br><span class="line">    <span class="comment">/* 给8253芯片编程，每 10ms 发起一次时钟中断(下面3行的工作) */</span></span><br><span class="line">    __asm__ (<span class="string">"outb %%al,%%dx\n"</span> <span class="string">"\tjmp 1f\n"</span> <span class="string">"1:\tjmp 1f\n"</span> <span class="string">"1:"</span>::<span class="string">"a"</span> (<span class="number">0x36</span>),<span class="string">"d"</span> (<span class="number">0x43</span>));   </span><br><span class="line">    __asm__ (<span class="string">"outb %%al,%%dx\n"</span> <span class="string">"\tjmp 1f\n"</span> <span class="string">"1:\tjmp 1f\n"</span> <span class="string">"1:"</span>::<span class="string">"a"</span> ((<span class="number">1193180</span>/<span class="number">100</span>) &amp; <span class="number">0xff</span>),<span class="string">"d"</span> (<span class="number">0x40</span>));</span><br><span class="line">    __asm__ (<span class="string">"outb %%al,%%dx"</span>::<span class="string">"a"</span> ((<span class="number">1193180</span>/<span class="number">100</span>) &gt;&gt; <span class="number">8</span>),<span class="string">"d"</span> (<span class="number">0x40</span>));</span><br><span class="line">    __asm__ (<span class="string">"movw %%dx,%%ax\n\t"</span> <span class="string">"movw %0,%%dx\n\t"</span> <span class="string">"movl %%eax,%1\n\t"</span> <span class="string">"movl %%edx,%2"</span> : : <span class="string">"i"</span> ((<span class="keyword">short</span>) (<span class="number">0x8000</span>+(<span class="number">0</span>&lt;&lt;<span class="number">13</span>)+(<span class="number">14</span>&lt;&lt;<span class="number">8</span>))), <span class="string">"o"</span> (*((<span class="keyword">char</span> *) (&amp;idt[<span class="number">0x20</span>]))), <span class="string">"o"</span> (*(<span class="number">4</span>+(<span class="keyword">char</span> *) (&amp;idt[<span class="number">0x20</span>]))), <span class="string">"d"</span> ((<span class="keyword">char</span> *) (&amp;timer_interrupt)),<span class="string">"a"</span> (<span class="number">0x00080000</span>)); <span class="comment">/* 在 IDT 中设置时钟中断描述符项，第32项为时钟中断*/</span></span><br><span class="line">    __asm__ (<span class="string">"outb %%al,%%dx"</span>::<span class="string">"a"</span> ((&#123; <span class="keyword">unsigned</span> <span class="keyword">char</span> _v; __asm__ <span class="keyword">volatile</span> (<span class="string">"inb %%dx,%%al\n"</span> <span class="string">"\tjmp 1f\n"</span> <span class="string">"1:\tjmp 1f\n"</span> <span class="string">"1:"</span>:<span class="string">"=a"</span> (_v):<span class="string">"d"</span> (<span class="number">0x21</span>)); _v; &#125;)&amp;~<span class="number">0x01</span>),<span class="string">"d"</span> (<span class="number">0x21</span>)); <span class="comment">/*重新设置时钟中断的可屏蔽属性，这样就可在调用 hlt 后被时钟中断唤醒 */</span></span><br><span class="line">    __asm__ (<span class="string">"movw %%dx,%%ax\n\t"</span> <span class="string">"movw %0,%%dx\n\t"</span> <span class="string">"movl %%eax,%1\n\t"</span> <span class="string">"movl %%edx,%2"</span> : : <span class="string">"i"</span> ((<span class="keyword">short</span>) (<span class="number">0x8000</span>+(<span class="number">3</span>&lt;&lt;<span class="number">13</span>)+(<span class="number">15</span>&lt;&lt;<span class="number">8</span>))), <span class="string">"o"</span> (*((<span class="keyword">char</span> *) (&amp;idt[<span class="number">0x80</span>]))), <span class="string">"o"</span> (*(<span class="number">4</span>+(<span class="keyword">char</span> *) (&amp;idt[<span class="number">0x80</span>]))), <span class="string">"d"</span> ((<span class="keyword">char</span> *) (&amp;system_call)),<span class="string">"a"</span> (<span class="number">0x00080000</span>)); <span class="comment">/* 在 IDT 中设置系统中断，第128项为时钟中断 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过执行 <code>sched_init()</code> ，操作系统开始有了任务的概念。并且把当前任务作为任务 0 来加以认识。</p><p>同时，预置了 64 个任务状态数组，用来辅助任务调度器完成未来调度任务时确认目前所有任务的基础性支持。</p><p>最重要的，当然是对 8253 芯片的编程，使其每 10ms 向 CPU 发起一个硬件时钟中断。由此将把系统暂时性的带入<strong>内核态</strong> 来完成 CPU 下一个 10ms 需要进行的任务的决策工作。</p><p>最后的设置时钟中断描述符和系统中断描述符自不用说。不设置的话，对于接收到的中断根本就没办法确认处理中断的代码在哪(毕竟中断处理逻辑也是由 CPU 执行指令来解决的)</p><h2 id="任务调度实施阶段"><a href="#任务调度实施阶段" class="headerlink" title="任务调度实施阶段"></a>任务调度实施阶段</h2><p>由于时钟中断是由硬件芯片进行控制，根本不会顾及当前 CPU 正在执行的任务已经执行到了哪个指令 (哈哈，这不得是当然的嘛，不然要任务调度做什么，所有任务流水线作业得了)。</p><p>因此，下面的描述将借着一次时钟中断，来看一下整一个任务调度操作。</p><h3 id="定位时钟中断处理逻辑"><a href="#定位时钟中断处理逻辑" class="headerlink" title="定位时钟中断处理逻辑"></a>定位时钟中断处理逻辑</h3><p>Intel 8253芯片发起时钟中断之后，CPU 立即开始处理该中断</p><ol><li><p>通过 IDTR 芯片查找中断描述符表(IDT, 最多256项，每项8字节) 的基址。</p></li><li><p>结合中断号作为偏移量，定位表中某一项具体的中断描述符 (时钟中断是0x20，因此偏移就是 0x20 * 8 = 256)</p></li></ol><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fw51zkvo2nj313q0mm3z3.jpg" alt=""><br><small>Copied from Intel® 64 and IA-32 Architectures Software Developer’s Manual</small></p><ol start="3"><li>每一个中断描述符项都将是任务门，中断门，陷阱门三类中的一类，其所占用的 8 字节数据将按如下的形式进行存储</li></ol><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fw527o8903j314614ita0.jpg" alt=""><br><small>Copied from Intel® 64 and IA-32 Architectures Software Developer’s Manual</small></p><ol start="4"><li>时钟中断是一种中断门，可以看到低 0~15 位和高 48~63 位共同组成了段内偏移量，而低16~31位组成了一个段选择符(可以去 GDT 找到相应的段)。</li></ol><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fw52a4jbe0j31440zeq3j.jpg" alt=""><br><small>Copied from Intel® 64 and IA-32 Architectures Software Developer’s Manual</small></p><ol start="5"><li>至此，我们就可以定位到处理时钟中断的代码究竟在呢。之后也就是普通的 CPU 继续执行指令的过程(当然，需要注意，这个时候需要注意当前段选择符所表示的 DPL=0 ，即已经进入了内核态)</li></ol><h3 id="模板式的保存现场-timer-interrupt"><a href="#模板式的保存现场-timer-interrupt" class="headerlink" title="模板式的保存现场 timer_interrupt"></a>模板式的保存现场 timer_interrupt</h3><p>在上一小节第 5 步定位时钟中断的代码时，由于发生了特权级的切换，因此中断处理流程会自动地在新的栈(这里指处理时钟中断使用的内核栈)中保存原来任务的信息，依次入新栈的数据有原任务的 SS, ESP, EFLAGS, CS, EIP, (Error Code) 。</p><p>然后将正式进入到 IDT 定位的时钟中断处理逻辑的开始位置 (当然了，到这里也还是在保存现场。毕竟还有好多寄存器的数据要保存的)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.align 4</span><br><span class="line">_timer_interrupt:</span><br><span class="line">push %ds# save ds,es and put kernel data space</span><br><span class="line">push %es# into them. %fs is used by _system_call</span><br><span class="line">push %fs</span><br><span class="line">pushl %edx# we save %eax,%ecx,%edx as gcc doesn&apos;t</span><br><span class="line">pushl %ecx# save those across function calls. %ebx</span><br><span class="line">pushl %ebx# is saved as we use that in ret_sys_call</span><br><span class="line">pushl %eax</span><br><span class="line">movl $0x10,%eax # 0x10 是内核数据段选择符，即 GDT 第二项</span><br><span class="line">mov %ax,%ds</span><br><span class="line">mov %ax,%es</span><br><span class="line">movl $0x17,%eax # 0x17 是当前任务数据段选择符，LDT 第二项 (区分选择符是使用 GDT or LDT ，看 val &amp; 0x4 的结果，如果为 1 使用 LDT，否则 GDT</span><br><span class="line">mov %ax,%fs</span><br><span class="line">incl _jiffies   # 反正每次时钟中断 +1 ，想不到合适的中文翻译</span><br><span class="line">movb $0x20,%al# EOI to interrupt controller #1 发送指令请求硬件结束这次时钟中断的报告</span><br><span class="line">outb %al,$0x20</span><br><span class="line">movl CS(%esp),%eax  # 这个 CS 是个常量，取出内核栈暂存的原来正在执行的任务的代码段选择符</span><br><span class="line">andl $3,%eax# %eax is CPL (0 or 3, 0=supervisor)    判断一下在中断开始前代码的特权级 0 是内核态，3 是用户态</span><br><span class="line">pushl %eax</span><br><span class="line">call _do_timer# 调用 do_timer(long CPL) 。真正的处理时钟中断</span><br><span class="line">addl $4,%esp# task switching to accounting ...</span><br><span class="line">jmp ret_from_sys_call</span><br></pre></td></tr></table></figure><h3 id="任务调度-do-timer"><a href="#任务调度-do-timer" class="headerlink" title="任务调度 do_timer"></a>任务调度 do_timer</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_timer</span><span class="params">(<span class="keyword">long</span> cpl)</span>     <span class="comment">/* 这个 cpl 是上一小节获取的原任务正在执行的指令的特权级 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> beepcount;       <span class="comment">/* 扬声器发声计数 */</span></span><br><span class="line">    <span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">sysbeepstop</span><span class="params">(<span class="keyword">void</span>)</span></span>;  <span class="comment">/* 关闭扬声器的函数声明 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beepcount)              <span class="comment">/* 这段逻辑作用很不清晰，可能是富有年代感的产物 */</span></span><br><span class="line">        <span class="keyword">if</span> (!--beepcount)</span><br><span class="line">            sysbeepstop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cpl)                    <span class="comment">/* 判断特权级 然后给当前任务的用户态/内核态用时计数 */</span></span><br><span class="line">        current-&gt;utime++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        current-&gt;stime++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这段逻辑是给操作系统定时任务用的，用兴趣的欢迎自己学习 */</span></span><br><span class="line">    <span class="keyword">if</span> (next_timer) &#123;</span><br><span class="line">        next_timer-&gt;jiffies--;</span><br><span class="line">        <span class="keyword">while</span> (next_timer &amp;&amp; next_timer-&gt;jiffies &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">void</span> (*fn)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">            fn = next_timer-&gt;fn;</span><br><span class="line">            next_timer-&gt;fn = ((<span class="keyword">void</span> *) <span class="number">0</span>);</span><br><span class="line">            next_timer = next_timer-&gt;next;</span><br><span class="line">            (fn)();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (current_DOR &amp; <span class="number">0xf0</span>)</span><br><span class="line">        do_floppy_timer();</span><br><span class="line">    <span class="keyword">if</span> ((--current-&gt;counter)&gt;<span class="number">0</span>) <span class="keyword">return</span>;     <span class="comment">/* 分配给当前任务的时间片 -1 。如果不为0，那么直接退出时钟中断，让任务继续执行 */</span></span><br><span class="line">    current-&gt;counter=<span class="number">0</span>;     <span class="comment">/* 否则，当前任务的时间片记为 0 */</span></span><br><span class="line">    <span class="keyword">if</span> (!cpl) <span class="keyword">return</span>;       <span class="comment">/* 如果当前任务正处于内核态(比如用户程序中使用了一些系统调用)，那么先让这个任务继续执行，避免任务切换引起的麻烦 */</span></span><br><span class="line">    schedule();             <span class="comment">/* 任务调用，决定下一个时间片的主人 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="任务调度-schedule"><a href="#任务调度-schedule" class="headerlink" title="任务调度 schedule()"></a>任务调度 schedule()</h3><p>schedule() 就开始对 CPU 之后要把时间片分配给哪个任务做一次决策了。</p><p>但是，在开始之前，我们有必要先了解一下结构体 task_struct </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line"><span class="keyword">long</span> state;<span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span></span><br><span class="line"><span class="keyword">long</span> counter;</span><br><span class="line"><span class="keyword">long</span> priority;</span><br><span class="line"><span class="keyword">long</span> signal;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sigaction</span>[32];</span></span><br><span class="line"><span class="keyword">long</span> blocked;<span class="comment">/* bitmap of masked signals */</span></span><br><span class="line"><span class="comment">/* various fields */</span></span><br><span class="line"><span class="keyword">int</span> exit_code;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> start_code,end_code,end_data,brk,start_stack;</span><br><span class="line"><span class="keyword">long</span> pid,father,pgrp,session,leader;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> uid,euid,suid;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> gid,egid,sgid;</span><br><span class="line"><span class="keyword">long</span> alarm;</span><br><span class="line"><span class="keyword">long</span> utime,stime,cutime,cstime,start_time;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> used_math;</span><br><span class="line"><span class="comment">/* file system info */</span></span><br><span class="line"><span class="keyword">int</span> tty;<span class="comment">/* -1 if no tty, so it must be signed */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> umask;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">pwd</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">root</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">executable</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> close_on_exec;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">filp</span>[<span class="title">NR_OPEN</span>];</span></span><br><span class="line"><span class="comment">/* ldt for this task 0 - zero 1 - cs 2 - ds&amp;ss */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> <span class="title">ldt</span>[3];</span></span><br><span class="line"><span class="comment">/* tss for this task */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span> <span class="title">tss</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>匆匆一瞥，不过是不是觉得有些变量名还是很熟悉的，比如说 priority, utime, uid, eid, gid 等等。<br>但是暂时还用不上这么多。只要有个概念就好。操作系统通过上述这些值共同维护起了一个任务的方方面面的信息。</p><p>其中，需要再次注意的是，Linux0.11 版本最多只支持 64 个任务 (这是硬编码决定的上限，因为这个 task_struct 结构实例只声明了 64 个)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  'schedule()' is the scheduler function. This is GOOD CODE! There</span></span><br><span class="line"><span class="comment"> * probably won't be any reason to change this, as it should work well</span></span><br><span class="line"><span class="comment"> * in all circumstances (ie gives IO-bound processes good response etc).</span></span><br><span class="line"><span class="comment"> * The one thing you might take a look at is the signal-handler code here.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   NOTE!!  Task 0 is the 'idle' task, which gets called when no other</span></span><br><span class="line"><span class="comment"> * tasks can run. It can not be killed, and it cannot sleep. The 'state'</span></span><br><span class="line"><span class="comment"> * information in task[0] is never used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,next,c;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> ** <span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check alarm, wake up any interruptible tasks that have got a signal */</span></span><br><span class="line"><span class="comment">/* 检测 alarm (任务定时报警信号)，并唤醒可中断的任务来完成预定义的工作, 好像自己用得少，还不太了解 alarm(xxx) 的细节</span></span><br><span class="line"><span class="comment"> * 从任务 63 号开始(总共 64 个任务, 0~63) ，倒着遍历所有任务，检测 alarm </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)</span><br><span class="line"><span class="keyword">if</span> (*p) &#123;</span><br><span class="line"><span class="keyword">if</span> ((*p)-&gt;alarm &amp;&amp; (*p)-&gt;alarm &lt; jiffies) &#123;</span><br><span class="line">(*p)-&gt;signal |= (<span class="number">1</span>&lt;&lt;(SIGALRM<span class="number">-1</span>));</span><br><span class="line">(*p)-&gt;alarm = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (((*p)-&gt;signal &amp; ~(_BLOCKABLE &amp; (*p)-&gt;blocked)) &amp;&amp;</span><br><span class="line">(*p)-&gt;state==TASK_INTERRUPTIBLE)</span><br><span class="line">(*p)-&gt;state=TASK_RUNNING;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* this is the scheduler proper: */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">c = <span class="number">-1</span>;</span><br><span class="line">next = <span class="number">0</span>;</span><br><span class="line">i = NR_TASKS;   <span class="comment">/* 这里的宏 NR_TASKS = 64 */</span></span><br><span class="line">p = &amp;task[NR_TASKS];</span><br><span class="line"><span class="keyword">while</span> (--i) &#123;</span><br><span class="line"><span class="keyword">if</span> (!*--p)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">/* 选择任务状态为 就绪态，且 counter 值最大的任务号作为下一个占用 CPU 的任务</span></span><br><span class="line"><span class="comment">if ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c) </span></span><br><span class="line"><span class="comment">c = (*p)-&gt;counter, next = i;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">        /* 如果没有其它任务，那么 next = 0 ，即接下来占用 cpu 的任务就是 0号任务(0号任务一定存在，不能被 kill ) */</span></span><br><span class="line"><span class="keyword">if</span> (c) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/* 如果 1~63 号任务(不存在或不在就绪态)至少存在一个任务，且时间片都为 0 ，那么重新计算分配给每个任务的 counter 值 */</span></span><br><span class="line"><span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)</span><br><span class="line"><span class="keyword">if</span> (*p)</span><br><span class="line">(*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; <span class="number">1</span>) + (*p)-&gt;priority;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/* 将当前任务切换为 next ，然后就可以一切就绪，退出时钟中断，就变成新的占用cpu的任务来执行了 */</span></span><br><span class="line">switch_to(next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>switch_to(next)</strong></p><p>switch_to(next) 这个函数，是通过内嵌汇编写的。下面我们来看看细节(这里选用 GCC 编译出来的汇编指令，不直接使用内嵌汇编)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 这里的汇编指令紧跟在 if(c) break; 之后</span><br><span class="line">.L36:</span><br><span class="line">movl%ebx, %edx          # 这里 ebx 存储的是 next 变量的值，现在复制到 edx 上</span><br><span class="line">sall$4, %edx            # sall、addl 两行的目的是计算得到一个 TSS 选择符，TSS0 在 GDT 是第4项，TSS1 在 GDT 是第 6 项，类推...其中选择符后3位为DPL和 GDTR/LDTR 选项</span><br><span class="line">addl$32, %edx</span><br><span class="line">movl_task(,%ebx,4), %ecx    # 找到 next 号任务的 task_struct 的指针 (存储在 task[64] 的数组中)</span><br><span class="line">#APP</span><br><span class="line"># 141 &quot;sched.c&quot; 1</span><br><span class="line">cmpl %ecx,_current          # 确认是不是原任务</span><br><span class="line">je 1f                       # 是的话直接跳出 (跳到最近的标签 1 )</span><br><span class="line">movw %dx,8(%esp)</span><br><span class="line">xchgl %ecx,_current         # 交换 ecx 和 _current 存储的值</span><br><span class="line">ljmp 4(%esp)                # 通过间接跳转完成任务切换。通用的形式是 jmp CS:IP，但是使用间接跳转，在内存中的值先读取 32 位偏移量，再读 16 位段选择符</span><br><span class="line">cmpl %ecx,_last_task_used_math</span><br><span class="line">jne 1f</span><br><span class="line">clts                        # 清除 CR0 寄存器中的 TS Flag </span><br><span class="line">1:</span><br><span class="line"># 0 &quot;&quot; 2</span><br><span class="line">#NO_AP</span><br></pre></td></tr></table></figure><p>上面这段程序有必要将它割裂成两部分来看待，以 <code>ljmp 4(%esp)</code> 为界。</p><p><code>jmp</code> ，这是一个相当明显的程序跳转。这里 jmp 给出的选择符是 GDT 上某个任务的 TSS 描述符</p><p>通过 <code>jmp</code> CPU 将完成老的任务所有寄存器的保存现场，以及新的任务所有寄存器暂存结果的载入。</p><p>CPU 执行的下一条指令，将是新的任务 CS:EIP 所指明的指令。</p><p>相应的，<code>ljmp</code> 之后的指令将在该任务重新获得占用 CPU 后获得执行。</p><h2 id="任务调度的结束阶段"><a href="#任务调度的结束阶段" class="headerlink" title="任务调度的结束阶段"></a>任务调度的结束阶段</h2><p>这段就比较绕了，现在假设一个前提，就是任务 A 也是在时钟中断重新进行任务调度的时候被替换掉的，现在 CPU 分配的时间片又轮到了任务 A 。</p><p>也就是紧随着上一小节 <code>ljmp</code> 看看从任务内核态回到用户态的流程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    # 这段与上面一段指令是直接承接的</span><br><span class="line">movl12(%esp), %eax</span><br><span class="line">xorl%gs:20, %eax</span><br><span class="line">je.L40</span><br><span class="line">call___stack_chk_fail</span><br><span class="line">.L40:</span><br><span class="line">addl$24, %esp           # 这里返还这次 call 额外申请的内核栈空间</span><br><span class="line">.cfi_def_cfa_offset 8</span><br><span class="line">popl%ebx                # 恢复进入 call 的时候暂存的 ebx</span><br><span class="line">.cfi_restore 3</span><br><span class="line">.cfi_def_cfa_offset 4</span><br><span class="line">ret                         # return 跳转回到当初调用的地方</span><br><span class="line">.cfi_endproc</span><br></pre></td></tr></table></figure><p>还是从汇编指令来看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">call_schedule           # 原先调用 schedule() 的地方</span><br><span class="line">.L93:</span><br><span class="line">    # return 跳转回来，直接承接的指令</span><br><span class="line">addl$8, %esp</span><br><span class="line">.cfi_def_cfa_offset 8</span><br><span class="line">popl%ebx</span><br><span class="line">.cfi_restore 3</span><br><span class="line">.cfi_def_cfa_offset 4</span><br><span class="line">ret                         # 继续 return ，跳出 do_timer() </span><br><span class="line">.cfi_endproc</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   call _do_timer# &apos;do_timer(long CPL)&apos; does everything from</span><br><span class="line">addl $4,%esp# task switching to accounting ...</span><br><span class="line">jmp ret_from_sys_call</span><br></pre></td></tr></table></figure><p><strong>ret_from_sys_call</strong></p><p>这里就打算正式结束由于这次时钟中断所引发的内核态指令执行的流程，正式回归用户态了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">ret_from_sys_call:</span><br><span class="line">    # 这 3 行来判断是不是任务0，如果是就不进行信号量的处理了</span><br><span class="line">movl _current,%eax# task[0] cannot have signals</span><br><span class="line">cmpl _task,%eax</span><br><span class="line">je 3f</span><br><span class="line">    # 判断在发生时钟中断前，CS 表示的是不是 LDT 第 1 项 (局部变量表的代码段)</span><br><span class="line">    # 否则 CS 就应该内核态代码段了，不进行信号量处理</span><br><span class="line">cmpw $0x0f,CS(%esp)# was old code segment supervisor ?</span><br><span class="line">jne 3f</span><br><span class="line">    # 判断在发生时钟中断前，SS 表示的是不是 LDT 第 2 项 (局部变量表的数据段)</span><br><span class="line">    # 否则认为程序还处在内核态，不进行信号量处理</span><br><span class="line">cmpw $0x17,OLDSS(%esp)# was stack segment = 0x17 ?</span><br><span class="line">jne 3f</span><br><span class="line">    # 设置信号量 (不清楚，先挖个坑)</span><br><span class="line">movl signal(%eax),%ebx</span><br><span class="line">movl blocked(%eax),%ecx</span><br><span class="line">notl %ecx</span><br><span class="line">andl %ebx,%ecx</span><br><span class="line">bsfl %ecx,%ecx</span><br><span class="line">je 3f</span><br><span class="line">btrl %ecx,%ebx</span><br><span class="line">movl %ebx,signal(%eax)</span><br><span class="line">incl %ecx</span><br><span class="line">pushl %ecx</span><br><span class="line">call _do_signal</span><br><span class="line">popl %eax</span><br><span class="line">3:popl %eax</span><br><span class="line">popl %ebx</span><br><span class="line">popl %ecx</span><br><span class="line">popl %edx</span><br><span class="line">pop %fs</span><br><span class="line">pop %es</span><br><span class="line">pop %ds</span><br><span class="line">iret</span><br></pre></td></tr></table></figure><p>至此，通过 iret 将跳转回到用户态代码被中断的位置，并继续执行</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="pause"><a href="#pause" class="headerlink" title="pause()"></a>pause()</h3><p><a href="https://dormouse-none.github.io/2018-10-06-understand-Kernel-3/">Linux Kernel(3) - 操作系统启动</a> 中，描述过任务0在完成了整个操作系统的启动流程之后，唯一在做的事情，就是调用 <code>for(;;) pause();</code> </p><p>CPU 每次把时间片分配给它，它就开始浪费权力，直接不要了这个时间片。</p><p>之前一直以为 pause() 会选择执行 <code>HLT</code> 指令让 CPU 暂时地陷入停止状态。但是出乎意料，并不是这个结果(当然，最终是不是还是另一个说法。毕竟代码都是人写的，每个人都可以各自有一套实现)。</p><p>当 CPU 把执行指令的权力交个任务 0 时，选择让 CPU 停止，直到接收到硬件中断为止也不失为一种选择。当然，不论其它，Linux0.11版本的代码不是这样的。</p><p>通过 <code>INT 0x80</code> 配合系统调用函数查表，最后定位到的就是 sys_pause() 了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_sys_pause:</span><br><span class="line">.LFB13:</span><br><span class="line">.cfi_startproc</span><br><span class="line">subl$12, %esp</span><br><span class="line">.cfi_def_cfa_offset 16</span><br><span class="line">movl_current, %eax</span><br><span class="line">movl$1, (%eax)</span><br><span class="line">call_schedule       # 调用 schedule() 重新划分时间片</span><br><span class="line">movl$0, %eax</span><br><span class="line">addl$12, %esp</span><br><span class="line">.cfi_def_cfa_offset 4</span><br><span class="line">ret</span><br><span class="line">.cfi_endproc</span><br></pre></td></tr></table></figure></p><h3 id="timer-定时器"><a href="#timer-定时器" class="headerlink" title="timer 定时器"></a>timer 定时器</h3><p>之前在 <code>do_timer()</code> 函数中也看过了每次时钟中断，都会检查一遍定时器，并决定是否触发预置的定时器处理函数。</p><p>当然了，既然是触发定时器，总是要有一个前提——设置定时器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_timer</span><span class="params">(<span class="keyword">long</span> jiffies, <span class="keyword">void</span> (*fn)(<span class="keyword">void</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> * <span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!fn)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">cli();</span><br><span class="line"><span class="keyword">if</span> (jiffies &lt;= <span class="number">0</span>)</span><br><span class="line">(fn)();</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (p = timer_list ; p &lt; timer_list + TIME_REQUESTS ; p++)</span><br><span class="line"><span class="keyword">if</span> (!p-&gt;fn)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (p &gt;= timer_list + TIME_REQUESTS)</span><br><span class="line">panic(<span class="string">"No more time requests free"</span>);</span><br><span class="line">p-&gt;fn = fn;</span><br><span class="line">p-&gt;jiffies = jiffies;</span><br><span class="line">p-&gt;next = next_timer;</span><br><span class="line">next_timer = p;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;next &amp;&amp; p-&gt;next-&gt;jiffies &lt; p-&gt;jiffies) &#123;</span><br><span class="line">p-&gt;jiffies -= p-&gt;next-&gt;jiffies;</span><br><span class="line">fn = p-&gt;fn;</span><br><span class="line">p-&gt;fn = p-&gt;next-&gt;fn;</span><br><span class="line">p-&gt;next-&gt;fn = fn;</span><br><span class="line">jiffies = p-&gt;jiffies;</span><br><span class="line">p-&gt;jiffies = p-&gt;next-&gt;jiffies;</span><br><span class="line">p-&gt;next-&gt;jiffies = jiffies;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sti();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>对于任务调度，更难的是对一个时间断层的理解。在调度过程中，旧任务被暂停，新的任务被重新启动, 直到旧的任务又被启动。这里就必须人为地将被中断的任务主动的连接起来看待。</p><p>早期版本的任务调度模块确实比较简单，累计不过百行 C 代码。哈哈。一点一点继续来吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面几节已经描述过，对于单核 CPU 来说。CPU 就处于不断地执行指令的过程(或者通过 &lt;code&gt;hlt&lt;/code&gt; 指令直接停止工作)。&lt;/p&gt;
&lt;p&gt;针对于每一个程序来说，这个程序执行流程是通过 CPU 中几组寄存器(通用寄存器、段寄存器、控制寄存器等) 和存储在内存中的代码和数据协作完成的。&lt;/p&gt;
&lt;p&gt;如果要达到单核多任务的目的，首先要做的就是完成对几组寄存器中当前值的保存(我称之为保存现场)。而对于内存来说，多个任务的代码、数据同时存在内存是完全合理且可行的。毕竟相较于有限的寄存器，内存实在是太大了(相对而言)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://DorMOUSE-None.github.io/tags/Linux/"/>
    
      <category term="Kernel" scheme="https://DorMOUSE-None.github.io/tags/Kernel/"/>
    
      <category term="time interrupt" scheme="https://DorMOUSE-None.github.io/tags/time-interrupt/"/>
    
  </entry>
  
  <entry>
    <title>理解 Linux Kernel (3) - 操作系统启动</title>
    <link href="https://DorMOUSE-None.github.io/2018-10-06-understand-Kernel-3/"/>
    <id>https://DorMOUSE-None.github.io/2018-10-06-understand-Kernel-3/</id>
    <published>2018-10-05T16:00:00.000Z</published>
    <updated>2019-04-21T05:41:08.110Z</updated>
    
    <content type="html"><![CDATA[<p>这次拖得有够久的，毕竟需要将知识串联起来并不是一件容易的事情。更何况很多内容可以说和常理(个人理解的常理)有了比较大的偏差。</p><p>不过确实比较有意思。从引导程序到操作系统启动，这中间究竟经历了多少流程呢？</p><p>由于前几篇已经有过介绍，这里不会再对引导程序及汇编语法做过多的介绍。而着重描述整个操作系统的启动流程。</p><a id="more"></a><h2 id="引导程序"><a href="#引导程序" class="headerlink" title="引导程序"></a>引导程序</h2><p>从 BIOS 将512字节长的引导程序加载到物理内存<code>0x7c00</code>开始的连续递增空间后，即将程序的执行权交给了引导程序(这里指的执行权可以简单理解成CS:IP)</p><blockquote><p><em>CS:IP</em></p><p><strong>CS</strong>. 代码段基址。一般用于划定一段连续代码开始的地址。是一个16位段寄存器，类似的还有 DS, ES, FS, GS, SS 等16位段寄存器，分别提供不同的段基址存储功能)<br><strong>IP</strong>. 代码段偏移值。配合 CS 共同为 CPU 确定下一个将要被执行的机器指令的线性地址。</p></blockquote><p>Linux 0.11 版本的引导程序实现的支持比较简单。</p><ol><li>将引导程序代码(自身) 512 字节的内容移动到 <code>0x90000</code> 开始的 512B 内存空间上</li><li>跳到 <code>0x90000</code> 开始的段的相应位置继续执行</li><li>从磁盘中读取 4*512 字节的 setup 程序的二进制内容</li><li>读取操作系统的二进制内容到内存 <code>0x10000</code> 开始的连续地址空间中 (此处最大可以有 0x90000 - 0x10000 = 0x80000 = 512 KB，即当时的操作系统二进制程序+数据最大只能是 512KB, 不过也很多了)</li><li>确认将要作为文件系统的磁盘是否存在</li><li>将控制权交给 setup 程序</li></ol><h2 id="SETUP-程序"><a href="#SETUP-程序" class="headerlink" title="SETUP 程序"></a>SETUP 程序</h2><p><strong>读取硬件配置</strong></p><p>setup 程序，顾名思义，就是在搞一些配置。那么究竟在配置什么？</p><p>就是通过 BIOS 中断读取各种硬件信息(诸如内存大小，显示器长宽比，磁盘等)，并将它们存储在内存的指定位置。</p><p>哈哈，由于引导程序已经执行完了，再也不会使用了。因此，setup 程序就是将这些信息存储到了原引导程序所在的位置，即 0x90000 ~ 0x901FF 共 512 B 的内存中。</p><p>当然，每个字节存的是什么内容都是一种约定(比如 setup 程序把内存大小的信息存到了哪，后面其它程序就到相应的位置去取)。</p><p><strong>移动操作系统程序指令</strong></p><p>OK，setup 程序也不是仅仅只干这么点事情的，不然要 4*512 字节岂不是太浪费了，哪用得了这么多。</p><p>setup 还要负责将操作系统程序移动到<em>方便</em>的位置。前面将操作系统程序加载到了内存 0x10000 处，主要是为了暂时保持 BIOS 中断向量表 (位于 0x0000 开始的连续 1024 B 内存中，由 BIOS 程序创建，用于各种中断调用) 。在 setup 决定不再使用 BIOS 中断之后，就已经可以完全废弃了。</p><p>因此，操作系统程序将从 0x10000 顺次移动到 0x00000 的位置。</p><p><strong>重置中断</strong></p><p>软中断与硬中断，应该是在软硬件划分下唯二的两种中断形式。软中断一般通过汇编指令 <code>INT {中断号}</code> 的形式通过软件执行的形式产生，而硬中断是硬件由于某些错误指令而自动产生的中断。</p><p>当然，这些中断都需要 CPU 进行相应的处理。那么，在 BIOS  中断向量表被覆盖了之后，如何来处理这些中断呢？</p><p>首先，在上一步 <strong>移动操作系统程序</strong> 开始时，就直接通过汇编指令 <code>cli</code> 强制禁止除 <em>非可屏蔽中断</em> 外的所有中断，因此也就基本不考虑中断的问题。</p><p>但是，总还得解除禁止吧。因此，setup 程序尽快地重新编制了硬件中断，进入保护模式。使用保护模式下的中断描述符表来替代 BIOS 中断向量表。</p><p>至于如何创建中断描述符表，哈哈，这都是直接在汇编编程的时候写好的。直接划出了一块区域写上了中断描述符表的表项，然后与 setup 代码一起被读取到了内存的指定位置。至于唯一要做的，就是将 IDTR (中断描述符表寄存器) 修改为中断描述符表在内存的开始地址。</p><p><strong>进入保护模式</strong></p><p>首先，简单介绍一下实模式 &amp; 保护模式。</p><p>保护模式与实模式的主要区别，就在于两者的内存寻址方式，归根结底也就是段寄存器如何辅助完成内存地址定位的问题。</p><p>先简单的回顾下实模式下的寻址方式</p><p>段寄存器的出现，很大程度上是为了对 16 bit CPU 下可寻址地址不足所作出的补充。<br>诸如 CS:IP = 0x07C0:0x0001 -&gt; 0x07C01 。通过CS:IP 的配合，物理地址 = CS &lt;&lt; 4 + IP ，将原本 128 KB 的可寻址空间扩展到 0xFFFF:0xFFFF -&gt; 0x10FFFE 的寻址空间</p><p>而保护模式的出现，也是由于实模式下的地址寻址仍然不能满足对内存寻址的需求。</p><p>那么保护模式究竟将如何进行寻址呢？简单来说就是通过新增了一个寄存器 GDTR (全局描述符表寄存器。当然，暂时不考虑 LDTR) 用来存储全局描述符表(全局描述符表是一些在内存中的有结构的数据) ，那么类似的，本来是段寄存器中是表示一个内存段基址，现在通过借助中间项 (GDTR) ，由全局描述符表的每一个表项来表示每一个内存段基址，从而达到在最大 4GB 的内存中进行内存地址的寻址。</p><p>而与上面的中断描述符表类似的，全局描述符表也是以同样的方式，预先写好，然后设置一下 GDTR 就 OK 了。</p><p><strong>转入操作系统程序</strong></p><p>最后的最后，当然是把控制权交给操作系统程序。即跳转到内存 0x00000 处。当然，由于现在已经处于保护模式下，因此 jmp 指令略有不同。 为 <code>jmpi 0, 8</code>。</p><p>简单解释一下这一条指令 </p><p><code>jmpi</code> 指令表示进行段间跳转。(段间跳转与段内跳转的区别在于: 程序代码的寻址一般通过 CS:IP 配合完成，如果是段内跳转，则段基址不变，即 CS 不变，只需要给出 IP 即可；而段间跳转需要同时给出新的段基址(CS)和新的段偏移(IP)。</p><p><code>0</code> 这里 0 就表示的是段偏移。</p><p><code>8</code> 保护模式下的段寄存器以一种特殊的方式来配合 GDTR/LDTR 来完成对全局/局部描述符表项的定位。如下图所示。最后两位表示特权级，用于区分用户态(11) or 内核态(00) (Linux 只使用了两个，还有 01 和 10 不使用)</p><p>第三位表示使用 GDTR 还是 LDTR</p><p>高 13 位共同组成了对 GDTR/LDTR 表项的描述，究竟使用哪一个表项。当然，这里其实也侧面反映了，其实每个全局描述符表/局部描述符表最多只能有 $2^{13} = 8192$ 个表项。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fulm7vumywj31220aw74f.jpg" alt=""></p><h2 id="操作系统程序"><a href="#操作系统程序" class="headerlink" title="操作系统程序"></a>操作系统程序</h2><p>终于要到操作系统程序了。这个就比较复杂了。这里只简单描述将操作系统启动起来的最基本使用到的代码。其它以后继续。</p><p>其实整一个操作系统程序是一个比较大的量，毕竟最大能够达到 512 KB 呢。</p><p>简单的看一下文档树，见附录一，编译前的源代码文件总计 100 多个。</p><p>首先被执行的是 head.s 中的代码，这里完成的工作主要包括:</p><ol><li><p>重新编制每个中断的具体处理代码(这个应该比较好理解，说到底中断出现了，也还是要通过实现代码来完成中断逻辑。不论是 BIOS 中断向量还是保护模式下使用的中断描述符表，都不过是记录了一下中断处理代码的位置，进行了定位而已)。</p></li><li><p>初始化分页模式(不详述，以后有机会在说)</p></li><li><p>验证 80387 数学协处理器。</p></li><li><p>进入 main.c 程序 (既然 Linus 都将其命名为 main 了，那么显然这是整个操作系统最核心的部分了)。</p></li></ol><p>下面将简单给出 main.c 程序的两段代码 <code>main(...)</code> 和 <code>init(...)</code>，并直接针对代码进行直接解释。</p><h3 id="main-void"><a href="#main-void" class="headerlink" title="main(void)"></a>main(void)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> ROOT_DEV = ORIG_ROOT_DEV;   <span class="comment">// 读取在引导程序执行时获取到的文件系统所在的磁盘</span></span><br><span class="line"> drive_info = DRIVE_INFO;</span><br><span class="line">memory_end = (<span class="number">1</span>&lt;&lt;<span class="number">20</span>) + (EXT_MEM_K&lt;&lt;<span class="number">10</span>); <span class="comment">// 首先先确认整个内存的大小</span></span><br><span class="line">memory_end &amp;= <span class="number">0xfffff000</span>;               <span class="comment">// 当然，这里为了分页方便 (每页 4096 B)，直接将不满一页的多余内存忽略掉</span></span><br><span class="line"><span class="keyword">if</span> (memory_end &gt; <span class="number">16</span>*<span class="number">1024</span>*<span class="number">1024</span>)          <span class="comment">// 最大支持 16 MB 的内存，这里是 Linus 当时的机器只有 16 MB，因此没有做更大内存的支持，但可以自己去改源码</span></span><br><span class="line">memory_end = <span class="number">16</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">if</span> (memory_end &gt; <span class="number">12</span>*<span class="number">1024</span>*<span class="number">1024</span>)          <span class="comment">// 确认缓冲区的末地址 (根据实际内存大小调整, &gt;12MB 留 4MB 做高速缓冲区，&gt;6MB 留 2 MB 缓冲，否则 1MB )</span></span><br><span class="line">buffer_memory_end = <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (memory_end &gt; <span class="number">6</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">buffer_memory_end = <span class="number">2</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">buffer_memory_end = <span class="number">1</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">main_memory_start = buffer_memory_end;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RAMDISK</span></span><br><span class="line">main_memory_start += rd_init(main_memory_start, RAMDISK*<span class="number">1024</span>);      <span class="comment">// 如果需要虚拟盘，则再留一部分作为交换区</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">mem_init(main_memory_start,memory_end); <span class="comment">// 内存初始化，毕竟 Linux 操作系统下的所有内存都将被统一分配，用户程序没有权限随便使用内存，只能用被分配的</span></span><br><span class="line">trap_init();            <span class="comment">// 初始化中断</span></span><br><span class="line">blk_dev_init();         <span class="comment">// 初始化块设备</span></span><br><span class="line">chr_dev_init();         <span class="comment">// 初始化字符设备</span></span><br><span class="line">tty_init();             <span class="comment">// 初始化 tty</span></span><br><span class="line">time_init();            <span class="comment">// 设置开机启动时间</span></span><br><span class="line">sched_init();           <span class="comment">// 初始化任务调度程序，由此就将可以进行多任务切换了</span></span><br><span class="line">buffer_init(buffer_memory_end); <span class="comment">// 缓存区初始化</span></span><br><span class="line">hd_init();              <span class="comment">// 硬盘初始化</span></span><br><span class="line">floppy_init();          <span class="comment">// 软盘初始化</span></span><br><span class="line">sti();                  <span class="comment">// 不再禁止中断，现在开始又允许中断了</span></span><br><span class="line">move_to_user_mode();    <span class="comment">// 进入用户态</span></span><br><span class="line"><span class="keyword">if</span> (!fork()) &#123;          <span class="comment">// 关于 fork 函数，下面将简单介绍。</span></span><br><span class="line">init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(;;) pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>fork()</strong></p><p>如果熟悉 C 语言，应该熟悉 fork 函数的作用。它创建一个新的任务 (任务是操作系统自己抽象出来的概念，这里将原来的操作系统程序认为是 0 号任务，将产生 1 号进程/任务)。新的任务与原任务几乎一模一样，除了 fork() 调用的返回值不同。子任务将返回 0 ，原任务将返回子任务的任务号。</p><p>因此，对于上面的代码，<code>if(!fork())</code> ，0号任务将不执行 <code>if(){}</code> 语句块内的 init ，而 1 号任务将执行 <code>init()</code> 函数</p><p>0 号进程要继续做什么呢? </p><p>很简单，下面 <code>for(;;) pause();</code>。 <code>pause()</code> 是指让处理器完全停止，只有发生硬件中断， CPU 才会从停止状态中恢复 (前面已经设置了定时的/ 10ms/次的时钟中断，因此处理器总是能够恢复运行)， </p><p>具体的描述就是，如果任务调度程序把时间片分配给了 0 号进程，那么 0 号进程唯一做的，就是让 CPU 停止。而且 0 号进程的 <code>for</code> 是死循环，每次把时间分配给 0 号进程，它就 CPU 停止。我们在 Linux 操作系统上，通过 top 可以看到对 cpu 有如下描述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%Cpu(s):  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br></pre></td></tr></table></figure><p>其中对 idle(id) 的统计，其实就在 0 号任务让 cpu 停止工作了而已。</p><h3 id="init-void"><a href="#init-void" class="headerlink" title="init(void)"></a>init(void)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pid,i;</span><br><span class="line"></span><br><span class="line">setup((<span class="keyword">void</span> *) &amp;drive_info);</span><br><span class="line">(<span class="keyword">void</span>) open(<span class="string">"/dev/tty0"</span>,O_RDWR,<span class="number">0</span>);</span><br><span class="line">(<span class="keyword">void</span>) dup(<span class="number">0</span>);</span><br><span class="line">(<span class="keyword">void</span>) dup(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d buffers = %d bytes buffer space\n\r"</span>,NR_BUFFERS,</span><br><span class="line">NR_BUFFERS*BLOCK_SIZE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Free mem: %d bytes\n\r"</span>,memory_end-main_memory_start);</span><br><span class="line"><span class="keyword">if</span> (!(pid=fork())) &#123;</span><br><span class="line">close(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (open(<span class="string">"/etc/rc"</span>,O_RDONLY,<span class="number">0</span>))</span><br><span class="line">_exit(<span class="number">1</span>);</span><br><span class="line">execve(<span class="string">"/bin/sh"</span>,argv_rc,envp_rc);</span><br><span class="line">_exit(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pid&gt;<span class="number">0</span>)</span><br><span class="line"><span class="keyword">while</span> (pid != wait(&amp;i))</span><br><span class="line"><span class="comment">/* nothing */</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ((pid=fork())&lt;<span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Fork failed in init\r\n"</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!pid) &#123;</span><br><span class="line">close(<span class="number">0</span>);close(<span class="number">1</span>);close(<span class="number">2</span>);</span><br><span class="line">setsid();</span><br><span class="line">(<span class="keyword">void</span>) open(<span class="string">"/dev/tty0"</span>,O_RDWR,<span class="number">0</span>);</span><br><span class="line">(<span class="keyword">void</span>) dup(<span class="number">0</span>);</span><br><span class="line">(<span class="keyword">void</span>) dup(<span class="number">0</span>);</span><br><span class="line">_exit(execve(<span class="string">"/bin/sh"</span>,argv,envp));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> (pid == wait(&amp;i))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n\rchild %d died with code %04x\n\r"</span>,pid,i);</span><br><span class="line">sync();</span><br><span class="line">&#125;</span><br><span class="line">_exit(<span class="number">0</span>);<span class="comment">/* NOTE! _exit, not exit() */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么 1 号任务在做什么呢？看 init 的代码，可以看到大量诸如 <code>/dev/tty0</code>, <code>/bin/sh</code> 的代码。哈哈，下面通过 1,2,3… 对步骤进行标号简单描述一下。</p><ol><li><p>1 号进程在做的是 fork 出新的进程(暂时叫它进程 X )</p></li><li><p>1 号进程不断询问 X 是否被销毁 </p><ul><li>如果 X 进程被销毁了：那么继续执行步骤 1</li><li>否则：继续执行步骤 2 （为什么会出现不断循环呢？其实由于任务调度程序的存在，在单个 CPU 看来，这个轮询并不一直发生，有一些时间片已经给了其他进程继续执行任务了</li></ul></li><li><p>X 任务通过调用 <code>execve()</code> 把当前程序的代码+数据全部替换成是 shell 的 (其实大量的用户程序都是通过这种 fork + execve 的形式出现的)</p></li><li>X 任务(也就是 Shell 程序) 开始通过 tty 与用户开始交互。直到用户选择 <code>exit</code> 退出 shell </li></ol><p><strong>execve(…)</strong></p><p>前面介绍过 fork 是复制一份程序的各个寄存器的状态 + 程序的数据。现在 execve 做出的操作是直接将当前程序的代码和数据替换成目标程序的代码和数据，并通过对寄存器一定的重置，完成一个用户程序的启动流程(程序启动说到底不就是在内存中存在这个程序的代码，然后通过 CS:IP 定位到即将执行的程序指令，最后让 CPU 开始执行就 OK 了)</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>整个操作系统的启动流程就简单地介绍到这里。</p><p>0 号任务作为操作系统的常驻程序，在 OS 启动完成，每次时间片被分配给它，它就让 CPU 停止工作(通过 pause() 系统调用)</p><p>1 号任务作为操作系统的常驻程序，唯一的任务就是判断进程X是否被退出，如果退出了，就重新创建一个(当然，也可能有人有疑问，为什么现在的 Linux 开多个 bash 都没有问题呢? 这里有个猜测是有一个隐藏的 shell 是被 1 号任务启动的，其它的 bash 是多余的。不过这只是猜测，待考察)</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>Linux 0.11 源码目录结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">|-- Makefile</span><br><span class="line">|-- boot</span><br><span class="line">|   |-- head.s</span><br><span class="line">|-- fs</span><br><span class="line">|   |-- Makefile</span><br><span class="line">|   |-- bitmap.c</span><br><span class="line">|   |-- block_dev.c</span><br><span class="line">|   |-- buffer.c</span><br><span class="line">|   |-- char_dev.c</span><br><span class="line">|   |-- exec.c</span><br><span class="line">|   |-- fcntl.c</span><br><span class="line">|   |-- file_dev.c</span><br><span class="line">|   |-- file_table.c</span><br><span class="line">|   |-- inode.c</span><br><span class="line">|   |-- ioctl.c</span><br><span class="line">|   |-- namei.c</span><br><span class="line">|   |-- open.c</span><br><span class="line">|   |-- pipe.c</span><br><span class="line">|   |-- read_write.c</span><br><span class="line">|   |-- stat.c</span><br><span class="line">|   |-- super.c</span><br><span class="line">|   `-- truncate.c</span><br><span class="line">|-- include</span><br><span class="line">|   |-- a.out.h</span><br><span class="line">|   |-- asm</span><br><span class="line">|   |   |-- io.h</span><br><span class="line">|   |   |-- memory.h</span><br><span class="line">|   |   |-- segment.h</span><br><span class="line">|   |   `-- system.h</span><br><span class="line">|   |-- const.h</span><br><span class="line">|   |-- ctype.h</span><br><span class="line">|   |-- errno.h</span><br><span class="line">|   |-- fcntl.h</span><br><span class="line">|   |-- linux</span><br><span class="line">|   |   |-- config.h</span><br><span class="line">|   |   |-- fdreg.h</span><br><span class="line">|   |   |-- fs.h</span><br><span class="line">|   |   |-- hdreg.h</span><br><span class="line">|   |   |-- head.h</span><br><span class="line">|   |   |-- kernel.h</span><br><span class="line">|   |   |-- mm.h</span><br><span class="line">|   |   |-- sched.h</span><br><span class="line">|   |   |-- sys.h</span><br><span class="line">|   |   `-- tty.h</span><br><span class="line">|   |-- signal.h</span><br><span class="line">|   |-- stdarg.h</span><br><span class="line">|   |-- stddef.h</span><br><span class="line">|   |-- string.h</span><br><span class="line">|   |-- sys</span><br><span class="line">|   |   |-- stat.h</span><br><span class="line">|   |   |-- times.h</span><br><span class="line">|   |   |-- types.h</span><br><span class="line">|   |   |-- utsname.h</span><br><span class="line">|   |   `-- wait.h</span><br><span class="line">|   |-- termios.h</span><br><span class="line">|   |-- time.h</span><br><span class="line">|   |-- unistd.h</span><br><span class="line">|   `-- utime.h</span><br><span class="line">|-- init</span><br><span class="line">|   |-- main.c</span><br><span class="line">|-- kernel</span><br><span class="line">|   |-- Makefile</span><br><span class="line">|   |-- asm.o</span><br><span class="line">|   |-- asm.s</span><br><span class="line">|   |-- blk_drv</span><br><span class="line">|   |   |-- Makefile</span><br><span class="line">|   |   |-- blk.h</span><br><span class="line">|   |   |-- floppy.c</span><br><span class="line">|   |   |-- hd.c</span><br><span class="line">|   |   |-- ll_rw_blk.c</span><br><span class="line">|   |   `-- ramdisk.c</span><br><span class="line">|   |-- chr_drv</span><br><span class="line">|   |   |-- Makefile</span><br><span class="line">|   |   |-- console.c</span><br><span class="line">|   |   |-- keyboard.S</span><br><span class="line">|   |   |-- rs_io.s</span><br><span class="line">|   |   |-- serial.c</span><br><span class="line">|   |   |-- tty_io.c</span><br><span class="line">|   |   `-- tty_ioctl.c</span><br><span class="line">|   |-- exit.c</span><br><span class="line">|   |-- fork.c</span><br><span class="line">|   |-- fork.i</span><br><span class="line">|   |-- math</span><br><span class="line">|   |   |-- Makefile</span><br><span class="line">|   |   `-- math_emulate.c</span><br><span class="line">|   |-- mktime.c</span><br><span class="line">|   |-- panic.c</span><br><span class="line">|   |-- printk.c</span><br><span class="line">|   |-- sched.c</span><br><span class="line">|   |-- sched.o</span><br><span class="line">|   |-- signal.c</span><br><span class="line">|   |-- sys.c</span><br><span class="line">|   |-- system_call.o</span><br><span class="line">|   |-- system_call.s</span><br><span class="line">|   |-- traps.c</span><br><span class="line">|   |-- traps.o</span><br><span class="line">|   `-- vsprintf.c</span><br><span class="line">|-- lib</span><br><span class="line">|   |-- Makefile</span><br><span class="line">|   |-- _exit.c</span><br><span class="line">|   |-- close.c</span><br><span class="line">|   |-- ctype.c</span><br><span class="line">|   |-- dup.c</span><br><span class="line">|   |-- errno.c</span><br><span class="line">|   |-- execve.c</span><br><span class="line">|   |-- malloc.c</span><br><span class="line">|   |-- open.c</span><br><span class="line">|   |-- setsid.c</span><br><span class="line">|   |-- string.c</span><br><span class="line">|   |-- wait.c</span><br><span class="line">|   `-- write.c</span><br><span class="line">|-- mm</span><br><span class="line">|   |-- Makefile</span><br><span class="line">|   |-- memory.c</span><br><span class="line">|   `-- page.s</span><br><span class="line">`-- tools</span><br><span class="line">    `-- build.c</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次拖得有够久的，毕竟需要将知识串联起来并不是一件容易的事情。更何况很多内容可以说和常理(个人理解的常理)有了比较大的偏差。&lt;/p&gt;
&lt;p&gt;不过确实比较有意思。从引导程序到操作系统启动，这中间究竟经历了多少流程呢？&lt;/p&gt;
&lt;p&gt;由于前几篇已经有过介绍，这里不会再对引导程序及汇编语法做过多的介绍。而着重描述整个操作系统的启动流程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://DorMOUSE-None.github.io/tags/Linux/"/>
    
      <category term="Kernel" scheme="https://DorMOUSE-None.github.io/tags/Kernel/"/>
    
      <category term="OS" scheme="https://DorMOUSE-None.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Understand MAIL</title>
    <link href="https://DorMOUSE-None.github.io/2018-09-27-mail/"/>
    <id>https://DorMOUSE-None.github.io/2018-09-27-mail/</id>
    <published>2018-09-26T16:00:00.000Z</published>
    <updated>2018-09-28T10:10:21.579Z</updated>
    
    <content type="html"><![CDATA[<p>在网络协议上，高层协议确实比底层协议更容易理解，也更加的人性化。<br>传输层的 TCP, UDP 都还停留在各种字节内容的整合和校验上，而更上层的应用层协议就已经能够直观到通过直接解读就能理解其每条消息的含义了。</p><a id="more"></a><h2 id="SMTP-协议"><a href="#SMTP-协议" class="headerlink" title="SMTP 协议"></a>SMTP 协议</h2><p>SMTP，简单邮件传输协议。单从协议内容上来说确实没有太多的学习难度。但是，扭转“常识”恰恰是巨大的绊脚石。<br>直接就进入了网页邮件系统 or 客户端邮件系统的时代。图形化的界面配合上一些关键字的内容 (比如收件人，主题等)。<br>点击发送就觉得一封邮件已经发出去了。</p><p>但是，究竟这中间做了什么呢？<br>163，GMAIL, QQ 等邮箱究竟又在其中扮演着怎样的一个角色？</p><p>首先，SMTP 是为了高效、可靠地传递邮件而存在的。</p><p>下面先给一段演示。通过 telnet 连接到 183.57.48.34 (这个是腾讯企业邮其中一台机器的 IP) 25 (SMTP 服务端口) ，以本机作为 SMTP 的客户端，而将 183.XXX 作为 SMTP 的服务端，来完成邮件信息的一次交互。 (当然，最后失败了。被企业邮识别为垃圾邮件了…)</p><p>下列每行 <code>#</code> 开始及之后的内容是个人添加的注释，其它内容是 telnet 交互的内容。<br>同时，<code>--</code> 标志该行内容由</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ telnet 183.57.48.34 25</span><br><span class="line">Trying 183.57.48.34...</span><br><span class="line">Connected to 183.57.48.34.</span><br><span class="line">Escape character is &apos;^]&apos;.</span><br><span class="line">220 bizmx17.qq.com MX QQ Mail Server</span><br><span class="line">HELO test                               -- # MEANS HELLO &lt;domain&gt; 在每次建立连接通道后，发送的第一条消息</span><br><span class="line">250 bizmx17.qq.com                         # 服务器的回复值 Code 250 </span><br><span class="line">MAIL FROM: &lt;from@test.net&gt;              -- # MAIL 表示邮件的发起方，用于退信等其他邮件反向事件</span><br><span class="line">250 Ok                                   </span><br><span class="line">RCPT TO: &lt;to@xxx.xxx&gt;                   -- # RCPT 表示邮件的接收方，用于投递邮件等正向事件</span><br><span class="line">250 Ok</span><br><span class="line">DATA                                    -- # DATA 表示之后的内容将作为邮件正文 (正文这个描述可能不太恰当，更应该是等同于信封内的所有内容)</span><br><span class="line">354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;</span><br><span class="line">                                        --</span><br><span class="line">It&apos;s a fake mail.                       -- # 邮件正文，其实还可以写上诸如 &apos;Subject: XXX&apos; &apos;Cc: XXX&apos; 的内容</span><br><span class="line">.                                       -- # 正文内容结束的标志，&lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;</span><br><span class="line">550 Mail content denied. http://service.exmail.qq.com/cgi-bin/help?subtype=1&amp;&amp;id=20022&amp;&amp;no=1000726 # 这里很无奈，没腾讯给拦了，没发出去。不过反正是假的，邮件信息不全。</span><br></pre></td></tr></table></figure><h3 id="几个主要的-SMTP-交互指令"><a href="#几个主要的-SMTP-交互指令" class="headerlink" title="几个主要的 SMTP 交互指令"></a>几个主要的 SMTP 交互指令</h3><ul><li>HELO: (HELLO)<br>  主要用于让 SMTP 服务器对当前连接的 SMTP 客户端(上例是 telnet 模拟的) 建立一个身份标志 (一般是当前的主机名)</li><li>MAIL:<br>  用法 MAIL FROM: <a href="mailto:&#120;&#120;&#x40;&#x78;&#x78;&#x2e;&#120;&#120;" target="_blank" rel="noopener">&#120;&#120;&#x40;&#x78;&#x78;&#x2e;&#120;&#120;</a> (不区分大小写)<br>  可以将其与普通信件的信封等同。毕竟都是要写上发信人，如果没人收信，也就可以根据这个声明将信件退回。</li><li>RCPT: (RECIPIENT)<br>  用法 RCPT TO: <a href="mailto:&#x78;&#x78;&#x40;&#x78;&#120;&#46;&#120;&#120;" target="_blank" rel="noopener">&#x78;&#x78;&#x40;&#x78;&#120;&#46;&#120;&#120;</a> (可多次重复声明，即将一封信件复制多次投送给每次声明的对象)<br>  相当于普通信件的收信人。不过也有点区别，毕竟普通信件没法一件多发嘛。</li><li>DATA:<br>  <code>DATA</code> 之后到 <code>&lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;</code> 之前的所有内容都作为邮件的正文内容。等同于普通信件信封内的信纸(当然了，信纸上在写上 <code>To XXX:</code> <code>Yours XXX</code> 也是很正常的嘛)，类似的也就是 DATA 数据中也可以包括 <code>Subject:</code> (主题), <code>From:</code> (写信人), <code>Date:</code> (日期), <code>To:</code>(收件人)等内容。</li></ul><hr><h3 id="几个次要的-SMTP-交互指令"><a href="#几个次要的-SMTP-交互指令" class="headerlink" title="几个次要的 SMTP 交互指令"></a>几个次要的 SMTP 交互指令</h3><ul><li><p>RSET: (Reset)<br>  重置，丢弃之前针对邮件所描述的所有内容，重新开始。</p></li><li><p>VRFY: (VERIFY)<br>  用于确认收件人是否存在，以及收件人的完整地址</p></li><li><p>NOOP:<br>  强制服务器做出一个回应，没有实际意义。</p></li><li><p>QUIT:<br>  要求收信服务器返回一个邮件接收成功的信号，之后释放连接通道。</p></li></ul><h2 id="SMTP-扩展"><a href="#SMTP-扩展" class="headerlink" title="SMTP 扩展"></a>SMTP 扩展</h2><p>前面描述了这么多，应该来说找一些支持 TCP (或者其他稳定的传输层连接也是可以的) 连接的命令就完全可以支持一次邮件发送的需求。</p><p>但是，如果想要发送一些中文字符之类的，马上就出现了问题。</p><p>这里有几种方式，但本人还没有理解透彻。仅列出知道的可行方案。</p><ul><li>通过 IMF (Internet Message Format) 进行发件</li><li>通过 ESMTP </li></ul><h2 id="SMTP-安全"><a href="#SMTP-安全" class="headerlink" title="SMTP 安全"></a>SMTP 安全</h2><p>出于 SMTP 本身协议的设计，没有一个有效的身份认证机制。</p><p>纵使通过 <code>MAIL FROM: &lt;A@test.net&gt;</code> 在信封上写明了是由 A 发出的信件。<br>但是，装在信封内的信纸却可以属上另一个人的名字。</p><p>利用这种规则，也就出现了伪装发信人这样的操作。当然，现在的大量邮箱服务提供商都会对这种情况进行标记。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fvpbzedf67j315e01q0sp.jpg" alt="“代发”标记"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://tools.ietf.org/html/rfc821" target="_blank" rel="noopener">SIMPLE MAIL TRANSFER PROTOCOL</a></li><li><a href="http://www.ruanyifeng.com/blog/2008/06/mime.html" target="_blank" rel="noopener">MIME</a></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在网络协议上，高层协议确实比底层协议更容易理解，也更加的人性化。&lt;br&gt;传输层的 TCP, UDP 都还停留在各种字节内容的整合和校验上，而更上层的应用层协议就已经能够直观到通过直接解读就能理解其每条消息的含义了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mail" scheme="https://DorMOUSE-None.github.io/tags/mail/"/>
    
      <category term="SMTP" scheme="https://DorMOUSE-None.github.io/tags/SMTP/"/>
    
      <category term="TCP" scheme="https://DorMOUSE-None.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>TCP SYN 包模拟</title>
    <link href="https://DorMOUSE-None.github.io/2018-09-18-TCP-SYN/"/>
    <id>https://DorMOUSE-None.github.io/2018-09-18-TCP-SYN/</id>
    <published>2018-09-17T16:00:00.000Z</published>
    <updated>2018-09-18T10:05:46.320Z</updated>
    
    <content type="html"><![CDATA[<p>写了两天，几乎是从零开始，C 语言搞了一个发 TCP SYN 包的小程序。<br>从协议到程序代码的转换，确实没有花费太多的时间，但是为了字节序(byteorder)的问题简直折腾得…</p><a id="more"></a><h2 id="TCP-首部格式"><a href="#TCP-首部格式" class="headerlink" title="TCP 首部格式"></a>TCP 首部格式</h2><p>从 RFC 793 了解到基础的 TCP 首部格式(当然，模拟三次握手的 SYN 包也根本不需要填充任何数据)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|          Source Port          |       Destination Port        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                        Sequence Number                        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Acknowledgment Number                      |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|  Data |           |U|A|P|R|S|F|                               |</span><br><span class="line">| Offset| Reserved  |R|C|S|S|Y|I|            Window             |</span><br><span class="line">|       |           |G|K|H|T|N|N|                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|           Checksum            |         Urgent Pointer        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Options                    |    Padding    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                             data                              |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>对于仅仅模拟一个 SYN 包而言，似乎无需关心 Sequence Number, Ack Number, Window 等信息，毕竟都不关心服务器端给的返回。<br>最低的要求，仅仅是发一个合法的 TCP 报文，得到服务器端的反馈，而非直接被服务器端丢弃(如果被验证到报文非法或者数据出错等)。</p><p>那么，最为重要的细节就是 Checksum (校验和) 了。服务器端会对接收到的数据流进行校验，如果有差错，则直接丢弃，而无任何结果。</p><h2 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h2><p>从细节上来说，网络协议中的校验和显得比较简单。以 TCP 协议的 Checksum 字段举例，就是为了让伪首部(TCP 首部 + source IP + destination IP 等一些额外信息)<br>以每 16 位 (2 字节) 为一个单位，循环累加和最终达到 0xFFFF 的效果。</p><p>下面以一个由 Source IP: 172.16.2.101 -&gt; Destination IP: 172.16.2.127 的 TCP 首部为例进行细节描述:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 总长为 20 字节的 TCP 报文首部</span><br><span class="line">27 11 0f a0 00 00 00 00 00 00 00 00 50 02 ff 00 1d 2c 00 00</span><br><span class="line"></span><br><span class="line">src Port: 0x2711 -&gt; 10001</span><br><span class="line">dst Port: 0x0fa0 -&gt; 4000</span><br><span class="line">Seq nr: 0x00000000 -&gt; 0</span><br><span class="line">Ack nr: 0x00000000 -&gt; 0</span><br><span class="line">Data off: 5 -&gt; 32 bits 数量是 5 -&gt; 20 字节 (即 TCP 首部长度为 20 字节)</span><br><span class="line">FLAG: 0x02 -&gt; urg ack psh rst SYN fin </span><br><span class="line">Window: 0xFF00 (窗口大小为 65280 字节)</span><br><span class="line">chk sum: 0x1d2c</span><br><span class="line">urg pointer: 0x0000</span><br></pre></td></tr></table></figure><p>在计算之前，TCP 校验和还将涉及到伪首部的概念</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|           Source Address          |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|         Destination Address       |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|  zero  |  PTCL  |    TCP Length   |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line"></span><br><span class="line">在此例中:</span><br><span class="line">Source Address: 172.16.2.101 -&gt; 0xAC100265</span><br><span class="line">Destination Address: 172.16.2.127 -&gt; 0XAC10027F</span><br><span class="line">zero: 0x00</span><br><span class="line">PTCL(protocol): TCP(6) -&gt; 0x06</span><br><span class="line">TCP Length: 20 bytes -&gt; 0x0014</span><br></pre></td></tr></table></figure><p>即加上伪首部的内容，需要共同进行校验的数据流如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ac 10 02 65 ac 10 02 7f 00 06 00 14 27 11 0f a0 00 00 00 00 00 00 00 00 50 02 ff 00 1d 2c 00 00</span><br></pre></td></tr></table></figure></p><h3 id="服务器端校验"><a href="#服务器端校验" class="headerlink" title="服务器端校验"></a>服务器端校验</h3><p>服务器端接收到 TCP 报文后，将对整个需要校验的数据流，按 16 bits (2字节) 为单位，进行累加。</p><p>即: <code>0xac10+0x0265+0xac10+0x027f+0x0006+0x0014+0x2711+0x0fa0+0x0000+0x0000+0x0000+0x0000+0x5002+0xff00+0x1d2c+0x0000 = 0x2fffd</code></p><p>对于超长计算结果 (超出 0xFFFF) ，循环将高位右移 16 位与低位进行累加，直到结果 &lt;= 0xFFFF ，即 <code>0x20000 &gt;&gt; 16 + 0xfffd = 0xffff</code></p><p>如果最终结果 <code>=0xffff</code>(全为 1) ，则认为 TCP 首部没有问题，服务器端接收报文，并回复 ACK SYN 包。</p><h3 id="客户端构造校验和"><a href="#客户端构造校验和" class="headerlink" title="客户端构造校验和"></a>客户端构造校验和</h3><p>与服务器端相对，显然客户端必须通过 Check sum ，使得最终的结果服务器端校验的条件。</p><p>作为反向问题，同样以上面为例子，假设 check sum 还未确定具体的值。则计算方式如下:</p><p>加上伪首部, 校验和暂时置零的数据流</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ac 10 02 65 ac 10 02 7f 00 06 00 14 27 11 0f a0 00 00 00 00 00 00 00 00 50 02 ff 00 00 00 00 00</span><br></pre></td></tr></table></figure><p>作为逆过程，按 16 bits 为单位，进行累加。即: <code>0xac10+0x0265+0xac10+0x027f+0x0006+0x0014+0x2711+0x0fa0+0x0000+0x0000+0x0000+0x0000+0x5002+0xff00+0x0000+0x0000 = 0x2e2d1</code></p><p>超长部分循环累加，<code>0x20000 &gt;&gt; 16 + 0xe2d1 = 0xe2d3</code></p><p>结果取反，<code>~ 0xe2d3 = 0x1d2c</code></p><p>即认为 <code>0x1d2c</code> 为校验和</p><h2 id="HBO-与-NBO"><a href="#HBO-与-NBO" class="headerlink" title="HBO 与 NBO"></a>HBO 与 NBO</h2><p>HBO: host byte order<br>NBO: network byte order </p><p>说起字节序简直能够把人逼疯，说实话虽然有一定的历史原因，但是不做统一真的对底层编程相当得不友好。</p><p>不过，再厌烦也不能改变什么。总还得继续写代码不是嘛。</p><h3 id="主机字节序-HBO-Host-Byte-Order"><a href="#主机字节序-HBO-Host-Byte-Order" class="headerlink" title="主机字节序 (HBO, Host Byte Order)"></a>主机字节序 (HBO, Host Byte Order)</h3><p>采用小端字节排序方式。简单描述为 高位字节存放在内存的高地址处，低位字节存储在内存的低地址处。</p><p>以 4 字节 int 型数据 0xAB1267EF 为例:</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fvdu3zhh92j31040newel.jpg" alt=""></p><p>而程序读取数据的顺序，如果不考虑数据类型，按字节读取，普遍将采用字节递增序读取，则优先将读到 0xEF 等低位字节数据</p><h3 id="网络字节序-NBO-Network-Byte-Order"><a href="#网络字节序-NBO-Network-Byte-Order" class="headerlink" title="网络字节序 (NBO, Network Byte Order)"></a>网络字节序 (NBO, Network Byte Order)</h3><p>采用大端字节排序方式。简单描述为通过网络接收到数据时将优先接收到数据的高位字节，然后再得到低位字节。</p><p>还是以 4 字节 int 型数据 0xAB1267EF 为例:</p><p>则通过网络得到的数据流将是 <code>0xEF 0x67 0x12 0xAB</code></p><h3 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h3><p>C 语言，BSD 平台的 netinet/tcp.h 定义了 tcp header 结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span>th_sport;<span class="comment">/* source port */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span>th_dport;<span class="comment">/* destination port */</span></span><br><span class="line">tcp_seqth_seq;<span class="comment">/* sequence number */</span></span><br><span class="line">tcp_seqth_ack;<span class="comment">/* acknowledgement number */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __DARWIN_BYTE_ORDER == __DARWIN_LITTLE_ENDIAN</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>th_x2:<span class="number">4</span>,<span class="comment">/* (unused) */</span></span><br><span class="line">th_off:<span class="number">4</span>;<span class="comment">/* data offset */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __DARWIN_BYTE_ORDER == __DARWIN_BIG_ENDIAN</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>th_off:<span class="number">4</span>,<span class="comment">/* data offset */</span></span><br><span class="line">th_x2:<span class="number">4</span>;<span class="comment">/* (unused) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>th_flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>TH_FIN0x01</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>TH_SYN0x02</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>TH_RST0x04</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>TH_PUSH0x08</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>TH_ACK0x10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>TH_URG0x20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>TH_ECE0x40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>TH_CWR0x80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>TH_FLAGS(TH_FIN|TH_SYN|TH_RST|TH_ACK|TH_URG|TH_ECE|TH_CWR)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span>th_win;<span class="comment">/* window */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span>th_sum;<span class="comment">/* checksum */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span>th_urp;<span class="comment">/* urgent pointer */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于 <code>unsigned char</code> 之类的单字节数据，将不存在任何问题。但是，诸如 <code>unsigned short</code> 等多字节数据，将涉及到字节序的转换。</p><p>比如，虽然令 <code>th_sport = 0x2711 (10001)</code> 看似合理。但是，从内存的角度来看，数据将被存储为 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 假设起始物理内存地址为 0x00007c000</span><br><span class="line">0x00007c01: 0x27 </span><br><span class="line">0x00007c00: 0x11</span><br></pre></td></tr></table></figure><p>等到构造完 TCP 首部，顺次地发送数据时，呈现的数据流将形如: <code>0x11 0x27...</code> 即使用里 HBO (小端字节序) 的数据无法满足 NBO (大端字节序) 的要求。<br>毕竟，两者相互对立。</p><p>因此，需要特别注意字节序的问题。当然，C 语言还是想当友好地提供了字节序转换的工具 <code>htons</code>, <code>htonl</code>, <code>ntohs</code>, <code>ntohl</code> 。详情请通过 <code>man byteorder</code> 查看。</p><h2 id="TCP-SYN-的简单例程"><a href="#TCP-SYN-的简单例程" class="headerlink" title="TCP SYN 的简单例程"></a>TCP SYN 的简单例程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/tcp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * +--------+--------+--------+--------+</span></span><br><span class="line"><span class="comment"> * |           Source Address          |</span></span><br><span class="line"><span class="comment"> * +--------+--------+--------+--------+</span></span><br><span class="line"><span class="comment"> * |         Destination Address       |</span></span><br><span class="line"><span class="comment"> * +--------+--------+--------+--------+</span></span><br><span class="line"><span class="comment"> * |  zero  |  PTCL  |    TCP Length   |</span></span><br><span class="line"><span class="comment"> * +--------+--------+--------+--------+</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pseudohdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> src_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> dst_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> zero:<span class="number">8</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> protocol:<span class="number">8</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> tcp_length;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> <span class="title">tcpHdr</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="title">check_sum</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> *ptr, <span class="keyword">size_t</span> nbytes)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(nbytes &gt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        sum += htons(*ptr++);</span><br><span class="line">        nbytes -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sum = (sum &gt;&gt; <span class="number">16</span>) + (sum &amp; <span class="number">0xFFFF</span>);</span><br><span class="line">    sum = (sum &gt;&gt; <span class="number">16</span>) + (sum &amp; <span class="number">0xFFFF</span>);</span><br><span class="line"></span><br><span class="line">    sum = ~sum;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">short</span>) sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct tcphdr * <span class="title">init_tcp_header</span><span class="params">(<span class="keyword">int</span> sport)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> * <span class="title">header</span> = (<span class="title">struct</span> <span class="title">tcphdr</span> *) <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">tcphdr</span>));</span></span><br><span class="line">    header-&gt;th_sport = htons(sport);    <span class="comment">// 源端口</span></span><br><span class="line">    header-&gt;th_dport = htons(<span class="number">4000</span>);     <span class="comment">// 目标端口</span></span><br><span class="line">    header-&gt;th_seq = <span class="number">0</span>;                <span class="comment">// 序列号</span></span><br><span class="line">    header-&gt;th_ack = <span class="number">0</span>;                <span class="comment">// 确认序号 | ACK 置位时有效</span></span><br><span class="line">    header-&gt;th_off = <span class="keyword">sizeof</span>(struct tcphdr) / <span class="number">4</span>;   <span class="comment">// TCP 首部长度 (字节)</span></span><br><span class="line">    header-&gt;th_flags = TH_SYN;      <span class="comment">// 标志位</span></span><br><span class="line">    header-&gt;th_win = <span class="number">255</span>;           <span class="comment">// 数据窗口大小</span></span><br><span class="line">    header-&gt;th_sum = <span class="number">0</span>;             <span class="comment">// 校验值 (先置为 0, 等会再修正)</span></span><br><span class="line">    header-&gt;th_urp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> header;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tcp_syn</span><span class="params">(<span class="keyword">int</span> tcp_sock, struct tcphdr *header)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">addr</span> = (<span class="title">struct</span> <span class="title">sockaddr_in</span> *) <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sockaddr_in</span>));</span></span><br><span class="line">    addr-&gt;sin_family = PF_INET;</span><br><span class="line">    addr-&gt;sin_port = htons(<span class="number">4000</span>);</span><br><span class="line">    addr-&gt;sin_addr.s_addr = inet_addr(<span class="string">"172.16.2.127"</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> size = sendto(tcp_sock, header, <span class="keyword">sizeof</span>(struct tcphdr), <span class="number">0</span>, (struct sockaddr *)addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tcp_sock = socket(PF_INET, SOCK_RAW, IPPROTO_TCP);</span><br><span class="line">    <span class="keyword">if</span>(tcp_sock == <span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Open Socket Failed: %s(errno: %d)\n"</span>, strerror(errno), errno);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> *<span class="title">tcpHdr</span> = <span class="title">init_tcp_header</span>(10001);</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pseudohdr</span> *<span class="title">psdHdr</span> = (<span class="title">struct</span> <span class="title">pseudohdr</span> *) <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">pseudohdr</span>));</span></span><br><span class="line">    psdHdr-&gt;src_addr = inet_addr(<span class="string">"172.16.2.101"</span>);</span><br><span class="line">    psdHdr-&gt;dst_addr = inet_addr(<span class="string">"172.16.2.127"</span>);</span><br><span class="line">    psdHdr-&gt;zero = <span class="number">0</span>;</span><br><span class="line">    psdHdr-&gt;protocol = <span class="number">6</span>;</span><br><span class="line">    psdHdr-&gt;tcp_length = htons(<span class="keyword">sizeof</span>(struct tcphdr));</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;psdHdr-&gt;tcpHdr, tcpHdr, <span class="keyword">sizeof</span>(struct tcphdr));</span><br><span class="line">    tcpHdr-&gt;th_sum = htons(check_sum((<span class="keyword">unsigned</span> <span class="keyword">short</span> *) psdHdr, <span class="keyword">sizeof</span>(struct pseudohdr)));</span><br><span class="line">    <span class="built_in">free</span>(psdHdr);</span><br><span class="line"></span><br><span class="line">    tcp_syn(tcp_sock, tcpHdr);</span><br><span class="line">    <span class="built_in">free</span>(tcpHdr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写了两天，几乎是从零开始，C 语言搞了一个发 TCP SYN 包的小程序。&lt;br&gt;从协议到程序代码的转换，确实没有花费太多的时间，但是为了字节序(byteorder)的问题简直折腾得…&lt;/p&gt;
    
    </summary>
    
    
      <category term="TCP" scheme="https://DorMOUSE-None.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Preprocessor Output</title>
    <link href="https://DorMOUSE-None.github.io/2018-09-08-preprocessor-output/"/>
    <id>https://DorMOUSE-None.github.io/2018-09-08-preprocessor-output/</id>
    <published>2018-09-07T16:00:00.000Z</published>
    <updated>2018-09-08T06:59:35.638Z</updated>
    
    <content type="html"><![CDATA[<p>最近重新开始回顾 C 语言以及其编译后的文件格式 ELF。<br>暂时告别一步到位的命令 <code>gcc main.c</code>，如果从 <code>.c</code> 文件的编译来说，主要分为预编译(preprocess)、编译(Compilation)、汇编(Assembly)、链接(Linking) 四个步骤。<br>但是，仅仅从第一个流程 <strong>预编译</strong> 而言，就已经遇到了一些麻烦。</p><p><small>program.i</small><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span> <span class="string">"program.c"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;built-in&gt;"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;command-line&gt;"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"/usr/include/stdc-predef.h"</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;command-line&gt;"</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"program.c"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"header.h"</span> <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"># <span class="number">2</span> <span class="string">"program.c"</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>预编译后的问题出现了诸如 <code># 1 &quot;program.c&quot;</code> 的 <em>注释?</em> </p><p>这里简单记录预处理输出文件的基本格式，方便今后回顾。<br><a id="more"></a></p><h2 id="Output-File-format"><a href="#Output-File-format" class="headerlink" title="Output File format"></a>Output File format</h2><p>首先，从预编译的结果看，<code>cpp (C preprocessor)</code> 程序主要是处理了所有的<strong>宏指令</strong>。然后添加上了一些所谓<strong>线性标记</strong>的内容。<br>最终得到的就是类似 <code>program.i</code> 的结果。</p><p>从细节上来说:<br>首先，所有的宏指令，包括 <code>#include</code> (用于引入用户自定义及系统预定义的头文件)、<code>#define</code> (用于将使用到的宏进行替换)。<br>当然，在替换完成后，这些指令所在的行将被替换成空行。同时，所有的注释行也将被替换成空行。</p><p>此外，将添加上注入 <code>#1 &quot;program.c&quot;</code> 的<strong>线性标记</strong>。</p><h3 id="线性标记"><a href="#线性标记" class="headerlink" title="线性标记"></a>线性标记</h3><p>线性标记的标准格式:</p><p><code># linenum filename flags</code></p><p>linenum 是为了配合预定义宏 <code>__LINE__</code> 是使用的，用于定位紧随的下一行内容在原文件中所在的行。</p><p>filename 指出了接下来的内容来自哪个原文件</p><p>flags 有如下几个取值:</p><ul><li>1 : 表示这是一个新的文件的开始</li><li>2 : 表示回到文件 <code>filename</code> 的内容 (从其他的 <em>include</em> 的文件中)</li><li>3 : 表示接下来的内容是从系统预定义头文件中来的，因此需要抑制某些警告</li><li>4 : 表示接下来的内容需要被视作是被封装的隐式 <code>extern &quot;C&quot;</code> 块</li></ul><h3 id="实例解读"><a href="#实例解读" class="headerlink" title="实例解读"></a>实例解读</h3><p><small>program.c</small><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"header.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(test());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><small>header.h</small><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></p><p>接下来的演示都将以 <strong>program.c</strong> 和 <strong>header.h</strong> 两个文件作为标准示例。<br>期间，将对 <strong>program.c</strong> or <strong>header.h</strong> 做不同程度的修改，已达到更好的展示效果。<br><em>注意:</em> 额外添加的注释由 <code>!</code> 开始到该行结束(并不符合 C 语言语法)，但是帮助理解</p><p><strong>Sample 1</strong></p><p>直接利用 program.c 与 header.h 进行预编译 <code>cpp -o program.i program.c</code><br>结果如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span> <span class="string">"program.c"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;built-in&gt;"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;command-line&gt;"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"/usr/include/stdc-predef.h"</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;command-line&gt;"</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"program.c"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"header.h"</span> <span class="number">1</span>            ! 下一行代码对应的是 header.h 文件第一行</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"># <span class="number">2</span> <span class="string">"program.c"</span> <span class="number">2</span>           ! flag=<span class="number">2</span> 表示下列内容由回到了 program.c 中，下一行对应原文件第二行</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(test());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Sample 2</strong></p><p>接着，给 <strong>program.c</strong> 加点注释，在加点空行</p><p><small>program.c - sub 1<small><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is comment          ! 这里添加了一行注释</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"header.h"</span></span></span><br><span class="line"></span><br><span class="line">                            ! 这里加了个空行</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(test());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></small></small></p><p>再看看效果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span> <span class="string">"program.c"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;built-in&gt;"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;command-line&gt;"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"/usr/include/stdc-predef.h"</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;command-line&gt;"</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"program.c"</span>             ! 下一行代码对应原代码中第 <span class="number">1</span> 行，本来是注释，但会被预编译器处理成空行 (多行将逐一处理，但行数不会变)</span><br><span class="line"></span><br><span class="line"># <span class="number">1</span> <span class="string">"header.h"</span> <span class="number">1</span>            ! 下面将描述 header.h 的代码</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"># <span class="number">3</span> <span class="string">"program.c"</span> <span class="number">2</span>           ! 继续描述 program.c ，下一行对应原代码第 <span class="number">3</span> 行。至于第 <span class="number">2</span> 行，就是 <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"header.h"</span> ，不会直接表现了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(test());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Sample 3</strong></p><p>在改变一些</p><p><small>program.c - sub 2</small><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is comment</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"header.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEN 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(test());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看看结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span> <span class="string">"program.c"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;built-in&gt;"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;command-line&gt;"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"/usr/include/stdc-predef.h"</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;command-line&gt;"</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"program.c"</span></span><br><span class="line"></span><br><span class="line"># <span class="number">1</span> <span class="string">"header.h"</span> <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"># <span class="number">3</span> <span class="string">"program.c"</span> <span class="number">2</span></span><br><span class="line">                        ! 原代码中对应行是宏 <span class="meta">#<span class="meta-keyword">define</span> TEN 10 ，已经被空行替换掉了。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(test());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近重新开始回顾 C 语言以及其编译后的文件格式 ELF。&lt;br&gt;暂时告别一步到位的命令 &lt;code&gt;gcc main.c&lt;/code&gt;，如果从 &lt;code&gt;.c&lt;/code&gt; 文件的编译来说，主要分为预编译(preprocess)、编译(Compilation)、汇编(Assembly)、链接(Linking) 四个步骤。&lt;br&gt;但是，仅仅从第一个流程 &lt;strong&gt;预编译&lt;/strong&gt; 而言，就已经遇到了一些麻烦。&lt;/p&gt;
&lt;p&gt;&lt;small&gt;program.i&lt;/small&gt;&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;program.c&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;built-in&amp;gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;command-line&amp;gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;/usr/include/stdc-predef.h&quot;&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;command-line&amp;gt;&quot;&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;program.c&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;header.h&quot;&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;program.c&quot;&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;预编译后的问题出现了诸如 &lt;code&gt;# 1 &amp;quot;program.c&amp;quot;&lt;/code&gt; 的 &lt;em&gt;注释?&lt;/em&gt; &lt;/p&gt;
&lt;p&gt;这里简单记录预处理输出文件的基本格式，方便今后回顾。&lt;br&gt;
    
    </summary>
    
    
      <category term="C" scheme="https://DorMOUSE-None.github.io/tags/C/"/>
    
      <category term="CPP" scheme="https://DorMOUSE-None.github.io/tags/CPP/"/>
    
      <category term="GCC" scheme="https://DorMOUSE-None.github.io/tags/GCC/"/>
    
  </entry>
  
  <entry>
    <title>理解 Linux Kernel (2) - 多任务切换</title>
    <link href="https://DorMOUSE-None.github.io/2018-08-26-understand-Kernel-2/"/>
    <id>https://DorMOUSE-None.github.io/2018-08-26-understand-Kernel-2/</id>
    <published>2018-08-25T16:00:00.000Z</published>
    <updated>2019-04-21T05:23:14.745Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>《只是为了好玩》书中，林纳斯描述过他最早的试验性程序就是执行两个不同的任务（一个不断输出A，另一个输出B），同时不断地让 CPU 在两个任务间做切换。结合《Linux 内核完全注释》提供的一个多任务切换示例程序，本篇将就多任务切换程序的执行流程进行详述，并提供当下汇编工具下的适配。</p><p>关于运行环境的说明，欢迎参考 <a href="https://www.ffutop.com/2018-08-19-understand-Kernel-1/#Bochs-%E4%BB%BF%E7%9C%9F%E5%99%A8" target="_blank" rel="noopener">Bochs 仿真器使用简介</a></p><a id="more"></a><h2 id="引导程序"><a href="#引导程序" class="headerlink" title="引导程序"></a>引导程序</h2><p><a href="https://www.ffutop.com/2018-08-19-understand-Kernel-1/" target="_blank" rel="noopener">理解 Linux Kernel (1)</a> 中已经描述过 BIOS 加载/执行引导程序的全流程。操作系统的概念对于处理器、内存等底层硬件来说，并不是必须的。处理器永远只是忠实地执行指令指针(IP, instruction pointer)指向的机器指令。那么，机器上电之后，第一个 IP 是如何提供给处理器的呢？由硬件来直接完成初始化的工作（至于细节，没实际操作过，不表）。</p><p>在机器上电启动之后，存储在非易失性存储器/只读存储器上的 BIOS 程序将被加载到内存，并执行(至于细节，不甚了解，不表)。随后，BIOS 从指定磁盘（软盘、硬盘等）读取首个扇区 512 字节的内容（称为 boot 引导程序），载入到预定的内存地址（0x7c000 开始的内存块）。同时处理器 JMP 到 CS:IP = 0x07c00:0x0000 的位置。从而触发引导程序。</p><p>随后处理器将忠实地执行 boot 引导程序描述的指令。至于引导程序的实现是让处理器执行一个操作系统程序，还是执行一个用户程序。这完全取决于编写引导程序的人，而对处理器来说，完全没有差别。</p><p><code>BIOS -&gt; boot 引导程序 -&gt; 操作系统引导程序 -&gt; 操作系统</code><br>这就构成了一个宏观的操作系统启动的一个流程。</p><p>boot.s 引导程序 <small>主体代码来自《Linux 内核完全注释》，进行了一定量的改写</small></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">BOOTSEG = 0x07c0</span><br><span class="line">SYSSEG = 0x0100</span><br><span class="line">SYSLEN = 17</span><br><span class="line"></span><br><span class="line">entry start</span><br><span class="line">start:</span><br><span class="line">    jmpi    go,#BOOTSEG</span><br><span class="line">go:</span><br><span class="line">    mov ax,cs</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,#0x0400</span><br><span class="line"></span><br><span class="line">load_system:</span><br><span class="line">    xor dx,dx       ! 开始位置, 磁头:硬盘号</span><br><span class="line">    mov cx,#0x0002  ! 开始位置, 磁道:扇区</span><br><span class="line">    mov ax,#0x0100</span><br><span class="line">    mov es,ax       ! 载入到, ES 段</span><br><span class="line">    xor bx,bx       ! 载入到, 偏移量 </span><br><span class="line">    mov ax,#0x0211  ! AH: 读取扇区子功能, AL: 读取多少个扇区</span><br><span class="line">    int 0x13        ! BIOS 13 号中断</span><br><span class="line">    jnc continue_load   ! JUMP if CF = 0</span><br><span class="line">die:</span><br><span class="line">    jmp die</span><br><span class="line"></span><br><span class="line">continue_load:</span><br><span class="line">    cli             ! 清除中断允许位标志</span><br><span class="line">    mov ax,#SYSSEG </span><br><span class="line">    mov ds,ax       ! 设置数据段寄存器位置 0x1000</span><br><span class="line">    xor ax,ax</span><br><span class="line">    mov es,ax       ! 设置扩展段寄存器 0x0000</span><br><span class="line">    mov cx,#0x1000  ! 计数器</span><br><span class="line">    sub si,si</span><br><span class="line">    sub di,di</span><br><span class="line">    rep </span><br><span class="line">    movsw</span><br><span class="line"></span><br><span class="line">    mov ax,#BOOTSEG</span><br><span class="line">    mov ds,ax       ! 重新设置数据段寄存器到当前数据段基地址</span><br><span class="line">    lidt idt_48     ! 设置中断描述符表寄存器</span><br><span class="line">    lgdt gdt_48     ! 设置全局描述符表寄存器</span><br><span class="line"></span><br><span class="line">    mov ax,#0x0001</span><br><span class="line">    lmsw ax         ! 设置 CR0, 进入保护模式</span><br><span class="line">    jmpi 0,8</span><br><span class="line"></span><br><span class="line">gdt:</span><br><span class="line">    .word   0,0,0,0</span><br><span class="line">    .word   0x07FF,0x0000,0x9A00,0x00C0</span><br><span class="line">    .word   0x07FF,0x0000,0x9200,0x00C0</span><br><span class="line"></span><br><span class="line">idt_48:</span><br><span class="line">    .word   0,0,0</span><br><span class="line">gdt_48:</span><br><span class="line">    .word   0x07FF,0x7C00+gdt,0</span><br><span class="line"></span><br><span class="line">.org 510</span><br><span class="line">    .word   0xAA55</span><br></pre></td></tr></table></figure><p>这段汇编程序，通过 <code>load_system</code> 标识符标识的这段程序表明需要加载0号磁盘,0号磁头,0号磁道,从第2扇区开始,连续17个扇区的内容(这里将存储支持任务切换的程序)，加载到内存以 0x1000 开始的物理地址处。</p><p><code>continue_load</code> 标识将 0x1000 物理地址开始的 4096 字 (即 8192 字节) 的内容依次复制到以 0x0000 开始的物理地址处。</p><p>其后，设置 IDT (中断描述符表)、IDTR(中断描述符表寄存器) 及 GDT(全局描述符表)、GDTR(全局描述符表寄存器)，将 CPU 运行模式改成 <code>保护模式</code> ，继而将控制权转交给这个被加载进来的程序。</p><h2 id="多任务程序"><a href="#多任务程序" class="headerlink" title="多任务程序"></a>多任务程序</h2><p><small>主体内容来自《Linux 内核完全注释》，经过一定量改变以适应当前运行环境</small><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br></pre></td><td class="code"><pre><span class="line"># head.s</span><br><span class="line">.code32</span><br><span class="line">LATCH = 11930</span><br><span class="line">SCRN_SEL = 0x18</span><br><span class="line">TSS0_SEL = 0x20</span><br><span class="line">LDT0_SEL = 0x28</span><br><span class="line">TSS1_SEL = 0x30</span><br><span class="line">LDT1_SEL = 0x38</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">.globl startup_32</span><br><span class="line">startup_32:</span><br><span class="line"></span><br><span class="line">    movl $0x00000010,%eax       # 段选择符 2</span><br><span class="line">    mov %ax,%ds                </span><br><span class="line">    lss init_stack,%esp         # Load Far Pointer 加载到 SS:ESP </span><br><span class="line"></span><br><span class="line">    call setup_idt              # 设置中断描述符表</span><br><span class="line">    call setup_gdt              # 设置全局描述符表</span><br><span class="line">    movl $0x00000010,%eax</span><br><span class="line">    mov %ax,%ds</span><br><span class="line">    mov %ax,%es</span><br><span class="line">    mov %ax,%fs</span><br><span class="line">    mov %ax,%gs</span><br><span class="line">    lss init_stack,%esp         # Load Far Pointer 加载到 SS:ESP</span><br><span class="line"></span><br><span class="line"># 设置 8253 定时芯片 10s 一个中断</span><br><span class="line">    movb $0x36,%al  </span><br><span class="line">    movl $0x00000043,%edx</span><br><span class="line">    outb %al,%dx</span><br><span class="line">    movl $LATCH,%eax</span><br><span class="line">    movl $0x40,%edx</span><br><span class="line">    outb %al,%dx</span><br><span class="line">    movb %ah,%al</span><br><span class="line">    outb %al,%dx</span><br><span class="line"></span><br><span class="line">    movl $0x00080000,%eax       # 重新设置 int 0x08 时钟中断</span><br><span class="line">    movw $timer_interrupt,%ax</span><br><span class="line">    movw $0x8E00,%dx</span><br><span class="line">    movl $0x08,%ecx</span><br><span class="line">    lea idt(,%ecx,8),%esi</span><br><span class="line">    movl %eax,(%esi)</span><br><span class="line">    movl %edx,4(%esi)</span><br><span class="line">    movw $system_interrupt,%ax  # 重新设置 int 0x80 系统中断</span><br><span class="line">    movw $0xef00,%dx</span><br><span class="line">    movl $0x80,%ecx</span><br><span class="line">    lea idt(,%ecx,8),%esi</span><br><span class="line">    movl %eax,(%esi)</span><br><span class="line">    movl %edx,4(%esi)</span><br><span class="line"></span><br><span class="line">    pushfl                      # 重置 EFLAGS 嵌套任务标志位</span><br><span class="line">    andl $0xffffbfff,(%esp)</span><br><span class="line">    popfl</span><br><span class="line">    movl $TSS0_SEL,%eax</span><br><span class="line">    ltr %ax                     # Load Task Register</span><br><span class="line">    movl $LDT0_SEL,%eax</span><br><span class="line">    lldt %ax                    # Load Local Descriptor Register</span><br><span class="line">    movl $0,current</span><br><span class="line">    sti                         # set interrupt flag</span><br><span class="line">    pushl $0x17</span><br><span class="line">    pushl $init_stack</span><br><span class="line">    pushfl</span><br><span class="line">    pushl $0x0f</span><br><span class="line">    pushl $task0</span><br><span class="line">    iret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setup_gdt:</span><br><span class="line">    lgdt lgdt_opcode</span><br><span class="line">    ret</span><br><span class="line">setup_idt:</span><br><span class="line">    lea ignore_int,%edx         # 预先把中断处理程序的偏移地址 ignore_int 存到 EDX</span><br><span class="line">    movl $0x00080000,%eax       # 预存 0x0008 - 段选择符</span><br><span class="line">    movw %dx,%ax                # 补上 0-15 位偏移地址</span><br><span class="line">    movw $0x8E00,%dx            # DX 补上标志位</span><br><span class="line">    lea idt,%edi</span><br><span class="line">    mov $256,%ecx</span><br><span class="line">rp_idt: movl %eax,(%edi)        # 循环 256 遍处理 IDT</span><br><span class="line">    movl %edx,4(%edi)</span><br><span class="line">    addl $8,%edi</span><br><span class="line">    dec %ecx</span><br><span class="line">    jne rp_idt</span><br><span class="line">    lidt lidt_opcode</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">write_char:</span><br><span class="line">    push %gs</span><br><span class="line">    pushl %ebx</span><br><span class="line">    mov $SCRN_SEL,%ebx</span><br><span class="line">    mov %bx,%gs</span><br><span class="line">    movl scr_loc,%ebx</span><br><span class="line">    shl $1,%ebx</span><br><span class="line">    movb %al,%gs:(%ebx)</span><br><span class="line">    shr $1,%ebx</span><br><span class="line">    incl %ebx</span><br><span class="line">    cmpl $2000,%ebx</span><br><span class="line">    jb 1f</span><br><span class="line">    movl $0,%ebx</span><br><span class="line">1:  movl %ebx,scr_loc</span><br><span class="line">    popl %ebx</span><br><span class="line">    pop %gs</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.align 4</span><br><span class="line">ignore_int:                 # 默认的中断处理程序</span><br><span class="line">    push %ds</span><br><span class="line">    pushl %eax</span><br><span class="line">    movl $0x10,%eax</span><br><span class="line">    mov %ax,%ds</span><br><span class="line">    movl $67,%eax</span><br><span class="line">    call write_char</span><br><span class="line">    popl %eax</span><br><span class="line">    pop %ds</span><br><span class="line">    iret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.align 4</span><br><span class="line">timer_interrupt:            # 定时中断处理程序</span><br><span class="line">    push %ds</span><br><span class="line">    pushl %eax</span><br><span class="line">    movl $0x10,%eax</span><br><span class="line">    mov %ax,%ds</span><br><span class="line">    movb $0x20,%al</span><br><span class="line">    outb %al,$0x20</span><br><span class="line">    movl $1,%eax</span><br><span class="line">    cmpl %eax,current</span><br><span class="line">    je 1f</span><br><span class="line">    movl %eax,current</span><br><span class="line">    jmp $TSS1_SEL, $0</span><br><span class="line">    jmp 2f</span><br><span class="line">1:  movl $0,current</span><br><span class="line">    jmp $TSS0_SEL, $0</span><br><span class="line">2:  popl %eax</span><br><span class="line">    pop %ds</span><br><span class="line">    iret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.align 4</span><br><span class="line">system_interrupt:           # 系统调用中断处理程序</span><br><span class="line">    push %ds</span><br><span class="line">    pushl %edx</span><br><span class="line">    pushl %ecx</span><br><span class="line">    pushl %ebx</span><br><span class="line">    pushl %eax</span><br><span class="line">    movl $0x10,%edx</span><br><span class="line">    mov %dx,%ds</span><br><span class="line">    call write_char</span><br><span class="line">    popl %eax</span><br><span class="line">    popl %ebx</span><br><span class="line">    popl %ecx</span><br><span class="line">    popl %edx</span><br><span class="line">    pop %ds</span><br><span class="line">    iret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">current:.long 0</span><br><span class="line">scr_loc:.long 0</span><br><span class="line"></span><br><span class="line">.align 4</span><br><span class="line">lidt_opcode:</span><br><span class="line">    .word 256*8-1</span><br><span class="line">    .long idt</span><br><span class="line">lgdt_opcode:</span><br><span class="line">    .word (end_gdt-gdt)-1</span><br><span class="line">    .long gdt</span><br><span class="line"></span><br><span class="line">.align 8</span><br><span class="line">idt:    .fill 256,8,0</span><br><span class="line"></span><br><span class="line">gdt:    .quad 0x0000000000000000</span><br><span class="line">        .quad 0x00c09a00000007ff</span><br><span class="line">        .quad 0x00c09200000007ff</span><br><span class="line">        .quad 0x00c0920b80000002</span><br><span class="line">        .word 0x68,tss0,0xe900,0x0</span><br><span class="line">        .word 0x40,ldt0,0xe200,0x0</span><br><span class="line">        .word 0x68,tss1,0xe900,0x0</span><br><span class="line">        .word 0x40,ldt1,0xe200,0x0</span><br><span class="line">end_gdt:</span><br><span class="line">        .fill 128,4,0</span><br><span class="line">init_stack:</span><br><span class="line">    .long init_stack</span><br><span class="line">    .word 0x0010</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.align 8</span><br><span class="line">ldt0:   .quad 0x0000000000000000</span><br><span class="line">        .quad 0x00c0fa00000003ff</span><br><span class="line">        .quad 0x00c0f200000003ff</span><br><span class="line"></span><br><span class="line">tss0:   .long 0</span><br><span class="line">        .long krn_stk0, 0x10</span><br><span class="line">        .long 0,0,0,0,0</span><br><span class="line">        .long 0,0,0,0,0</span><br><span class="line">        .long 0,0,0,0,0</span><br><span class="line">        .long 0,0,0,0,0,0</span><br><span class="line">        .long LDT0_SEL,0x8000000</span><br><span class="line"></span><br><span class="line">        .fill 128,4,0</span><br><span class="line">krn_stk0:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.align 8</span><br><span class="line">ldt1:   .quad 0x0000000000000000</span><br><span class="line">        .quad 0x00c0fa00000003ff</span><br><span class="line">        .quad 0x00c0f200000003ff</span><br><span class="line"></span><br><span class="line">tss1:   .long 0</span><br><span class="line">        .long krn_stk1,0x10</span><br><span class="line">        .long 0,0,0,0,0</span><br><span class="line">        .long task1,0x200</span><br><span class="line">        .long 0,0,0,0</span><br><span class="line">        .long usr_stk1,0,0,0</span><br><span class="line">        .long 0x17,0x0f,0x17,0x17,0x17,0x17</span><br><span class="line">        .long LDT1_SEL,0x8000000</span><br><span class="line"></span><br><span class="line">        .fill 128,4,0</span><br><span class="line">krn_stk1:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">task0:</span><br><span class="line">    movl $0x17,%eax</span><br><span class="line">    movw %ax,%ds</span><br><span class="line">    mov $65,%al</span><br><span class="line">    int $0x80</span><br><span class="line">    movl $0xfff,%ecx</span><br><span class="line">1:  loop 1b</span><br><span class="line">    jmp task0</span><br><span class="line">task1:</span><br><span class="line">    mov $66,%al</span><br><span class="line">    int $0x80</span><br><span class="line">    movl $0xfff,%ecx</span><br><span class="line">1:  loop 1b</span><br><span class="line">    jmp task1</span><br><span class="line"></span><br><span class="line">    .fill 128,4,0</span><br><span class="line">usr_stk1:</span><br></pre></td></tr></table></figure></p><p>上面的这个程序内容不再详述，想了解细节请参考 《Linux 内核完全注释》</p><p>下面提供编译 <code>boot.s</code> 以及 <code>head.s</code> 的可用 Makefile</p><p>首先描述一下额外的工具版本</p><ul><li>GNU as : GNU assembler version 2.26.1 </li><li>GNU ld : GNU ld 2.26.1<br>其它内容详见 <a href="https://dormouse-none.github.io/2018-08-19-understand-Kernel-0/">理解 Linux Kernel (0)</a></li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Makefile for the simple example kernel.</span></span><br><span class="line">AS86=as86 -0 -a</span><br><span class="line">LD86=ld86 -0</span><br><span class="line">AS=as</span><br><span class="line">ASFLAGS =-32</span><br><span class="line">LD=ld</span><br><span class="line">LDFLAGS=-s -x -M -m elf_i386 -e startup_32 -Ttext 0x0</span><br><span class="line"></span><br><span class="line"><span class="section">all:Image</span></span><br><span class="line"></span><br><span class="line"><span class="section">Image: boot system</span></span><br><span class="line">dd bs=32 if=boot of=Image skip=1</span><br><span class="line">dd bs=512 if=system of=Image skip=8 seek=1</span><br><span class="line">sync</span><br><span class="line"></span><br><span class="line"><span class="section">disk: Image</span></span><br><span class="line">dd bs=8192 if=Image of=/dev/fd0</span><br><span class="line">sync;sync;sync</span><br><span class="line"></span><br><span class="line"><span class="section">head.o: </span></span><br><span class="line"><span class="variable">$(AS)</span> <span class="variable">$(ASFLAGS)</span> -o head.o head.s</span><br><span class="line"></span><br><span class="line"><span class="section">system:head.o </span></span><br><span class="line"><span class="variable">$(LD)</span> <span class="variable">$(LDFLAGS)</span> head.o  -o system &gt; System.map</span><br><span class="line"></span><br><span class="line"><span class="section">boot:boot.s</span></span><br><span class="line"><span class="variable">$(AS86)</span> -o boot.o boot.s</span><br><span class="line"><span class="variable">$(LD86)</span> -s -o boot boot.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f Image System.map core boot *.o system</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>想了解更多细节的请自行实操查看吧!</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fun1fvafhwg30k40d4x6p.gif" alt=""></p><h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><p><a href="https://raw.githubusercontent.com/DorMOUSE-None/Repo/master/understand-kernel-2.zip" target="_blank" rel="noopener">程序源码</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;《只是为了好玩》书中，林纳斯描述过他最早的试验性程序就是执行两个不同的任务（一个不断输出A，另一个输出B），同时不断地让 CPU 在两个任务间做切换。结合《Linux 内核完全注释》提供的一个多任务切换示例程序，本篇将就多任务切换程序的执行流程进行详述，并提供当下汇编工具下的适配。&lt;/p&gt;
&lt;p&gt;关于运行环境的说明，欢迎参考 &lt;a href=&quot;https://www.ffutop.com/2018-08-19-understand-Kernel-1/#Bochs-%E4%BB%BF%E7%9C%9F%E5%99%A8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Bochs 仿真器使用简介&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://DorMOUSE-None.github.io/tags/Linux/"/>
    
      <category term="Kernel" scheme="https://DorMOUSE-None.github.io/tags/Kernel/"/>
    
      <category term="Multi-Task" scheme="https://DorMOUSE-None.github.io/tags/Multi-Task/"/>
    
  </entry>
  
  <entry>
    <title>理解 Linux Kernel (1) - BIOS</title>
    <link href="https://DorMOUSE-None.github.io/2018-08-19-understand-Kernel-1/"/>
    <id>https://DorMOUSE-None.github.io/2018-08-19-understand-Kernel-1/</id>
    <published>2018-08-18T16:00:00.000Z</published>
    <updated>2019-04-21T04:36:13.743Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在<a href="https://www.ffutop.com/2018-08-19-understand-Kernel-0/" target="_blank" rel="noopener">概述</a>，我已经介绍过《理解 Linux Kernel》系列文章的写作原因。我不能担保我所进行的所有试验性操作都是对的，但至少操作我的环境下成功地运行了，并帮助我触及我始终敬畏的<strong>硬件&amp;OS</strong></p><p>《Linux 内核完全注释》第三章——内核编程语言和环境，描述了用 as86 汇编语言构建 boot 引导程序，在 Bochs 仿真器成功模拟开机运行，最终输出 <em>Loading System…</em>。这就是本篇所要尝试的核心实验。之所以在已经有资料的基础上再写一遍，是书中缺失了仿真器模拟的环节。</p><a id="more"></a><h2 id="Bochs-仿真器"><a href="#Bochs-仿真器" class="headerlink" title="Bochs 仿真器"></a>Bochs 仿真器</h2><p><a href="http://bochs.sourceforge.net/" target="_blank" rel="noopener">Bochs 官网</a></p><p><a href="https://sourceforge.net/projects/bochs/files/" target="_blank" rel="noopener">Bochs 下载链</a></p><p>用 Bochs 仿真器跑 0.11 版本内核绝对是一个明智的选择，实践出真知放在这里绝对不会错。但说实话这一周都差不多要被 Bochs 折腾死，用源码进行编译出现各种各样的问题。(我猜新版本根本就没考虑对 macOS 做兼容)</p><p>最后，不得不使用经编译后的二进制分发版。 <code>brew install bochs</code> 当然了，反正也能用，就不纠结非得自己编译了。(如果哪位能成功编译个 macOS 可用的应用，希望能把踩得坑整理整理，供后来者参考)</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── CHANGES</span><br><span class="line">├── COPYING</span><br><span class="line">├── INSTALL_RECEIPT.json</span><br><span class="line">├── LICENSE</span><br><span class="line">├── README</span><br><span class="line">├── TODO</span><br><span class="line">├── bin</span><br><span class="line">│   ├── bochs                           // bochs 可执行文件</span><br><span class="line">│   └── bximage                         // 制作磁盘映像文件的工具</span><br><span class="line">├── lib                                 // 动态库目录</span><br><span class="line">│   └── bochs</span><br><span class="line">│       └── plugins</span><br><span class="line">│           ├── libbx_acpi.0.0.0.so</span><br><span class="line">│           ├── ... 略</span><br><span class="line">│           └── libbx_vga.so -&gt; libbx_vga.0.0.0.so</span><br><span class="line">└── share                               // 与体系结构无关的文件放在此目录下</span><br><span class="line">    ├── bochs</span><br><span class="line">    │   ├── BIOS-bochs-latest</span><br><span class="line">    │   ├── BIOS-bochs-legacy</span><br><span class="line">    │   ├── SeaBIOS-README</span><br><span class="line">    │   ├── VGABIOS-elpin-2.40</span><br><span class="line">    │   ├── VGABIOS-elpin-LICENSE</span><br><span class="line">    │   ├── VGABIOS-lgpl-README</span><br><span class="line">    │   ├── VGABIOS-lgpl-latest</span><br><span class="line">    │   ├── VGABIOS-lgpl-latest-cirrus</span><br><span class="line">    │   ├── VGABIOS-lgpl-latest-cirrus-debug</span><br><span class="line">    │   ├── VGABIOS-lgpl-latest-debug</span><br><span class="line">    │   ├── bios.bin-1.7.5</span><br><span class="line">    │   └── keymaps</span><br><span class="line">    │       ├── sdl-pc-us.map</span><br><span class="line">    │       ├── ... 略</span><br><span class="line">    │       └── x11-pc-us.map</span><br><span class="line">    ├── doc</span><br><span class="line">    │   └── bochs</span><br><span class="line">    │       ├── CHANGES</span><br><span class="line">    │       ├── COPYING</span><br><span class="line">    │       ├── LICENSE</span><br><span class="line">    │       ├── README</span><br><span class="line">    │       ├── TODO</span><br><span class="line">    │       ├── bochsrc-sample.txt      // bochsrc 配置文件的示例样板</span><br><span class="line">    │       └── slirp.conf</span><br><span class="line">    └── man</span><br><span class="line">        ├── man1</span><br><span class="line">        │   ├── bochs-dlx.1.gz</span><br><span class="line">        │   ├── bochs.1.gz</span><br><span class="line">        │   └── bximage.1.gz</span><br><span class="line">        └── man5</span><br><span class="line">            └── bochsrc.5.gz</span><br></pre></td></tr></table></figure><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>Bochs 下载链提供了 Bochs 不同版本的源码的下载，同时也提供了一些可用的磁盘映像文件(都是一些已经经过处理，可用使用进行仿真运行的 OS )</p><p>说实话，这是绝对有必要进行的一步，不仅仅是了解配置文件 bochsrc 的配置方式，更可用借此了解一下仿真器的使用方式。(在启动系统上，我也被坑了一天，后面细说)</p><p>首先，这里演示的将是 DLX Linux 。</p><ol><li><p>下载，解压，进入目录。</p></li><li><p>目录下文件如下</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── bochsrc.txt         // bochs 启动时将默认通过这个文件读取仿真器配置</span><br><span class="line">├── hd10meg.img         // 磁盘映像文件</span><br><span class="line">├── readme.txt</span><br><span class="line">└── testform.txt</span><br></pre></td></tr></table></figure><ol start="3"><li>启动仿真器</li></ol><p>在 DLX Linux 目录下键入命令 <code>bochs</code>, 观察到命令行输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">========================================================================</span><br><span class="line">                       Bochs x86 Emulator 2.6.9</span><br><span class="line">               Built from SVN snapshot on April 9, 2017</span><br><span class="line">                  Compiled on May  2 2018 at 13:26:32</span><br><span class="line">========================================================================</span><br><span class="line">00000000000i[      ] LTDL_LIBRARY_PATH not set. using compile time default &apos;/usr/local/Cellar/bochs/2.6.9_2/lib/bochs/plugins&apos;</span><br><span class="line">00000000000i[      ] BXSHARE not set. using compile time default &apos;/usr/local/Cellar/bochs/2.6.9_2/share/bochs&apos;</span><br><span class="line">00000000000i[      ] lt_dlhandle is 0x7fef2252a500</span><br><span class="line">00000000000i[PLUGIN] loaded plugin libbx_usb_common.so</span><br><span class="line">00000000000i[      ] lt_dlhandle is 0x7fef2252a8a0</span><br><span class="line">00000000000i[PLUGIN] loaded plugin libbx_unmapped.so</span><br><span class="line">00000000000i[      ] lt_dlhandle is 0x7fef2252ad00</span><br><span class="line">00000000000i[PLUGIN] loaded plugin libbx_biosdev.so</span><br><span class="line">00000000000i[      ] lt_dlhandle is 0x7fef2252b1e0</span><br><span class="line">00000000000i[PLUGIN] loaded plugin libbx_speaker.so</span><br><span class="line">00000000000i[      ] lt_dlhandle is 0x7fef2252ba50</span><br><span class="line">00000000000i[PLUGIN] loaded plugin libbx_extfpuirq.so</span><br><span class="line">00000000000i[      ] lt_dlhandle is 0x7fef2252be70</span><br><span class="line">00000000000i[PLUGIN] loaded plugin libbx_parallel.so</span><br><span class="line">00000000000i[      ] lt_dlhandle is 0x7fef238013c0</span><br><span class="line">00000000000i[PLUGIN] loaded plugin libbx_serial.so</span><br><span class="line">00000000000i[      ] lt_dlhandle is 0x7fef22706cd0</span><br><span class="line">00000000000i[PLUGIN] loaded plugin libbx_iodebug.so</span><br><span class="line">00000000000i[      ] reading configuration from bochsrc.txt</span><br><span class="line">------------------------------</span><br><span class="line">Bochs Configuration: Main Menu</span><br><span class="line">------------------------------</span><br><span class="line"></span><br><span class="line">This is the Bochs Configuration Interface, where you can describe the</span><br><span class="line">machine that you want to simulate.  Bochs has already searched for a</span><br><span class="line">configuration file (typically called bochsrc.txt) and loaded it if it</span><br><span class="line">could be found.  When you are satisfied with the configuration, go</span><br><span class="line">ahead and start the simulation.</span><br><span class="line"></span><br><span class="line">You can also start bochs with the -q option to skip these menus.</span><br><span class="line"></span><br><span class="line">1. Restore factory default configuration</span><br><span class="line">2. Read options from...</span><br><span class="line">3. Edit options</span><br><span class="line">4. Save options to...</span><br><span class="line">5. Restore the Bochs state from...</span><br><span class="line">6. Begin simulation</span><br><span class="line">7. Quit now</span><br><span class="line"></span><br><span class="line">Please choose one: [6]</span><br></pre></td></tr></table></figure><p>bochs 默认读取当前目录下 <code>bochsrc.txt</code> 文件，因此不需要其他配置。</p><p>选择 6 或者直接 <em>回车</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00000000000i[      ] lt_dlhandle is 0x7fef22707270</span><br><span class="line">00000000000i[PLUGIN] loaded plugin libbx_sdl2.so</span><br><span class="line">00000000000i[      ] installing sdl2 module as the Bochs GUI</span><br><span class="line">00000000000i[SDL2  ] maximum host resolution: x=2880 y=1800</span><br><span class="line">00000000000i[      ] using log file bochsout.txt</span><br><span class="line">Next at t=0</span><br><span class="line">(0) [0x0000fffffff0] f000:fff0 (unk. ctxt): jmpf 0xf000:e05b          ; ea5be000f0</span><br><span class="line">&lt;bochs:1&gt;</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fuevtktuh0j30zc0tcwfd.jpg" alt=""></p><p>终端出现更多输出，同时 Bochs 开启了一个可视化终端(当然，现在还没有任何内容)。</p><p>在这儿被坑了好久。本来以为 Bochs 会直接执行 BIOS 指令，启动操作系统，但是自始至终，停在这里就没动过…</p><p>这边是由于 Bochs 本身是支持调试的(T_T，见鬼)，就像是 GDB 和 LLDB 一样，进入调试后，需要指令 <code>c</code> (continue) 来继续执行(当然，还有其它调试命令)</p><ol start="4"><li>键入 <code>c</code> </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bochs:1&gt; c</span><br></pre></td></tr></table></figure><p>仿真器开始引导程序的加载</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fuew9zoocuj313c0pstaw.jpg" alt=""></p><p>OS Kernel 启动，等待用户登录 (默认的用户是 root , 没有密码)。<br>之后就和普通的 Linux 机器类似，不过支持的命令比较少。毕竟是一个精简后的系统。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fuewamqzm6j313q0pqjtw.jpg" alt=""></p><ol start="5"><li>关机</li></ol><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fuewi9wjawj313q0q2gnc.jpg" alt=""></p><p>仿真器仿真了许多实体机案件，右上角最后一个就是关机键</p><h3 id="Docker-容器中运行-Ubuntu"><a href="#Docker-容器中运行-Ubuntu" class="headerlink" title="Docker 容器中运行 Ubuntu"></a>Docker 容器中运行 Ubuntu</h3><p>这部分不详述，作为一个热门的技术，这方面的资料很多。Ubuntu 系统只是为了来执行一些 macOS 上没有的命令的(比如 <code>as86</code>, <code>ld86</code>)</p><p>简述两个 docker 容器和宿主机间复制文件的命令 </p><p>在宿主机下执行命令:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-</span><br><span class="line">docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH [flags]</span><br></pre></td></tr></table></figure><p>例如:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker cp linux:/root/hello.c ./hello.c         <span class="comment"># 这里 linux 是 docker 容器名</span></span><br><span class="line">docker cp 92dfc8ad70e1:/root/hello.c ./hello.c  <span class="comment"># 这里 92dfc8ad70e1 是 docker 容器 ID</span></span><br></pre></td></tr></table></figure><h2 id="boot-s-汇编程序"><a href="#boot-s-汇编程序" class="headerlink" title="boot.s 汇编程序"></a>boot.s 汇编程序</h2><p>这里没法多说，都是书中的源码，只是供未读过书的读者参考，特意摘录了下来(不过，就不加注释了)</p><p>boot.s 源代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">.global begtext, begdata, begbss, endtext, enddata, endbss</span><br><span class="line">.text</span><br><span class="line">begtext:</span><br><span class="line">.data</span><br><span class="line">begdata:</span><br><span class="line">.bss</span><br><span class="line">begbss:</span><br><span class="line">.text</span><br><span class="line">BOOTSEG=0x07c0</span><br><span class="line"></span><br><span class="line">entry start</span><br><span class="line">start:</span><br><span class="line">    jmpi    go,BOOTSEG</span><br><span class="line">go: mov ax,cs</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov [msg+17],ah</span><br><span class="line">    mov cx,#20</span><br><span class="line">    mov dx,#0x1004</span><br><span class="line">    mov bx,#0x000c</span><br><span class="line">    mov bp,#msg</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line">loop1:  jmp loop1</span><br><span class="line">msg:    .ascii  &quot;Loading System...&quot;</span><br><span class="line">        .byte   13,10</span><br><span class="line">.org    510</span><br><span class="line">.word   0xAA55</span><br><span class="line">.text</span><br><span class="line">endtext:</span><br><span class="line">.data</span><br><span class="line">enddata:</span><br><span class="line">.bss</span><br><span class="line">endbss:</span><br></pre></td></tr></table></figure><p>这段程序的主要的执行流程将是:</p><ol><li>通过 BIOS 加载这段 boot 引导程序</li><li>红色字体打印 <em>Loading System…</em> 并响铃</li><li>指令自循环 (<code>loop1 jmp loop1</code>) ，将始终展示上述字样，并不接收命令</li></ol><p>下面就该把这个汇编程序 <em>编译 + 链接</em> 成 boot 引导程序。</p><p>虽然在 macOS 上确实找到了一个 as86 汇编器(来自 nasm 的一个编译选项，但我不知道为什么始终无法正常编译，也可能这个根本就不是我想要的)。</p><p>通过 docker 容器部署的 Ubuntu，可以很容易地得到一个 as86 汇编程序。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apt-get install bin86   <span class="comment"># as86, ld86 都在这个包里提供了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这句需要在宿主机上执行</span></span><br><span class="line">docker cp boot.s linux:/root/boot.s     <span class="comment"># 这里 linux 是我 docker 部署的 Ubuntu 的容器的名称。   如果之前 boot.s 在宿主机上，可以这样拷贝到容器中</span></span><br><span class="line"></span><br><span class="line">as86 -0 -a -o boot.o boot.s             <span class="comment"># 编译</span></span><br><span class="line"></span><br><span class="line">ld86 -0 -s -o execfile boot.o           <span class="comment"># 链接</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然，到这里为止，其实都可以理解成在将汇编代码编译链接成可执行程序 (和 boot 引导程序没有太大关系，唯一有关系的就是这段汇编语言是以引导为目的写的)</span></span><br><span class="line"></span><br><span class="line">dd bs=32 <span class="keyword">if</span>=execfile of=boot skip=1     <span class="comment"># 这里去掉可执行程序的前 32 字节，形成刚好 512 字节的 boot 引导程序</span></span><br></pre></td></tr></table></figure><h2 id="用仿真器启动引导程序"><a href="#用仿真器启动引导程序" class="headerlink" title="用仿真器启动引导程序"></a>用仿真器启动引导程序</h2><p>事实上，这部分内容，我始终没有搞清楚 <strong>磁盘映像文件</strong> 和 <strong>boot 引导程序</strong> 间的关系(当然还有 floppy 和 ata0~3)</p><p>在上一节成功拿到 <em>512B</em> 的 boot 引导程序之后，直接使用这个貌似我也运行成功了(根本就不需要创建磁盘映像文件并将引导程序写入映像文件中，不过，也许只是因为这个引导程序太简单了，根本就不需要其他程序的配合。它最后就是一个死循环 )</p><p>总之，先按照最简单的来吧。</p><p>把 boot 引导程序拷贝到宿主机上(貌似频繁地在两个OS上交互文件，这个很无奈，docker容器中的进程难以启动显示程序)</p><ol><li>在宿主机新建一个目录 <em>linux-boot</em></li><li>拷贝 boot 引导程序到宿主机上 <code>docker cp linux:/root/boot linux-boot/</code></li><li>在 <em>linux-boot</em> 下建立 bochsrc 文件(这将是整个仿真器的配置，用于模拟组装机器涉及的 CPU, 内存, BIOS, 显示器等)</li><li>这里使用的配置文件如下:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># You may now use double quotes around pathnames, in case</span><br><span class="line"># your pathname includes spaces.</span><br><span class="line"></span><br><span class="line">cpu: model=pentium, count=1, ips=50000000, reset_on_triple_fault=1, ignore_bad_msrs=1, msrs=&quot;msrs.def&quot;</span><br><span class="line">cpu: cpuid_limit_winnt=0</span><br><span class="line"></span><br><span class="line">memory: guest=512, host=256</span><br><span class="line"></span><br><span class="line">romimage: file=$BXSHARE/BIOS-bochs-legacy, options=fastboot     # BIOS 配置</span><br><span class="line"></span><br><span class="line">vgaromimage: file=$BXSHARE/VGABIOS-lgpl-latest</span><br><span class="line"></span><br><span class="line">mouse: enabled=0</span><br><span class="line"></span><br><span class="line">pci: enabled=1, chipset=i440fx</span><br><span class="line"></span><br><span class="line">private_colormap: enabled=0</span><br><span class="line"></span><br><span class="line">floppya: 1\_44=&quot;./boot&quot;, status=inserted         # 装载一个软盘 A ，这里用当前目录下的 boot (boot 引导程序，事实上书中说要用 .img 磁盘映像文件，但这里不影响实际效果)</span><br><span class="line"></span><br><span class="line">ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14</span><br><span class="line">ata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15</span><br><span class="line">ata2: enabled=0, ioaddr1=0x1e8, ioaddr2=0x3e0, irq=11</span><br><span class="line">ata3: enabled=0, ioaddr1=0x168, ioaddr2=0x360, irq=9</span><br><span class="line"></span><br><span class="line">boot: a                                         # 配置引导程序所在的磁盘</span><br><span class="line"></span><br><span class="line">floppy_bootsig_check: disabled=0</span><br><span class="line"></span><br><span class="line">log: bochsout.txt</span><br><span class="line"></span><br><span class="line">panic: action=ask</span><br><span class="line">error: action=report</span><br><span class="line">info: action=report</span><br><span class="line">debug: action=ignore, pci=report # report BX_DEBUG from module &apos;pci&apos;</span><br><span class="line"></span><br><span class="line">debugger_log: -</span><br><span class="line"></span><br><span class="line">parport1: enabled=1, file=&quot;parport.out&quot;</span><br><span class="line"></span><br><span class="line">speaker: enabled=1, mode=sound</span><br></pre></td></tr></table></figure><ol start="5"><li>当前目录 <em>linux-boot</em> 下，键入命令 <code>bochs</code></li><li>由于读取到 <em>bochsrc</em> 配置文件的存在，menu 的默认选项为 6 (开始模拟机器)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">You can also start bochs with the -q option to skip these menus.</span><br><span class="line"></span><br><span class="line">1. Restore factory default configuration</span><br><span class="line">2. Read options from...</span><br><span class="line">3. Edit options</span><br><span class="line">4. Save options to...</span><br><span class="line">5. Restore the Bochs state from...</span><br><span class="line">6. Begin simulation</span><br><span class="line">7. Quit now</span><br><span class="line"></span><br><span class="line">Please choose one: [6]</span><br></pre></td></tr></table></figure><ol start="7"><li>直接开始运行机器，键入命令 <code>c</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Please choose one: [6]</span><br><span class="line">00000000000i[      ] lt_dlhandle is 0x7f85d0405ff0</span><br><span class="line">00000000000i[PLUGIN] loaded plugin libbx_sdl2.so</span><br><span class="line">00000000000i[      ] installing sdl2 module as the Bochs GUI</span><br><span class="line">00000000000i[SDL2  ] maximum host resolution: x=2880 y=1800</span><br><span class="line">00000000000i[      ] using log file bochsout.txt</span><br><span class="line">Next at t=0</span><br><span class="line">(0) [0x0000fffffff0] f000:fff0 (unk. ctxt): jmpf 0xf000:e05b          ; ea5be000f0</span><br><span class="line">&lt;bochs:1&gt; c</span><br></pre></td></tr></table></figure><ol start="8"><li>观察仿真器的表现</li></ol><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fuf2kicsqyj313y0q0gn4.jpg" alt=""></p><p>Oh, YES! 成功输出了 <em>Loading System…</em> (不过响铃没有听到，可能与我没有配置 sound 有关)</p><ol start="9"><li>关机</li></ol><p>无需多言，右上角模拟的就是<strong>关机实体按键</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在&lt;a href=&quot;https://www.ffutop.com/2018-08-19-understand-Kernel-0/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;概述&lt;/a&gt;，我已经介绍过《理解 Linux Kernel》系列文章的写作原因。我不能担保我所进行的所有试验性操作都是对的，但至少操作我的环境下成功地运行了，并帮助我触及我始终敬畏的&lt;strong&gt;硬件&amp;amp;OS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;《Linux 内核完全注释》第三章——内核编程语言和环境，描述了用 as86 汇编语言构建 boot 引导程序，在 Bochs 仿真器成功模拟开机运行，最终输出 &lt;em&gt;Loading System…&lt;/em&gt;。这就是本篇所要尝试的核心实验。之所以在已经有资料的基础上再写一遍，是书中缺失了仿真器模拟的环节。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://DorMOUSE-None.github.io/tags/Linux/"/>
    
      <category term="Kernel" scheme="https://DorMOUSE-None.github.io/tags/Kernel/"/>
    
      <category term="BIOS" scheme="https://DorMOUSE-None.github.io/tags/BIOS/"/>
    
  </entry>
  
  <entry>
    <title>理解 Linux Kernel (0) - 概述</title>
    <link href="https://DorMOUSE-None.github.io/2018-08-19-understand-Kernel-0/"/>
    <id>https://DorMOUSE-None.github.io/2018-08-19-understand-Kernel-0/</id>
    <published>2018-08-18T16:00:00.000Z</published>
    <updated>2019-04-21T04:35:22.403Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>《理解Linux Kernel》系列最早开始于 2018 年中，当时我刚刚结束对 JVM (Java Virtual Machine, Java 虚拟机) <a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html" target="_blank" rel="noopener">ClassFile 文件格式</a>的学习。彼时，在<em>实现新编程语言</em>、<em>学习 Linux 内核实现</em>、<em>继续深入 JVM 源码</em>三个下一阶段的命题中，我选择了拥抱 Linux 源码。</p><p>时间过去了大半年，我已经简单地建立了对 Linux Kernel 的结构化认知。趁着现阶段有一些闲暇，整理过去的文章，以期删繁就简，并对错误的描述进行修正。</p><p>《理解 Linux Kernel》系列最早发布于<a href="https://www.ffutop.com/" target="_blank" rel="noopener">我的博客 (Utop’s Blog)</a>。由于这些文章的完成完全出于个人兴趣，对每个内核子系统的学习往往浅尝辄止，但我依旧认为这个系列对初学者来说是大有裨益的。</p><p>本系列对内核的学习完全建立在 0.11、2.6.24 两个版本源码的基础上。从 0.11 版本入门，学习硬件启动阶段进行的主要操作、任务调度、文件系统等早期版本已初现雏形的子系统；从 2.6.24 版本进阶，学习网络、内存管理等子系统的实现。在此强烈推荐，直接阅读源码对理解的帮助最为深远。请随时备上两个版本的源码，以备深入理解。</p><a id="more"></a><h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><p>=== 分割线 （以下待整理） ===</p><ul><li><a href="https://www.ffutop.com/2018-08-19-understand-Kernel-0/" target="_blank" rel="noopener">理解 Linux Kernel (0) - 概述</a></li><li><a href="https://www.ffutop.com/2018-08-19-understand-Kernel-1/" target="_blank" rel="noopener">理解 Linux Kernel (1) - BIOS</a></li><li><a href="https://www.ffutop.com/2018-08-26-understand-Kernel-2/" target="_blank" rel="noopener">理解 Linux Kernel (2) - 多任务切换</a></li><li><a href="https://www.ffutop.com/2018-10-06-understand-Kernel-3/" target="_blank" rel="noopener">理解 Linux Kernel (3) - 操作系统启动</a></li><li><a href="https://www.ffutop.com/2018-10-12-understand-Kernel-4/" target="_blank" rel="noopener">理解 Linux Kernel (4) - 任务调度</a></li><li><a href="https://www.ffutop.com/2018-10-14-understand-Kernel-5/" target="_blank" rel="noopener">理解 Linux Kernel (5) - 文件系统</a></li><li><a href="https://www.ffutop.com/2018-11-11-understand-Kernel-6/" target="_blank" rel="noopener">理解 Linux Kernel (6) - 文件操作（读、写）</a></li><li><a href="https://www.ffutop.com/2018-12-28-understand-Kernel-7/" target="_blank" rel="noopener">理解 Linux Kernel (7) - 字符设备</a></li><li><a href="https://www.ffutop.com/2019-01-15-understand-Kernel-8/" target="_blank" rel="noopener">理解 Linux Kernel (8) - 网络</a></li><li><a href="https://www.ffutop.com/2019-03-05-understand-Kernel-9/" target="_blank" rel="noopener">理解 Linux Kernel (9) - I/O 多路复用</a></li><li><a href="https://www.ffutop.com/2019-04-10-understand-Kernel-10/" target="_blank" rel="noopener">理解 Linux Kernel (10) - 执行的上下文</a></li></ul><p><em>以下是18年年中原文（稍作整理）</em></p><h2 id="开端"><a href="#开端" class="headerlink" title="开端"></a>开端</h2><p>刚刚结束 JVM ClassFile 文件格式的学习，见识了 JVM 对 CPU 架构的模拟：</p><ol><li>有限而统一的指令集（不超过 256 个，可以用 1 字节维护）</li><li>剔除寄存器概念而使用操作数栈作为替代</li><li>使用局部变量表来模拟任务栈</li><li>高度封装的成员变量和方法的寻址方式</li></ol><p>Java 虚拟机的机制相当简洁。就寄存器而言，就已经极大的简化了 CPU 复杂的结构。更遑论不同 CPU 架构带来的多套指令集的问题。</p><p>其实我本来是想要继续学习 Hotspot 虚拟机的实现。但是，混杂的代码(C++, Java, 平台相关各种实现)给我带来了很大的阅读障碍。最根本的，我甚至找不到一个入口作为整个学习计划的起点。<em>当然，也与我根本没仔细去看有关，笑:)</em>。</p><p>受老大推荐，我开始看《程序员的自我修养——链接、装载与库》一书。此书对 ELF 格式的介绍，对静态链接与动态链接的深入剖析都给了我深刻的印象，向我展示了 C 语言更深入的一面。但是，macOS 给我带来了比较大的客观阻碍（即使使用 Docker 容器得到了一个可用的 Linux 环境，但与直接建立在硬件上的系统还是有所区别）。同时，书中的部分内容上下文不一致，给阅读带来了障碍。总之，此书中的内容不适合我我这种初学者逐一进行书中所述的全部实验。</p><p>多重因素最终使我决定学习 Linux Kernel，希望对操作系统的理解能够帮助我建立对各种用户层面应用的画像。</p><h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><ol><li>Source Code of <a href="http://www.oldlinux.org/Linux.old/kernel/0.1x/linux-0.11/" target="_blank" rel="noopener">linux-v0.11</a> and <a href="https://mirrors.edge.kernel.org/pub/linux/kernel/v2.6/" target="_blank" rel="noopener">linux-2.6.24</a></li><li>《Linux 内核完全注释》</li><li>《深入 Linux 内核架构》</li><li>Bochs 仿真器</li><li><a href="http://vger.kernel.org/vger-lists.html" target="_blank" rel="noopener">内核邮件组</a></li></ol><h2 id="软硬件描述"><a href="#软硬件描述" class="headerlink" title="软硬件描述"></a>软硬件描述</h2><p>进行这方面的描述，是因为 Linux Kernel 将直接与底层硬件打交道(当然，这方面使用的 Bochs 仿真器)。<br>但是，准备诸如 .img (磁盘映像文件), 机器指令文件等都不得不借助于现有的平台。</p><ul><li>操作系统: macOS Mojave 10.14.4 , Ubuntu 18.04 （云主机）</li><li>仿真器  : Bochs 2.6.9_2 （macOS 与 Ubuntu 上相同）</li><li>更多    : 将直接在正文首次使用到时进行说明</li></ul><p><em>Read the Source Code. Have Fun.</em></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1]. 俞甲子. 程序员的自我修养[M]. 电子工业出版社, 2009.<br>[2]. 赵炯. Linux内核完全注释 内核版本0.11 V3.0[EB/OL]. <a href="http://www.oldlinux.org/" target="_blank" rel="noopener">http://www.oldlinux.org/</a>, 2007</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;《理解Linux Kernel》系列最早开始于 2018 年中，当时我刚刚结束对 JVM (Java Virtual Machine, Java 虚拟机) &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ClassFile 文件格式&lt;/a&gt;的学习。彼时，在&lt;em&gt;实现新编程语言&lt;/em&gt;、&lt;em&gt;学习 Linux 内核实现&lt;/em&gt;、&lt;em&gt;继续深入 JVM 源码&lt;/em&gt;三个下一阶段的命题中，我选择了拥抱 Linux 源码。&lt;/p&gt;
&lt;p&gt;时间过去了大半年，我已经简单地建立了对 Linux Kernel 的结构化认知。趁着现阶段有一些闲暇，整理过去的文章，以期删繁就简，并对错误的描述进行修正。&lt;/p&gt;
&lt;p&gt;《理解 Linux Kernel》系列最早发布于&lt;a href=&quot;https://www.ffutop.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的博客 (Utop’s Blog)&lt;/a&gt;。由于这些文章的完成完全出于个人兴趣，对每个内核子系统的学习往往浅尝辄止，但我依旧认为这个系列对初学者来说是大有裨益的。&lt;/p&gt;
&lt;p&gt;本系列对内核的学习完全建立在 0.11、2.6.24 两个版本源码的基础上。从 0.11 版本入门，学习硬件启动阶段进行的主要操作、任务调度、文件系统等早期版本已初现雏形的子系统；从 2.6.24 版本进阶，学习网络、内存管理等子系统的实现。在此强烈推荐，直接阅读源码对理解的帮助最为深远。请随时备上两个版本的源码，以备深入理解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://DorMOUSE-None.github.io/tags/Linux/"/>
    
      <category term="Kernel" scheme="https://DorMOUSE-None.github.io/tags/Kernel/"/>
    
  </entry>
  
</feed>
