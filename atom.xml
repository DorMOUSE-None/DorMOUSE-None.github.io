<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Utop&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://utop.xin/"/>
  <updated>2018-06-12T12:49:33.655Z</updated>
  <id>http://utop.xin/</id>
  
  <author>
    <name>Utop</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring JDBC 源码学习</title>
    <link href="http://utop.xin/2018-06-12-Spring-JDBC-Source-Code-Reading/"/>
    <id>http://utop.xin/2018-06-12-Spring-JDBC-Source-Code-Reading/</id>
    <published>2018-06-12T12:49:33.655Z</published>
    <updated>2018-06-12T12:49:33.655Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure><h1 id="Spring-JDBC-源码学习"><a href="#Spring-JDBC-源码学习" class="headerlink" title="Spring JDBC 源码学习"></a>Spring JDBC 源码学习</h1><p>[TOC]</p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>在学习 Spring-JDBC 之前，我们有必要从 Java 原生提供的 JDBC 开始，对 JDBC 操作的一整套完整的流程有一个清晰的概念。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * copied from https://www.tutorialspoint.com/jdbc/jdbc-sample-code.htm</span></span><br><span class="line"><span class="comment"> * updated by DorMOUSENone</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//STEP 1. 引入必须的包</span></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line"><span class="comment">// JDBC 驱动名 与 DB URL </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String JDBC_DRIVER = <span class="string">"com.mysql.jdbc.Driver"</span>;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DB_URL = <span class="string">"jdbc:mysql://&lt;host&gt;:&lt;port&gt;/&lt;dbName&gt;"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数据库登录验证 (用户名、密码等)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String USER = <span class="string">"username"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String PASS = <span class="string">"password"</span>;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">Statement stmt = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//STEP 2: 注册驱动(注册到驱动管理器 DriverManager 类中)</span></span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//STEP 3: 创建一个连接</span></span><br><span class="line">          System.out.println(<span class="string">"Connecting to database..."</span>);</span><br><span class="line">          conn = DriverManager.getConnection(DB_URL,USER,PASS);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//STEP 4: 执行一个查询</span></span><br><span class="line">          System.out.println(<span class="string">"Creating statement..."</span>);</span><br><span class="line">          stmt = conn.createStatement();</span><br><span class="line">          String sql;</span><br><span class="line">          sql = <span class="string">"SELECT id, first, last, age FROM Employees"</span>;</span><br><span class="line">          ResultSet rs = stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//STEP 5: 将结果从结果集(ResultSet)中取出</span></span><br><span class="line">          <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">             <span class="comment">//根据列名逐一取出数据</span></span><br><span class="line">             <span class="keyword">int</span> id  = rs.getInt(<span class="string">"id"</span>);</span><br><span class="line">             <span class="keyword">int</span> age = rs.getInt(<span class="string">"age"</span>);</span><br><span class="line">             String first = rs.getString(<span class="string">"first"</span>);</span><br><span class="line">             String last = rs.getString(<span class="string">"last"</span>);</span><br><span class="line"></span><br><span class="line">             <span class="comment">//展示结果</span></span><br><span class="line">             System.out.print(<span class="string">"ID: "</span> + id);</span><br><span class="line">             System.out.print(<span class="string">", Age: "</span> + age);</span><br><span class="line">             System.out.print(<span class="string">", First: "</span> + first);</span><br><span class="line">             System.out.println(<span class="string">", Last: "</span> + last);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//STEP 6: 清理环境</span></span><br><span class="line">          rs.close();</span><br><span class="line">          stmt.close();</span><br><span class="line">          conn.close();</span><br><span class="line">       &#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">          <span class="comment">//处理 JDBC 错误</span></span><br><span class="line">          se.printStackTrace();</span><br><span class="line">       &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">          <span class="comment">//处理 Class.forName() 引起的错误</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">       &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">          <span class="comment">// finally 代码库来关闭资源</span></span><br><span class="line">          <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(stmt!=<span class="keyword">null</span>)</span><br><span class="line">                stmt.close();</span><br><span class="line">          &#125;<span class="keyword">catch</span>(SQLException se2)&#123;</span><br><span class="line">          &#125;<span class="comment">// 不做任何处理</span></span><br><span class="line">          <span class="keyword">try</span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(conn!=<span class="keyword">null</span>)</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">               se.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">"Goodbye!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的通用 JDBC 代码可以看到，利用 Java 原生提供的 java.sql.* 包可以完成注册驱动，创建连接，执行查询，处理结果等一系列一整套操作。</p><p>而 Spring-JDBC 对于 Java 原生提供的 JDBC ，对一系列数据及操作进行了整合：</p><ol><li>实现了 DataSource 接口，用于整合数据源配置，将各种零散的属性值（诸如 URL、用户名、 密码等）整合成完整的一个对象，便于重用；也实现了 getConnection(…) 接口，便于直接通过 DataSource 获取连接。</li><li>对执行查询的流程进行了封装。</li><li>对结果集的处理提供了多种接口，针对不同的应用场景可自由选择所必须的实现类。例如直接通过 JDBC 获得 Bean ，而无需如上例 39-42 行所示，逐一编码进行提取。</li></ol><p>本节提供对《Spring-JDBC 源码学习》完整学习过程的一个梳理：</p><ol><li><a href="http://blog.csdn.net/dormousenone/article/details/79035440" target="_blank" rel="noopener">JdbcTemplate</a> 一节作为学习 Spring-jdbc 的切入点，是 org.springframework.jdbc.core 包中的核心类，是一个提供不同场景下数据库操作的模板类。主要描述其持有的属性 DataSource 等以及其实现的方法。</li><li><a href="http://blog.csdn.net/dormousenone/article/details/79037012" target="_blank" rel="noopener">DataSource</a> 一节承接 JdbcTemplate 一节，提供 Spring-jdbc 对数据源的一个包装与应用。同时描述其核心方法 getConnection(…) 的实现。</li><li><a href="http://blog.csdn.net/dormousenone/article/details/79042212" target="_blank" rel="noopener">DriverManager</a> 描述其对不同数据库供应商提供的驱动的管理与使用方法。同时简单描述通过具体驱动获得一个连接的实现。</li><li><a href="http://blog.csdn.net/dormousenone/article/details/79046865" target="_blank" rel="noopener">PreparedStatement &amp; CallableStatement</a> 一节主要表述 Spring-jdbc 如何对执行查询的流程进行了封装。特别是对于 PreparedStatement 与 CallableStatement 这类预置可变 SQL 语句，在执行前必须对其中可变参数进行补全的 Statement 。</li><li><a href="http://blog.csdn.net/dormousenone/article/details/79062275" target="_blank" rel="noopener">ResultSet</a> 描述 Spring-jdbc 如何对结果集进行处理，提供了多种不同的接口实现不同的处理逻辑。这种封装后的操作可以极大地简化直接使用 Java 原生 JDBC 所必须的硬编码提取数据的问题。</li></ol><h2 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h2><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fn90ghu9ufj30ki0jm75t.jpg" alt=""></p><p>JdbcTemplate 类作为 org.springframework.core 包下的核心类，对 Java 实现的 JDBC 进行了一定程度的封装，可以简化 JDBC 的使用，同时避免许多常见的错误。由该类来执行 JDBC 工作流，应用程序只需要提供 SQL 语句就可以获得 DB 执行结果（😀，当然实际操作上没有描述的这么简单）。</p><p><strong>使用 JdbcTemplate 类只需要实现两个回调接口 PreparedStatementCreator (创建一个 PreparedStatement，给定连接，提供 SQL 语句以及必要的参数), ResultSetExtractor (用于花式获取结果集)。当然，不实现上述两个接口也可以进行简单的数据库操作，比如只通过 JdbcTemplate 获取一个连接(Connection) 或者执行一个静态 SQL Update。</strong></p><p><em>看不懂无所谓，先继续向下看，会做更详细的讲解。</em></p><h3 id="JdbcAccessor"><a href="#JdbcAccessor" class="headerlink" title="JdbcAccessor"></a>JdbcAccessor</h3><p>首先了解 JdbcTemplate 的实现，JdbcTemplate 继承了 JdbcAccessor 抽象类，该抽象类有两个主要属性—— <strong>DataSource dataSource</strong> &amp; <strong>SQLExceptionTranslator exceptionTranslator</strong> ，以及一个懒加载标识符 <strong>lazyInit</strong> 。</p><p>其中，</p><ul><li>DataSource 可以认为是一个存储有与数据库相关的属性实例，主要方法包括 <code>Connection getConnection()</code> &amp; <code>Connection getConnection(String username, String password)</code> 。</li><li>SQLExceptionTranslator 利用策略模式将 Java 定义的 SQLException 转换成 Spring 声明的 DataAccessException。</li></ul><p>JdbcAccessor 实现的 InitializingBean 接口，InitializingBean 接口为 Bean 提供了一个初始化实例的方法 —— afterPropertiesSet() 方法，凡是继承该接口的类，一般都在类构造方法中执行该方法。同样的，声明初始化实例调用的方法还可采用 <code>&lt;bean id=&quot;&quot; class=&quot;&quot; init-method=&quot;myInitMethod&quot;/&gt;</code> 在初始化 bean 时执行 myInitMethod() 方法。具体执行顺序为 ：</p><ol><li>bean 的属性注入</li><li>调用 afterPropertiesSet() 方法</li><li>执行 myInitMethod() 方法</li></ol><p>此处继承该接口是为了实现 DataSource 验证以及 SQLExceptionTranslator 的懒加载 OR NOT 的选择。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (getDataSource() == <span class="keyword">null</span>) &#123;<span class="comment">// 判断是否注入了 DataSource</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Property 'dataSource' is required"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!isLazyInit()) &#123;<span class="comment">// 根据懒加载标识符选择执行与否</span></span><br><span class="line">getExceptionTranslator();<span class="comment">// 获取一个 SQLExceptionTranslator 实例</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法在 BeanFactory 完成该 bean 的依赖注入后执行，将首先判断 DataSource 是否已经被注入，再根据懒加载标识符来决定是否实例化一个 SQLExceptionTranslator 。</p><h3 id="JdbcOperations"><a href="#JdbcOperations" class="headerlink" title="JdbcOperations"></a>JdbcOperations</h3><p>同时，JdbcTemplate 类实现了 JdbcOperations 接口，该接口定义了基本的 JDBC 操作。基本方法如下：</p><ol><li><code>&lt;T&gt; T execute(ConnectionCallback&lt;T&gt; action);</code></li><li><code>&lt;T&gt; T execute(StatementCallback&lt;T&gt; action);</code></li><li><code>&lt;T&gt; T execute(PreparedStatementCreator psc, PreparedStatementCallback&lt;T&gt; action);</code></li><li><code>&lt;T&gt; T execute(CallableStatementCreator csc, CallableStatementCallback&lt;T&gt; action);</code></li></ol><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fncp2ncqd6j31j00au0uv.jpg" alt=""></p><p>其它的 execute(…) , query(…), update(…) 等最终都将调用上述 4 种方法其一来完成目的。</p><p>详细观察上述方法的入参， ConnectionCallback, StatementCallback, PreparedStatementCallback 和 CallableStatementCallback 四个 Callback 接口，分别都是函数式接口，其中的唯一方法 doInXXX() 将在 execute() 中被调用，以此实现获得 ResultSet 并返回 Result 。execute 中调用 doInXXX() 的通用代码如下 （以 Statement 为例）：</p><p><em>对于不理解<strong>回调</strong>的同学，请自行了解概念</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(StatementCallback&lt;T&gt; action)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line"><span class="comment">// 通过工具类 DataSourceUtils 获取一个连接</span></span><br><span class="line">  Connection con = DataSourceUtils.getConnection(obtainDataSource());</span><br><span class="line">  <span class="comment">// 一个 Statement 空实例，PreparedStatement, CallableStatement 类似</span></span><br><span class="line">Statement stmt = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">stmt = con.createStatement();<span class="comment">// 通过连接(Connection)获取一个 Statement</span></span><br><span class="line">applyStatementSettings(stmt);<span class="comment">// 配置 Statement 参数</span></span><br><span class="line">      <span class="comment">// 回调执行 doInXXX() 方法, 并获得 result</span></span><br><span class="line">T result = action.doInStatement(stmt);</span><br><span class="line">handleWarnings(stmt);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line"><span class="comment">// Release Connection early, to avoid potential connection pool deadlock</span></span><br><span class="line"><span class="comment">// in the case when the exception translator hasn't been initialized yet.</span></span><br><span class="line">String sql = getSql(action);</span><br><span class="line">JdbcUtils.closeStatement(stmt);</span><br><span class="line">stmt = <span class="keyword">null</span>;</span><br><span class="line">DataSourceUtils.releaseConnection(con, getDataSource());</span><br><span class="line">con = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">throw</span> translateException(<span class="string">"StatementCallback"</span>, sql, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">JdbcUtils.closeStatement(stmt);</span><br><span class="line">DataSourceUtils.releaseConnection(con, getDataSource());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 Statement, PreparedStatement, CallableStatement 的区别，首先下图表现了三个接口的继承关系。</p><ul><li>Statement 可以支持静态 SQL 语句</li><li>PreparedStatement 支持可变参数的 SQL 语句</li><li>CallableStatement 支持可变参数的 SQL 语句，并且支持定制 DB 的输出结果</li></ul><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fncpaec17yj30ew0hcdh7.jpg" alt=""></p><h2 id="DataSource"><a href="#DataSource" class="headerlink" title="DataSource"></a>DataSource</h2><p>上一节在粗略地了解了 JdbcTemplate 提供的方法之后，下面先来对 DataSource 做一点了解。</p><h3 id="Java-提供的-DataSource-定义"><a href="#Java-提供的-DataSource-定义" class="headerlink" title="Java 提供的 DataSource 定义"></a>Java 提供的 DataSource 定义</h3><p>DataSource 是 Java 核心库提供的接口。位于 javax.sql package 下。</p><p>DataSource 接口可以被视作是一个提供物理 DB 实例连接(Connection) 的工厂，通过 DataSource 持有的各种属性（包括 DB Url, Username, Password 等）来获取一个连接(Connection) 。DataSource 接口有三种不同的实现方案：</p><ol><li>最基本的实现——生产一个标准连接(Connection) 对象</li><li>连接池方案——生产会被自动添加到连接池的对象</li><li>分布式事物实现——生产一个可以支持分布式事物，并默认被添加到连接池的连接对象</li></ol><p>包括两个对外提供连接(Connection) 对象的方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="function">Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure><p>其父接口 CommonDataSource 提供设置/获取 LogWriter，登录 DB 超时时间和获取父 Logger 的方法。</p><h3 id="Spring-JDBC-扩展的-DataSource-定义"><a href="#Spring-JDBC-扩展的-DataSource-定义" class="headerlink" title="Spring-JDBC 扩展的 DataSource 定义"></a>Spring-JDBC 扩展的 DataSource 定义</h3><p>在 Spring-jdbc 下，DataSources 最顶级的类是 AbstractDataSource ，对 DataSource 的所有父接口方法做了实现。但保留 getConnection() 方法由子类实现。</p><p>在 AbstractDriverBasedDataSource 中，定义了大量的参数，诸如 url, username 等，这些都被用来定位并定义与数据库实例的连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDriverBasedDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> String catalog;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> String schema;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="comment">// 可以看到此处有一个 Properties 类</span></span><br><span class="line">   <span class="keyword">private</span> Properties connectionProperties;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 省略若干方法</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">      <span class="comment">// 调用内部方法 getConnectionFromDriver()</span></span><br><span class="line"><span class="keyword">return</span> getConnectionFromDriver(getUsername(), getPassword());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">      <span class="comment">// 调用内部方法 getConnectionFromDriver()</span></span><br><span class="line"><span class="keyword">return</span> getConnectionFromDriver(username, password);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 定义了一个获取 Connection 的方法，由 getConnection() 方法调用，</span></span><br><span class="line">   <span class="comment">// 此方法主要是将属性做了一个整合</span></span><br><span class="line">   <span class="comment">// 具体获取 Connection 的逻辑仍然下放到子类实现 见 40 行</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> Connection <span class="title">getConnectionFromDriver</span><span class="params">(@Nullable String username, @Nullable String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">Properties mergedProps = <span class="keyword">new</span> Properties();</span><br><span class="line">Properties connProps = getConnectionProperties();</span><br><span class="line"><span class="keyword">if</span> (connProps != <span class="keyword">null</span>) &#123;</span><br><span class="line">mergedProps.putAll(connProps);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (username != <span class="keyword">null</span>) &#123;</span><br><span class="line">mergedProps.setProperty(<span class="string">"user"</span>, username);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (password != <span class="keyword">null</span>) &#123;</span><br><span class="line">mergedProps.setProperty(<span class="string">"password"</span>, password);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 获取 Connection 逻辑下放</span></span><br><span class="line">Connection con = getConnectionFromDriver(mergedProps);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.catalog != <span class="keyword">null</span>) &#123;</span><br><span class="line">con.setCatalog(<span class="keyword">this</span>.catalog);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.schema != <span class="keyword">null</span>) &#123;</span><br><span class="line">con.setSchema(<span class="keyword">this</span>.schema);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> con;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 该类中获取 Connection 的方法是抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Connection <span class="title">getConnectionFromDriver</span><span class="params">(Properties props)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整合方案为将除 url 外的所有参数整合在同一个 Properties 对象中 (其中，Properties 可以被认为是一个线程安全的 Hash Map) 。最终调用 <code>Connection getConnectionFromDriver(Properties props)</code> 获取连接。</p><p>AbstractDriverBasedDataSource 抽象类的两个子类 DriverManagerDataSource 和 SimpleDriverDataSource 都以不同方式获得了连接(Connection)，但总结而言，获取连接(Connection) 的任务被委托给了 Driver 来实现（其中，Driver 有 Java 定义接口，并由各数据库提供商提供，例如 MySQL 提供了 mysql-connector-java-XXX.jar 来完成针对相应数据库的具体实现）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ----------------------------</span></span><br><span class="line"><span class="comment">// SimpleDriverDataSource 的实现</span></span><br><span class="line"><span class="comment">// ----------------------------</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Connection <span class="title">getConnectionFromDriver</span><span class="params">(Properties props)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">Driver driver = getDriver();</span><br><span class="line">String url = getUrl();</span><br><span class="line">Assert.notNull(driver, <span class="string">"Driver must not be null"</span>);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Creating new JDBC Driver Connection to ["</span> + url + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 哈哈，重点在这... driver 在该类中被预先注入</span></span><br><span class="line"><span class="keyword">return</span> driver.connect(url, props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------</span></span><br><span class="line"><span class="comment">// DriverManagerDataSource 的实现</span></span><br><span class="line"><span class="comment">// -----------------------------</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Connection <span class="title">getConnectionFromDriver</span><span class="params">(Properties props)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">String url = getUrl();</span><br><span class="line">Assert.state(url != <span class="keyword">null</span>, <span class="string">"'url' not set"</span>);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Creating new JDBC DriverManager Connection to ["</span> + url + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 调了个内部函数</span></span><br><span class="line"><span class="keyword">return</span> getConnectionFromDriverManager(url, props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Connection <span class="title">getConnectionFromDriverManager</span><span class="params">(String url, Properties props)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// 委托给 DriverManager 类来获取连接</span></span><br><span class="line">    <span class="comment">// DriverManager 的主要操作是遍历在该管理类中注册的 Driver</span></span><br><span class="line">    <span class="comment">// 每个 Driver 实例都去尝试一下，能不能获得一个连接</span></span><br><span class="line">    <span class="comment">// 第一次在某个 Driver 中拿到一个连接即返回连接 (Connection)</span></span><br><span class="line"><span class="keyword">return</span> DriverManager.getConnection(url, props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简要的类图如下：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fncrgqcjqoj31es15ajxj.jpg" alt=""></p><h2 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h2><p>上面提到 DataSource 获取连接(Connection) 的操作实质上将委托具体的 Driver 来提供 Connection 。有两种不同的方式，包括经由 DriverManager 遍历所有处于管理下的 Driver 尝试获取连接，或者在 DataSource 实例中直接声明一个特定的 Driver 来获取连接。</p><p>对于获取连接的具体操作，挖坑-待填。只描述简单的数据库供应商提供的 Driver 如何与 java 相联系。</p><p>###在 DriverManager 中注册 Driver 实例</p><p>通常在与数据库交互逻辑的 Java 代码中，都会有 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code> (此处以 MySQL 提供的 mysql-connector-java-XXX.jar 为例，下同）的代码块，加载指定的 com.mysql.jdbc.Driver 为 java.lang.Class 类。</p><p><em>当然，在 JDBC 4.0 标准下，可以不必再显示声明 <code>Class.forName(&quot;&quot;)</code> 语句，Driver 也同样会在 DriverManager 初始化时自动注册。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Class 类中对于 forName(String className) 的方法</span></span><br><span class="line"><span class="comment">// 作用为返回一个 java.lang.Class 实例。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;...&#125;</span><br></pre></td></tr></table></figure><p>同时， JVM 在加载类的过程中会执行类中的 static 代码块。下述 row 10 ~ 16 的代码片段将被执行。唯一的逻辑就是 new 一个 com.mysql.jdbc.Driver 实例，并将实例注册(registerDriver) 到 <strong>java.sql.DriverManager</strong> 中。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mysql.jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">extends</span> <span class="title">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">sql</span>.<span class="title">Driver</span> </span>&#123;</span><br><span class="line"><span class="comment">// ~ Static fields/initializers</span></span><br><span class="line"><span class="comment">// ---------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Register ourselves with the DriverManager</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't register driver!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ~ Constructors</span></span><br><span class="line"><span class="comment">// -----------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Construct a new driver and register it with DriverManager</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment"> *             if a database error occurs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="comment">// Required for Class.forName().newInstance()</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面再来看一下 DriverManager 中的 registerDriver() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DriverManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// DriverManager 维护一个线程安全的 Driver 列表</span></span><br><span class="line">  <span class="comment">// 此处的 DriverInfo 里面即包装了 Driver </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = </span><br><span class="line">      <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在 DriverManager 中注册 Driver</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">registerDriver</span><span class="params">(java.sql.Driver driver)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        registerDriver(driver, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">registerDriver</span><span class="params">(java.sql.Driver driver,</span></span></span><br><span class="line"><span class="function"><span class="params">            DriverAction da)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 如果当前 Driver 不在列表中，即添加到列表。 */</span></span><br><span class="line">        <span class="keyword">if</span>(driver != <span class="keyword">null</span>) &#123;</span><br><span class="line">            registeredDrivers.addIfAbsent(<span class="keyword">new</span> DriverInfo(driver, da));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// This is for compatibility with the original DriverManager</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"registerDriver: "</span> + driver);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过-DriverManager-获取连接-Connection"><a href="#通过-DriverManager-获取连接-Connection" class="headerlink" title="通过 DriverManager 获取连接(Connection)"></a>通过 DriverManager 获取连接(Connection)</h3><p>上一节有提到过可以通过 DriverManager 来遍历获取连接，也可以直接声明具体 Driver 并获取连接。下面代码展示的是通过 DriverManager 获取连接的操作。 <del>哈哈哈，反正最后都是由具体驱动实现获取连接。</del></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DriverManager</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取连接的 public 接口 (1)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(String url,</span></span></span><br><span class="line"><span class="function"><span class="params">java.util.Properties info)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取连接的 public 接口 (2)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(String url,</span></span></span><br><span class="line"><span class="function"><span class="params">        String user, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        java.util.Properties info = <span class="keyword">new</span> java.util.Properties();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">            info.put(<span class="string">"user"</span>, user);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (password != <span class="keyword">null</span>) &#123;</span><br><span class="line">            info.put(<span class="string">"password"</span>, password);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 获取连接的 public 接口 (3)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(String url)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        java.util.Properties info = <span class="keyword">new</span> java.util.Properties();</span><br><span class="line">        <span class="keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 获取连接的内部逻辑实现</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        String url, java.util.Properties info, Class&lt;?&gt; caller)</span> </span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * When callerCl is null, we should check the application's</span></span><br><span class="line"><span class="comment">         * (which is invoking this class indirectly)</span></span><br><span class="line"><span class="comment">         * classloader, so that the JDBC driver class outside rt.jar</span></span><br><span class="line"><span class="comment">         * can be loaded from here.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ClassLoader callerCL = caller != <span class="keyword">null</span> ? caller.getClassLoader() : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span>(DriverManager.class) &#123;</span><br><span class="line">            <span class="comment">// synchronize loading of the correct classloader.</span></span><br><span class="line">            <span class="keyword">if</span> (callerCL == <span class="keyword">null</span>) &#123;</span><br><span class="line">                callerCL = Thread.currentThread().getContextClassLoader();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// url 是定位 DBMS 最重要的参数，不能为空</span></span><br><span class="line">        <span class="keyword">if</span>(url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"The url cannot be null"</span>, <span class="string">"08001"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"DriverManager.getConnection(\""</span> + url + <span class="string">"\")"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 遍历所有注册的 Driver ，并都尝试获取连接(Connection)</span></span><br><span class="line">        SQLException reason = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(DriverInfo aDriver : registeredDrivers) &#123;</span><br><span class="line">          <span class="comment">// 判断注册的 Driver 是否由 ClassLoader callerCL 加载，不是则跳过</span></span><br><span class="line">            <span class="keyword">if</span>(isDriverAllowed(aDriver.driver, callerCL)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    println(<span class="string">"    trying "</span> + aDriver.driver.getClass().getName());</span><br><span class="line">                    <span class="comment">// 获取连接，:) 还是由 driver 实例自行提供</span></span><br><span class="line">                  Connection con = aDriver.driver.connect(url, info);</span><br><span class="line">                    <span class="keyword">if</span> (con != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// Success!</span></span><br><span class="line">                        println(<span class="string">"getConnection returning "</span> + </span><br><span class="line">                                aDriver.driver.getClass().getName());</span><br><span class="line">                        <span class="keyword">return</span> (con);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (reason == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        reason = ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                println(<span class="string">"    skipping: "</span> + aDriver.getClass().getName());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果运行到下列代码，则表明获取连接失败，抛出错误</span></span><br><span class="line">        <span class="keyword">if</span> (reason != <span class="keyword">null</span>)    &#123;</span><br><span class="line">            println(<span class="string">"getConnection failed: "</span> + reason);</span><br><span class="line">            <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"getConnection: no suitable driver found for "</span>+ url);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"No suitable driver found for "</span>+ url, <span class="string">"08001"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>简单的提一嘴，Connection 仍然只是一个针对 Java -&gt; DB Server 的上层接口，如果想要更深层次地了解 Connection 与 DB Server 的交互，可以尝试去看一下 com.mysql.jdbc.MysqlIO 类，MySQL 实现的 JDBC4Connection 类也是在使用该类来实现对 DB Server 交互。（哈哈，只看过 MySQL 提供的 Driver 包）。</em></p><h2 id="PreparedStatement-amp-CallableStatement"><a href="#PreparedStatement-amp-CallableStatement" class="headerlink" title="PreparedStatement &amp; CallableStatement"></a>PreparedStatement &amp; CallableStatement</h2><p>在了解了 DataSource 获取连接(Connection) 的实质以及 JdbcTemplate 的通用接口之后，使用 Spring-jdbc 进行数据库相关的操作可以直截了当的利用如下代码进行实现（此处仅展示通过 Java 硬编码的形式进行实现，XML 配置方法类似）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 定义数据源</span></span><br><span class="line">DriverManagerDataSource dataSource = <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">  <span class="comment">// 配置参数</span></span><br><span class="line">dataSource.setUrl(<span class="string">"jdbc:mysql://&lt;host&gt;:&lt;port&gt;/&lt;dbName&gt;?&lt;props&gt;"</span>);</span><br><span class="line">   dataSource.setUsername(<span class="string">"&lt;username&gt;"</span>);</span><br><span class="line">    dataSource.setPassword(<span class="string">"&lt;passwd&gt;"</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 实例化一个 JDBC 工具类</span></span><br><span class="line">  JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">  <span class="comment">// 执行相关 CRUD 操作</span></span><br><span class="line">  jdbcTemplate.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回顾第一节所讲的 JdbcTemplate 的 4 个基础方法：</p><ol><li><code>&lt;T&gt; T execute(ConnectionCallback&lt;T&gt; action);</code></li><li><code>&lt;T&gt; T execute(StatementCallback&lt;T&gt; action);</code></li><li><code>&lt;T&gt; T execute(PreparedStatementCreator psc, PreparedStatementCallback&lt;T&gt; action);</code></li><li><code>&lt;T&gt; T execute(CallableStatementCreator csc, CallableStatementCallback&lt;T&gt; action);</code></li></ol><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fndsm5tl7aj30zg0byq47.jpg" alt=""></p><p>四个基础方法都有一个特定的回调函数将通过预配置的 DataSource 得到的 Connection 或 更进一步的 Statement or PreparedStatement or CallableStatement 作为入参来执行定义的唯一方法。</p><p>以 <code>&lt;T&gt; T execute(StatementCallback&lt;T&gt; action);</code> 为例来了解一下方法的核心逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(StatementCallback&lt;T&gt; action)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line"><span class="comment">// 通过工具类 DataSourceUtils 获取一个连接</span></span><br><span class="line">  Connection con = DataSourceUtils.getConnection(obtainDataSource());</span><br><span class="line">  <span class="comment">// 一个 Statement 空实例，PreparedStatement, CallableStatement 类似</span></span><br><span class="line">Statement stmt = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">stmt = con.createStatement();<span class="comment">// 通过连接(Connection)获取一个 Statement</span></span><br><span class="line">applyStatementSettings(stmt);<span class="comment">// 配置 Statement 参数</span></span><br><span class="line">      <span class="comment">// 回调执行 doInXXX() 方法, 并获得 result</span></span><br><span class="line">T result = action.doInStatement(stmt);</span><br><span class="line">handleWarnings(stmt);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span>() &#123;</span><br><span class="line">      </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，对于 PreparedStatement 和 CallableStatement 而言，获取一个 <em>XXX</em>Statement 的方式就有所不同了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 Statement 实例</span></span><br><span class="line">Statement stmt = con.createStatement();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 PreparedStatement 实例</span></span><br><span class="line"><span class="comment">// psc 是一个 PreparedStatementCreator 接口实现的实例</span></span><br><span class="line">PreparedStatement ps = psc.createPreparedStatement(con);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 CallableStatement 实例</span></span><br><span class="line"><span class="comment">// csc 是一个 CallableStatementCreator 接口实现的实例</span></span><br><span class="line">CallableStatement cs = csc.createCallableStatement(con);</span><br></pre></td></tr></table></figure><p>可以看到 Statement 直接通过 Connection 获取实例，但是 PreparedStatement 和 CallableStatement 就有所不同，其区别就在于 PreparedStatement 和 CallableStatement 两个 Statement 都是可以定制入参的，更甚者， CallableStatement 可以定制 DB 执行结果的出参。当然，核心还是 <code>con.prepareStatement() OR con.prepareCall()</code> 方法，只不过是将获取 XXXStatement 的操作下放给 XXXStatementCreator 实例类实现，给予使用者重复的自主权，同时也是逻辑解耦的一种操作。</p><p>例如：</p><p>SimplePreparedStatementCreator 这个 PreparedStatementCreator 接口的实现类，只是简单的调用了 <code>con.prepareStatement(sql)</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePreparedStatementCreator</span> </span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">PreparedStatementCreator</span>, <span class="title">SqlProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String sql;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">createPreparedStatement</span><span class="params">(Connection con)</span> </span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> con.prepareStatement(<span class="keyword">this</span>.sql);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于 PreparedStatementCreatorImpl ，在 createPreparedStatement(Connection con) 的实现上，又添加了更多的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PreparedStatementCreatorImpl</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">PreparedStatementCreator</span>, <span class="title">PreparedStatementSetter</span>, <span class="title">SqlProvider</span>, <span class="title">ParameterDisposer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String actualSql;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;?&gt; parameters;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">createPreparedStatement</span><span class="params">(Connection con)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">PreparedStatement ps;</span><br><span class="line"><span class="keyword">if</span> (generatedKeysColumnNames != <span class="keyword">null</span> || returnGeneratedKeys) &#123;</span><br><span class="line"><span class="keyword">if</span> (generatedKeysColumnNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// 获取一个 PreparedStatement 实例，下同</span></span><br><span class="line">ps = con.prepareStatement(<span class="keyword">this</span>.actualSql, </span><br><span class="line">                                          generatedKeysColumnNames);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ps = con.prepareStatement(<span class="keyword">this</span>.actualSql, </span><br><span class="line">                                         PreparedStatement.RETURN_GENERATED_KEYS);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (resultSetType == ResultSet.TYPE_FORWARD_ONLY </span><br><span class="line">                 &amp;&amp; !updatableResults) &#123;</span><br><span class="line">ps = con.prepareStatement(<span class="keyword">this</span>.actualSql);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ps = con.prepareStatement(<span class="keyword">this</span>.actualSql, resultSetType,</span><br><span class="line">updatableResults ? ResultSet.CONCUR_UPDATABLE : </span><br><span class="line">                                      ResultSet.CONCUR_READ_ONLY);</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">// 将可变 SQL (例如 SELECT * FROM msg WHERE id = ?) 的 ? 用实际参数替换</span></span><br><span class="line">setValues(ps);</span><br><span class="line"><span class="keyword">return</span> ps;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述两种 PreparedStatementCreator 接口的不同实现，也可以从另一种角度理解到，函数式接口将获取目标出参的具体逻辑交给使用者定义，给予了使用者充分的自主权，同时也是一种业务逻辑的解耦。</p><p>在上面代码 PreparedStatementCreatorImpl 类的实现中，我们看到第 32 行代码 <code>setValue(ps)</code> 。此处的方法是由接口 PreparedStatementSetter 定义的。主要目的是将可变 SQL 中的 ? 参数用实际参数进行一个替换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以 SQL (SELECT * FROM msg WHERE id = ? AND day = ?) 为例</span></span><br><span class="line"><span class="comment">/** 纯 Java 核心库的实现 PreparedStatement 参数注入 */</span></span><br><span class="line">ps.setInt(<span class="number">1</span>, <span class="number">1763</span>);</span><br><span class="line">ps.setString(<span class="number">2</span>, <span class="string">"2018-01-01"</span>);</span><br><span class="line">ps.executeQuery();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 以 Spring-jdbc 实现 PreparedStatement 参数注入 */</span></span><br><span class="line"><span class="comment">// setValues() 由接口 PreparedStatementSetter 定义，封装了注入参数的具体实现逻辑</span></span><br><span class="line"><span class="comment">// 可以由使用者自行定义</span></span><br><span class="line">setValues(ps);</span><br><span class="line">ps.executeQuery();</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fndyybh4q1j31kw0u3afx.jpg" alt=""></p><p>上面类图表示了 PreparedStatementSetter 及其实现类的相关依赖。</p><p>Setter 的主要目标即为对 SQL 中的 ? 参数进行注入。</p><p><del>个人精力有限，对Spring-jdbc在Statement上对参数注入的回调理解有限。</del></p><h2 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h2><p>在前几节已经提到讲了数据源、驱动管理器以及 Statement 之后，利用 JDBC 的最重要的目的就是对 DB 进行操作，并获得预期结果。对于查询语句而言，结果应该是若干记录行；就更新语句而言，结果可能是影响的行数。而 Spring-jdbc 对 ResultSet 额外进行的封装，即是将原本散乱的结果进行一个整合，例如整合成一个(一组)完整的 Bean 来进行展示。</p><p>在 JdbcTemplate 中，四个基本方法入参都包括一个回调接口，而在执行回调获得 ResultSet 之后，方法并不是直接返回，而是进行了一定的操作。</p><p>以一个 PreparedStatementCallback 的实例类为例，在 doInPreparedStatement() 方法中，获得了 ResultSet ，但是仍通过 rse.extractData(rs) 语句进行了处理后再返回结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">doInPreparedStatement</span><span class="params">(PreparedStatement ps)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">// 声明一个 ResultSet </span></span><br><span class="line">ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (pss != <span class="keyword">null</span>) &#123;<span class="comment">// setValues() 方法填充 PreparedStatement 中的可变参数 ? </span></span><br><span class="line">pss.setValues(ps);</span><br><span class="line">&#125;</span><br><span class="line">rs = ps.executeQuery();<span class="comment">// 执行查询 sql ，获取结果</span></span><br><span class="line"><span class="keyword">return</span> rse.extractData(rs);<span class="comment">// 重点... 该语句一定是对结果进行了一些操作.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">JdbcUtils.closeResultSet(rs);</span><br><span class="line"><span class="keyword">if</span> (pss <span class="keyword">instanceof</span> ParameterDisposer) &#123;</span><br><span class="line">((ParameterDisposer) pss).cleanupParameters();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在来看一下究竟在返回结果前进行了什么操作。</p><p>由于是一个回调接口的实现类，rse 应该在外部方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">query</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">PreparedStatementCreator psc, @Nullable <span class="keyword">final</span> PreparedStatementSetter pss, </span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">final</span> ResultSetExtractor&lt;T&gt; rse)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> execute(psc, <span class="keyword">new</span> PreparedStatementCallback&lt;T&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">doInPreparedStatement</span><span class="params">(PreparedStatement ps)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">...</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 rse 是一个 ResultSetExtractor<t> 的实例。从名称上可以看出 Extractor 即为提取器，结果集提取器。</t></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 函数式接口，提供的唯一方法为 extractData(...) */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResultSetExtractor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">T <span class="title">extractData</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException, DataAccessException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fndzz0pqnrj31a60i676v.jpg" alt=""></p><p>Spring-jdbc 中现有的实现有三个类，其中 RowCallbackHandlerResultSetExtractor 和 RowMapperResultSetExtractor 两个类从上面类图及命名即可看出，两个是作为一个适配器而存在的，将 extractData() 进行转换，分别由 RowCallbackHandler 和 RowMapper 实例进行具体操作。而 AbstractLobStreamingResultSetExtractor 类从名称上看，也是一个类似流操作的实现类(其中的 Lob 指的是 DB 中的 BLOB 与 CLOB 类型，在 Spring-jdbc 中也加入了额外的支持) 。</p><h3 id="RowCallbackHandler"><a href="#RowCallbackHandler" class="headerlink" title="RowCallbackHandler"></a>RowCallbackHandler</h3><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fnh2uw3a0aj30h20jeta4.jpg" alt=""></p><p>从名称上看，这是一个与 ResultSet 结果集行相关的回调接口。processRow(ResultSet rs) 方法将处理行相关的逻辑。</p><p>从它的一个实现类 RowCountCallbackHandler 来说，其最主要的私有属性 rowCount 即是统计 ResultSet 的结果行数。下面是一个具体使用的该类的案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">    DriverManagerDataSource dataSource = <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">    dataSource.setUrl(<span class="string">"jdbc:mysql://&lt;host&gt;:&lt;port&gt;/&lt;dbName&gt;"</span>);</span><br><span class="line">    dataSource.setUsername(<span class="string">"&lt;username&gt;"</span>);</span><br><span class="line">    dataSource.setPassword(<span class="string">"&lt;password&gt;"</span>);</span><br><span class="line"></span><br><span class="line">    JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    RowCountCallbackHandler rcch = <span class="keyword">new</span> RowCountCallbackHandler();</span><br><span class="line"></span><br><span class="line">    jdbcTemplate.query(<span class="string">"SELECT * FROM info WHERE id='2018'"</span>, </span><br><span class="line">                       (RowCallbackHandler) rcch);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  System.out.println(rcch.getRowCount());<span class="comment">//获取结果集行数</span></span><br><span class="line">    System.out.println(rcch.getColumnCount());<span class="comment">// 获取结果集列数</span></span><br><span class="line">    <span class="keyword">for</span> (String arg : rcch.getColumnNames()) &#123;<span class="comment">// 打印结果集每一列名称</span></span><br><span class="line">        System.out.println(<span class="string">"ColumnNames : "</span> + arg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : rcch.getColumnTypes()) &#123;<span class="comment">// 打印结果集每一列类型(Types 为枚举类)</span></span><br><span class="line">        System.out.println(<span class="string">"ColumnTypes : "</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体查看 RowCountCallbackHandler 类的 processRow() 方法可以看到，其获取列相关信息都来自于 ResultSetMetaData 。而结果行数来源于 Iterator 迭代。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processRow</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.rowCount == <span class="number">0</span>) &#123;</span><br><span class="line">ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line"><span class="keyword">this</span>.columnCount = rsmd.getColumnCount();</span><br><span class="line"><span class="keyword">this</span>.columnTypes = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.columnCount];</span><br><span class="line"><span class="keyword">this</span>.columnNames = <span class="keyword">new</span> String[<span class="keyword">this</span>.columnCount];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.columnCount; i++) &#123;</span><br><span class="line"><span class="keyword">this</span>.columnTypes[i] = rsmd.getColumnType(i + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">this</span>.columnNames[i] = JdbcUtils.lookupColumnName(rsmd, i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// could also get column names</span></span><br><span class="line">&#125;</span><br><span class="line">processRow(rs, <span class="keyword">this</span>.rowCount++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RowMapper"><a href="#RowMapper" class="headerlink" title="RowMapper"></a>RowMapper</h3><p>上面 RowCallbackHandler 接口从逻辑上划分是用于处理 ResultSet 元数据信息的。而 RowMapper 较上一个接口而言，有更高的实用性。</p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fnh3h739kaj30z60nago4.jpg" alt=""></p><p>特别是其实现类 BeanPropertyRowMapper<t> 可以将散乱的 ResultSet 的结果数据整理成一个个 Object Bean 作为返回结果。而省去了对逐一读取 ResultSet 行记录并填充 Bean 属性的麻烦。</t></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line"></span><br><span class="line">BeanPropertyRowMapper&lt;Model&gt; rowMapper = <span class="keyword">new</span> BeanPropertyRowMapper&lt;&gt;(Model.class);</span><br><span class="line">List&lt;Model&gt; list = jdbcTemplate.query(</span><br><span class="line">  <span class="string">"SELECT * FROM info WHERE id = '2018'"</span>, rowMapper);</span><br><span class="line"><span class="comment">/** 获得的 Model list 的对应属性将通过 Java 的反射机制进行填充</span></span><br><span class="line"><span class="comment"> *List&lt;Model&gt; list 即结果</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>当然，要求是 Model 类中的属性与 DB table 中的列名保持一致（大小写无要求）。</p><p>而其它两个类的实现也是基于反射机制，实现其相应的业务逻辑。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://utop.xin/tags/Spring/"/>
    
      <category term="JDBC" scheme="http://utop.xin/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>区块链技术概述</title>
    <link href="http://utop.xin/2018-03-01-%E5%8C%BA%E5%9D%97%E9%93%BE%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
    <id>http://utop.xin/2018-03-01-区块链简单介绍/</id>
    <published>2018-06-12T12:38:18.604Z</published>
    <updated>2018-06-12T12:38:18.604Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __</span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _</span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fs8oc4ri7qj30mq055aap.jpg" alt="区块链简单结构"></p><center><small>图1. 区块链简单结构</small></center><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1foxcpmmpfhj31kw107n2e.jpg" alt="Merkle tree"></p><center><small>图2. 单个区块的抽象结构</small></center><h2 id="基本工作流程"><a href="#基本工作流程" class="headerlink" title="基本工作流程"></a>基本工作流程</h2><p>###新交易发起流程</p><ol><li>用户通过公/私钥与区块链网络进行交互</li><li>处理用户交易的节点向网络邻节点广播用户交易</li><li>邻节点验证交易的有效性；可信，继续向其它邻节点广播；不可信，丢弃。</li></ol><h3 id="新区块产生流程"><a href="#新区块产生流程" class="headerlink" title="新区块产生流程"></a>新区块产生流程</h3><ol><li>矿工尝试将一个时间区间内的交易进行打包形成新区块（怎么打包，看下文）</li><li>生产出新区块的矿工节点向网络广播新区块</li><li>收到新区块的网络节点验证该区块的有效性</li></ol><p><a href="https://blockchain.info/zh-cn" target="_blank" rel="noopener">比特币区块浏览器</a>      更多<a href="https://en.wikipedia.org/wiki/Metric_prefix" target="_blank" rel="noopener">国际单位制前缀</a></p><h2 id="网络共识"><a href="#网络共识" class="headerlink" title="网络共识"></a>网络共识</h2><p>所有区块链网络节点需要对交易以及其在新区块里面的顺序达成一致（交易的有效性以及交易的打包顺序）。</p><p>可能出现：</p><ul><li>女巫攻击——单一实体以多重身份重复对新区块结果进行表决（少数人抓住了网络的投票权）</li><li><a href="https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">拜占庭将军问题</a>——分布式对等网络的通信容错问题<ul><li>不同的计算机通过通讯交换信息达成共识而按照同一套协作策略行动<ul><li>成员计算机可能出错而发送错误信息</li><li>网络的不可靠性</li><li>从而影响网络共识的达成，破坏一致性。</li></ul></li><li>不解决的话可能导致——区块链分叉</li></ul></li></ul><p>解决方案：</p><ul><li>工作量证明（proof-of-work, PoW），权益证明(proof-of-stake, PoS)，白名单机制（仅适用于私有网络）等</li><li>实用拜占庭容错算法</li></ul><h3 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h3><p>网络共识机制的实现导致了：</p><ol><li>交易吞吐量</li><li>更高的交易时延。交易确认时间（只有打包的新区块中才交易才会被承认）。</li></ol><p>共识机制的伸缩可以一定程度上解决上述问题</p><h2 id="资产交易"><a href="#资产交易" class="headerlink" title="资产交易"></a>资产交易</h2><p>简单交易状态描述，以集中式数据库为例</p><p>假设初始状态为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-------------------------</span><br><span class="line">| 资产类型 | 所有者 | 数量 |</span><br><span class="line">-------------------------</span><br><span class="line">|   CNY   |  防风  |  10 |</span><br><span class="line">-------------------------</span><br><span class="line">|   CNY   |  红薯  |  0  |</span><br><span class="line">-------------------------</span><br></pre></td></tr></table></figure><p>防风 向 红薯 转账 2 CNY </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-------------------------</span><br><span class="line">| 资产类型 | 所有者 | 数量 |</span><br><span class="line">-------------------------</span><br><span class="line">|   CNY   |  防风  |  8  |</span><br><span class="line">-------------------------</span><br><span class="line">|   CNY   |  红薯  |  2  |</span><br><span class="line">-------------------------</span><br></pre></td></tr></table></figure><p>数据库中相应记录的更改完成了资产的交易过程。</p><p>在区块链中，仍然将分布式链看作是一个达成共识的集中式数据库</p><p>那么现在的初始状态可以表示成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---------------------------------</span><br><span class="line">| 资产类型 |     所有者     | 数量 |</span><br><span class="line">---------------------------------</span><br><span class="line">|   IOTA  |  防风 pub_key  | 10  |</span><br><span class="line">---------------------------------</span><br></pre></td></tr></table></figure><p>现在的所有者由公钥表示，想要修改记录必须提供对应的密钥。</p><p>例如，防风 向 红薯 转账 2 IOTA ，需要提供防风的私钥和红薯的公钥。交易记录修改结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---------------------------------</span><br><span class="line">| 资产类型 |     所有者     | 数量 |</span><br><span class="line">---------------------------------</span><br><span class="line">                                 被删除了         |   IOTA  |  防风 pub_key  | 10  |</span><br><span class="line">---------------------------------</span><br><span class="line">|   IOTA  |  红薯 pub_key  |  2  |</span><br><span class="line">---------------------------------</span><br><span class="line">|   IOTA  |  防风 pub_key  |  8  |</span><br></pre></td></tr></table></figure><p>交易的概念流程：</p><ol><li>定位防风所有的资产记录行</li><li>删除该行前验证密钥</li><li>确认该记录没有被别的交易使用（双花问题，双重交易）</li><li>写入新的正确的记录（红薯获得的资产 &amp; 防风剩余的资产），确保交易前与交易后资产总额不变</li></ol><p>上面的模型 —— 基于比特币的交易模型(UTXO <em>model</em>)</p><p><strong>适合于数字标记资产的传输与追踪</strong></p><ul><li>概念：UTXO (unspent transaction outputs) 未花费的交易输出：数据库现有的记录</li></ul><p>-——————————–</p><p>另一种模型常用于智能合约 —— 基于账号的模型(account-based <em>model</em>)</p><p><strong>提供了建立多步骤执行的基本机制</strong> </p><h3 id="资产如何产生"><a href="#资产如何产生" class="headerlink" title="资产如何产生"></a>资产如何产生</h3><ul><li>比特币：<ul><li>矿工节点允许在挖出的新节点中加入一种 coinbase 类型的交易（不存在交易输入，新资产数额有比特币链提前定义）</li></ul></li><li>在创始新代币的时候全额发行</li><li>其它机制</li></ul><h2 id="区块链特性"><a href="#区块链特性" class="headerlink" title="区块链特性"></a>区块链特性</h2><ol><li>一种健壮的、真正的分布式对等系统，它能容忍节点故障。</li><li>能够识别冲突和分叉并自动解决的网络，以便收敛到单一的、公认的唯一状态。（区块链永远选择最长的分支来达成网络上的共识）</li><li>网络活动的透明性、可验证性、可审计性。我们能获取可验证的过程，无论它们是否交换和跟踪数字资产，还是数据驱动的交互。每一个行为，都存有公开的与网络交互的记录，并以此来消除人为的矛盾。</li><li>这是一种可以标记不同信息的触发者的方法，并且能够在没有中央权威的情况下强制执行。</li><li>这是一个使得不信任双方根据可预测的、确定性的方式交互的系统。</li></ol><h2 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h2><p>自动化地执行一系列合约条款的交易协议</p><p>智能合约是存储在区块链中的脚本（认识上可以与关系型数据库的存储过程类似）。</p><p>以基于账号的模型为例对合约执行进行描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">假设定义一个合约，包括三个方法</span><br><span class="line"></span><br><span class="line">(1) “存储”——合约的“存款”功能允许 防风（通过防风的密钥验证）将若干单位的X存入合约中；</span><br><span class="line">(2) “交易”——“交易”功能允许任何人向合约发送5单位Y，并从合约持有的X中返回1单位给交易方；</span><br><span class="line">(3) “撤销”——“撤销”功能允许 防风 取出合约中存有的所有资产。</span><br><span class="line"></span><br><span class="line">请注意，上述“存款”和“撤销”功能被限制为只允许被 防风（实际上是防风的私钥）调用。当然，这只有由于上述合约由防风制定。若人为的制定一个所有人都能调用任何功能的合约也是允许的（虽然这在事实上没有意义）。</span><br></pre></td></tr></table></figure><p>那么在基于账户的模型下，可以认为 拥有“存储”、“交易”、“撤销”方法的合约持有一个单独的账户（与用户所持有的账户等价）。</p><p>在上述合约下，这个账户将可能持有一定数量的资产。除了只能按照预定的合约步骤对资产进行处置之外，其它与用户持有的账户别无二致。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ASM - ClassReader 与 Java ClassFile 文件格式</title>
    <link href="http://utop.xin/2018-06-11-ASM-ClassReader/"/>
    <id>http://utop.xin/2018-06-11-ASM-ClassReader/</id>
    <published>2018-06-10T16:00:00.000Z</published>
    <updated>2018-06-12T03:40:49.188Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure><p>[TOC]</p><h2 id="Java-ClassFile-文件格式"><a href="#Java-ClassFile-文件格式" class="headerlink" title="Java ClassFile 文件格式"></a>Java ClassFile 文件格式</h2><p>读了将近一周的时间，勉强算是把 ClassFile 的文件格式给简单的梳理了个脉络。<br><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" title="Java Virtual Machine Specification" target="_blank" rel="noopener">The class File Format(Java SE 8)</a></p><blockquote><p>u1, u2, u4 分别表示无符号的一字节、二字节、四字节数据(以大端存储)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic;                                   <span class="comment">// 魔数(magic) 固定为 0xCAFEBABE</span></span><br><span class="line">    u2             minor_version;                           <span class="comment">// 次版本号</span></span><br><span class="line">    u2             major_version;                           <span class="comment">// 主版本号</span></span><br><span class="line">    u2             constant_pool_count;                     <span class="comment">// 常量池 constant_pool 的数量 + 1, 最大为 (2&lt;&lt;16 - 1) = 65535</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count<span class="number">-1</span>];    <span class="comment">// 常量池 取值下标为 [1, constant_pool_count)</span></span><br><span class="line">    u2             access_flags;                            <span class="comment">// 对类 or 接口的访问权限和属性的标志的掩码</span></span><br><span class="line">    u2             this_class;                              <span class="comment">// 值为 constant_pool 的有效下标(且 constant_pool[this_class] 的类型为 CONSTANT_Class_info)</span></span><br><span class="line">    u2             super_class;                             <span class="comment">// 值为 0 或者 constant_pool 的有效下标(同上), 如果是 interface, 则该值一定为有效下标</span></span><br><span class="line">    u2             interfaces_count;                        <span class="comment">// 直接父接口的数量</span></span><br><span class="line">    u2             interfaces[interfaces_count];            <span class="comment">// 值必须是 constant_pool 的有效下标, 且 interfaces[i](0≤i&lt;interfaces_count), 指向的类型为 CONSTANT_Class_info)</span></span><br><span class="line">    u2             fields_count;                            <span class="comment">// 字段数量, 统计所有字段, 包括 class variables(静态变量) 和 instance variables(实例变量)</span></span><br><span class="line">    field_info     fields[fields_count];                    <span class="comment">// 字段的详细声明, 不包含继承来的字段</span></span><br><span class="line">    u2             methods_count;                           <span class="comment">// 方法数量</span></span><br><span class="line">    method_info    methods[methods_count];                  <span class="comment">// 方法的详细声明, 不包括继承来的方法</span></span><br><span class="line">    u2             attributes_count;                        <span class="comment">// 属性数量</span></span><br><span class="line">    attribute_info attributes[attributes_count];            <span class="comment">// 属性的详细声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>通过 <code>javac Xxx.java</code> 命令得到的 <code>Xxx.class</code> 文件严格按照定义的 ClassFile 文件格式以8比特的字节为单位进行存储。</p><p><strong>下面的例子都将通过 Trie.java (实际代码见本文最后) 以及其经编译后的文件 Trie.class 做基本的介绍。</strong></p><h3 id="magic-minor-verion-amp-major-version"><a href="#magic-minor-verion-amp-major-version" class="headerlink" title="magic, minor_verion &amp; major_version"></a>magic, minor_verion &amp; major_version</h3><p>通过命令 <code>xxd Trie.class</code> 查看 Trie.class 的十六进制编码，前16字节的内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000000: cafe babe 0000 0034 008f 0a00 2400 4b09  .......4....$.K.</span><br></pre></td></tr></table></figure></p><p>可以看到前4字节的内容 <code>0xcafebabe</code>，没有实际意义，但是作为其是能否被JVM(Java Virtual Machine, Java虚拟机)接收的Class文件的一个校验。</p><p>紧接着的4个字节包括<code>次版本号</code> 和 <code>主版本号</code>，暂时不做深入。</p><h3 id="常量池-constant-pool"><a href="#常量池-constant-pool" class="headerlink" title="常量池 constant_pool"></a>常量池 constant_pool</h3><p>从第10个字节开始(从第0字节开始计数)，连续的两个字节表示常量池中各种 CONSTANT 的总个数+1 (constant_pool_count)。constant_pool_count 只有2字节也就意味着: 常量池的最大常量数量为 (2&lt;&lt;16 - 1) = 65535 (当然，貌似在这个量级上，也从没见过有谁能够维护这样一个大JAVA类文件了)。</p><p>可以看到 constant_pool_count 的内容为 <code>0x008f = 143</code> ，即对于常量池的声明可以认为是 <code>cp_info constant_pool[142]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u1 info[]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用 JDK 自带的 <code>javap</code> 来查看 <code>Trie.class</code> 文件(<code>javap -v Trie.class</code>)，可以对 cp_info 的格式有一个粗浅但形象化的认识(结果见<strong>附录2</strong>)<br>其中第一列的内容 <code>#? = ?</code> <code>#?</code>表示id，<code>= ?</code>表示一个 cp_info 的实际类型，有 <code>cp_info.tag</code> 指定，具体映射表为</p><table><thead><tr><th>Constant Type</th><th>Value</th></tr></thead><tbody><tr><td><code>CONSTANT_Class</code></td><td>7</td></tr><tr><td><code>CONSTANT_Fieldref</code></td><td>9</td></tr><tr><td><code>CONSTANT_Methodref</code></td><td>10</td></tr><tr><td><code>CONSTANT_InterfaceMethodref</code></td><td>11</td></tr><tr><td><code>CONSTANT_String</code></td><td>8</td></tr><tr><td><code>CONSTANT_Integer</code></td><td>3</td></tr><tr><td><code>CONSTANT_Float</code></td><td>4</td></tr><tr><td><code>CONSTANT_Long</code></td><td>5</td></tr><tr><td><code>CONSTANT_Double</code></td><td>6</td></tr><tr><td><code>CONSTANT_NameAndType</code></td><td>12</td></tr><tr><td><code>CONSTANT_Utf8</code></td><td>1</td></tr><tr><td><code>CONSTANT_MethodHandle</code></td><td>15</td></tr><tr><td><code>CONSTANT_MethodType</code></td><td>16</td></tr><tr><td><code>CONSTANT_InvokeDynamic</code></td><td>18</td></tr><tr><td><code>CONSTANT_Module</code></td><td>19</td></tr><tr><td><code>CONSTANT_Package</code></td><td>20</td></tr></tbody></table><p>在 Java ClassFile 的格式定义中，同时定义了每种 <code>CONSTANT</code> 的长度与格式。<br>例如:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Class_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 name_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Fieldref_info &#123;</span><br><span class="line">     u1 tag;</span><br><span class="line">     u2 class_index;</span><br><span class="line">     u2 name_and_type_index;</span><br><span class="line">&#125;</span><br><span class="line">CONSTANT_Methodref_info &#123;</span><br><span class="line">  u1 tag;</span><br><span class="line">  u2 class_index;</span><br><span class="line">  u2 name_and_type_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多的 <code>CONSTANT_XXX</code> 的格式定义见 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4" target="_blank" rel="noopener">ClassFile CONSTANT_XXX 结构</a></p><p>简单解析一下 cp_info<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" title="Java Virtual Machine Specification" target="_blank" rel="noopener">1</a>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000: cafe babe 0000 0034 008f 0a00 2400 4b09  .......4....$.K.</span><br><span class="line"></span><br><span class="line">#1 = Methodref          #36.#75       // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br></pre></td></tr></table></figure></p><p><code>cp_info[1].tag = 0x0a = 10</code>，即 cp_info<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" title="Java Virtual Machine Specification" target="_blank" rel="noopener">1</a> 的类型为 Methodref 。<br>之后就直接套用 <code>CONSTANT_Methodref_info</code> 的数据结构定义的格式<br><code>cp_info[1].class_index = 0x0024 = 36</code>，即 cp_info<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" title="Java Virtual Machine Specification" target="_blank" rel="noopener">1</a>.class_index 表示的类名指向常量池第 36 个元素表示的类<br><code>cp_info[1].name_and_type_index = 0x004b = 75</code>。表示指向的是常量池第 75 个元素表示的 NameAndType 结构</p><p>对于这部分内容的理解，如果觉得有能够阅读英文文档，可以参考 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" title="Java Virtual Machine Specification" target="_blank" rel="noopener">The Java® Virtual Machine Specification Chap 4.</a><br>否则，可以选择 <a href="http://icyfenix.iteye.com/blog/1256329" title="Java虚拟机规范（Java SE 7 中文版）" target="_blank" rel="noopener">Java 虚拟机规范(Java SE 7 版) 第四章</a><br>并尝试根据经编译后.class文件的二进制码进行人工解析，以加深对此的理解。</p><h3 id="more…"><a href="#more…" class="headerlink" title="more…"></a>more…</h3><p>更多内容于此基本类似，均属于已经被严格预定义的规范化格式，对此进行解析即可得到相应的内容。</p><h2 id="ASM-概览"><a href="#ASM-概览" class="headerlink" title="ASM 概览"></a>ASM 概览</h2><h3 id="包结构"><a href="#包结构" class="headerlink" title="包结构"></a>包结构</h3><p>asm, asm-analysis, asm-commons, asm-tree, asm-util, asm-xml 模块基于 Maven 的组织形式，并包含有单元测试的内容。</p><p>asm-test 实现了对上述模块的单元测试的整合。</p><p>benchmarks 定义了一些基本的 JMH 基准测试来衡量ASM的表现</p><p>gradle 包含了一些 Gradle 包装器，来辅助 Linux or Windows 脚本的调用请求</p><p>tools 包含两个 Gradle 项目来帮助 ASM 生成 Artifacts 。</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1frywra01upj308g0akmxr.jpg" alt="ASM Structure"></p><h3 id="代码组织形式"><a href="#代码组织形式" class="headerlink" title="代码组织形式"></a>代码组织形式</h3><p><img src="http://asm.ow2.io/asm-package-dependencies.svg" alt="Code Organization"></p><ul><li>org.objectweb.asm 作为核心包，定义了 ASM 访问者 API 以及两个核心类 ClassReader &amp; ClassWriter 来读写编译后的 Java 类。该包不依赖于其他包，且可单独使用</li><li>org.objectweb.asm.signature 提供了读写泛型签名的 API</li><li>org.objectweb.asm.tree 提供了类 DOM API 与类 SAX API。</li><li>org.objectweb.asm.tree.analysis 基于 .tree 提供了静态字节码分析框架</li><li>org.objectweb.asm.commons 提供了一些基于 core 和 tree 包的类适配器。</li><li>org.objectweb.asm.util 提供了一些用于 DEBUG 的访问者类与适配器类</li><li>org.objectweb.asm.xml 目前已经被 @Deprecated 。提供了类文件与 XML 互相转换的能力</li></ul><p>综上，asm 核心包是最为复杂的一个模块，而其它诸如 tree, util, xml 等都只是提供了将 JAVA 类从一种高级表示形态转换为另一种的能力。signature 也相当简单，提供了解析和打印简单语法的能力。</p><h3 id="主要数据结构"><a href="#主要数据结构" class="headerlink" title="主要数据结构"></a>主要数据结构</h3><p>核心包由 28 个类(接口) 组成。如果不考虑 Opcodes 接口, 5 个抽象访问者类(AnnotationVistitor, ClassVisitor, FieldVisitor, MethodVisitor and ModuleVisitor), 6 个工具类(ConstantDynamic, Contants, Handle, Type, TypePath and TypeReference), 剩下 16 个类的由下图提供一个粗略的展示。</p><p><img src="http://asm.ow2.io/asm-package-overview.svg" alt=""></p><p>编译类到访问事件的转换只由一个类 ClassReader 以及辅助类 Context 完成。其逆过程由以 ClassWriter 为核心的其它 14 个类完成。</p><h3 id="ClassReader"><a href="#ClassReader" class="headerlink" title="ClassReader"></a>ClassReader</h3><p>ClassReader 作为 ASM 核心包解析现有 .class 的唯一工具，组织形式相当简单。</p><ul><li>在构造函数中完成对常量池和引导方法的解析<ul><li>存储每个常量池项目的起始偏移量 cpInfoOffsets</li><li>存储每个引导方法的起始偏移量 bootstrapMethodOffsets</li><li>存储最长字符串常量的大小 maxStringLength</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">ClassReader(<span class="keyword">final</span> <span class="keyword">byte</span>[] classFileBuffer, <span class="keyword">final</span> <span class="keyword">int</span> classFileOffset, <span class="keyword">final</span> <span class="keyword">boolean</span> checkClassVersion) &#123;</span><br><span class="line">  <span class="keyword">this</span>.b = classFileBuffer;   <span class="comment">// .class 文件缓存</span></span><br><span class="line">  <span class="comment">// 检查主版本号, 第6,7个字节(从0字节开始计数)</span></span><br><span class="line">  <span class="keyword">if</span> (checkClassVersion &amp;&amp; readShort(classFileOffset + <span class="number">6</span>) &gt; Opcodes.V11) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">        <span class="string">"Unsupported class file major version "</span> + readShort(classFileOffset + <span class="number">6</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建常量池数组，常量池长度的定义 constant_pool_count 在第8,9字节</span></span><br><span class="line">  <span class="keyword">int</span> constantPoolCount = readUnsignedShort(classFileOffset + <span class="number">8</span>);     <span class="comment">// 读取无符号short, 即读取连续两字节作为一个short值</span></span><br><span class="line">  cpInfoOffsets = <span class="keyword">new</span> <span class="keyword">int</span>[constantPoolCount];                         <span class="comment">// 每个常量的偏移位置</span></span><br><span class="line">  cpInfoValues = <span class="keyword">new</span> Object[constantPoolCount];                       <span class="comment">// 每个常量的实例对象</span></span><br><span class="line">  <span class="keyword">int</span> currentCpInfoIndex = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> currentCpInfoOffset = classFileOffset + <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> currentMaxStringLength = <span class="number">0</span>;                                     <span class="comment">// 最长字符串常量</span></span><br><span class="line">  <span class="keyword">while</span> (currentCpInfoIndex &lt; constantPoolCount) &#123;</span><br><span class="line">    cpInfoOffsets[currentCpInfoIndex++] = currentCpInfoOffset + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cpInfoSize;</span><br><span class="line">    <span class="keyword">switch</span> (classFileBuffer[currentCpInfoOffset]) &#123;</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_FIELDREF_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_METHODREF_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_INTERFACE_METHODREF_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_INTEGER_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_FLOAT_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_NAME_AND_TYPE_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_DYNAMIC_TAG:</span><br><span class="line">        cpInfoSize = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_LONG_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_DOUBLE_TAG:</span><br><span class="line">        cpInfoSize = <span class="number">9</span>;</span><br><span class="line">        currentCpInfoIndex++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_UTF8_TAG:</span><br><span class="line">        cpInfoSize = <span class="number">3</span> + readUnsignedShort(currentCpInfoOffset + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (cpInfoSize &gt; currentMaxStringLength) &#123;</span><br><span class="line">          <span class="comment">// The size in bytes of this CONSTANT_Utf8 structure provides a conservative estimate</span></span><br><span class="line">          <span class="comment">// of the length in characters of the corresponding string, and is much cheaper to</span></span><br><span class="line">          <span class="comment">// compute than this exact length.</span></span><br><span class="line">          currentMaxStringLength = cpInfoSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_METHOD_HANDLE_TAG:</span><br><span class="line">        cpInfoSize = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_CLASS_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_STRING_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_METHOD_TYPE_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_PACKAGE_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_MODULE_TAG:</span><br><span class="line">        cpInfoSize = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    currentCpInfoOffset += cpInfoSize;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.maxStringLength = currentMaxStringLength;</span><br><span class="line">  <span class="comment">// The Classfile's access_flags field is just after the last constant pool entry.</span></span><br><span class="line">  <span class="keyword">this</span>.header = currentCpInfoOffset;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取 BootstrapMethods 属性(如果存在)</span></span><br><span class="line">  <span class="keyword">int</span> currentAttributeOffset = getFirstAttributeOffset();</span><br><span class="line">  <span class="keyword">int</span>[] currentBootstrapMethodOffsets = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = readUnsignedShort(currentAttributeOffset - <span class="number">2</span>); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="comment">// 读取每个 attribute_info 的属性名和属性长度</span></span><br><span class="line">    String attributeName = readUTF8(currentAttributeOffset, <span class="keyword">new</span> <span class="keyword">char</span>[maxStringLength]);</span><br><span class="line">    <span class="keyword">int</span> attributeLength = readInt(currentAttributeOffset + <span class="number">2</span>);</span><br><span class="line">    currentAttributeOffset += <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 如果当前属性名为 BootstrapMethods ，则进入处理逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (Constants.BOOTSTRAP_METHODS.equals(attributeName)) &#123;</span><br><span class="line">      <span class="comment">// Read the num_bootstrap_methods field and create an array of this size.</span></span><br><span class="line">      currentBootstrapMethodOffsets = <span class="keyword">new</span> <span class="keyword">int</span>[readUnsignedShort(currentAttributeOffset)];</span><br><span class="line">      <span class="comment">// Compute and store the offset of each 'bootstrap_methods' array field entry.</span></span><br><span class="line">      <span class="keyword">int</span> currentBootstrapMethodOffset = currentAttributeOffset + <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; currentBootstrapMethodOffsets.length; ++j) &#123;</span><br><span class="line">        currentBootstrapMethodOffsets[j] = currentBootstrapMethodOffset;</span><br><span class="line">        <span class="comment">// Skip the bootstrap_method_ref and num_bootstrap_arguments fields (2 bytes each),</span></span><br><span class="line">        <span class="comment">// as well as the bootstrap_arguments array field (of size num_bootstrap_arguments * 2).</span></span><br><span class="line">        currentBootstrapMethodOffset +=</span><br><span class="line">            <span class="number">4</span> + readUnsignedShort(currentBootstrapMethodOffset + <span class="number">2</span>) * <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    currentAttributeOffset += attributeLength;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.bootstrapMethodOffsets = currentBootstrapMethodOffsets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，ClassReader 已经解析了包括 magic, minor version, major version, constant pool 。<br>但是，诸如 field_info, method_info, attribute_info 等仍然没有得到处理。</p><p>这部分的内容在 accept(…) 和 readXXX(…) 中将得到解析。</p><p>主要流程类似:</p><ol><li>读取当前内容的偏移量(相较于整个 byte[])</li><li>解析当前的内容</li><li>调用 visitXXX 方法</li><li>在 visitXXX 方法中进行相关的处理</li><li>visitEnd</li></ol><h2 id="附录1-Trie-java"><a href="#附录1-Trie-java" class="headerlink" title="附录1 Trie.java"></a>附录1 Trie.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.fangfeng.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fangfeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/5/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_ITEM = <span class="number">700000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> AVG_LENGTH = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_NODE = MAX_ITEM * AVG_LENGTH;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> CHAR_NUM = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] nxt = <span class="keyword">new</span> <span class="keyword">int</span>[MAX_NODE][CHAR_NUM];</span><br><span class="line">    <span class="keyword">boolean</span>[] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[MAX_NODE];</span><br><span class="line">    <span class="keyword">int</span> trieIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">long</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmpIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;number != <span class="number">0</span>;number /= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nxt[tmpIndex][(<span class="keyword">int</span>) (number % <span class="number">10</span>)] == <span class="number">0</span>) &#123;</span><br><span class="line">                nxt[tmpIndex][(<span class="keyword">int</span>) (number % <span class="number">10</span>)] = ++trieIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            tmpIndex = nxt[tmpIndex][(<span class="keyword">int</span>) (number % <span class="number">10</span>)];</span><br><span class="line">        &#125;</span><br><span class="line">        flag[tmpIndex] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">query</span><span class="params">(<span class="keyword">long</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmpIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;number != <span class="number">0</span>;number /= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nxt[tmpIndex][(<span class="keyword">int</span>) (number % <span class="number">10</span>)] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tmpIndex = nxt[tmpIndex][(<span class="keyword">int</span>) (number % <span class="number">10</span>)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag[tmpIndex];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> <span class="keyword">throws</span> FileNotFoundException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        String ruleFilePath = args[<span class="number">0</span>];</span><br><span class="line">        String sendFilePath = args[<span class="number">1</span>];</span><br><span class="line">        String outFilePath = args[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        BufferedReader ruleReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(ruleFilePath)));</span><br><span class="line">        BufferedReader sendReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(sendFilePath)));</span><br><span class="line"></span><br><span class="line">        BufferedWriter outWriter = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(outFilePath)));</span><br><span class="line"></span><br><span class="line">        Trie trie = <span class="keyword">new</span> Trie();</span><br><span class="line">        String mobile;</span><br><span class="line">        <span class="keyword">while</span>((mobile = ruleReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            trie.insert(Long.parseLong(mobile));</span><br><span class="line">        &#125;</span><br><span class="line">        ruleReader.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>((mobile = sendReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(trie.query(Long.parseLong(mobile)) == <span class="keyword">false</span>) &#123;</span><br><span class="line">                outWriter.write(mobile);</span><br><span class="line">                outWriter.newLine();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sendReader.close();</span><br><span class="line"></span><br><span class="line">        outWriter.flush();</span><br><span class="line">        outWriter.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(String.format(<span class="string">"exec success! used %d ms"</span>, end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附录2-Constant-pool"><a href="#附录2-Constant-pool" class="headerlink" title="附录2 Constant pool"></a>附录2 Constant pool</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">    #1 = Methodref          #36.#75       // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">    #2 = Fieldref           #23.#76       // me/fangfeng/filter/Trie.MAX_NODE:I</span><br><span class="line">    #3 = Fieldref           #23.#77       // me/fangfeng/filter/Trie.CHAR_NUM:I</span><br><span class="line">    #4 = Class              #49           // &quot;[[I&quot;</span><br><span class="line">    #5 = Fieldref           #23.#78       // me/fangfeng/filter/Trie.nxt:[[I</span><br><span class="line">    #6 = Fieldref           #23.#79       // me/fangfeng/filter/Trie.flag:[Z</span><br><span class="line">    #7 = Fieldref           #23.#80       // me/fangfeng/filter/Trie.trieIndex:I</span><br><span class="line">    #8 = Long               10l</span><br><span class="line">   #10 = Methodref          #81.#82       // java/lang/System.currentTimeMillis:()J</span><br><span class="line">   #11 = Class              #83           // java/io/BufferedReader</span><br><span class="line">   #12 = Class              #84           // java/io/InputStreamReader</span><br><span class="line">   #13 = Class              #85           // java/io/FileInputStream</span><br><span class="line">   #14 = Methodref          #13.#86       // java/io/FileInputStream.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="line">   #15 = Methodref          #12.#87       // java/io/InputStreamReader.&quot;&lt;init&gt;&quot;:(Ljava/io/InputStream;)V</span><br><span class="line">   #16 = Methodref          #11.#88       // java/io/BufferedReader.&quot;&lt;init&gt;&quot;:(Ljava/io/Reader;)V</span><br><span class="line">   #17 = Class              #89           // java/io/BufferedWriter</span><br><span class="line">   #18 = Class              #90           // java/io/OutputStreamWriter</span><br><span class="line">   #19 = Class              #91           // java/io/FileOutputStream</span><br><span class="line">   #20 = Methodref          #19.#86       // java/io/FileOutputStream.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="line">   #21 = Methodref          #18.#92       // java/io/OutputStreamWriter.&quot;&lt;init&gt;&quot;:(Ljava/io/OutputStream;)V</span><br><span class="line">   #22 = Methodref          #17.#93       // java/io/BufferedWriter.&quot;&lt;init&gt;&quot;:(Ljava/io/Writer;)V</span><br><span class="line">   #23 = Class              #94           // me/fangfeng/filter/Trie</span><br><span class="line">   #24 = Methodref          #23.#75       // me/fangfeng/filter/Trie.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #25 = Methodref          #11.#95       // java/io/BufferedReader.readLine:()Ljava/lang/String;</span><br><span class="line">   #26 = Methodref          #96.#97       // java/lang/Long.parseLong:(Ljava/lang/String;)J</span><br><span class="line">   #27 = Methodref          #23.#98       // me/fangfeng/filter/Trie.insert:(J)V</span><br><span class="line">   #28 = Methodref          #11.#99       // java/io/BufferedReader.close:()V</span><br><span class="line">   #29 = Methodref          #23.#100      // me/fangfeng/filter/Trie.query:(J)Z</span><br><span class="line">   #30 = Methodref          #17.#101      // java/io/BufferedWriter.write:(Ljava/lang/String;)V</span><br><span class="line">   #31 = Methodref          #17.#102      // java/io/BufferedWriter.newLine:()V</span><br><span class="line">   #32 = Methodref          #17.#103      // java/io/BufferedWriter.flush:()V</span><br><span class="line">   #33 = Methodref          #17.#99       // java/io/BufferedWriter.close:()V</span><br><span class="line">   #34 = Fieldref           #81.#104      // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #35 = String             #105          // exec success! used %d ms</span><br><span class="line">   #36 = Class              #106          // java/lang/Object</span><br><span class="line">   #37 = Methodref          #96.#107      // java/lang/Long.valueOf:(J)Ljava/lang/Long;</span><br><span class="line">   #38 = Methodref          #108.#109     // java/lang/String.format:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;</span><br><span class="line">   #39 = Methodref          #110.#111     // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #40 = Integer            700000</span><br><span class="line">   #41 = Fieldref           #23.#112      // me/fangfeng/filter/Trie.MAX_ITEM:I</span><br><span class="line">   #42 = Fieldref           #23.#113      // me/fangfeng/filter/Trie.AVG_LENGTH:I</span><br><span class="line">   #43 = Utf8               MAX_ITEM</span><br><span class="line">   #44 = Utf8               I</span><br><span class="line">   #45 = Utf8               AVG_LENGTH</span><br><span class="line">   #46 = Utf8               MAX_NODE</span><br><span class="line">   #47 = Utf8               CHAR_NUM</span><br><span class="line">   #48 = Utf8               nxt</span><br><span class="line">   #49 = Utf8               [[I</span><br><span class="line">   #50 = Utf8               flag</span><br><span class="line">   #51 = Utf8               [Z</span><br><span class="line">   #52 = Utf8               trieIndex</span><br><span class="line">   #53 = Utf8               &lt;init&gt;</span><br><span class="line">   #54 = Utf8               ()V</span><br><span class="line">   #55 = Utf8               Code</span><br><span class="line">   #56 = Utf8               LineNumberTable</span><br><span class="line">   #57 = Utf8               insert</span><br><span class="line">   #58 = Utf8               (J)V</span><br><span class="line">   #59 = Utf8               StackMapTable</span><br><span class="line">   #60 = Utf8               query</span><br><span class="line">   #61 = Utf8               (J)Z</span><br><span class="line">   #62 = Utf8               main</span><br><span class="line">   #63 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">   #64 = Class              #114          // &quot;[Ljava/lang/String;&quot;</span><br><span class="line">   #65 = Class              #115          // java/lang/String</span><br><span class="line">   #66 = Class              #83           // java/io/BufferedReader</span><br><span class="line">   #67 = Class              #89           // java/io/BufferedWriter</span><br><span class="line">   #68 = Class              #94           // me/fangfeng/filter/Trie</span><br><span class="line">   #69 = Utf8               Exceptions</span><br><span class="line">   #70 = Class              #116          // java/io/FileNotFoundException</span><br><span class="line">   #71 = Class              #117          // java/io/IOException</span><br><span class="line">   #72 = Utf8               &lt;clinit&gt;</span><br><span class="line">   #73 = Utf8               SourceFile</span><br><span class="line">   #74 = Utf8               Trie.java</span><br><span class="line">   #75 = NameAndType        #53:#54       // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #76 = NameAndType        #46:#44       // MAX_NODE:I</span><br><span class="line">   #77 = NameAndType        #47:#44       // CHAR_NUM:I</span><br><span class="line">   #78 = NameAndType        #48:#49       // nxt:[[I</span><br><span class="line">   #79 = NameAndType        #50:#51       // flag:[Z</span><br><span class="line">   #80 = NameAndType        #52:#44       // trieIndex:I</span><br><span class="line">   #81 = Class              #118          // java/lang/System</span><br><span class="line">   #82 = NameAndType        #119:#120     // currentTimeMillis:()J</span><br><span class="line">   #83 = Utf8               java/io/BufferedReader</span><br><span class="line">   #84 = Utf8               java/io/InputStreamReader</span><br><span class="line">   #85 = Utf8               java/io/FileInputStream</span><br><span class="line">   #86 = NameAndType        #53:#121      // &quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="line">   #87 = NameAndType        #53:#122      // &quot;&lt;init&gt;&quot;:(Ljava/io/InputStream;)V</span><br><span class="line">   #88 = NameAndType        #53:#123      // &quot;&lt;init&gt;&quot;:(Ljava/io/Reader;)V</span><br><span class="line">   #89 = Utf8               java/io/BufferedWriter</span><br><span class="line">   #90 = Utf8               java/io/OutputStreamWriter</span><br><span class="line">   #91 = Utf8               java/io/FileOutputStream</span><br><span class="line">   #92 = NameAndType        #53:#124      // &quot;&lt;init&gt;&quot;:(Ljava/io/OutputStream;)V</span><br><span class="line">   #93 = NameAndType        #53:#125      // &quot;&lt;init&gt;&quot;:(Ljava/io/Writer;)V</span><br><span class="line">   #94 = Utf8               me/fangfeng/filter/Trie</span><br><span class="line">   #95 = NameAndType        #126:#127     // readLine:()Ljava/lang/String;</span><br><span class="line">   #96 = Class              #128          // java/lang/Long</span><br><span class="line">   #97 = NameAndType        #129:#130     // parseLong:(Ljava/lang/String;)J</span><br><span class="line">   #98 = NameAndType        #57:#58       // insert:(J)V</span><br><span class="line">   #99 = NameAndType        #131:#54      // close:()V</span><br><span class="line">  #100 = NameAndType        #60:#61       // query:(J)Z</span><br><span class="line">  #101 = NameAndType        #132:#121     // write:(Ljava/lang/String;)V</span><br><span class="line">  #102 = NameAndType        #133:#54      // newLine:()V</span><br><span class="line">  #103 = NameAndType        #134:#54      // flush:()V</span><br><span class="line">  #104 = NameAndType        #135:#136     // out:Ljava/io/PrintStream;</span><br><span class="line">  #105 = Utf8               exec success! used %d ms</span><br><span class="line">  #106 = Utf8               java/lang/Object</span><br><span class="line">  #107 = NameAndType        #137:#138     // valueOf:(J)Ljava/lang/Long;</span><br><span class="line">  #108 = Class              #115          // java/lang/String</span><br><span class="line">  #109 = NameAndType        #139:#140     // format:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;</span><br><span class="line">  #110 = Class              #141          // java/io/PrintStream</span><br><span class="line">  #111 = NameAndType        #142:#121     // println:(Ljava/lang/String;)V</span><br><span class="line">  #112 = NameAndType        #43:#44       // MAX_ITEM:I</span><br><span class="line">  #113 = NameAndType        #45:#44       // AVG_LENGTH:I</span><br><span class="line">  #114 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #115 = Utf8               java/lang/String</span><br><span class="line">  #116 = Utf8               java/io/FileNotFoundException</span><br><span class="line">  #117 = Utf8               java/io/IOException</span><br><span class="line">  #118 = Utf8               java/lang/System</span><br><span class="line">  #119 = Utf8               currentTimeMillis</span><br><span class="line">  #120 = Utf8               ()J</span><br><span class="line">  #121 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  #122 = Utf8               (Ljava/io/InputStream;)V</span><br><span class="line">  #123 = Utf8               (Ljava/io/Reader;)V</span><br><span class="line">  #124 = Utf8               (Ljava/io/OutputStream;)V</span><br><span class="line">  #125 = Utf8               (Ljava/io/Writer;)V</span><br><span class="line">  #126 = Utf8               readLine</span><br><span class="line">  #127 = Utf8               ()Ljava/lang/String;</span><br><span class="line">  #128 = Utf8               java/lang/Long</span><br><span class="line">  #129 = Utf8               parseLong</span><br><span class="line">  #130 = Utf8               (Ljava/lang/String;)J</span><br><span class="line">  #131 = Utf8               close</span><br><span class="line">  #132 = Utf8               write</span><br><span class="line">  #133 = Utf8               newLine</span><br><span class="line">  #134 = Utf8               flush</span><br><span class="line">  #135 = Utf8               out</span><br><span class="line">  #136 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #137 = Utf8               valueOf</span><br><span class="line">  #138 = Utf8               (J)Ljava/lang/Long;</span><br><span class="line">  #139 = Utf8               format</span><br><span class="line">  #140 = Utf8               (Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;</span><br><span class="line">  #141 = Utf8               java/io/PrintStream</span><br><span class="line">  #142 = Utf8               println</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
  </entry>
  
</feed>
