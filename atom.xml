<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Utop&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://DorMOUSE-None.github.io/"/>
  <updated>2018-10-06T11:26:22.419Z</updated>
  <id>https://DorMOUSE-None.github.io/</id>
  
  <author>
    <name>Utop</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://DorMOUSE-None.github.io/-@understand-Kernel-3/"/>
    <id>https://DorMOUSE-None.github.io/-@understand-Kernel-3/</id>
    <published>2018-10-06T11:26:22.414Z</published>
    <updated>2018-10-06T11:26:22.419Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>理解 Linux Kernel (3) - 操作系统启动</title>
    <link href="https://DorMOUSE-None.github.io/2018-10-06-understand-Kernel-3/"/>
    <id>https://DorMOUSE-None.github.io/2018-10-06-understand-Kernel-3/</id>
    <published>2018-10-05T16:00:00.000Z</published>
    <updated>2018-10-06T11:26:56.685Z</updated>
    
    <content type="html"><![CDATA[<p>这次拖得有够久的，毕竟需要将知识串联起来并不是一件容易的事情。更何况很多内容可以说和常理(个人理解的常理)有了比较大的偏差。</p><p>不过确实比较有意思。从引导程序到操作系统启动，这中间究竟经历了多少流程呢？</p><p>由于有了前几节的内容，这里不会再对引导程序及汇编语法做过多的介绍。而着重在于整个流程的描述。</p><a id="more"></a><h2 id="引导程序"><a href="#引导程序" class="headerlink" title="引导程序"></a>引导程序</h2><p>从 BIOS 将512字节长的引导程序加载到物理内存<code>0x7c00</code>开始的连续递增空间后，即将程序的执行权交给了引导程序(这里指的执行权可以简单理解成CS:IP)</p><blockquote><p><em>CS:IP</em></p><p><strong>CS</strong>. 代码段基址。一般用于划定一段连续代码开始的地址。是一个16位段寄存器，类似的还有 DS, ES, FS, GS, SS 等16位段寄存器，分别提供不同的段基址存储功能)<br><strong>IP</strong>. 代码段偏移值。配合 CS 共同为 CPU 确定下一个将要被执行的机器指令的线性地址。</p></blockquote><p>Linux 0.11 版本的引导程序实现的支持比较简单。</p><ol><li>将引导程序代码(自身) 512 字节的内容移动到 <code>0x90000</code> 开始的 512B 内存空间上</li><li>跳到 <code>0x90000</code> 开始的段的相应位置继续执行</li><li>从磁盘中读取 4*512 字节的 setup 程序的二进制内容</li><li>读取操作系统的二进制内容到内存 <code>0x10000</code> 开始的连续地址空间中 (此处最大可以有 0x90000 - 0x10000 = 0x80000 = 512 KB，即当时的操作系统二进制程序+数据最大只能是 512KB, 不过也很多了)</li><li>确认将要作为文件系统的磁盘是否存在</li><li>将控制权交给 setup 程序</li></ol><h2 id="SETUP-程序"><a href="#SETUP-程序" class="headerlink" title="SETUP 程序"></a>SETUP 程序</h2><p><strong>读取硬件配置</strong></p><p>setup 程序，顾名思义，就是在搞一些配置。那么究竟在配置什么？</p><p>就是通过 BIOS 中断读取各种硬件信息(诸如内存大小，显示器长宽比，磁盘等)，并将它们存储在内存的指定位置。</p><p>哈哈，由于引导程序已经执行完了，再也不会使用了。因此，setup 程序就是将这些信息存储到了原引导程序所在的位置，即 0x90000 ~ 0x901FF 共 512 B 的内存中。</p><p>当然，每个字节存的是什么内容都是一种约定(比如 setup 程序把内存大小的信息存到了哪，后面其它程序就到相应的位置去取)。</p><p><strong>移动操作系统程序</strong></p><p>OK，setup 程序也不是仅仅只干这么点事情的，不然要 4*512 字节岂不是太浪费了，哪用得了这么多。</p><p>setup 还要负责将操作系统程序移动到<em>方便</em>的位置。前面将操作系统程序加载到了内存 0x10000 处，主要是为了暂时保持 BIOS 中断向量表 (位于 0x0000 开始的连续 1024 B 内存中，由 BIOS 程序创建，用于各种中断调用) 。在 setup 决定不再使用 BIOS 中断之后，就已经可以完全废弃了。</p><p>因此，操作系统程序将从 0x10000 顺次移动到 0x00000 的位置。</p><p><strong>重置中断</strong></p><p>软中断与硬中断，应该是在软硬件划分下唯二的两种中断形式。软中断一般通过汇编指令 <code>INT {中断号}</code> 的形式通过软件执行的形式产生，而硬中断是硬件由于某些错误指令而自动产生的中断。</p><p>当然，这些中断都需要 CPU 进行相应的处理。那么，在 BIOS  中断向量表被覆盖了之后，如何来处理这些中断呢？</p><p>首先，在上一步 <strong>移动操作系统程序</strong> 开始时，就直接通过汇编指令 <code>cli</code> 强制禁止除 <em>非可屏蔽中断</em> 外的所有中断，因此也就基本不考虑中断的问题。</p><p>但是，总还得解除禁止吧。因此，setup 程序尽快地重新编制了硬件中断，进入保护模式。使用保护模式下的中断描述符表来替代 BIOS 中断向量表。</p><p>至于如何创建中断描述符表，哈哈，这都是直接在汇编编程的时候写好的。直接划出了一块区域写上了中断描述符表的表项，然后与 setup 代码一起被读取到了内存的指定位置。至于唯一要做的，就是将 IDTR (中断描述符表寄存器) 修改为中断描述符表在内存的开始地址。</p><p><strong>进入保护模式</strong></p><p>首先，简单介绍一下实模式 &amp; 保护模式。</p><p>保护模式与实模式的主要区别，就在于两者的内存寻址方式，归根结底也就是段寄存器如何辅助完成内存地址定位的问题。</p><p>先简单的回顾下实模式下的寻址方式</p><p>段寄存器的出现，很大程度上是为了对 16 bit CPU 下可寻址地址不足所作出的补充。<br>诸如 CS:IP = 0x07C0:0x0001 -&gt; 0x07C01 。通过CS:IP 的配合，物理地址 = CS &lt;&lt; 4 + IP ，将原本 128 KB 的可寻址空间扩展到 0xFFFF:0xFFFF -&gt; 0x10FFFE 的寻址空间</p><p>而保护模式的出现，也是由于实模式下的地址寻址仍然不能满足对内存寻址的需求。</p><p>那么保护模式究竟将如何进行寻址呢？简单来说就是通过新增了一个寄存器 GDTR (全局描述符表寄存器。当然，暂时不考虑 LDTR) 用来存储全局描述符表(全局描述符表是一些在内存中的有结构的数据) ，那么类似的，本来是段寄存器中是表示一个内存段基址，现在通过借助中间项 (GDTR) ，由全局描述符表的每一个表项来表示每一个内存段基址，从而达到在最大 4GB 的内存中进行内存地址的寻址。</p><p>而与上面的中断描述符表类似的，全局描述符表也是以同样的方式，预先写好，然后设置一下 GDTR 就 OK 了。</p><p><strong>转入操作系统程序</strong></p><p>最后的最后，当然是把控制权交给操作系统程序。即跳转到内存 0x00000 处。当然，由于现在已经处于保护模式下，因此 jmp 指令略有不同。 为 <code>jmpi 0, 8</code>。</p><p>简单解释一下这一条指令 </p><p><code>jmpi</code> 指令表示进行段间跳转。(段间跳转与段内跳转的区别在于: 程序代码的寻址一般通过 CS:IP 配合完成，如果是段内跳转，则段基址不变，即 CS 不变，只需要给出 IP 即可；而段间跳转需要同时给出新的段基址(CS)和新的段偏移(IP)。</p><p><code>0</code> 这里 0 就表示的是段偏移。</p><p><code>8</code> 保护模式下的段寄存器以一种特殊的方式来配合 GDTR/LDTR 来完成对全局/局部描述符表项的定位。如下图所示。最后两位表示特权级，用于区分用户态(11) or 内核态(00) (Linux 只使用了两个，还有 01 和 10 不使用)</p><p>第三位表示使用 GDTR 还是 LDTR</p><p>高 13 位共同组成了对 GDTR/LDTR 表项的描述，究竟使用哪一个表项。当然，这里其实也侧面反映了，其实每个全局描述符表/局部描述符表最多只能有 $2^{13} = 8192$ 个表项。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fulm7vumywj31220aw74f.jpg" alt=""></p><h2 id="操作系统程序"><a href="#操作系统程序" class="headerlink" title="操作系统程序"></a>操作系统程序</h2><p>终于要到操作系统程序了。这个就比较复杂了。这里只简单描述将操作系统启动起来的最基本使用到的代码。其它以后继续。</p><p>其实整一个操作系统程序是一个比较大的量，毕竟最大能够达到 512 KB 呢。</p><p>简单的看一下文档树，见附录一，编译前的源代码文件总计 100 多个。</p><p>首先被执行的是 head.s 中的代码，这里完成的工作主要包括:</p><ol><li><p>重新编制每个中断的具体处理代码(这个应该比较好理解，说到底中断出现了，也还是要通过实现代码来完成中断逻辑。不论是 BIOS 中断向量还是保护模式下使用的中断描述符表，都不过是记录了一下中断处理代码的位置，进行了定位而已)。</p></li><li><p>初始化分页模式(不详述，以后有机会在说)</p></li><li><p>验证 80387 数学协处理器。</p></li><li><p>进入 main.c 程序 (既然 Linus 都将其命名为 main 了，那么显然这是整个操作系统最核心的部分了)。</p></li></ol><h3 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h3><p>下面将简单给出 main.c 程序的两段代码 <code>main(...)</code> 和 <code>init(...)</code>，并直接针对代码进行直接解释。</p><h4 id="main-void"><a href="#main-void" class="headerlink" title="main(void)"></a>main(void)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> ROOT_DEV = ORIG_ROOT_DEV;   <span class="comment">// 读取在引导程序执行时获取到的文件系统所在的磁盘</span></span><br><span class="line"> drive_info = DRIVE_INFO;</span><br><span class="line">memory_end = (<span class="number">1</span>&lt;&lt;<span class="number">20</span>) + (EXT_MEM_K&lt;&lt;<span class="number">10</span>); <span class="comment">// 首先先确认整个内存的大小</span></span><br><span class="line">memory_end &amp;= <span class="number">0xfffff000</span>;               <span class="comment">// 当然，这里为了分页方便 (每页 4096 B)，直接将不满一页的内存忽略掉了</span></span><br><span class="line"><span class="keyword">if</span> (memory_end &gt; <span class="number">16</span>*<span class="number">1024</span>*<span class="number">1024</span>)          <span class="comment">// 最大支持 16 MB 的内存，这里是 Linus 当时的机器只有 16 MB，因此没有做更大内存的支持，但可以自己去改源码</span></span><br><span class="line">memory_end = <span class="number">16</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">if</span> (memory_end &gt; <span class="number">12</span>*<span class="number">1024</span>*<span class="number">1024</span>)          <span class="comment">// 确认缓存区的末地址 (根据实际内存大小调整, &gt;12MB 留 4MB 缓存，&gt;6MB 留 2 MB 缓存，否则 1MB )</span></span><br><span class="line">buffer_memory_end = <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (memory_end &gt; <span class="number">6</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">buffer_memory_end = <span class="number">2</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">buffer_memory_end = <span class="number">1</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">main_memory_start = buffer_memory_end;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RAMDISK</span></span><br><span class="line">main_memory_start += rd_init(main_memory_start, RAMDISK*<span class="number">1024</span>);      <span class="comment">// 如果需要虚拟盘，则再留一部分作为交换区</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">mem_init(main_memory_start,memory_end); <span class="comment">// 内存初始化，毕竟 Linux 操作系统下的所有内存都将被统一分配，用户程序没有权限随便使用内存，只能用被分配的</span></span><br><span class="line">trap_init();            <span class="comment">// 初始化中断</span></span><br><span class="line">blk_dev_init();         <span class="comment">// 初始化块设备</span></span><br><span class="line">chr_dev_init();         <span class="comment">// 初始化字符设备</span></span><br><span class="line">tty_init();             <span class="comment">// 初始化 tty</span></span><br><span class="line">time_init();            <span class="comment">// 设置开机启动时间</span></span><br><span class="line">sched_init();           <span class="comment">// 初始化任务调度程序，由此就将可以进行多任务切换了</span></span><br><span class="line">buffer_init(buffer_memory_end); <span class="comment">// 缓存区初始化</span></span><br><span class="line">hd_init();              <span class="comment">// 硬盘初始化</span></span><br><span class="line">floppy_init();          <span class="comment">// 软盘初始化</span></span><br><span class="line">sti();                  <span class="comment">// 不再禁止中断，现在开始又允许中断了</span></span><br><span class="line">move_to_user_mode();    <span class="comment">// 进入用户态</span></span><br><span class="line"><span class="keyword">if</span> (!fork()) &#123;          <span class="comment">// 关于 fork 函数，下面将简单介绍。</span></span><br><span class="line">init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(;;) pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>fork()</strong></p><p>如果熟悉 C 语言，应该对 fork() 也比较熟悉吧。这将执行一次系统调用，最终的结果是，创建一个新的任务 (这里将原来的操作系统程序认为是 0 号进程/任务，将产生 1 号进程/任务)。新的任务与原有任务几乎一模一样，除了 fork() 调用的返回值不同。子任务将返回 0 ，原有任务将返回子任务的任务号。</p><p>因此，对于上面的代码，<code>if(!fork())</code> ，0号任务将不执行 <code>if(){}</code> 语句块内的 init ，而 1 号任务将执行 <code>init()</code> 函数</p><p>而 0 号进程在做什么呢? </p><p>很简单，下面 <code>for(;;) pause();</code>。 <code>pause()</code> 是指让 CPU 完全停止，只有发生硬件中断， CPU 才会从停止状态中恢复 (前面已经设置了定时的/ 10ms/次的时钟中断，因此 CPU 总是能够恢复)， </p><p>具体的描述就是，如果任务调度程序把时间片分配给了 0 号进程，那么 0 号进程唯一做的，就是让 CPU 停止。而且 0 号进程的 <code>for</code> 是死循环，每次把时间分配给 0 号进程，它就 CPU 停止。我们在 Linux 操作系统上，通过 top 可以看到对 cpu 有如下描述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%Cpu(s):  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br></pre></td></tr></table></figure><p>其中对 idle(id) 的统计，其实就在 0 号任务让 cpu 停止工作了而已。</p><h4 id="init-void"><a href="#init-void" class="headerlink" title="init(void)"></a>init(void)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pid,i;</span><br><span class="line"></span><br><span class="line">setup((<span class="keyword">void</span> *) &amp;drive_info);</span><br><span class="line">(<span class="keyword">void</span>) open(<span class="string">"/dev/tty0"</span>,O_RDWR,<span class="number">0</span>);</span><br><span class="line">(<span class="keyword">void</span>) dup(<span class="number">0</span>);</span><br><span class="line">(<span class="keyword">void</span>) dup(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d buffers = %d bytes buffer space\n\r"</span>,NR_BUFFERS,</span><br><span class="line">NR_BUFFERS*BLOCK_SIZE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Free mem: %d bytes\n\r"</span>,memory_end-main_memory_start);</span><br><span class="line"><span class="keyword">if</span> (!(pid=fork())) &#123;</span><br><span class="line">close(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (open(<span class="string">"/etc/rc"</span>,O_RDONLY,<span class="number">0</span>))</span><br><span class="line">_exit(<span class="number">1</span>);</span><br><span class="line">execve(<span class="string">"/bin/sh"</span>,argv_rc,envp_rc);</span><br><span class="line">_exit(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pid&gt;<span class="number">0</span>)</span><br><span class="line"><span class="keyword">while</span> (pid != wait(&amp;i))</span><br><span class="line"><span class="comment">/* nothing */</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ((pid=fork())&lt;<span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Fork failed in init\r\n"</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!pid) &#123;</span><br><span class="line">close(<span class="number">0</span>);close(<span class="number">1</span>);close(<span class="number">2</span>);</span><br><span class="line">setsid();</span><br><span class="line">(<span class="keyword">void</span>) open(<span class="string">"/dev/tty0"</span>,O_RDWR,<span class="number">0</span>);</span><br><span class="line">(<span class="keyword">void</span>) dup(<span class="number">0</span>);</span><br><span class="line">(<span class="keyword">void</span>) dup(<span class="number">0</span>);</span><br><span class="line">_exit(execve(<span class="string">"/bin/sh"</span>,argv,envp));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> (pid == wait(&amp;i))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n\rchild %d died with code %04x\n\r"</span>,pid,i);</span><br><span class="line">sync();</span><br><span class="line">&#125;</span><br><span class="line">_exit(<span class="number">0</span>);<span class="comment">/* NOTE! _exit, not exit() */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么 1 号任务在做什么呢？看 init 的代码，可以看到大量诸如 <code>/dev/tty0</code>, <code>/bin/sh</code> 的代码。哈哈，下面通过 1,2,3… 对步骤进行标号简单描述一下。</p><ol><li><p>1 号进程在做的是 fork 出新的进程(暂时叫它进程 X )</p></li><li><p>1 号进程不断询问 X 是否被销毁 </p><ul><li>如果 X 进程被销毁了：那么继续执行步骤 1</li><li>否则：继续执行步骤 2 （为什么会出现不断循环呢？其实由于任务调度程序的存在，在单个 CPU 看来，这个轮询并不一直发生，有一些时间片已经给了其他进程继续执行任务了</li></ul></li><li><p>X 任务通过调用 <code>execve()</code> 把当前程序的代码+数据全部替换成是 shell 的 (其实大量的用户程序都是通过这种 fork + execve 的形式出现的)</p></li><li>X 任务(也就是 Shell 程序) 开始通过 tty 与用户开始交互。直到用户选择 <code>exit</code> 退出 shell </li></ol><p><strong>execve(…)</strong></p><p>前面介绍过 fork 是复制一份程序的各个寄存器的状态 + 程序的数据。现在 execve 做出的操作是直接将当前程序的代码和数据替换成目标程序的代码和数据，并通过对寄存器一定的重置，完成一个用户程序的启动流程(程序启动说到底不就是在内存中存在这个程序的代码，然后通过 CS:IP 定位到即将执行的程序指令，最后让 CPU 开始执行就 OK 了)</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>整个操作系统的启动流程就简单地介绍到这里。</p><p>0 号任务作为操作系统的常驻程序，在 OS 启动完成，每次时间片被分配给它，它就让 CPU 停止工作(通过 pause() 系统调用)</p><p>1 号任务作为操作系统的常驻程序，唯一的任务就是判断进程X是否被退出，如果退出了，就重新创建一个(当然，也可能有人有疑问，为什么现在的 Linux 开多个 bash 都没有问题呢? 这里有个猜测是有一个隐藏的 shell 是被 1 号任务启动的，其它的 bash 是多余的。不过这只是猜测，待考察)</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="附录一"><a href="#附录一" class="headerlink" title="附录一"></a>附录一</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">|-- Makefile</span><br><span class="line">|-- boot</span><br><span class="line">|   |-- head.s</span><br><span class="line">|-- fs</span><br><span class="line">|   |-- Makefile</span><br><span class="line">|   |-- bitmap.c</span><br><span class="line">|   |-- block_dev.c</span><br><span class="line">|   |-- buffer.c</span><br><span class="line">|   |-- char_dev.c</span><br><span class="line">|   |-- exec.c</span><br><span class="line">|   |-- fcntl.c</span><br><span class="line">|   |-- file_dev.c</span><br><span class="line">|   |-- file_table.c</span><br><span class="line">|   |-- inode.c</span><br><span class="line">|   |-- ioctl.c</span><br><span class="line">|   |-- namei.c</span><br><span class="line">|   |-- open.c</span><br><span class="line">|   |-- pipe.c</span><br><span class="line">|   |-- read_write.c</span><br><span class="line">|   |-- stat.c</span><br><span class="line">|   |-- super.c</span><br><span class="line">|   `-- truncate.c</span><br><span class="line">|-- include</span><br><span class="line">|   |-- a.out.h</span><br><span class="line">|   |-- asm</span><br><span class="line">|   |   |-- io.h</span><br><span class="line">|   |   |-- memory.h</span><br><span class="line">|   |   |-- segment.h</span><br><span class="line">|   |   `-- system.h</span><br><span class="line">|   |-- const.h</span><br><span class="line">|   |-- ctype.h</span><br><span class="line">|   |-- errno.h</span><br><span class="line">|   |-- fcntl.h</span><br><span class="line">|   |-- linux</span><br><span class="line">|   |   |-- config.h</span><br><span class="line">|   |   |-- fdreg.h</span><br><span class="line">|   |   |-- fs.h</span><br><span class="line">|   |   |-- hdreg.h</span><br><span class="line">|   |   |-- head.h</span><br><span class="line">|   |   |-- kernel.h</span><br><span class="line">|   |   |-- mm.h</span><br><span class="line">|   |   |-- sched.h</span><br><span class="line">|   |   |-- sys.h</span><br><span class="line">|   |   `-- tty.h</span><br><span class="line">|   |-- signal.h</span><br><span class="line">|   |-- stdarg.h</span><br><span class="line">|   |-- stddef.h</span><br><span class="line">|   |-- string.h</span><br><span class="line">|   |-- sys</span><br><span class="line">|   |   |-- stat.h</span><br><span class="line">|   |   |-- times.h</span><br><span class="line">|   |   |-- types.h</span><br><span class="line">|   |   |-- utsname.h</span><br><span class="line">|   |   `-- wait.h</span><br><span class="line">|   |-- termios.h</span><br><span class="line">|   |-- time.h</span><br><span class="line">|   |-- unistd.h</span><br><span class="line">|   `-- utime.h</span><br><span class="line">|-- init</span><br><span class="line">|   |-- main.c</span><br><span class="line">|-- kernel</span><br><span class="line">|   |-- Makefile</span><br><span class="line">|   |-- asm.o</span><br><span class="line">|   |-- asm.s</span><br><span class="line">|   |-- blk_drv</span><br><span class="line">|   |   |-- Makefile</span><br><span class="line">|   |   |-- blk.h</span><br><span class="line">|   |   |-- floppy.c</span><br><span class="line">|   |   |-- hd.c</span><br><span class="line">|   |   |-- ll_rw_blk.c</span><br><span class="line">|   |   `-- ramdisk.c</span><br><span class="line">|   |-- chr_drv</span><br><span class="line">|   |   |-- Makefile</span><br><span class="line">|   |   |-- console.c</span><br><span class="line">|   |   |-- keyboard.S</span><br><span class="line">|   |   |-- rs_io.s</span><br><span class="line">|   |   |-- serial.c</span><br><span class="line">|   |   |-- tty_io.c</span><br><span class="line">|   |   `-- tty_ioctl.c</span><br><span class="line">|   |-- exit.c</span><br><span class="line">|   |-- fork.c</span><br><span class="line">|   |-- fork.i</span><br><span class="line">|   |-- math</span><br><span class="line">|   |   |-- Makefile</span><br><span class="line">|   |   `-- math_emulate.c</span><br><span class="line">|   |-- mktime.c</span><br><span class="line">|   |-- panic.c</span><br><span class="line">|   |-- printk.c</span><br><span class="line">|   |-- sched.c</span><br><span class="line">|   |-- sched.o</span><br><span class="line">|   |-- signal.c</span><br><span class="line">|   |-- sys.c</span><br><span class="line">|   |-- system_call.o</span><br><span class="line">|   |-- system_call.s</span><br><span class="line">|   |-- traps.c</span><br><span class="line">|   |-- traps.o</span><br><span class="line">|   `-- vsprintf.c</span><br><span class="line">|-- lib</span><br><span class="line">|   |-- Makefile</span><br><span class="line">|   |-- _exit.c</span><br><span class="line">|   |-- close.c</span><br><span class="line">|   |-- ctype.c</span><br><span class="line">|   |-- dup.c</span><br><span class="line">|   |-- errno.c</span><br><span class="line">|   |-- execve.c</span><br><span class="line">|   |-- malloc.c</span><br><span class="line">|   |-- open.c</span><br><span class="line">|   |-- setsid.c</span><br><span class="line">|   |-- string.c</span><br><span class="line">|   |-- wait.c</span><br><span class="line">|   `-- write.c</span><br><span class="line">|-- mm</span><br><span class="line">|   |-- Makefile</span><br><span class="line">|   |-- memory.c</span><br><span class="line">|   `-- page.s</span><br><span class="line">`-- tools</span><br><span class="line">    `-- build.c</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次拖得有够久的，毕竟需要将知识串联起来并不是一件容易的事情。更何况很多内容可以说和常理(个人理解的常理)有了比较大的偏差。&lt;/p&gt;
&lt;p&gt;不过确实比较有意思。从引导程序到操作系统启动，这中间究竟经历了多少流程呢？&lt;/p&gt;
&lt;p&gt;由于有了前几节的内容，这里不会再对引导程序及汇编语法做过多的介绍。而着重在于整个流程的描述。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://DorMOUSE-None.github.io/tags/Linux/"/>
    
      <category term="Kernel" scheme="https://DorMOUSE-None.github.io/tags/Kernel/"/>
    
      <category term="OS" scheme="https://DorMOUSE-None.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Understand MAIL</title>
    <link href="https://DorMOUSE-None.github.io/2018-09-27-mail/"/>
    <id>https://DorMOUSE-None.github.io/2018-09-27-mail/</id>
    <published>2018-09-26T16:00:00.000Z</published>
    <updated>2018-09-28T10:10:21.579Z</updated>
    
    <content type="html"><![CDATA[<p>在网络协议上，高层协议确实比底层协议更容易理解，也更加的人性化。<br>传输层的 TCP, UDP 都还停留在各种字节内容的整合和校验上，而更上层的应用层协议就已经能够直观到通过直接解读就能理解其每条消息的含义了。</p><a id="more"></a><h2 id="SMTP-协议"><a href="#SMTP-协议" class="headerlink" title="SMTP 协议"></a>SMTP 协议</h2><p>SMTP，简单邮件传输协议。单从协议内容上来说确实没有太多的学习难度。但是，扭转“常识”恰恰是巨大的绊脚石。<br>直接就进入了网页邮件系统 or 客户端邮件系统的时代。图形化的界面配合上一些关键字的内容 (比如收件人，主题等)。<br>点击发送就觉得一封邮件已经发出去了。</p><p>但是，究竟这中间做了什么呢？<br>163，GMAIL, QQ 等邮箱究竟又在其中扮演着怎样的一个角色？</p><p>首先，SMTP 是为了高效、可靠地传递邮件而存在的。</p><p>下面先给一段演示。通过 telnet 连接到 183.57.48.34 (这个是腾讯企业邮其中一台机器的 IP) 25 (SMTP 服务端口) ，以本机作为 SMTP 的客户端，而将 183.XXX 作为 SMTP 的服务端，来完成邮件信息的一次交互。 (当然，最后失败了。被企业邮识别为垃圾邮件了…)</p><p>下列每行 <code>#</code> 开始及之后的内容是个人添加的注释，其它内容是 telnet 交互的内容。<br>同时，<code>--</code> 标志该行内容由</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ telnet 183.57.48.34 25</span><br><span class="line">Trying 183.57.48.34...</span><br><span class="line">Connected to 183.57.48.34.</span><br><span class="line">Escape character is &apos;^]&apos;.</span><br><span class="line">220 bizmx17.qq.com MX QQ Mail Server</span><br><span class="line">HELO test                               -- # MEANS HELLO &lt;domain&gt; 在每次建立连接通道后，发送的第一条消息</span><br><span class="line">250 bizmx17.qq.com                         # 服务器的回复值 Code 250 </span><br><span class="line">MAIL FROM: &lt;from@test.net&gt;              -- # MAIL 表示邮件的发起方，用于退信等其他邮件反向事件</span><br><span class="line">250 Ok                                   </span><br><span class="line">RCPT TO: &lt;to@xxx.xxx&gt;                   -- # RCPT 表示邮件的接收方，用于投递邮件等正向事件</span><br><span class="line">250 Ok</span><br><span class="line">DATA                                    -- # DATA 表示之后的内容将作为邮件正文 (正文这个描述可能不太恰当，更应该是等同于信封内的所有内容)</span><br><span class="line">354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;</span><br><span class="line">                                        --</span><br><span class="line">It&apos;s a fake mail.                       -- # 邮件正文，其实还可以写上诸如 &apos;Subject: XXX&apos; &apos;Cc: XXX&apos; 的内容</span><br><span class="line">.                                       -- # 正文内容结束的标志，&lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;</span><br><span class="line">550 Mail content denied. http://service.exmail.qq.com/cgi-bin/help?subtype=1&amp;&amp;id=20022&amp;&amp;no=1000726 # 这里很无奈，没腾讯给拦了，没发出去。不过反正是假的，邮件信息不全。</span><br></pre></td></tr></table></figure><h3 id="几个主要的-SMTP-交互指令"><a href="#几个主要的-SMTP-交互指令" class="headerlink" title="几个主要的 SMTP 交互指令"></a>几个主要的 SMTP 交互指令</h3><ul><li>HELO: (HELLO)<br>  主要用于让 SMTP 服务器对当前连接的 SMTP 客户端(上例是 telnet 模拟的) 建立一个身份标志 (一般是当前的主机名)</li><li>MAIL:<br>  用法 MAIL FROM: <a href="mailto:&#120;&#120;&#x40;&#120;&#120;&#x2e;&#120;&#120;" target="_blank" rel="noopener">&#120;&#120;&#x40;&#120;&#120;&#x2e;&#120;&#120;</a> (不区分大小写)<br>  可以将其与普通信件的信封等同。毕竟都是要写上发信人，如果没人收信，也就可以根据这个声明将信件退回。</li><li>RCPT: (RECIPIENT)<br>  用法 RCPT TO: <a href="mailto:&#x78;&#x78;&#64;&#120;&#x78;&#x2e;&#120;&#x78;" target="_blank" rel="noopener">&#x78;&#x78;&#64;&#120;&#x78;&#x2e;&#120;&#x78;</a> (可多次重复声明，即将一封信件复制多次投送给每次声明的对象)<br>  相当于普通信件的收信人。不过也有点区别，毕竟普通信件没法一件多发嘛。</li><li>DATA:<br>  <code>DATA</code> 之后到 <code>&lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;</code> 之前的所有内容都作为邮件的正文内容。等同于普通信件信封内的信纸(当然了，信纸上在写上 <code>To XXX:</code> <code>Yours XXX</code> 也是很正常的嘛)，类似的也就是 DATA 数据中也可以包括 <code>Subject:</code> (主题), <code>From:</code> (写信人), <code>Date:</code> (日期), <code>To:</code>(收件人)等内容。</li></ul><hr><h3 id="几个次要的-SMTP-交互指令"><a href="#几个次要的-SMTP-交互指令" class="headerlink" title="几个次要的 SMTP 交互指令"></a>几个次要的 SMTP 交互指令</h3><ul><li><p>RSET: (Reset)<br>  重置，丢弃之前针对邮件所描述的所有内容，重新开始。</p></li><li><p>VRFY: (VERIFY)<br>  用于确认收件人是否存在，以及收件人的完整地址</p></li><li><p>NOOP:<br>  强制服务器做出一个回应，没有实际意义。</p></li><li><p>QUIT:<br>  要求收信服务器返回一个邮件接收成功的信号，之后释放连接通道。</p></li></ul><h2 id="SMTP-扩展"><a href="#SMTP-扩展" class="headerlink" title="SMTP 扩展"></a>SMTP 扩展</h2><p>前面描述了这么多，应该来说找一些支持 TCP (或者其他稳定的传输层连接也是可以的) 连接的命令就完全可以支持一次邮件发送的需求。</p><p>但是，如果想要发送一些中文字符之类的，马上就出现了问题。</p><p>这里有几种方式，但本人还没有理解透彻。仅列出知道的可行方案。</p><ul><li>通过 IMF (Internet Message Format) 进行发件</li><li>通过 ESMTP </li></ul><h2 id="SMTP-安全"><a href="#SMTP-安全" class="headerlink" title="SMTP 安全"></a>SMTP 安全</h2><p>出于 SMTP 本身协议的设计，没有一个有效的身份认证机制。</p><p>纵使通过 <code>MAIL FROM: &lt;A@test.net&gt;</code> 在信封上写明了是由 A 发出的信件。<br>但是，装在信封内的信纸却可以属上另一个人的名字。</p><p>利用这种规则，也就出现了伪装发信人这样的操作。当然，现在的大量邮箱服务提供商都会对这种情况进行标记。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fvpbzedf67j315e01q0sp.jpg" alt="“代发”标记"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://tools.ietf.org/html/rfc821" target="_blank" rel="noopener">SIMPLE MAIL TRANSFER PROTOCOL</a></li><li><a href="http://www.ruanyifeng.com/blog/2008/06/mime.html" target="_blank" rel="noopener">MIME</a></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在网络协议上，高层协议确实比底层协议更容易理解，也更加的人性化。&lt;br&gt;传输层的 TCP, UDP 都还停留在各种字节内容的整合和校验上，而更上层的应用层协议就已经能够直观到通过直接解读就能理解其每条消息的含义了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mail" scheme="https://DorMOUSE-None.github.io/tags/mail/"/>
    
      <category term="SMTP" scheme="https://DorMOUSE-None.github.io/tags/SMTP/"/>
    
      <category term="TCP" scheme="https://DorMOUSE-None.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>TCP SYN 包模拟</title>
    <link href="https://DorMOUSE-None.github.io/2018-09-18-TCP-SYN/"/>
    <id>https://DorMOUSE-None.github.io/2018-09-18-TCP-SYN/</id>
    <published>2018-09-17T16:00:00.000Z</published>
    <updated>2018-09-18T10:05:46.320Z</updated>
    
    <content type="html"><![CDATA[<p>写了两天，几乎是从零开始，C 语言搞了一个发 TCP SYN 包的小程序。<br>从协议到程序代码的转换，确实没有花费太多的时间，但是为了字节序(byteorder)的问题简直折腾得…</p><a id="more"></a><h2 id="TCP-首部格式"><a href="#TCP-首部格式" class="headerlink" title="TCP 首部格式"></a>TCP 首部格式</h2><p>从 RFC 793 了解到基础的 TCP 首部格式(当然，模拟三次握手的 SYN 包也根本不需要填充任何数据)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|          Source Port          |       Destination Port        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                        Sequence Number                        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Acknowledgment Number                      |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|  Data |           |U|A|P|R|S|F|                               |</span><br><span class="line">| Offset| Reserved  |R|C|S|S|Y|I|            Window             |</span><br><span class="line">|       |           |G|K|H|T|N|N|                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|           Checksum            |         Urgent Pointer        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Options                    |    Padding    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                             data                              |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>对于仅仅模拟一个 SYN 包而言，似乎无需关心 Sequence Number, Ack Number, Window 等信息，毕竟都不关心服务器端给的返回。<br>最低的要求，仅仅是发一个合法的 TCP 报文，得到服务器端的反馈，而非直接被服务器端丢弃(如果被验证到报文非法或者数据出错等)。</p><p>那么，最为重要的细节就是 Checksum (校验和) 了。服务器端会对接收到的数据流进行校验，如果有差错，则直接丢弃，而无任何结果。</p><h2 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h2><p>从细节上来说，网络协议中的校验和显得比较简单。以 TCP 协议的 Checksum 字段举例，就是为了让伪首部(TCP 首部 + source IP + destination IP 等一些额外信息)<br>以每 16 位 (2 字节) 为一个单位，循环累加和最终达到 0xFFFF 的效果。</p><p>下面以一个由 Source IP: 172.16.2.101 -&gt; Destination IP: 172.16.2.127 的 TCP 首部为例进行细节描述:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 总长为 20 字节的 TCP 报文首部</span><br><span class="line">27 11 0f a0 00 00 00 00 00 00 00 00 50 02 ff 00 1d 2c 00 00</span><br><span class="line"></span><br><span class="line">src Port: 0x2711 -&gt; 10001</span><br><span class="line">dst Port: 0x0fa0 -&gt; 4000</span><br><span class="line">Seq nr: 0x00000000 -&gt; 0</span><br><span class="line">Ack nr: 0x00000000 -&gt; 0</span><br><span class="line">Data off: 5 -&gt; 32 bits 数量是 5 -&gt; 20 字节 (即 TCP 首部长度为 20 字节)</span><br><span class="line">FLAG: 0x02 -&gt; urg ack psh rst SYN fin </span><br><span class="line">Window: 0xFF00 (窗口大小为 65280 字节)</span><br><span class="line">chk sum: 0x1d2c</span><br><span class="line">urg pointer: 0x0000</span><br></pre></td></tr></table></figure><p>在计算之前，TCP 校验和还将涉及到伪首部的概念</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|           Source Address          |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|         Destination Address       |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|  zero  |  PTCL  |    TCP Length   |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line"></span><br><span class="line">在此例中:</span><br><span class="line">Source Address: 172.16.2.101 -&gt; 0xAC100265</span><br><span class="line">Destination Address: 172.16.2.127 -&gt; 0XAC10027F</span><br><span class="line">zero: 0x00</span><br><span class="line">PTCL(protocol): TCP(6) -&gt; 0x06</span><br><span class="line">TCP Length: 20 bytes -&gt; 0x0014</span><br></pre></td></tr></table></figure><p>即加上伪首部的内容，需要共同进行校验的数据流如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ac 10 02 65 ac 10 02 7f 00 06 00 14 27 11 0f a0 00 00 00 00 00 00 00 00 50 02 ff 00 1d 2c 00 00</span><br></pre></td></tr></table></figure></p><h3 id="服务器端校验"><a href="#服务器端校验" class="headerlink" title="服务器端校验"></a>服务器端校验</h3><p>服务器端接收到 TCP 报文后，将对整个需要校验的数据流，按 16 bits (2字节) 为单位，进行累加。</p><p>即: <code>0xac10+0x0265+0xac10+0x027f+0x0006+0x0014+0x2711+0x0fa0+0x0000+0x0000+0x0000+0x0000+0x5002+0xff00+0x1d2c+0x0000 = 0x2fffd</code></p><p>对于超长计算结果 (超出 0xFFFF) ，循环将高位右移 16 位与低位进行累加，直到结果 &lt;= 0xFFFF ，即 <code>0x20000 &gt;&gt; 16 + 0xfffd = 0xffff</code></p><p>如果最终结果 <code>=0xffff</code>(全为 1) ，则认为 TCP 首部没有问题，服务器端接收报文，并回复 ACK SYN 包。</p><h3 id="客户端构造校验和"><a href="#客户端构造校验和" class="headerlink" title="客户端构造校验和"></a>客户端构造校验和</h3><p>与服务器端相对，显然客户端必须通过 Check sum ，使得最终的结果服务器端校验的条件。</p><p>作为反向问题，同样以上面为例子，假设 check sum 还未确定具体的值。则计算方式如下:</p><p>加上伪首部, 校验和暂时置零的数据流</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ac 10 02 65 ac 10 02 7f 00 06 00 14 27 11 0f a0 00 00 00 00 00 00 00 00 50 02 ff 00 00 00 00 00</span><br></pre></td></tr></table></figure><p>作为逆过程，按 16 bits 为单位，进行累加。即: <code>0xac10+0x0265+0xac10+0x027f+0x0006+0x0014+0x2711+0x0fa0+0x0000+0x0000+0x0000+0x0000+0x5002+0xff00+0x0000+0x0000 = 0x2e2d1</code></p><p>超长部分循环累加，<code>0x20000 &gt;&gt; 16 + 0xe2d1 = 0xe2d3</code></p><p>结果取反，<code>~ 0xe2d3 = 0x1d2c</code></p><p>即认为 <code>0x1d2c</code> 为校验和</p><h2 id="HBO-与-NBO"><a href="#HBO-与-NBO" class="headerlink" title="HBO 与 NBO"></a>HBO 与 NBO</h2><p>HBO: host byte order<br>NBO: network byte order </p><p>说起字节序简直能够把人逼疯，说实话虽然有一定的历史原因，但是不做统一真的对底层编程相当得不友好。</p><p>不过，再厌烦也不能改变什么。总还得继续写代码不是嘛。</p><h3 id="主机字节序-HBO-Host-Byte-Order"><a href="#主机字节序-HBO-Host-Byte-Order" class="headerlink" title="主机字节序 (HBO, Host Byte Order)"></a>主机字节序 (HBO, Host Byte Order)</h3><p>采用小端字节排序方式。简单描述为 高位字节存放在内存的高地址处，低位字节存储在内存的低地址处。</p><p>以 4 字节 int 型数据 0xAB1267EF 为例:</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fvdu3zhh92j31040newel.jpg" alt=""></p><p>而程序读取数据的顺序，如果不考虑数据类型，按字节读取，普遍将采用字节递增序读取，则优先将读到 0xEF 等低位字节数据</p><h3 id="网络字节序-NBO-Network-Byte-Order"><a href="#网络字节序-NBO-Network-Byte-Order" class="headerlink" title="网络字节序 (NBO, Network Byte Order)"></a>网络字节序 (NBO, Network Byte Order)</h3><p>采用大端字节排序方式。简单描述为通过网络接收到数据时将优先接收到数据的高位字节，然后再得到低位字节。</p><p>还是以 4 字节 int 型数据 0xAB1267EF 为例:</p><p>则通过网络得到的数据流将是 <code>0xEF 0x67 0x12 0xAB</code></p><h3 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h3><p>C 语言，BSD 平台的 netinet/tcp.h 定义了 tcp header 结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span>th_sport;<span class="comment">/* source port */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span>th_dport;<span class="comment">/* destination port */</span></span><br><span class="line">tcp_seqth_seq;<span class="comment">/* sequence number */</span></span><br><span class="line">tcp_seqth_ack;<span class="comment">/* acknowledgement number */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __DARWIN_BYTE_ORDER == __DARWIN_LITTLE_ENDIAN</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>th_x2:<span class="number">4</span>,<span class="comment">/* (unused) */</span></span><br><span class="line">th_off:<span class="number">4</span>;<span class="comment">/* data offset */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __DARWIN_BYTE_ORDER == __DARWIN_BIG_ENDIAN</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>th_off:<span class="number">4</span>,<span class="comment">/* data offset */</span></span><br><span class="line">th_x2:<span class="number">4</span>;<span class="comment">/* (unused) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>th_flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>TH_FIN0x01</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>TH_SYN0x02</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>TH_RST0x04</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>TH_PUSH0x08</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>TH_ACK0x10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>TH_URG0x20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>TH_ECE0x40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>TH_CWR0x80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>TH_FLAGS(TH_FIN|TH_SYN|TH_RST|TH_ACK|TH_URG|TH_ECE|TH_CWR)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span>th_win;<span class="comment">/* window */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span>th_sum;<span class="comment">/* checksum */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span>th_urp;<span class="comment">/* urgent pointer */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于 <code>unsigned char</code> 之类的单字节数据，将不存在任何问题。但是，诸如 <code>unsigned short</code> 等多字节数据，将涉及到字节序的转换。</p><p>比如，虽然令 <code>th_sport = 0x2711 (10001)</code> 看似合理。但是，从内存的角度来看，数据将被存储为 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 假设起始物理内存地址为 0x00007c000</span><br><span class="line">0x00007c01: 0x27 </span><br><span class="line">0x00007c00: 0x11</span><br></pre></td></tr></table></figure><p>等到构造完 TCP 首部，顺次地发送数据时，呈现的数据流将形如: <code>0x11 0x27...</code> 即使用里 HBO (小端字节序) 的数据无法满足 NBO (大端字节序) 的要求。<br>毕竟，两者相互对立。</p><p>因此，需要特别注意字节序的问题。当然，C 语言还是想当友好地提供了字节序转换的工具 <code>htons</code>, <code>htonl</code>, <code>ntohs</code>, <code>ntohl</code> 。详情请通过 <code>man byteorder</code> 查看。</p><h2 id="TCP-SYN-的简单例程"><a href="#TCP-SYN-的简单例程" class="headerlink" title="TCP SYN 的简单例程"></a>TCP SYN 的简单例程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/tcp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * +--------+--------+--------+--------+</span></span><br><span class="line"><span class="comment"> * |           Source Address          |</span></span><br><span class="line"><span class="comment"> * +--------+--------+--------+--------+</span></span><br><span class="line"><span class="comment"> * |         Destination Address       |</span></span><br><span class="line"><span class="comment"> * +--------+--------+--------+--------+</span></span><br><span class="line"><span class="comment"> * |  zero  |  PTCL  |    TCP Length   |</span></span><br><span class="line"><span class="comment"> * +--------+--------+--------+--------+</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pseudohdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> src_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> dst_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> zero:<span class="number">8</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> protocol:<span class="number">8</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> tcp_length;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> <span class="title">tcpHdr</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="title">check_sum</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> *ptr, <span class="keyword">size_t</span> nbytes)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(nbytes &gt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        sum += htons(*ptr++);</span><br><span class="line">        nbytes -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sum = (sum &gt;&gt; <span class="number">16</span>) + (sum &amp; <span class="number">0xFFFF</span>);</span><br><span class="line">    sum = (sum &gt;&gt; <span class="number">16</span>) + (sum &amp; <span class="number">0xFFFF</span>);</span><br><span class="line"></span><br><span class="line">    sum = ~sum;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">short</span>) sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct tcphdr * <span class="title">init_tcp_header</span><span class="params">(<span class="keyword">int</span> sport)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> * <span class="title">header</span> = (<span class="title">struct</span> <span class="title">tcphdr</span> *) <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">tcphdr</span>));</span></span><br><span class="line">    header-&gt;th_sport = htons(sport);    <span class="comment">// 源端口</span></span><br><span class="line">    header-&gt;th_dport = htons(<span class="number">4000</span>);     <span class="comment">// 目标端口</span></span><br><span class="line">    header-&gt;th_seq = <span class="number">0</span>;                <span class="comment">// 序列号</span></span><br><span class="line">    header-&gt;th_ack = <span class="number">0</span>;                <span class="comment">// 确认序号 | ACK 置位时有效</span></span><br><span class="line">    header-&gt;th_off = <span class="keyword">sizeof</span>(struct tcphdr) / <span class="number">4</span>;   <span class="comment">// TCP 首部长度 (字节)</span></span><br><span class="line">    header-&gt;th_flags = TH_SYN;      <span class="comment">// 标志位</span></span><br><span class="line">    header-&gt;th_win = <span class="number">255</span>;           <span class="comment">// 数据窗口大小</span></span><br><span class="line">    header-&gt;th_sum = <span class="number">0</span>;             <span class="comment">// 校验值 (先置为 0, 等会再修正)</span></span><br><span class="line">    header-&gt;th_urp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> header;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tcp_syn</span><span class="params">(<span class="keyword">int</span> tcp_sock, struct tcphdr *header)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">addr</span> = (<span class="title">struct</span> <span class="title">sockaddr_in</span> *) <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sockaddr_in</span>));</span></span><br><span class="line">    addr-&gt;sin_family = PF_INET;</span><br><span class="line">    addr-&gt;sin_port = htons(<span class="number">4000</span>);</span><br><span class="line">    addr-&gt;sin_addr.s_addr = inet_addr(<span class="string">"172.16.2.127"</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> size = sendto(tcp_sock, header, <span class="keyword">sizeof</span>(struct tcphdr), <span class="number">0</span>, (struct sockaddr *)addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tcp_sock = socket(PF_INET, SOCK_RAW, IPPROTO_TCP);</span><br><span class="line">    <span class="keyword">if</span>(tcp_sock == <span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Open Socket Failed: %s(errno: %d)\n"</span>, strerror(errno), errno);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> *<span class="title">tcpHdr</span> = <span class="title">init_tcp_header</span>(10001);</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pseudohdr</span> *<span class="title">psdHdr</span> = (<span class="title">struct</span> <span class="title">pseudohdr</span> *) <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">pseudohdr</span>));</span></span><br><span class="line">    psdHdr-&gt;src_addr = inet_addr(<span class="string">"172.16.2.101"</span>);</span><br><span class="line">    psdHdr-&gt;dst_addr = inet_addr(<span class="string">"172.16.2.127"</span>);</span><br><span class="line">    psdHdr-&gt;zero = <span class="number">0</span>;</span><br><span class="line">    psdHdr-&gt;protocol = <span class="number">6</span>;</span><br><span class="line">    psdHdr-&gt;tcp_length = htons(<span class="keyword">sizeof</span>(struct tcphdr));</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;psdHdr-&gt;tcpHdr, tcpHdr, <span class="keyword">sizeof</span>(struct tcphdr));</span><br><span class="line">    tcpHdr-&gt;th_sum = htons(check_sum((<span class="keyword">unsigned</span> <span class="keyword">short</span> *) psdHdr, <span class="keyword">sizeof</span>(struct pseudohdr)));</span><br><span class="line">    <span class="built_in">free</span>(psdHdr);</span><br><span class="line"></span><br><span class="line">    tcp_syn(tcp_sock, tcpHdr);</span><br><span class="line">    <span class="built_in">free</span>(tcpHdr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写了两天，几乎是从零开始，C 语言搞了一个发 TCP SYN 包的小程序。&lt;br&gt;从协议到程序代码的转换，确实没有花费太多的时间，但是为了字节序(byteorder)的问题简直折腾得…&lt;/p&gt;
    
    </summary>
    
    
      <category term="TCP" scheme="https://DorMOUSE-None.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Preprocessor Output</title>
    <link href="https://DorMOUSE-None.github.io/2018-09-08-preprocessor-output/"/>
    <id>https://DorMOUSE-None.github.io/2018-09-08-preprocessor-output/</id>
    <published>2018-09-07T16:00:00.000Z</published>
    <updated>2018-09-08T06:59:35.638Z</updated>
    
    <content type="html"><![CDATA[<p>最近重新开始回顾 C 语言以及其编译后的文件格式 ELF。<br>暂时告别一步到位的命令 <code>gcc main.c</code>，如果从 <code>.c</code> 文件的编译来说，主要分为预编译(preprocess)、编译(Compilation)、汇编(Assembly)、链接(Linking) 四个步骤。<br>但是，仅仅从第一个流程 <strong>预编译</strong> 而言，就已经遇到了一些麻烦。</p><p><small>program.i</small><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span> <span class="string">"program.c"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;built-in&gt;"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;command-line&gt;"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"/usr/include/stdc-predef.h"</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;command-line&gt;"</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"program.c"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"header.h"</span> <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"># <span class="number">2</span> <span class="string">"program.c"</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>预编译后的问题出现了诸如 <code># 1 &quot;program.c&quot;</code> 的 <em>注释?</em> </p><p>这里简单记录预处理输出文件的基本格式，方便今后回顾。<br><a id="more"></a></p><h2 id="Output-File-format"><a href="#Output-File-format" class="headerlink" title="Output File format"></a>Output File format</h2><p>首先，从预编译的结果看，<code>cpp (C preprocessor)</code> 程序主要是处理了所有的<strong>宏指令</strong>。然后添加上了一些所谓<strong>线性标记</strong>的内容。<br>最终得到的就是类似 <code>program.i</code> 的结果。</p><p>从细节上来说:<br>首先，所有的宏指令，包括 <code>#include</code> (用于引入用户自定义及系统预定义的头文件)、<code>#define</code> (用于将使用到的宏进行替换)。<br>当然，在替换完成后，这些指令所在的行将被替换成空行。同时，所有的注释行也将被替换成空行。</p><p>此外，将添加上注入 <code>#1 &quot;program.c&quot;</code> 的<strong>线性标记</strong>。</p><h3 id="线性标记"><a href="#线性标记" class="headerlink" title="线性标记"></a>线性标记</h3><p>线性标记的标准格式:</p><p><code># linenum filename flags</code></p><p>linenum 是为了配合预定义宏 <code>__LINE__</code> 是使用的，用于定位紧随的下一行内容在原文件中所在的行。</p><p>filename 指出了接下来的内容来自哪个原文件</p><p>flags 有如下几个取值:</p><ul><li>1 : 表示这是一个新的文件的开始</li><li>2 : 表示回到文件 <code>filename</code> 的内容 (从其他的 <em>include</em> 的文件中)</li><li>3 : 表示接下来的内容是从系统预定义头文件中来的，因此需要抑制某些警告</li><li>4 : 表示接下来的内容需要被视作是被封装的隐式 <code>extern &quot;C&quot;</code> 块</li></ul><h3 id="实例解读"><a href="#实例解读" class="headerlink" title="实例解读"></a>实例解读</h3><p><small>program.c</small><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"header.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(test());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><small>header.h</small><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></p><p>接下来的演示都将以 <strong>program.c</strong> 和 <strong>header.h</strong> 两个文件作为标准示例。<br>期间，将对 <strong>program.c</strong> or <strong>header.h</strong> 做不同程度的修改，已达到更好的展示效果。<br><em>注意:</em> 额外添加的注释由 <code>!</code> 开始到该行结束(并不符合 C 语言语法)，但是帮助理解</p><p><strong>Sample 1</strong></p><p>直接利用 program.c 与 header.h 进行预编译 <code>cpp -o program.i program.c</code><br>结果如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span> <span class="string">"program.c"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;built-in&gt;"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;command-line&gt;"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"/usr/include/stdc-predef.h"</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;command-line&gt;"</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"program.c"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"header.h"</span> <span class="number">1</span>            ! 下一行代码对应的是 header.h 文件第一行</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"># <span class="number">2</span> <span class="string">"program.c"</span> <span class="number">2</span>           ! flag=<span class="number">2</span> 表示下列内容由回到了 program.c 中，下一行对应原文件第二行</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(test());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Sample 2</strong></p><p>接着，给 <strong>program.c</strong> 加点注释，在加点空行</p><p><small>program.c - sub 1<small><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is comment          ! 这里添加了一行注释</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"header.h"</span></span></span><br><span class="line"></span><br><span class="line">                            ! 这里加了个空行</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(test());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></small></small></p><p>再看看效果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span> <span class="string">"program.c"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;built-in&gt;"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;command-line&gt;"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"/usr/include/stdc-predef.h"</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;command-line&gt;"</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"program.c"</span>             ! 下一行代码对应原代码中第 <span class="number">1</span> 行，本来是注释，但会被预编译器处理成空行 (多行将逐一处理，但行数不会变)</span><br><span class="line"></span><br><span class="line"># <span class="number">1</span> <span class="string">"header.h"</span> <span class="number">1</span>            ! 下面将描述 header.h 的代码</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"># <span class="number">3</span> <span class="string">"program.c"</span> <span class="number">2</span>           ! 继续描述 program.c ，下一行对应原代码第 <span class="number">3</span> 行。至于第 <span class="number">2</span> 行，就是 <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"header.h"</span> ，不会直接表现了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(test());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Sample 3</strong></p><p>在改变一些</p><p><small>program.c - sub 2</small><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is comment</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"header.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEN 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(test());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看看结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span> <span class="string">"program.c"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;built-in&gt;"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;command-line&gt;"</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"/usr/include/stdc-predef.h"</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"&lt;command-line&gt;"</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"program.c"</span></span><br><span class="line"></span><br><span class="line"># <span class="number">1</span> <span class="string">"header.h"</span> <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"># <span class="number">3</span> <span class="string">"program.c"</span> <span class="number">2</span></span><br><span class="line">                        ! 原代码中对应行是宏 <span class="meta">#<span class="meta-keyword">define</span> TEN 10 ，已经被空行替换掉了。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(test());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近重新开始回顾 C 语言以及其编译后的文件格式 ELF。&lt;br&gt;暂时告别一步到位的命令 &lt;code&gt;gcc main.c&lt;/code&gt;，如果从 &lt;code&gt;.c&lt;/code&gt; 文件的编译来说，主要分为预编译(preprocess)、编译(Compilation)、汇编(Assembly)、链接(Linking) 四个步骤。&lt;br&gt;但是，仅仅从第一个流程 &lt;strong&gt;预编译&lt;/strong&gt; 而言，就已经遇到了一些麻烦。&lt;/p&gt;
&lt;p&gt;&lt;small&gt;program.i&lt;/small&gt;&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;program.c&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;built-in&amp;gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;command-line&amp;gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;/usr/include/stdc-predef.h&quot;&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;command-line&amp;gt;&quot;&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;program.c&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;header.h&quot;&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;program.c&quot;&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;预编译后的问题出现了诸如 &lt;code&gt;# 1 &amp;quot;program.c&amp;quot;&lt;/code&gt; 的 &lt;em&gt;注释?&lt;/em&gt; &lt;/p&gt;
&lt;p&gt;这里简单记录预处理输出文件的基本格式，方便今后回顾。&lt;br&gt;
    
    </summary>
    
    
      <category term="C" scheme="https://DorMOUSE-None.github.io/tags/C/"/>
    
      <category term="CPP" scheme="https://DorMOUSE-None.github.io/tags/CPP/"/>
    
      <category term="GCC" scheme="https://DorMOUSE-None.github.io/tags/GCC/"/>
    
  </entry>
  
  <entry>
    <title>理解 Linux Kernel (2) - 多任务切换</title>
    <link href="https://DorMOUSE-None.github.io/2018-08-26-understand-Kernel-2/"/>
    <id>https://DorMOUSE-None.github.io/2018-08-26-understand-Kernel-2/</id>
    <published>2018-08-25T16:00:00.000Z</published>
    <updated>2018-08-26T05:40:04.404Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>《只是为了好玩》一书中，林纳斯描述过他最早的试验性程序就是让 CPU 执行两个不同的任务(一个不断输出A，另一个输出B)，同时不断地让 CPU 在两个任务间的切换。</p><p>结合《Linux 内核完全注释》一书，得到了多任务切换的示例程序。</p><p>本节所要描述的内容，正是结合一个框架式的汇编程序(多任务切换程序, 书中提供的内容比较老，无法适应目前的各种工具、环境)，在现有环境中加以处理并成功运行。</p><p>关于运行环境的说明，欢迎参考 <a href="https://dormouse-none.github.io/2018-08-19-understand-Kernel-0/">理解 Linux Kernel (0)</a></p><a id="more"></a><h2 id="引导程序"><a href="#引导程序" class="headerlink" title="引导程序"></a>引导程序</h2><p>在 <a href="https://dormouse-none.github.io/2018-08-19-understand-Kernel-1/">理解 Linux Kernel (1)</a> 已经描述过通过 BIOS 加载引导程序，并执行引导程序的全部流程。<br>当然，也就仅仅到引导程序就结束了。诸如操作系统之类的内容根本就没有涉及。</p><p>不过，无论是操作系统，还是用户程序，都是基于 CPU、内存等硬件而进一步抽象的上层概念。如果问没有操作系统而直接运行程序是否可行？毫无疑问，这绝对是没有问题的。</p><p>CPU 只是忠实地执行寄存器定位到的机器指令，并加以执行。特别是，如果在 <a href="https://dormouse-none.github.io/2018-08-19-understand-Kernel-1/">理解 Linux Kernel (1)</a> 提供的输出 “System Loading…” 的示例程序上继续加以改编，无论是算术运算、显示文本等等目的都是没有问题的。<br>当然，限制也还是有的，512B 是引导程序的上限。</p><p>在机器上电启动之后，存储在非易失性存储器 / 只读存储器上的 BIOS 程序将被加载到内存，并进行执行(至于细节，不甚了解，不表)<br>之后，BIOS 将默认地将指定磁盘(软盘、硬盘等) 首个扇区 512 字节的内容(称为 boot 引导程序)加载到内存地址，并 JMP 到 CS:IP = 0x07c00:0x0000 的位置。从而触发引导程序。</p><p>继而，如果在编写 boot 引导程序的时候，我们使其能够从外存加载额外的代码，并在引导程序结束位置将 CPU 的控制权交给这段额外加载的代码。显然，操作系统就是这样子被加载的。</p><p><code>BIOS -&gt; boot 引导程序 -&gt; 操作系统引导程序 -&gt; 操作系统</code><br>这就构成了一个宏观的操作系统启动的一个流程。</p><p>boot.s 引导程序 <small>主体代码来自《Linux 内核完全注释》，进行了一定量的改写</small></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">BOOTSEG = 0x07c0</span><br><span class="line">SYSSEG = 0x0100</span><br><span class="line">SYSLEN = 17</span><br><span class="line"></span><br><span class="line">entry start</span><br><span class="line">start:</span><br><span class="line">    jmpi    go,#BOOTSEG</span><br><span class="line">go:</span><br><span class="line">    mov ax,cs</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,#0x0400</span><br><span class="line"></span><br><span class="line">load_system:</span><br><span class="line">    xor dx,dx       ! 开始位置, 磁头:硬盘号</span><br><span class="line">    mov cx,#0x0002  ! 开始位置, 磁道:扇区</span><br><span class="line">    mov ax,#0x0100</span><br><span class="line">    mov es,ax       ! 载入到, ES 段</span><br><span class="line">    xor bx,bx       ! 载入到, 偏移量 </span><br><span class="line">    mov ax,#0x0211  ! AH: 读取扇区子功能, AL: 读取多少个扇区</span><br><span class="line">    int 0x13        ! BIOS 13 号中断</span><br><span class="line">    jnc continue_load   ! JUMP if CF = 0</span><br><span class="line">die:</span><br><span class="line">    jmp die</span><br><span class="line"></span><br><span class="line">continue_load:</span><br><span class="line">    cli             ! 清除中断允许位标志</span><br><span class="line">    mov ax,#SYSSEG </span><br><span class="line">    mov ds,ax       ! 设置数据段寄存器位置 0x1000</span><br><span class="line">    xor ax,ax</span><br><span class="line">    mov es,ax       ! 设置扩展段寄存器 0x0000</span><br><span class="line">    mov cx,#0x1000  ! 计数器</span><br><span class="line">    sub si,si</span><br><span class="line">    sub di,di</span><br><span class="line">    rep </span><br><span class="line">    movsw</span><br><span class="line"></span><br><span class="line">    mov ax,#BOOTSEG</span><br><span class="line">    mov ds,ax       ! 重新设置数据段寄存器到当前数据段基地址</span><br><span class="line">    lidt idt_48     ! 设置中断描述符表寄存器</span><br><span class="line">    lgdt gdt_48     ! 设置全局描述符表寄存器</span><br><span class="line"></span><br><span class="line">    mov ax,#0x0001</span><br><span class="line">    lmsw ax         ! 设置 CR0, 进入保护模式</span><br><span class="line">    jmpi 0,8</span><br><span class="line"></span><br><span class="line">gdt:</span><br><span class="line">    .word   0,0,0,0</span><br><span class="line">    .word   0x07FF,0x0000,0x9A00,0x00C0</span><br><span class="line">    .word   0x07FF,0x0000,0x9200,0x00C0</span><br><span class="line"></span><br><span class="line">idt_48:</span><br><span class="line">    .word   0,0,0</span><br><span class="line">gdt_48:</span><br><span class="line">    .word   0x07FF,0x7C00+gdt,0</span><br><span class="line"></span><br><span class="line">.org 510</span><br><span class="line">    .word   0xAA55</span><br></pre></td></tr></table></figure><p>这段汇编程序，通过 <code>load_system</code> 标识符标识的这段程序表明需要加载0号磁盘,0号磁头,0号磁道,从第2扇区开始,连续17个扇区的内容(这里将存储支持任务切换的程序)，加载到内存以 0x1000 开始的物理地址处。</p><p><code>continue_load</code> 标识将 0x1000 物理地址开始的 4096 字 (即 8192 字节) 的内容依次复制到以 0x0000 开始的物理地址处。</p><p>其后，设置 IDT (中断描述符表)、IDTR(中断描述符表寄存器) 及 GDT(全局描述符表)、GDTR(全局描述符表寄存器)，将 CPU 运行模式改成 <code>保护模式</code> ，继而将控制权转交给这个被加载进来的程序。</p><h2 id="多任务程序"><a href="#多任务程序" class="headerlink" title="多任务程序"></a>多任务程序</h2><p><small>主体内容来自《Linux 内核完全注释》，经过一定量改变以适应当前运行环境</small><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br></pre></td><td class="code"><pre><span class="line"># head.s</span><br><span class="line">.code32</span><br><span class="line">LATCH = 11930</span><br><span class="line">SCRN_SEL = 0x18</span><br><span class="line">TSS0_SEL = 0x20</span><br><span class="line">LDT0_SEL = 0x28</span><br><span class="line">TSS1_SEL = 0x30</span><br><span class="line">LDT1_SEL = 0x38</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">.globl startup_32</span><br><span class="line">startup_32:</span><br><span class="line"></span><br><span class="line">    movl $0x00000010,%eax       # 段选择符 2</span><br><span class="line">    mov %ax,%ds                </span><br><span class="line">    lss init_stack,%esp         # Load Far Pointer 加载到 SS:ESP </span><br><span class="line"></span><br><span class="line">    call setup_idt              # 设置中断描述符表</span><br><span class="line">    call setup_gdt              # 设置全局描述符表</span><br><span class="line">    movl $0x00000010,%eax</span><br><span class="line">    mov %ax,%ds</span><br><span class="line">    mov %ax,%es</span><br><span class="line">    mov %ax,%fs</span><br><span class="line">    mov %ax,%gs</span><br><span class="line">    lss init_stack,%esp         # Load Far Pointer 加载到 SS:ESP</span><br><span class="line"></span><br><span class="line"># 设置 8253 定时芯片 10s 一个中断</span><br><span class="line">    movb $0x36,%al  </span><br><span class="line">    movl $0x00000043,%edx</span><br><span class="line">    outb %al,%dx</span><br><span class="line">    movl $LATCH,%eax</span><br><span class="line">    movl $0x40,%edx</span><br><span class="line">    outb %al,%dx</span><br><span class="line">    movb %ah,%al</span><br><span class="line">    outb %al,%dx</span><br><span class="line"></span><br><span class="line">    movl $0x00080000,%eax       # 重新设置 int 0x08 时钟中断</span><br><span class="line">    movw $timer_interrupt,%ax</span><br><span class="line">    movw $0x8E00,%dx</span><br><span class="line">    movl $0x08,%ecx</span><br><span class="line">    lea idt(,%ecx,8),%esi</span><br><span class="line">    movl %eax,(%esi)</span><br><span class="line">    movl %edx,4(%esi)</span><br><span class="line">    movw $system_interrupt,%ax  # 重新设置 int 0x80 系统中断</span><br><span class="line">    movw $0xef00,%dx</span><br><span class="line">    movl $0x80,%ecx</span><br><span class="line">    lea idt(,%ecx,8),%esi</span><br><span class="line">    movl %eax,(%esi)</span><br><span class="line">    movl %edx,4(%esi)</span><br><span class="line"></span><br><span class="line">    pushfl                      # 重置 EFLAGS 嵌套任务标志位</span><br><span class="line">    andl $0xffffbfff,(%esp)</span><br><span class="line">    popfl</span><br><span class="line">    movl $TSS0_SEL,%eax</span><br><span class="line">    ltr %ax                     # Load Task Register</span><br><span class="line">    movl $LDT0_SEL,%eax</span><br><span class="line">    lldt %ax                    # Load Local Descriptor Register</span><br><span class="line">    movl $0,current</span><br><span class="line">    sti                         # set interrupt flag</span><br><span class="line">    pushl $0x17</span><br><span class="line">    pushl $init_stack</span><br><span class="line">    pushfl</span><br><span class="line">    pushl $0x0f</span><br><span class="line">    pushl $task0</span><br><span class="line">    iret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setup_gdt:</span><br><span class="line">    lgdt lgdt_opcode</span><br><span class="line">    ret</span><br><span class="line">setup_idt:</span><br><span class="line">    lea ignore_int,%edx         # 预先把中断处理程序的偏移地址 ignore_int 存到 EDX</span><br><span class="line">    movl $0x00080000,%eax       # 预存 0x0008 - 段选择符</span><br><span class="line">    movw %dx,%ax                # 补上 0-15 位偏移地址</span><br><span class="line">    movw $0x8E00,%dx            # DX 补上标志位</span><br><span class="line">    lea idt,%edi</span><br><span class="line">    mov $256,%ecx</span><br><span class="line">rp_idt: movl %eax,(%edi)        # 循环 256 遍处理 IDT</span><br><span class="line">    movl %edx,4(%edi)</span><br><span class="line">    addl $8,%edi</span><br><span class="line">    dec %ecx</span><br><span class="line">    jne rp_idt</span><br><span class="line">    lidt lidt_opcode</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">write_char:</span><br><span class="line">    push %gs</span><br><span class="line">    pushl %ebx</span><br><span class="line">    mov $SCRN_SEL,%ebx</span><br><span class="line">    mov %bx,%gs</span><br><span class="line">    movl scr_loc,%ebx</span><br><span class="line">    shl $1,%ebx</span><br><span class="line">    movb %al,%gs:(%ebx)</span><br><span class="line">    shr $1,%ebx</span><br><span class="line">    incl %ebx</span><br><span class="line">    cmpl $2000,%ebx</span><br><span class="line">    jb 1f</span><br><span class="line">    movl $0,%ebx</span><br><span class="line">1:  movl %ebx,scr_loc</span><br><span class="line">    popl %ebx</span><br><span class="line">    pop %gs</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.align 4</span><br><span class="line">ignore_int:                 # 默认的中断处理程序</span><br><span class="line">    push %ds</span><br><span class="line">    pushl %eax</span><br><span class="line">    movl $0x10,%eax</span><br><span class="line">    mov %ax,%ds</span><br><span class="line">    movl $67,%eax</span><br><span class="line">    call write_char</span><br><span class="line">    popl %eax</span><br><span class="line">    pop %ds</span><br><span class="line">    iret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.align 4</span><br><span class="line">timer_interrupt:            # 定时中断处理程序</span><br><span class="line">    push %ds</span><br><span class="line">    pushl %eax</span><br><span class="line">    movl $0x10,%eax</span><br><span class="line">    mov %ax,%ds</span><br><span class="line">    movb $0x20,%al</span><br><span class="line">    outb %al,$0x20</span><br><span class="line">    movl $1,%eax</span><br><span class="line">    cmpl %eax,current</span><br><span class="line">    je 1f</span><br><span class="line">    movl %eax,current</span><br><span class="line">    jmp $TSS1_SEL, $0</span><br><span class="line">    jmp 2f</span><br><span class="line">1:  movl $0,current</span><br><span class="line">    jmp $TSS0_SEL, $0</span><br><span class="line">2:  popl %eax</span><br><span class="line">    pop %ds</span><br><span class="line">    iret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.align 4</span><br><span class="line">system_interrupt:           # 系统调用中断处理程序</span><br><span class="line">    push %ds</span><br><span class="line">    pushl %edx</span><br><span class="line">    pushl %ecx</span><br><span class="line">    pushl %ebx</span><br><span class="line">    pushl %eax</span><br><span class="line">    movl $0x10,%edx</span><br><span class="line">    mov %dx,%ds</span><br><span class="line">    call write_char</span><br><span class="line">    popl %eax</span><br><span class="line">    popl %ebx</span><br><span class="line">    popl %ecx</span><br><span class="line">    popl %edx</span><br><span class="line">    pop %ds</span><br><span class="line">    iret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">current:.long 0</span><br><span class="line">scr_loc:.long 0</span><br><span class="line"></span><br><span class="line">.align 4</span><br><span class="line">lidt_opcode:</span><br><span class="line">    .word 256*8-1</span><br><span class="line">    .long idt</span><br><span class="line">lgdt_opcode:</span><br><span class="line">    .word (end_gdt-gdt)-1</span><br><span class="line">    .long gdt</span><br><span class="line"></span><br><span class="line">.align 8</span><br><span class="line">idt:    .fill 256,8,0</span><br><span class="line"></span><br><span class="line">gdt:    .quad 0x0000000000000000</span><br><span class="line">        .quad 0x00c09a00000007ff</span><br><span class="line">        .quad 0x00c09200000007ff</span><br><span class="line">        .quad 0x00c0920b80000002</span><br><span class="line">        .word 0x68,tss0,0xe900,0x0</span><br><span class="line">        .word 0x40,ldt0,0xe200,0x0</span><br><span class="line">        .word 0x68,tss1,0xe900,0x0</span><br><span class="line">        .word 0x40,ldt1,0xe200,0x0</span><br><span class="line">end_gdt:</span><br><span class="line">        .fill 128,4,0</span><br><span class="line">init_stack:</span><br><span class="line">    .long init_stack</span><br><span class="line">    .word 0x0010</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.align 8</span><br><span class="line">ldt0:   .quad 0x0000000000000000</span><br><span class="line">        .quad 0x00c0fa00000003ff</span><br><span class="line">        .quad 0x00c0f200000003ff</span><br><span class="line"></span><br><span class="line">tss0:   .long 0</span><br><span class="line">        .long krn_stk0, 0x10</span><br><span class="line">        .long 0,0,0,0,0</span><br><span class="line">        .long 0,0,0,0,0</span><br><span class="line">        .long 0,0,0,0,0</span><br><span class="line">        .long 0,0,0,0,0,0</span><br><span class="line">        .long LDT0_SEL,0x8000000</span><br><span class="line"></span><br><span class="line">        .fill 128,4,0</span><br><span class="line">krn_stk0:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.align 8</span><br><span class="line">ldt1:   .quad 0x0000000000000000</span><br><span class="line">        .quad 0x00c0fa00000003ff</span><br><span class="line">        .quad 0x00c0f200000003ff</span><br><span class="line"></span><br><span class="line">tss1:   .long 0</span><br><span class="line">        .long krn_stk1,0x10</span><br><span class="line">        .long 0,0,0,0,0</span><br><span class="line">        .long task1,0x200</span><br><span class="line">        .long 0,0,0,0</span><br><span class="line">        .long usr_stk1,0,0,0</span><br><span class="line">        .long 0x17,0x0f,0x17,0x17,0x17,0x17</span><br><span class="line">        .long LDT1_SEL,0x8000000</span><br><span class="line"></span><br><span class="line">        .fill 128,4,0</span><br><span class="line">krn_stk1:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">task0:</span><br><span class="line">    movl $0x17,%eax</span><br><span class="line">    movw %ax,%ds</span><br><span class="line">    mov $65,%al</span><br><span class="line">    int $0x80</span><br><span class="line">    movl $0xfff,%ecx</span><br><span class="line">1:  loop 1b</span><br><span class="line">    jmp task0</span><br><span class="line">task1:</span><br><span class="line">    mov $66,%al</span><br><span class="line">    int $0x80</span><br><span class="line">    movl $0xfff,%ecx</span><br><span class="line">1:  loop 1b</span><br><span class="line">    jmp task1</span><br><span class="line"></span><br><span class="line">    .fill 128,4,0</span><br><span class="line">usr_stk1:</span><br></pre></td></tr></table></figure></p><p>上面的这个程序内容不再详述，想了解细节请参考 《Linux 内核完全注释》</p><p>下面提供编译 <code>boot.s</code> 以及 <code>head.s</code> 的可用 Makefile</p><p>首先描述一下额外的工具版本</p><ul><li>GNU as : GNU assembler version 2.26.1 </li><li>GNU ld : GNU ld 2.26.1<br>其它内容详见 <a href="https://dormouse-none.github.io/2018-08-19-understand-Kernel-0/">理解 Linux Kernel (0)</a></li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Makefile for the simple example kernel.</span></span><br><span class="line">AS86=as86 -0 -a</span><br><span class="line">LD86=ld86 -0</span><br><span class="line">AS=as</span><br><span class="line">ASFLAGS =-32</span><br><span class="line">LD=ld</span><br><span class="line">LDFLAGS=-s -x -M -m elf_i386 -e startup_32 -Ttext 0x0</span><br><span class="line"></span><br><span class="line"><span class="section">all:Image</span></span><br><span class="line"></span><br><span class="line"><span class="section">Image: boot system</span></span><br><span class="line">dd bs=32 if=boot of=Image skip=1</span><br><span class="line">dd bs=512 if=system of=Image skip=8 seek=1</span><br><span class="line">sync</span><br><span class="line"></span><br><span class="line"><span class="section">disk: Image</span></span><br><span class="line">dd bs=8192 if=Image of=/dev/fd0</span><br><span class="line">sync;sync;sync</span><br><span class="line"></span><br><span class="line"><span class="section">head.o: </span></span><br><span class="line"><span class="variable">$(AS)</span> <span class="variable">$(ASFLAGS)</span> -o head.o head.s</span><br><span class="line"></span><br><span class="line"><span class="section">system:head.o </span></span><br><span class="line"><span class="variable">$(LD)</span> <span class="variable">$(LDFLAGS)</span> head.o  -o system &gt; System.map</span><br><span class="line"></span><br><span class="line"><span class="section">boot:boot.s</span></span><br><span class="line"><span class="variable">$(AS86)</span> -o boot.o boot.s</span><br><span class="line"><span class="variable">$(LD86)</span> -s -o boot boot.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f Image System.map core boot *.o system</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>想了解更多细节的请自行实操查看吧!</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fun1fvafhwg30k40d4x6p.gif" alt=""></p><h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><p><a href="https://raw.githubusercontent.com/DorMOUSE-None/Repo/master/understand-kernel-2.zip" target="_blank" rel="noopener">程序源码</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;《只是为了好玩》一书中，林纳斯描述过他最早的试验性程序就是让 CPU 执行两个不同的任务(一个不断输出A，另一个输出B)，同时不断地让 CPU 在两个任务间的切换。&lt;/p&gt;
&lt;p&gt;结合《Linux 内核完全注释》一书，得到了多任务切换的示例程序。&lt;/p&gt;
&lt;p&gt;本节所要描述的内容，正是结合一个框架式的汇编程序(多任务切换程序, 书中提供的内容比较老，无法适应目前的各种工具、环境)，在现有环境中加以处理并成功运行。&lt;/p&gt;
&lt;p&gt;关于运行环境的说明，欢迎参考 &lt;a href=&quot;https://dormouse-none.github.io/2018-08-19-understand-Kernel-0/&quot;&gt;理解 Linux Kernel (0)&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://DorMOUSE-None.github.io/tags/Linux/"/>
    
      <category term="Kernel" scheme="https://DorMOUSE-None.github.io/tags/Kernel/"/>
    
      <category term="Multi-Task" scheme="https://DorMOUSE-None.github.io/tags/Multi-Task/"/>
    
  </entry>
  
  <entry>
    <title>理解 Linux Kernel (1) - BIOS</title>
    <link href="https://DorMOUSE-None.github.io/2018-08-19-understand-Kernel-1/"/>
    <id>https://DorMOUSE-None.github.io/2018-08-19-understand-Kernel-1/</id>
    <published>2018-08-18T16:00:00.000Z</published>
    <updated>2018-08-19T08:22:30.382Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在<a href="https://dormouse-none.github.io/2018-08-19-understand-Kernel-0/">概述</a>，我想我已经介绍过我开始这一些列博文的原因。<br>我不能担保我所进行的所有试验性操作都是对的，但是，至少这些在我所描述的环境下成功的运行了起来，并帮助我触及我始终敬畏而又敬而远之的<strong>硬件&amp;OS</strong></p><p>在《Linux内核完全注释》一书第三章——内核编程语言和环境，描述了用 as86 汇编语言构建 boot 引导程序，并最终通过 Bochs 仿真器在模拟开机通电后，BIOS Load<br>boot 程序，通过显示器输出 <em>Loading System…</em> 。</p><p>这些，将是这里所要描述的主要内容。</p><a id="more"></a><h2 id="boot-s-汇编程序"><a href="#boot-s-汇编程序" class="headerlink" title="boot.s 汇编程序"></a>boot.s 汇编程序</h2><p>这里没法多说，都是书中的源码，只是供未读过书的读者参考，特意摘录了下来(不过，就不加注释了)</p><p>boot.s 源代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">.global begtext, begdata, begbss, endtext, enddata, endbss</span><br><span class="line">.text</span><br><span class="line">begtext:</span><br><span class="line">.data</span><br><span class="line">begdata:</span><br><span class="line">.bss</span><br><span class="line">begbss:</span><br><span class="line">.text</span><br><span class="line">BOOTSEG=0x07c0</span><br><span class="line"></span><br><span class="line">entry start</span><br><span class="line">start:</span><br><span class="line">    jmpi    go,BOOTSEG</span><br><span class="line">go: mov ax,cs</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov [msg+17],ah</span><br><span class="line">    mov cx,#20</span><br><span class="line">    mov dx,#0x1004</span><br><span class="line">    mov bx,#0x000c</span><br><span class="line">    mov bp,#msg</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line">loop1:  jmp loop1</span><br><span class="line">msg:    .ascii  &quot;Loading System...&quot;</span><br><span class="line">        .byte   13,10</span><br><span class="line">.org    510</span><br><span class="line">.word   0xAA55</span><br><span class="line">.text</span><br><span class="line">endtext:</span><br><span class="line">.data</span><br><span class="line">enddata:</span><br><span class="line">.bss</span><br><span class="line">endbss:</span><br></pre></td></tr></table></figure><p>这段程序的主要的执行流程将是:</p><ol><li>通过 BIOS 加载这段 boot 引导程序</li><li>红色字体打印 <em>Loading System…</em> 并响铃</li><li>指令自循环 (<code>loop1 jmp loop1</code>) ，将始终展示上述字样，并不接收命令</li></ol><p>下面就该把这个汇编程序 <em>编译 + 链接</em> 成 boot 引导程序。</p><p>虽然在 macOS 上确实找到了一个 as86 汇编器(来自 nasm 的一个编译选项，但我不知道为什么始终无法正常编译，也可能这个根本就不是我想要的)。</p><p>通过 docker 容器部署的 Ubuntu，可以很容易地得到一个 as86 汇编程序。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apt-get install bin86   <span class="comment"># as86, ld86 都在这个包里提供了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这句需要在宿主机上执行</span></span><br><span class="line">docker cp boot.s linux:/root/boot.s     <span class="comment"># 这里 linux 是我 docker 部署的 Ubuntu 的容器的名称。   如果之前 boot.s 在宿主机上，可以这样拷贝到容器中</span></span><br><span class="line"></span><br><span class="line">as86 -0 -a -o boot.o boot.s             <span class="comment"># 编译</span></span><br><span class="line"></span><br><span class="line">ld86 -0 -s -o execfile boot.o           <span class="comment"># 链接</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然，到这里为止，其实都可以理解成在将汇编代码编译链接成可执行程序 (和 boot 引导程序没有太大关系，唯一有关系的就是这段汇编语言是以引导为目的写的)</span></span><br><span class="line"></span><br><span class="line">dd bs=32 <span class="keyword">if</span>=execfile of=boot skip=1     <span class="comment"># 这里去掉可执行程序的前 32 字节，形成刚好 512 字节的 boot 引导程序</span></span><br></pre></td></tr></table></figure><h2 id="用仿真器启动引导程序"><a href="#用仿真器启动引导程序" class="headerlink" title="用仿真器启动引导程序"></a>用仿真器启动引导程序</h2><p>事实上，这部分内容，我始终没有搞清楚 <strong>磁盘映像文件</strong> 和 <strong>boot 引导程序</strong> 间的关系(当然还有 floppy 和 ata0~3)</p><p>在上一节成功拿到 <em>512B</em> 的 boot 引导程序之后，直接使用这个貌似我也运行成功了(根本就不需要创建磁盘映像文件并将引导程序写入映像文件中，不过，也许只是因为这个引导程序太简单了，根本就不需要其他程序的配合。它最后就是一个死循环 )</p><p>总之，先按照最简单的来吧。</p><p>把 boot 引导程序拷贝到宿主机上(貌似频繁地在两个OS上交互文件，这个很无奈，docker容器中的进程难以启动显示程序)</p><ol><li>在宿主机新建一个目录 <em>linux-boot</em></li><li>拷贝 boot 引导程序到宿主机上 <code>docker cp linux:/root/boot linux-boot/</code></li><li>在 <em>linux-boot</em> 下建立 bochsrc 文件(这将是整个仿真器的配置，用于模拟组装机器涉及的 CPU, 内存, BIOS, 显示器等)</li><li>这里使用的配置文件如下:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># You may now use double quotes around pathnames, in case</span><br><span class="line"># your pathname includes spaces.</span><br><span class="line"></span><br><span class="line">cpu: model=pentium, count=1, ips=50000000, reset_on_triple_fault=1, ignore_bad_msrs=1, msrs=&quot;msrs.def&quot;</span><br><span class="line">cpu: cpuid_limit_winnt=0</span><br><span class="line"></span><br><span class="line">memory: guest=512, host=256</span><br><span class="line"></span><br><span class="line">romimage: file=$BXSHARE/BIOS-bochs-legacy, options=fastboot     # BIOS 配置</span><br><span class="line"></span><br><span class="line">vgaromimage: file=$BXSHARE/VGABIOS-lgpl-latest</span><br><span class="line"></span><br><span class="line">mouse: enabled=0</span><br><span class="line"></span><br><span class="line">pci: enabled=1, chipset=i440fx</span><br><span class="line"></span><br><span class="line">private_colormap: enabled=0</span><br><span class="line"></span><br><span class="line">floppya: 1\_44=&quot;./boot&quot;, status=inserted         # 装载一个软盘 A ，这里用当前目录下的 boot (boot 引导程序，事实上书中说要用 .img 磁盘映像文件，但这里不影响实际效果)</span><br><span class="line"></span><br><span class="line">ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14</span><br><span class="line">ata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15</span><br><span class="line">ata2: enabled=0, ioaddr1=0x1e8, ioaddr2=0x3e0, irq=11</span><br><span class="line">ata3: enabled=0, ioaddr1=0x168, ioaddr2=0x360, irq=9</span><br><span class="line"></span><br><span class="line">boot: a                                         # 配置引导程序所在的磁盘</span><br><span class="line"></span><br><span class="line">floppy_bootsig_check: disabled=0</span><br><span class="line"></span><br><span class="line">log: bochsout.txt</span><br><span class="line"></span><br><span class="line">panic: action=ask</span><br><span class="line">error: action=report</span><br><span class="line">info: action=report</span><br><span class="line">debug: action=ignore, pci=report # report BX_DEBUG from module &apos;pci&apos;</span><br><span class="line"></span><br><span class="line">debugger_log: -</span><br><span class="line"></span><br><span class="line">parport1: enabled=1, file=&quot;parport.out&quot;</span><br><span class="line"></span><br><span class="line">speaker: enabled=1, mode=sound</span><br></pre></td></tr></table></figure><ol start="5"><li>当前目录 <em>linux-boot</em> 下，键入命令 <code>bochs</code></li><li>由于读取到 <em>bochsrc</em> 配置文件的存在，menu 的默认选项为 6 (开始模拟机器)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">You can also start bochs with the -q option to skip these menus.</span><br><span class="line"></span><br><span class="line">1. Restore factory default configuration</span><br><span class="line">2. Read options from...</span><br><span class="line">3. Edit options</span><br><span class="line">4. Save options to...</span><br><span class="line">5. Restore the Bochs state from...</span><br><span class="line">6. Begin simulation</span><br><span class="line">7. Quit now</span><br><span class="line"></span><br><span class="line">Please choose one: [6]</span><br></pre></td></tr></table></figure><ol start="7"><li>直接开始运行机器，键入命令 <code>c</code> (这部分在 <a href="https://dormouse-none.github.io/2018-08-19-understand-Kernel-0/">概述</a> 有过了描述，以后将不再描述)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Please choose one: [6]</span><br><span class="line">00000000000i[      ] lt_dlhandle is 0x7f85d0405ff0</span><br><span class="line">00000000000i[PLUGIN] loaded plugin libbx_sdl2.so</span><br><span class="line">00000000000i[      ] installing sdl2 module as the Bochs GUI</span><br><span class="line">00000000000i[SDL2  ] maximum host resolution: x=2880 y=1800</span><br><span class="line">00000000000i[      ] using log file bochsout.txt</span><br><span class="line">Next at t=0</span><br><span class="line">(0) [0x0000fffffff0] f000:fff0 (unk. ctxt): jmpf 0xf000:e05b          ; ea5be000f0</span><br><span class="line">&lt;bochs:1&gt; c</span><br></pre></td></tr></table></figure><ol start="8"><li>观察仿真器的表现</li></ol><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fuf2kicsqyj313y0q0gn4.jpg" alt=""></p><p>Oh, YES! 成功输出了 <em>Loading System…</em> (不过响铃没有听到，可能与我没有配置 sound 有关)</p><ol start="9"><li>关机</li></ol><p>无需多言，右上角模拟的就是<strong>关机实体按键</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在&lt;a href=&quot;https://dormouse-none.github.io/2018-08-19-understand-Kernel-0/&quot;&gt;概述&lt;/a&gt;，我想我已经介绍过我开始这一些列博文的原因。&lt;br&gt;我不能担保我所进行的所有试验性操作都是对的，但是，至少这些在我所描述的环境下成功的运行了起来，并帮助我触及我始终敬畏而又敬而远之的&lt;strong&gt;硬件&amp;amp;OS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在《Linux内核完全注释》一书第三章——内核编程语言和环境，描述了用 as86 汇编语言构建 boot 引导程序，并最终通过 Bochs 仿真器在模拟开机通电后，BIOS Load&lt;br&gt;boot 程序，通过显示器输出 &lt;em&gt;Loading System…&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;这些，将是这里所要描述的主要内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://DorMOUSE-None.github.io/tags/Linux/"/>
    
      <category term="Kernel" scheme="https://DorMOUSE-None.github.io/tags/Kernel/"/>
    
      <category term="BIOS" scheme="https://DorMOUSE-None.github.io/tags/BIOS/"/>
    
  </entry>
  
  <entry>
    <title>理解 Linux Kernel (0) - 概述</title>
    <link href="https://DorMOUSE-None.github.io/2018-08-19-understand-Kernel-0/"/>
    <id>https://DorMOUSE-None.github.io/2018-08-19-understand-Kernel-0/</id>
    <published>2018-08-18T16:00:00.000Z</published>
    <updated>2018-08-19T04:46:27.020Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>之所以想要了解 Linux Kernel，与前一个月的 JVM ClassFile 的学习有这很大的关联。</p><p>说实话，刨除 JVM 的具体实现，Sun (或者现在该说是 Oracle) 确实将 Java 的底层逻辑设计得相当简单。</p><ol><li>有限而统一的指令集(不超过 256 个，可以用 1 字节表示)</li><li>操作数栈+局部变量表共同实现的指令运算</li><li>高度封装的成员变量/方法的寻址方式</li><li>… (见识短浅，想不到了…以后再补充吧)</li></ol><p>但是，与 JVM 模拟的虚拟机不同，实体机器有着更为复杂的结构。<br>最根本的，不同厂商的机器就带来了不同的 CPU 指令集，这就已经让人难以接受了。</p><p>其实最初，是想要继续去看看 Hotspot 虚拟机的。但是，混杂的代码(C++, Java, 平台相关各种实现) 带来了很大的阅读障碍。<br>最根本的，我甚至找不到一个学习的基本立足点，出发点(当然，也可能我根本就没仔细去看，哈哈)。</p><p>借着一次机会，我开始看《程序员的自我修养——链接、装载与库》一书。确实无论是 ELF 格式，静态链接与动态链接甚至 Linux 的内建函数<br>都给了我比较深刻的印象，向我展示了 C 更深入的一面。但是，macOS 给我带来了比较大的客观阻碍(即使用 Docker 容器得到了一个可用的 Linux 环境，但是否与直接建立在机器上的系统有所区别，此处还得打个问号)。<br>同时，书中的部分内容上下不统一，缺少前后文也是一个重大的问题。总之，这并不完全适合我这种初学者逐一进行书中所描述的全部实验。</p><p>最后，我决定展开对 Linux Kernel 的学习，试图通过对直接构架在硬件上的操作系统进行一番比较深入的学习。</p><p>期间，找过一些资料，也了解到 Linus Torvals 直接领导着的 <a href="https://www.kernel.org/" target="_blank" rel="noopener">Kernel 项目的官网</a>；甚至，找到了各个版本的 kernel 源码(虽然确实地丢失了最早期 0.XX 的若干版本)。<br>不得不说，就目前来讲，我觉得《Linux内核完全注释》是最适合(<em>打个问号，至少暂时是的</em>)我学习的一书。</p><p>之后的若干博文，将都以《Linux内核完全注释》中的内容为基础，结合目前的实际需要，从而进行实操性的认知与学习。</p><a id="more"></a><h2 id="软硬件描述"><a href="#软硬件描述" class="headerlink" title="软硬件描述"></a>软硬件描述</h2><p>进行这方面的描述，是因为 Linux Kernel 将直接与底层硬件打交道(当然，这方面使用的 Bochs 仿真器)。<br>但是，准备诸如 .img (磁盘映像文件), 机器指令文件等都不得不借助于现有的平台。</p><ul><li>操作系统: macOS 10.13.6 , Ubuntu 16.04 (Docker 虚拟机容器)</li><li>仿真器  : Bochs 2.6.9_2 (macOS 与 Ubuntu 上相同)</li><li>更多    : 将直接在正文首次使用到时进行说明</li></ul><h2 id="Bochs"><a href="#Bochs" class="headerlink" title="Bochs"></a>Bochs</h2><p><a href="http://bochs.sourceforge.net/" target="_blank" rel="noopener">Bochs 官网</a></p><p><a href="https://sourceforge.net/projects/bochs/files/" target="_blank" rel="noopener">Bochs 下载链</a></p><p>说实话这一周都差不多要被 Bochs 折腾死，用源码进行编译出现各种各样的问题。(我猜新版本根本就没考虑对 macOS 做兼容)</p><p>最后，不得不使用经编译后的二进制分发版。 <code>brew install bochs</code> 当然了，反正也能用，就不纠结非得自己编译了。(如果哪位能成功编译个 macOS 可用的应用，希望能把踩得坑整理整理，供后来者参考)</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── CHANGES</span><br><span class="line">├── COPYING</span><br><span class="line">├── INSTALL_RECEIPT.json</span><br><span class="line">├── LICENSE</span><br><span class="line">├── README</span><br><span class="line">├── TODO</span><br><span class="line">├── bin</span><br><span class="line">│   ├── bochs                           // bochs 可执行文件</span><br><span class="line">│   └── bximage                         // 制作磁盘映像文件的工具</span><br><span class="line">├── lib                                 // 动态库目录</span><br><span class="line">│   └── bochs</span><br><span class="line">│       └── plugins</span><br><span class="line">│           ├── libbx_acpi.0.0.0.so</span><br><span class="line">│           ├── ... 略</span><br><span class="line">│           └── libbx_vga.so -&gt; libbx_vga.0.0.0.so</span><br><span class="line">└── share                               // 与体系结构无关的文件放在此目录下</span><br><span class="line">    ├── bochs</span><br><span class="line">    │   ├── BIOS-bochs-latest</span><br><span class="line">    │   ├── BIOS-bochs-legacy</span><br><span class="line">    │   ├── SeaBIOS-README</span><br><span class="line">    │   ├── VGABIOS-elpin-2.40</span><br><span class="line">    │   ├── VGABIOS-elpin-LICENSE</span><br><span class="line">    │   ├── VGABIOS-lgpl-README</span><br><span class="line">    │   ├── VGABIOS-lgpl-latest</span><br><span class="line">    │   ├── VGABIOS-lgpl-latest-cirrus</span><br><span class="line">    │   ├── VGABIOS-lgpl-latest-cirrus-debug</span><br><span class="line">    │   ├── VGABIOS-lgpl-latest-debug</span><br><span class="line">    │   ├── bios.bin-1.7.5</span><br><span class="line">    │   └── keymaps</span><br><span class="line">    │       ├── sdl-pc-us.map</span><br><span class="line">    │       ├── ... 略</span><br><span class="line">    │       └── x11-pc-us.map</span><br><span class="line">    ├── doc</span><br><span class="line">    │   └── bochs</span><br><span class="line">    │       ├── CHANGES</span><br><span class="line">    │       ├── COPYING</span><br><span class="line">    │       ├── LICENSE</span><br><span class="line">    │       ├── README</span><br><span class="line">    │       ├── TODO</span><br><span class="line">    │       ├── bochsrc-sample.txt      // bochsrc 配置文件的示例样板</span><br><span class="line">    │       └── slirp.conf</span><br><span class="line">    └── man</span><br><span class="line">        ├── man1</span><br><span class="line">        │   ├── bochs-dlx.1.gz</span><br><span class="line">        │   ├── bochs.1.gz</span><br><span class="line">        │   └── bximage.1.gz</span><br><span class="line">        └── man5</span><br><span class="line">            └── bochsrc.5.gz</span><br></pre></td></tr></table></figure><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>Bochs 下载链提供了 Bochs 不同版本的源码的下载，同时也提供了一些可用的磁盘映像文件(都是一些已经经过处理，可用使用进行仿真运行的 OS )</p><p>说实话，这是绝对有必要进行的一步，不仅仅是了解配置文件 bochsrc 的配置方式，更可用借此了解一下仿真器的使用方式。(在启动系统上，我也被坑了一天，后面细说)</p><p>首先，这里演示的将是 DLX Linux 。</p><ol><li><p>下载，解压，进入目录。</p></li><li><p>目录下文件如下</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── bochsrc.txt         // bochs 启动时将默认通过这个文件读取仿真器配置</span><br><span class="line">├── hd10meg.img         // 磁盘映像文件</span><br><span class="line">├── readme.txt</span><br><span class="line">└── testform.txt</span><br></pre></td></tr></table></figure><ol start="3"><li>启动仿真器</li></ol><p>在 DLX Linux 目录下键入命令 <code>bochs</code>, 观察到命令行输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">========================================================================</span><br><span class="line">                       Bochs x86 Emulator 2.6.9</span><br><span class="line">               Built from SVN snapshot on April 9, 2017</span><br><span class="line">                  Compiled on May  2 2018 at 13:26:32</span><br><span class="line">========================================================================</span><br><span class="line">00000000000i[      ] LTDL_LIBRARY_PATH not set. using compile time default &apos;/usr/local/Cellar/bochs/2.6.9_2/lib/bochs/plugins&apos;</span><br><span class="line">00000000000i[      ] BXSHARE not set. using compile time default &apos;/usr/local/Cellar/bochs/2.6.9_2/share/bochs&apos;</span><br><span class="line">00000000000i[      ] lt_dlhandle is 0x7fef2252a500</span><br><span class="line">00000000000i[PLUGIN] loaded plugin libbx_usb_common.so</span><br><span class="line">00000000000i[      ] lt_dlhandle is 0x7fef2252a8a0</span><br><span class="line">00000000000i[PLUGIN] loaded plugin libbx_unmapped.so</span><br><span class="line">00000000000i[      ] lt_dlhandle is 0x7fef2252ad00</span><br><span class="line">00000000000i[PLUGIN] loaded plugin libbx_biosdev.so</span><br><span class="line">00000000000i[      ] lt_dlhandle is 0x7fef2252b1e0</span><br><span class="line">00000000000i[PLUGIN] loaded plugin libbx_speaker.so</span><br><span class="line">00000000000i[      ] lt_dlhandle is 0x7fef2252ba50</span><br><span class="line">00000000000i[PLUGIN] loaded plugin libbx_extfpuirq.so</span><br><span class="line">00000000000i[      ] lt_dlhandle is 0x7fef2252be70</span><br><span class="line">00000000000i[PLUGIN] loaded plugin libbx_parallel.so</span><br><span class="line">00000000000i[      ] lt_dlhandle is 0x7fef238013c0</span><br><span class="line">00000000000i[PLUGIN] loaded plugin libbx_serial.so</span><br><span class="line">00000000000i[      ] lt_dlhandle is 0x7fef22706cd0</span><br><span class="line">00000000000i[PLUGIN] loaded plugin libbx_iodebug.so</span><br><span class="line">00000000000i[      ] reading configuration from bochsrc.txt</span><br><span class="line">------------------------------</span><br><span class="line">Bochs Configuration: Main Menu</span><br><span class="line">------------------------------</span><br><span class="line"></span><br><span class="line">This is the Bochs Configuration Interface, where you can describe the</span><br><span class="line">machine that you want to simulate.  Bochs has already searched for a</span><br><span class="line">configuration file (typically called bochsrc.txt) and loaded it if it</span><br><span class="line">could be found.  When you are satisfied with the configuration, go</span><br><span class="line">ahead and start the simulation.</span><br><span class="line"></span><br><span class="line">You can also start bochs with the -q option to skip these menus.</span><br><span class="line"></span><br><span class="line">1. Restore factory default configuration</span><br><span class="line">2. Read options from...</span><br><span class="line">3. Edit options</span><br><span class="line">4. Save options to...</span><br><span class="line">5. Restore the Bochs state from...</span><br><span class="line">6. Begin simulation</span><br><span class="line">7. Quit now</span><br><span class="line"></span><br><span class="line">Please choose one: [6]</span><br></pre></td></tr></table></figure><p>bochs 默认读取当前目录下 <code>bochsrc.txt</code> 文件，因此不需要其他配置。</p><p>选择 6 或者直接 <em>回车</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00000000000i[      ] lt_dlhandle is 0x7fef22707270</span><br><span class="line">00000000000i[PLUGIN] loaded plugin libbx_sdl2.so</span><br><span class="line">00000000000i[      ] installing sdl2 module as the Bochs GUI</span><br><span class="line">00000000000i[SDL2  ] maximum host resolution: x=2880 y=1800</span><br><span class="line">00000000000i[      ] using log file bochsout.txt</span><br><span class="line">Next at t=0</span><br><span class="line">(0) [0x0000fffffff0] f000:fff0 (unk. ctxt): jmpf 0xf000:e05b          ; ea5be000f0</span><br><span class="line">&lt;bochs:1&gt;</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fuevtktuh0j30zc0tcwfd.jpg" alt=""></p><p>终端出现更多输出，同时 Bochs 开启了一个可视化终端(当然，现在还没有任何内容)。</p><p>在这儿被坑了好久。本来以为 Bochs 会直接执行 BIOS 指令，启动操作系统，但是自始至终，停在这里就没动过…</p><p>这边是由于 Bochs 本身是支持调试的(T_T，见鬼)，就像是 GDB 和 LLDB 一样，进入调试后，需要指令 <code>c</code> (continue) 来继续执行(当然，还有其它调试命令)</p><ol start="4"><li>键入 <code>c</code> </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bochs:1&gt; c</span><br></pre></td></tr></table></figure><p>仿真器开始引导程序的加载</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fuew9zoocuj313c0pstaw.jpg" alt=""></p><p>OS Kernel 启动，等待用户登录 (默认的用户是 root , 没有密码)。<br>之后就和普通的 Linux 机器类似，不过支持的命令比较少。毕竟是一个精简后的系统。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fuewamqzm6j313q0pqjtw.jpg" alt=""></p><ol start="5"><li>关机</li></ol><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fuewi9wjawj313q0q2gnc.jpg" alt=""></p><p>仿真器仿真了许多实体机案件，右上角最后一个就是关机键</p><h2 id="Docker-容器中运行-Ubuntu"><a href="#Docker-容器中运行-Ubuntu" class="headerlink" title="Docker 容器中运行 Ubuntu"></a>Docker 容器中运行 Ubuntu</h2><p>这部分不详述，作为一个热门的技术，这方面的资料很多。Ubuntu 系统只是为了来执行一些 macOS 上没有的命令的(比如 <code>as86</code>, <code>ld86</code>)</p><p>简述两个 docker 容器和宿主机间复制文件的命令 </p><p>在宿主机下执行命令:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-</span><br><span class="line">docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH [flags]</span><br></pre></td></tr></table></figure><p>例如:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker cp linux:/root/hello.c ./hello.c         <span class="comment"># 这里 linux 是 docker 容器名</span></span><br><span class="line">docker cp 92dfc8ad70e1:/root/hello.c ./hello.c  <span class="comment"># 这里 92dfc8ad70e1 是 docker 容器 ID</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1]. 俞甲子. 程序员的自我修养[M]. 电子工业出版社, 2009.<br>[2]. 赵炯. Linux内核完全注释 内核版本0.11 V3.0[EB/OL]. <a href="http://www.oldlinux.org/" target="_blank" rel="noopener">http://www.oldlinux.org/</a>, 2007</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;之所以想要了解 Linux Kernel，与前一个月的 JVM ClassFile 的学习有这很大的关联。&lt;/p&gt;
&lt;p&gt;说实话，刨除 JVM 的具体实现，Sun (或者现在该说是 Oracle) 确实将 Java 的底层逻辑设计得相当简单。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有限而统一的指令集(不超过 256 个，可以用 1 字节表示)&lt;/li&gt;
&lt;li&gt;操作数栈+局部变量表共同实现的指令运算&lt;/li&gt;
&lt;li&gt;高度封装的成员变量/方法的寻址方式&lt;/li&gt;
&lt;li&gt;… (见识短浅，想不到了…以后再补充吧)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是，与 JVM 模拟的虚拟机不同，实体机器有着更为复杂的结构。&lt;br&gt;最根本的，不同厂商的机器就带来了不同的 CPU 指令集，这就已经让人难以接受了。&lt;/p&gt;
&lt;p&gt;其实最初，是想要继续去看看 Hotspot 虚拟机的。但是，混杂的代码(C++, Java, 平台相关各种实现) 带来了很大的阅读障碍。&lt;br&gt;最根本的，我甚至找不到一个学习的基本立足点，出发点(当然，也可能我根本就没仔细去看，哈哈)。&lt;/p&gt;
&lt;p&gt;借着一次机会，我开始看《程序员的自我修养——链接、装载与库》一书。确实无论是 ELF 格式，静态链接与动态链接甚至 Linux 的内建函数&lt;br&gt;都给了我比较深刻的印象，向我展示了 C 更深入的一面。但是，macOS 给我带来了比较大的客观阻碍(即使用 Docker 容器得到了一个可用的 Linux 环境，但是否与直接建立在机器上的系统有所区别，此处还得打个问号)。&lt;br&gt;同时，书中的部分内容上下不统一，缺少前后文也是一个重大的问题。总之，这并不完全适合我这种初学者逐一进行书中所描述的全部实验。&lt;/p&gt;
&lt;p&gt;最后，我决定展开对 Linux Kernel 的学习，试图通过对直接构架在硬件上的操作系统进行一番比较深入的学习。&lt;/p&gt;
&lt;p&gt;期间，找过一些资料，也了解到 Linus Torvals 直接领导着的 &lt;a href=&quot;https://www.kernel.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kernel 项目的官网&lt;/a&gt;；甚至，找到了各个版本的 kernel 源码(虽然确实地丢失了最早期 0.XX 的若干版本)。&lt;br&gt;不得不说，就目前来讲，我觉得《Linux内核完全注释》是最适合(&lt;em&gt;打个问号，至少暂时是的&lt;/em&gt;)我学习的一书。&lt;/p&gt;
&lt;p&gt;之后的若干博文，将都以《Linux内核完全注释》中的内容为基础，结合目前的实际需要，从而进行实操性的认知与学习。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://DorMOUSE-None.github.io/tags/Linux/"/>
    
      <category term="Kernel" scheme="https://DorMOUSE-None.github.io/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>Java Instrumentation</title>
    <link href="https://DorMOUSE-None.github.io/2018-08-15-Java-Instrumentation/"/>
    <id>https://DorMOUSE-None.github.io/2018-08-15-Java-Instrumentation/</id>
    <published>2018-08-14T16:00:00.000Z</published>
    <updated>2018-08-17T09:34:33.762Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><p>从现有的前置知识来说，我们能够认识到两个事实:</p><ol><li>Java Class 通过 ClassLoader 进行加载。<br>通过<code>全限定名</code>进行区分。当需要加载新的类时，ClassLoader 通过双亲委派机制判断是否已经加载过这个类。<br>换句话说: Class 一经加载，就不会尝试重复加载 (至少按绝大多数人的认知来说，确实是的)</li><li>有没有可能让被加载的 Class 与物理存储上的 .class 内容不同。<br>当然也是完全可以做到的。不管怎么说，CGlib 和 Java Proxy 也是一个耳熟能详的概念吧<br>(虽然可能不了解细节。在此，欢迎学习前置技能 <a href="https://dormouse-none.github.io/2018-07-10-CGlib-Enhancer/">CGlib Enhancer 主流程源码解析</a> 和 <a href="https://dormouse-none.github.io/2018-07-20-Java-Proxy/">Java Proxy 源码解析</a>。不过不影响本文后续内容)</li></ol><p>另一个方面，也许绝大多数人都听说过所谓的<code>热部署</code>。但是究竟怎么才能做到 <code>热部署</code>(话题开得有点大哈。Y_Y 本文不讲这个)</p><p>操作字节码一定是一个逃不开的话题，毕竟 Class 就是所谓的被加载到内存的字节码嘛。</p><p>如何操作字节码? ASM, CGlib, Java Proxy, Javassist ? 不过这些都要等到需要被操作的类被加载了才行啊，似乎有点晚…</p><p>Java 提供了一个可行的机制，用来在 ClassLoader 加载字节码之前完成对操作字节码的目的</p><h2 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a>Instrumentation</h2><p><code>java.lang.instrument.Instrumentation</code> 类为提供直接操作 Java 字节码的又一个途径(虽然 Java Doc 的说明是用来检测 Java 代码的)</p><p>相信我这个说明是没有问题的。毕竟完成对代码检测的途径是直接修改字节码。</p><p>下列有两种方法可以达到目的</p><ol><li>当 JVM 以指示一个代理类的方式启动时，将传递给代理类的 premain 方法一个 Instrumentation 实例。</li><li>当 JVM 提供某种机制在 JVM 启动之后某一时刻启动代理时，将传递给代理代码的 agentmain 方法一个 Instrumentation 实例。</li></ol><p>话不多说，下面将全部以实例来展现对这种 JVM 检测机制(虽然例子已经脱离了<em>检测</em>的目的)的使用</p><a id="more"></a><h2 id="对各方法进行执行时间统计"><a href="#对各方法进行执行时间统计" class="headerlink" title="对各方法进行执行时间统计"></a>对各方法进行执行时间统计</h2><h3 id="随-JVM-一起启动"><a href="#随-JVM-一起启动" class="headerlink" title="随 JVM 一起启动"></a>随 JVM 一起启动</h3><p>基本实例: 将对特定包 <code>me.fangfeng.client</code> 下的每个方法执行计时</p><p>首先了解一下 client 包的内容:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.fangfeng.client;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Main.java</span></span><br><span class="line"><span class="comment"> * 执行两个方法，rand() &amp; sleep() </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fangfeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/8/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Rand rand = <span class="keyword">new</span> Rand();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"&gt;&gt;&gt; start Rand.run() &lt;&lt;&lt;"</span>);</span><br><span class="line">            rand.run();</span><br><span class="line">            System.out.println(<span class="string">"&gt;&gt;&gt; end Rand.run() &lt;&lt;&lt;"</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"&gt;&gt;&gt; start Main.sleep() &lt;&lt;&lt;"</span>);</span><br><span class="line">            Main.sleep();</span><br><span class="line">            System.out.println(<span class="string">"&gt;&gt;&gt; end MAin.sleep() &lt;&lt;&lt;"</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.fangfeng.client;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Rand.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fangfeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/8/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rand</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">double</span> rand = Math.random();</span><br><span class="line">            <span class="keyword">if</span> (rand &gt; <span class="number">0.995</span>) &#123;</span><br><span class="line">                System.out.println(String.format(<span class="string">"get random, values %f"</span>, rand));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，来构造一个代理类，以及最重要的 <code>premain</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.fangfeng.javaagent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Agent - 代理</span></span><br><span class="line"><span class="comment"> * 基于 JVM TI (JVM Tool Interface) 实现的 Java ClassFile 的增强</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fangfeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/8/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Agent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// premain 将 JVM 初始化后，main(String... ) 执行前调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String args, Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// new 一个转换器实例</span></span><br><span class="line">        ClassTimer transformer = <span class="keyword">new</span> ClassTimer();</span><br><span class="line">        instrumentation.addTransformer(transformer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 之后的 agentmain(...) 将在这里提供，暂时隐去，避免对对读者产生干扰</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.fangfeng.javaagent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.ClassReader;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.ClassWriter;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.Opcodes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.ClassFileTransformer;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fangfeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/8/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTimer</span> <span class="keyword">implements</span> <span class="title">ClassFileTransformer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer) &#123;</span><br><span class="line">        <span class="comment">// 这里涉及到了 ASM 的内容，主要目的是向每个方法块的开始及方法块的结束部分插入与计时器有关的代码</span></span><br><span class="line">        <span class="comment">// 如果想了解 ASM 的内容，请参阅 https://dormouse-none.github.io/2018-06-25-ASM-Core/  提供了一些基础性的内容，更多的请自行学习</span></span><br><span class="line">        <span class="comment">// 不了解具体内容将不影响对主体内容的理解</span></span><br><span class="line">        ClassReader cr = <span class="keyword">new</span> ClassReader(classfileBuffer);</span><br><span class="line">        ClassWriter cw = <span class="keyword">new</span> ClassWriter(ClassWriter.COMPUTE_FRAMES);</span><br><span class="line">        MyClassWriter mcw = <span class="keyword">new</span> MyClassWriter(Opcodes.ASM6, cw);</span><br><span class="line">        cr.accept(mcw, ClassReader.EXPAND_FRAMES);</span><br><span class="line">        <span class="keyword">return</span> cw.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其它代码略，详见附件。</p><p>Java 这种对操作字节码的支持有个坑爹的地方，就是不得不打包成 Jar 来使用。</p><p>具体来看一下</p><p><code>me.fangfeng.javaagent</code> 包中包括 </p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fublsbbdw0j309o07g74u.jpg" alt=""></p><p>将被打包成 <code>agent.jar</code> 来使用</p><p>首先，来看一下需要打包在 <code>agent.jar</code> 的 <strong>MANIFEST.MF</strong> 的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Class-Path: /Users/fangfeng/.m2/repository/org/ow2/asm/asm/6.1.1/asm-6.1.1.jar</span><br><span class="line">Premain-Class: me.fangfeng.javaagent.Agent</span><br><span class="line">Can-Retransform-Classes: true</span><br></pre></td></tr></table></figure><p>再来个 SHELL 脚本，用来给打包这个 Jar</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 me.fangfeng.javaagent 包下的类</span></span><br><span class="line">javac -cp .:/Users/fangfeng/.m2/repository/org/ow2/asm/asm/6.1.1/asm-6.1.1.jar me/fangfeng/javaagent/Agent.java me/fangfeng/javaagent/ClassTimer.java me/fangfeng/javaagent/MyClassWriter.java me/fangfeng/javaagent/MyMethodWriter.java me/fangfeng/javaagent/StaticTimer.java</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包 me.fangfeng.javaagent 的 .class -&gt; agent.jar</span></span><br><span class="line">jar cvfm agent.jar MANIFEST-agent.MF me/fangfeng/javaagent/Agent.class me/fangfeng/javaagent/ClassTimer.class me/fangfeng/javaagent/MyClassWriter.class me/fangfeng/javaagent/MyMethodWriter.class me/fangfeng/javaagent/StaticTimer.class</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 me.fangfeng.client 包下的类</span></span><br><span class="line">javac me/fangfeng/client/Main.java me/fangfeng/client/Rand.java</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以 me.fangfeng.client.Main 作为主类启动</span></span><br><span class="line">java -javaagent:agent.jar me.fangfeng.client.Main</span><br></pre></td></tr></table></figure><p>执行后，可以看到类似如下内容:</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fubmp354ejj30tq0rmtdp.jpg" alt=""></p><p>而直接用 <code>java me.fangfeng.client.Main</code> 的执行结果是:</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fubmqmj4uhj30j00f0dho.jpg" alt=""></p><p>从理论上来讲，<code>-javaagent:agent.jar</code> 配合 <code>agent.jar</code> 中的 MANIFEST.MF 文件，<br>使得 JVM 在初始化之后触发了被声明为 <code>Pre-Main</code> 的 me.fangfeng.javaagent.Agent 类的 premain(…) 方法。</p><p>并为 ClassLoader 在加载类的流程上增加了一层<strong>拦截器</strong> (这里是 ClassTimer.java 类，它实现了 <code>ClassFileTransformer</code> 接口</p><p>另外，<code>Can-Retransform-Classes: true</code> 的配置使得 ClassTimer 被允许对字节码进行重新转换。(而操作字节码是通过 ASM 来实现的)</p><h3 id="在运行中进行增强"><a href="#在运行中进行增强" class="headerlink" title="在运行中进行增强"></a>在运行中进行增强</h3><p>随着程序启动时直接使用了 <code>-javaagent</code> 选项。</p><p>那么是否存在在程序运行中进行额外代理操作的支持呢？当然是可以的。这里要借助 Java 提供的另一个类 com.sun.tools.attach.VirtualMachine 。</p><p>启动一个新的进程来连接到 正在运行中的进程，并令其加载 java agent。</p><p>基本的类与上一节的描述相同，主要是包 <code>me.fangfeng.javaagent.*</code> 和 <code>me.fangfeng.client.*</code></p><p>新增一个类 <code>me.fangfeng.javaagent.Main</code> 用来启动另一个进程，并要求运行中的 java 进程加载 agent.jar 来进行增强。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.fangfeng.javaagent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.tools.attach.AgentInitializationException;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.attach.AgentLoadException;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.attach.AttachNotSupportedException;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.attach.VirtualMachine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fangfeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/8/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, AttachNotSupportedException, AgentLoadException, AgentInitializationException </span>&#123;</span><br><span class="line">        VirtualMachine vm = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 通过 VirtualMachine 连接到 运行中的进程 (可以通过 jps 找到进程号)</span></span><br><span class="line">            vm = VirtualMachine.attach(&lt;PID&gt;);</span><br><span class="line">            vm.loadAgent(&lt;agent.jar 的路径&gt;);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (vm != <span class="keyword">null</span>) &#123;</span><br><span class="line">                vm.detach();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Agent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String args, Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">        ClassTimer transformer = <span class="keyword">new</span> ClassTimer();</span><br><span class="line">        instrumentation.addTransformer(transformer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在在 Agent.java 上补上 agentmain(...) 的具体实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String args, Instrumentation instrumentation)</span> <span class="keyword">throws</span> UnmodifiableClassException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SUCCESS AGENTMAIN"</span>);</span><br><span class="line">        ClassTimer transformer = <span class="keyword">new</span> ClassTimer();</span><br><span class="line">        <span class="comment">// add Transformer</span></span><br><span class="line">        instrumentation.addTransformer(transformer, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 对 Rand.class 进行重新转换</span></span><br><span class="line">        instrumentation.retransformClasses(Rand.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其它内容基本相同</p><p>首先需要先打包 agent.jar 。当然，如果是顺着本文的顺序进行本机实验，则 agent.jar 已经存在</p><p>先启动进程 <code>java me.fangfeng.client.Main</code></p><p>通过 <code>jps</code> 获取 Main 进程的 <strong>PID</strong></p><p>在 <code>java me.fangfeng.javaagent.Main</code> 中替换上进程号，并执行</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fuboclcelsj30tu152dlw.jpg" alt=""></p><p>从执行结果可以看到，原进程首先正常执行代码，等到被 load Agent 之后，字节码已经有了新的变化，从而导致输出结果动态的产生了变化。</p><p><em>当然，需要注意的是，执行中的进程被要求 load Agent 之后，运行中的 Class 将被改写，并始终如此，知道进程终止。再下一次重新启动</em></p><h2 id="BTrace"><a href="#BTrace" class="headerlink" title="BTrace"></a>BTrace</h2><p>以上描述的内容也可以理解为是 BTrace 实现的基础。毕竟，JVMTI (JVM Tool Interface) 原本的目的就是赋予使用者一个在运行中<br>查询系统各项数据的权利</p><p>当然，实现上，上述代码直接将各种增强(计时)硬编码到该进程中，同时统一使用了该进程的输入输出。</p><p>但是，BTrace 通过 Socket 将这些分离，检测代码通过 Socket 发回新的进程来维持输入输出。</p><p>在此，不再细说。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>[1]. 示例代码: <a href="https://github.com/DorMOUSE-None/Repo/raw/master/instru.zip" target="_blank" rel="noopener">instru.zip</a><br>[2]. <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/Instrumentation.html" target="_blank" rel="noopener">java.lang.instrument.Instrumentation</a><br>[3]. <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/package-summary.html" target="_blank" rel="noopener">Package java.lang.instrument</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Start&quot;&gt;&lt;a href=&quot;#Start&quot; class=&quot;headerlink&quot; title=&quot;Start&quot;&gt;&lt;/a&gt;Start&lt;/h2&gt;&lt;p&gt;从现有的前置知识来说，我们能够认识到两个事实:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Java Class 通过 ClassLoader 进行加载。&lt;br&gt;通过&lt;code&gt;全限定名&lt;/code&gt;进行区分。当需要加载新的类时，ClassLoader 通过双亲委派机制判断是否已经加载过这个类。&lt;br&gt;换句话说: Class 一经加载，就不会尝试重复加载 (至少按绝大多数人的认知来说，确实是的)&lt;/li&gt;
&lt;li&gt;有没有可能让被加载的 Class 与物理存储上的 .class 内容不同。&lt;br&gt;当然也是完全可以做到的。不管怎么说，CGlib 和 Java Proxy 也是一个耳熟能详的概念吧&lt;br&gt;(虽然可能不了解细节。在此，欢迎学习前置技能 &lt;a href=&quot;https://dormouse-none.github.io/2018-07-10-CGlib-Enhancer/&quot;&gt;CGlib Enhancer 主流程源码解析&lt;/a&gt; 和 &lt;a href=&quot;https://dormouse-none.github.io/2018-07-20-Java-Proxy/&quot;&gt;Java Proxy 源码解析&lt;/a&gt;。不过不影响本文后续内容)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另一个方面，也许绝大多数人都听说过所谓的&lt;code&gt;热部署&lt;/code&gt;。但是究竟怎么才能做到 &lt;code&gt;热部署&lt;/code&gt;(话题开得有点大哈。Y_Y 本文不讲这个)&lt;/p&gt;
&lt;p&gt;操作字节码一定是一个逃不开的话题，毕竟 Class 就是所谓的被加载到内存的字节码嘛。&lt;/p&gt;
&lt;p&gt;如何操作字节码? ASM, CGlib, Java Proxy, Javassist ? 不过这些都要等到需要被操作的类被加载了才行啊，似乎有点晚…&lt;/p&gt;
&lt;p&gt;Java 提供了一个可行的机制，用来在 ClassLoader 加载字节码之前完成对操作字节码的目的&lt;/p&gt;
&lt;h2 id=&quot;Instrumentation&quot;&gt;&lt;a href=&quot;#Instrumentation&quot; class=&quot;headerlink&quot; title=&quot;Instrumentation&quot;&gt;&lt;/a&gt;Instrumentation&lt;/h2&gt;&lt;p&gt;&lt;code&gt;java.lang.instrument.Instrumentation&lt;/code&gt; 类为提供直接操作 Java 字节码的又一个途径(虽然 Java Doc 的说明是用来检测 Java 代码的)&lt;/p&gt;
&lt;p&gt;相信我这个说明是没有问题的。毕竟完成对代码检测的途径是直接修改字节码。&lt;/p&gt;
&lt;p&gt;下列有两种方法可以达到目的&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当 JVM 以指示一个代理类的方式启动时，将传递给代理类的 premain 方法一个 Instrumentation 实例。&lt;/li&gt;
&lt;li&gt;当 JVM 提供某种机制在 JVM 启动之后某一时刻启动代理时，将传递给代理代码的 agentmain 方法一个 Instrumentation 实例。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;话不多说，下面将全部以实例来展现对这种 JVM 检测机制(虽然例子已经脱离了&lt;em&gt;检测&lt;/em&gt;的目的)的使用&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://DorMOUSE-None.github.io/tags/Java/"/>
    
      <category term="ASM" scheme="https://DorMOUSE-None.github.io/tags/ASM/"/>
    
      <category term="BTrace" scheme="https://DorMOUSE-None.github.io/tags/BTrace/"/>
    
  </entry>
  
  <entry>
    <title>JVM 指令简析</title>
    <link href="https://DorMOUSE-None.github.io/2018-07-24-JVM-Instruction/"/>
    <id>https://DorMOUSE-None.github.io/2018-07-24-JVM-Instruction/</id>
    <published>2018-07-23T16:00:00.000Z</published>
    <updated>2018-07-24T01:08:24.556Z</updated>
    
    <content type="html"><![CDATA[<p>在之前描述过包括 ASM, CGlib, Java Proxy 的基本内容之后，本文将就更为基础的 JVM 指令集进行简单而有效的介绍。</p><p>当然，在开始正文前，读者需要了解到，JVM 指令集这种类似于汇编的规范性内容，包含一百多个指令，若要求一一介绍。<br>那么，直接阅读 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" target="_blank" rel="noopener">官方文档</a> 绝对是比本文的内容更为详实且准确。</p><p>这篇文档的目的，只是为了使读者建立起关于 JVM 指令集基本的常识性观念。</p><a id="more"></a><h2 id="术语约定"><a href="#术语约定" class="headerlink" title="术语约定"></a>术语约定</h2><p>首先，需要就 <code>术语</code> 进行一些基础性的约定:</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1ftidi0xpmij30oa07kaaq.jpg" alt="变量"></p><ul><li><code>变量</code>: 在类中，区分于 <code>方法</code> 的声明<ul><li><code>成员变量</code>: 作用域为整个类，在方法体与语句块之外声明的内容。在 <code>字节码</code> 中通常被称为 <code>字段(Field)</code><ul><li><code>类成员变量 / 静态成员变量</code>: 被 <code>static</code> 修饰的 <code>成员变量</code>。一个类只有一份，在类被加载的时候即初始化。</li><li><code>实例成员变量</code>: 非 <code>static</code> 修饰的 <code>成员变量</code>。随着类被实例化而进行初始化，每个实例对象都有一份特有的 <code>实例变量</code>。</li></ul></li><li><code>局部变量</code>: 作用域为方法体或者语句块。</li></ul></li></ul><h3 id="JVM-指令"><a href="#JVM-指令" class="headerlink" title="JVM 指令"></a>JVM 指令</h3><p>通常，我们借助于 <code>javap</code> 命令来对 .class 文件的字节码内容进行查阅。</p><p>类似于汇编代码，<code>javap</code> 打印的JVM 指令将以下列格式进行展示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;index&gt; &lt;opcode&gt; [&lt;operand1&gt; [&lt;operand2&gt; ...]] [&lt;comment&gt;]</span><br></pre></td></tr></table></figure><p>其中 </p><ul><li><code>&lt;index&gt;</code> 指在 <code>code[]</code> 属性中这条指令的偏移量(从 0 开始计数)。</li><li><code>&lt;opcode&gt;</code> 指 <code>操作码</code></li><li><code>&lt;operandX&gt;</code> 指 <code>操作数</code>，每个 <code>&lt;opcode&gt;</code> 都需要确定数量的操作数(规范中已经确定)。</li><li><code>&lt;comment&gt;</code> 指注释</li></ul><h2 id="指令集概览"><a href="#指令集概览" class="headerlink" title="指令集概览"></a>指令集概览</h2><p>首先，Java 代码经编译后的所有指令都基于 <code>方法(Method)</code> 被定义在 <code>Code</code> 属性中。</p><p>在 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.3" target="_blank" rel="noopener">ClassFile</a> 的 <code>Code</code> 属性，结构定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Code_attribute &#123;</span><br><span class="line">    <span class="comment">// 其中 u1, u2, u4 分别表示这个变量所占的字节长度</span></span><br><span class="line">    u2 attribute_name_index;                    <span class="comment">// 属性名在常量池中的 index (执行常量池中 Code 的位置)</span></span><br><span class="line">    u4 attribute_length;                        <span class="comment">// 属性长度，不包括开始的六个字节</span></span><br><span class="line">    u2 max_stack;                               <span class="comment">// 运行时操作数栈的最大深度</span></span><br><span class="line">    u2 max_locals;                              <span class="comment">// 运行时所需的局部变量表的大小</span></span><br><span class="line">    u4 code_length;                             <span class="comment">// code 数组的长度</span></span><br><span class="line">    u1 code[code_length];                       <span class="comment">// code 数组，编译后方法体的内容都通过字节码指令存储在这里</span></span><br><span class="line">    u2 exception_table_length;                  <span class="comment">// 异常表的长度</span></span><br><span class="line">    &#123;   u2 start_pc;</span><br><span class="line">        u2 end_pc;</span><br><span class="line">        u2 handler_pc;</span><br><span class="line">        u2 catch_type;</span><br><span class="line">    &#125; exception_table[exception_table_length]; <span class="comment">// 异常表，Java 代码中所有的 catch, finally 的捕获都将由此表进行实现</span></span><br><span class="line">    u2 attributes_count;                       <span class="comment">// 属性计数</span></span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 虚拟机的指令是由一个字节长度的 <code>操作码</code> 配合上其后的 0 个或多个 <code>操作数</code> 所构成的。</p><p>其中，<code>操作数</code> 的数量取决于 <code>操作码</code>，不同的 <code>操作码</code> 需要不同数量的 <code>操作数</code>。</p><p>按照类型划分，<code>操作数</code> 主要包括下列几类:</p><ul><li>加载与存储指令，例如 iload, istore 等</li><li>运算指令，例如 iadd, isub, imul 等</li><li>类型转换指令，例如 i2b, i2s 等</li><li>对象创建与操作指令，例如 new, newarray 等</li><li>操作数栈管理指令，例如 dup, pop 等</li><li>控制转移指令，例如 if_icmpeq 等</li><li>方法调用与返回指令，例如 invokevirtual, invokestatic 等</li><li>抛出异常指令，例如 athrow 等</li><li>同步指令，例如 monitorenter 等</li></ul><p><strong>举几个简单的例子:</strong></p><p><code>iadd</code> 指令，表示对两个 int 数的相加指令。将从操作数栈顶依次取出两个数，并相加，再重新压入操作数栈中。</p><p><code>bipush 100</code> ，其中 <code>bipush</code> 是指令，后随一个操作数，表示把 <code>操作数 100 这个 byte 类型的数</code> 压入操作数栈顶</p><h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><p>JVM 定义了若干种运行期间会使用到的运行时数据区，见下图:</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ft5osi6it1j31kw0ql78e.jpg" alt="JVM 运行时数据区"></p><p>至于每一个的具体意义，在此不做详细展开，可用参考:</p><ul><li>由周志明等翻译的 《Java 虚拟机规范(Java SE 7版) 》 2.5节内容 <a href="http://icyfenix.iteye.com/blog/1256329" target="_blank" rel="noopener">链接</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5" target="_blank" rel="noopener">JVMS 2.5. Run-Time Data Areas</a></li></ul><h2 id="Getter-Setter-的指令代码"><a href="#Getter-Setter-的指令代码" class="headerlink" title="Getter, Setter 的指令代码"></a>Getter, Setter 的指令代码</h2><p>首先，有必要提及，想要得到 .class 可视且友好的展示结果，可以使用 JDK 自带的 <code>javap</code> 命令。</p><p>本节要展示的内容是常见的 POJO 的 get, set 方法的指令代码。使用的示例代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在经过 <code>javac</code> 编译，<code>javap</code> 解析之后，我们将看到下列内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">Classfile /Users/fangfeng/WorkPkg/lab/src/main/java/me/fangfeng/asm/Test.class</span><br><span class="line">  Last modified Jul 23, 2018; size 357 bytes</span><br><span class="line">  MD5 checksum bb1940cc6534d789359295b8dc80233b</span><br><span class="line">  Compiled from &quot;Test.java&quot;</span><br><span class="line">public class me.fangfeng.asm.Test</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #4.#17         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #3.#18         // me/fangfeng/asm/Test.number:I</span><br><span class="line">   #3 = Class              #19            // me/fangfeng/asm/Test</span><br><span class="line">   #4 = Class              #20            // java/lang/Object</span><br><span class="line">   #5 = Utf8               number</span><br><span class="line">   #6 = Utf8               I</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               getNumber</span><br><span class="line">  #12 = Utf8               ()I</span><br><span class="line">  #13 = Utf8               setNumber</span><br><span class="line">  #14 = Utf8               (I)V</span><br><span class="line">  #15 = Utf8               SourceFile</span><br><span class="line">  #16 = Utf8               Test.java</span><br><span class="line">  #17 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #18 = NameAndType        #5:#6          // number:I</span><br><span class="line">  #19 = Utf8               me/fangfeng/asm/Test</span><br><span class="line">  #20 = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  public me.fangfeng.asm.Test();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line"></span><br><span class="line">  public int getNumber();</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: getfield      #2                  // Field number:I</span><br><span class="line">         4: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 8: 0</span><br><span class="line"></span><br><span class="line">  public void setNumber(int);</span><br><span class="line">    descriptor: (I)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=2, args_size=2</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: iload_1</span><br><span class="line">         2: putfield      #2                  // Field number:I</span><br><span class="line">         5: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 12: 0</span><br><span class="line">        line 13: 5</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;Test.java&quot;</span><br></pre></td></tr></table></figure><p>打印出来的内容包括有 类的全限定名，访问控制权限，父类，接口，常量池以及各个方法。</p><p>以 <code>getNumber</code> 为例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public int getNumber();</span><br><span class="line">  descriptor: ()I</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=1, locals=1, args_size=1</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: getfield      #2                  // Field number:I</span><br><span class="line">       4: ireturn</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line 8: 0</span><br></pre></td></tr></table></figure><ul><li>descriptor: 表示方法描述符，其中 <code>()</code> 内容表示入参，<code>I</code> 表示返回值的类型</li><li>flags     : 表示方法的访问权限，当前限定为 <code>public</code></li><li>Code      : 存储有当前方法体指令码的一种方法内部属性。<ul><li>stack : 表示当前方法(意即在运行时所处的栈帧，每个方法的调用都将在 <code>虚拟机栈</code> 中构建一个新的 <code>栈帧</code>) 使用的 <code>操作数栈的最大深度</code></li><li>locals: 表示当前方法使用的 <code>局部变量表</code> 的大小</li><li>args_size : 表示变量个数</li><li>LineNumberTable : 与 Debug 有关，指当前的的指令集在源文件中的第几行开始</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0: aload_0              // 从局部变量表中加载 0 号元素到操作数栈中</span><br><span class="line">1: getfield #2          // 获取常量池中 2 号元素(即 Field number:I) 的值，并加载到操作数栈中</span><br><span class="line">4: ireturn              // 抛出当前操作数栈顶元素作为返回值</span><br></pre></td></tr></table></figure><p>其中，每条指令前的 0, 1, 4 指当前指令作为 <code>Code</code> 属性的内容的偏移量。</p><p>换一句话说，<code>aload_0</code> 是 Code 属性 code[] 的第 0 个字节的内容<br><code>getfield #2</code> 的是从 code[] 的第 1 个字节开始的。<br><code>ireturn</code> 是从 code[] 的第 4 个字节开始。</p><p>至于为什么每条指令的开始位置不同，这取决于每条指令的长度。<code>aload_0</code> 指令本身为 1 字节的长度，且不要求附带操作数。<br><code>getfield</code> 指令自长 1 个字节，但需要一个长度为 2 字节的常量池索引。因此 <code>ireturn</code> 将从第 4 字节开始</p><hr><p>同时，可能有人会有所疑问，<code>aload_0</code> 加载的 0 号元素是什么？它貌似没有被用到？</p><p>首先，在每个方法被触发，在构建新的栈帧时，<code>this</code> 将自动作为 0 号元素被存入新栈帧的局部变量表作为 0 号元素。<br>同时，如果方法有入参，则入参按入参声明顺序依次作为 1, 2, 3, … 元素存入。<br>(当然，这里存在特殊情况，诸如 long, double 这样长为 8 字节的元素，将占用 2 个局部变量表的数组下标，而其他元素顺延)。</p><p>至于看似 0 号元素 <code>this</code> 并没有被用到。事实上，它是作为 <code>getfield</code> 的一个限定被使用的。<br>试想，<code>getfield</code> 虽然通过 <code>#2</code> 能够知道需要获取到的变量名为 <code>number</code> 类型为 <code>I(即 int)</code> 的元素。但是，这个元素究竟属于哪个实例？<br>而操作数栈顶的 <code>this</code> 恰恰是指明，需要使用当前方法所在的类的 number 变量。</p><hr><p>类似的，我们看一下 <code>setNumber</code> 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0: aload_0              // 从局部变量表中加载 0 号元素到操作数栈中 (用于确定字段所属的类)</span><br><span class="line">1: iload_1              // 从局部变量表中加载 1 号元素到操作数栈中 (用于确定将要给字段赋的值)</span><br><span class="line">2: putfield      #2     // 获取常量池中 2 号元素(即 Field number:I) 的地址，并赋值</span><br><span class="line">5: return               // 无返回值的 return 指令来结束当前栈帧的执行</span><br></pre></td></tr></table></figure><h2 id="给变量赋初始值"><a href="#给变量赋初始值" class="headerlink" title="给变量赋初始值"></a>给变量赋初始值</h2><p>经常会见到在方法体内部有类似这样的声明 <code>int score = 100</code> ，那么这样的内容翻译成指令会是如何？</p><p>对于较小的值，例如 100，将通过 <code>bipush 100</code>, <code>istore_1(假设用局部变量表 1 号元素存储 score 变量</code> 类似的形式进行赋值。<br>类似的，还是 <code>sipush</code> ，两者的区别是 bipush 可以支持 1 字节大小的整数，sipush 支持 2 字节大小的整数。</p><p>但是，int 最大可是可以到达 4 字节，更甚者，long 将达到 8 字节。</p><p>这时候，将要借助的就是 <code>ldc #&lt;index&gt;</code> 用来读取常量池编号小于 128 的常量(例如整数常量，浮点常量等等)<br>那么，超出 128 编号的？使用 <code>ldc_w #&lt;index&gt;</code> 读取 2 字节内容作为编号，最大 65535。当然，更大的内容，常量池都不能支持了哈。</p><p>同时，区别于将 byte, short, int, float 统一作为 4 字节结果读取，对于 long, double 这样的八字节元素，使用 <code>ldc2_w</code></p><h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><p>作为一门图灵完备的语言，至少，控制结构是必不可少的元素。</p><p>那么，类似 <code>for(int i=0;i&lt;10;i++)</code> 的 Java 代码编译成指令到底是什么样的呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0: iconst_0                     // 赋值指令，往操作数栈顶添加整数值 0</span><br><span class="line">1: istore_1                     // 将操作数栈顶的元素存入局部变量表 1 号位置</span><br><span class="line">2: iload_1                      // 从局部变量表 1 号位置加载元素到操作数栈</span><br><span class="line">3: bipush        10             // 往操作数栈顶压入 byte 型值 10</span><br><span class="line">5: if_icmpge     21             // 将操作数栈顶的两个元素进行比较, 如果 次顶部元素 &gt;= 顶部元素，则重定向到偏移量为 21 的指令</span><br><span class="line">//  for (...) &#123;&#125; 语句块的内容</span><br><span class="line">15: iinc          1, 1          // 将局部变量表的 1 号位置元素 +1</span><br><span class="line">18: goto          2             // 跳转到偏移量为 2 的指令</span><br><span class="line">21: return                      // 调用无返回值的 return</span><br></pre></td></tr></table></figure><p>类似的，<code>if(...)</code> 语句的比较较之 <code>for(;;)</code> 就更为简单。类比偏移量为 5 的指令即可。</p><h2 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h2><p>JVM 指令集中总计有 4 种调用方法的指令，包括有: </p><ul><li><code>invokevirtual</code>, 对普通实例方法的调用，将根据对象类型进行分发调用</li><li><code>invokestatic</code>, 对静态方法的调用</li><li><code>invokespecial</code>, 用于调用类的初始化方法，也用于调用父类方法和私有方法</li><li><code>invokeinterface</code>, 用于调用接口方法</li></ul><p>以执行 <code>System.out.println()</code> 为例<br>假设常量池内容存在目标元素(具体以相应注释为准)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">invokevirtual #4                  // Method java/io/PrintStream.println:()V</span><br></pre></td></tr></table></figure><h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p>更多内容，包括: 如何实例化一个对象，如何抛出及处理异常，代码同步声明等，暂且不表。</p><p>有时间再做补充</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前描述过包括 ASM, CGlib, Java Proxy 的基本内容之后，本文将就更为基础的 JVM 指令集进行简单而有效的介绍。&lt;/p&gt;
&lt;p&gt;当然，在开始正文前，读者需要了解到，JVM 指令集这种类似于汇编的规范性内容，包含一百多个指令，若要求一一介绍。&lt;br&gt;那么，直接阅读 &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/html/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt; 绝对是比本文的内容更为详实且准确。&lt;/p&gt;
&lt;p&gt;这篇文档的目的，只是为了使读者建立起关于 JVM 指令集基本的常识性观念。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="https://DorMOUSE-None.github.io/tags/JVM/"/>
    
      <category term="Instruction" scheme="https://DorMOUSE-None.github.io/tags/Instruction/"/>
    
  </entry>
  
  <entry>
    <title>Java Proxy 源码解析</title>
    <link href="https://DorMOUSE-None.github.io/2018-07-20-Java-Proxy/"/>
    <id>https://DorMOUSE-None.github.io/2018-07-20-Java-Proxy/</id>
    <published>2018-07-19T16:00:00.000Z</published>
    <updated>2018-07-21T22:38:18.419Z</updated>
    
    <content type="html"><![CDATA[<p>在 Java 整个生态里面, 通用的有两类动态代理的应用: Java Proxy 与 CGlib 代理。</p><p>从宽泛的区别来说，Java Proxy 只能对接口进行增强，而 CGlib 同时适用于类和接口的增强。<br>而且，业内普遍的认知是，CGlib 动态代理较之于 Java Proxy 在生成字节码的速度上也更为高效。</p><a id="more"></a><h2 id="从实例开始…"><a href="#从实例开始…" class="headerlink" title="从实例开始…"></a>从实例开始…</h2><p>下面，首先来了解一下 Java Proxy 的使用编码:</p><p>ICodeFactory 接口, 作为将被 Java 动态代理增强的基本接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICodeFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Code <span class="title">getCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCode</span><span class="params">(Code code)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>CodeFactory 类, 作为 ICodeFactory 接口的实现类。被视为是真正被动态代理增强的内容，:) 因为接口方法并不存在方法体(当然，Java 8 及以上的 default 请容我忽视)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodeFactory</span> <span class="keyword">implements</span> <span class="title">ICodeFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Code code;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Code <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Code();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(Code code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>辅助类 Code 的内容(简单写，请忽略不符合实际编程规范的一些内容):<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> codeA;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String codeB;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>构建增强的代码逻辑:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main(String[]) 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部匿名类，用于动态代理生成类的构造方法及其它内容，后面讲。</span></span><br><span class="line">    InvocationHandler handler = <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line"></span><br><span class="line">        Object obj = <span class="keyword">new</span> CodeFactory();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (method.getName() == <span class="string">"getCode"</span>) &#123;</span><br><span class="line">                Code code = (Code) method.invoke(obj, args);</span><br><span class="line">                code.codeA = code.codeA + <span class="number">100</span>;</span><br><span class="line">                code.codeB = <span class="string">"Proxied: "</span> + code.codeB;</span><br><span class="line">                <span class="keyword">return</span> code;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> method.invoke(obj, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建生成类实例</span></span><br><span class="line">    Class&lt;?&gt; clazz = Proxy.getProxyClass(ICodeFactory.class.getClassLoader(), ICodeFactory.class);</span><br><span class="line">    <span class="comment">// 获取生成类对象</span></span><br><span class="line">    ICodeFactory factory = (ICodeFactory) clazz.getConstructor(<span class="keyword">new</span> Class[] &#123; InvocationHandler.class &#125;).newInstance(<span class="keyword">new</span> Object[] &#123; handler &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 getCode() 方法</span></span><br><span class="line">    Code code = factory.getCode();</span><br><span class="line">    <span class="comment">// 打印参数</span></span><br><span class="line">    System.out.println(code.codeA);</span><br><span class="line">    System.out.println(code.codeB);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从默认预期来讲，我们是对接口进行增强。接口方法不存在方法体，也许将在 <code>factory.getCode()</code> 时执行失败？<br>或者结合已有的认知，成功调用 <code>CodeFactory.getCode()</code> 方法，并获得 <code>new Code()</code> 。</p><p>那么，<code>code.codeA</code> <code>code.codeB</code> 的具体值将是什么？</p><p>执行结果将是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100</span><br><span class="line">Proxied: null</span><br></pre></td></tr></table></figure><h2 id="了解-Proxy-的内容逻辑"><a href="#了解-Proxy-的内容逻辑" class="headerlink" title="了解 Proxy 的内容逻辑"></a>了解 Proxy 的内容逻辑</h2><p>从 <code>Proxy.getProxyClass(ClassLoader, Class&lt;?&gt;...)</code> 入手，下面将展开对 <code>Proxy</code> 具体执行逻辑的探究。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces) <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">    <span class="comment">// 对 interfaces 数组的浅拷贝</span></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">    <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果配置了安全管理器，那么需要确认 Proxy 有创建新的代理类的许可</span></span><br><span class="line">        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 </span></span><br><span class="line">    <span class="keyword">return</span> getProxyClass0(loader, intfs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    <span class="comment">// 确认需要进行增强的接口数量少于等于 65535，详细原因请去了解 ClassFile 规范(规范中的接口上限)</span></span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要由指定 ClassLoader 加载, 实现给定 interfaces 的代理类已经存在, </span></span><br><span class="line">    <span class="comment">// 将直接返回已经缓存过的拷贝</span></span><br><span class="line">    <span class="comment">// 否则，通过 ProxyClassFactory 创建新的代理类</span></span><br><span class="line">    <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在需要额外来考察一下 proxyClassCache 的具体类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">        proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(), <span class="keyword">new</span> ProxyClassFactory());</span><br></pre></td></tr></table></figure><p><code>WeakCache</code>, 从名称来将，是一个缓存，同时应该使用了 WeakReference 技术</p><p>进入 <code>WeakCache.get(...)</code> 方法体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key, P parameter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// parameter 传入的是接口数组，要求不能为空</span></span><br><span class="line">    Objects.requireNonNull(parameter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除过期元素</span></span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建一个 WeakReference 对象(key 表示 ClassLoader)</span></span><br><span class="line">    Object cacheKey = CacheKey.valueOf(key, refQueue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lazily install the 2nd level valuesMap for the particular cacheKey</span></span><br><span class="line">    ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (valuesMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap</span><br><span class="line">                = map.putIfAbsent(cacheKey,</span><br><span class="line">                valuesMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line">        <span class="keyword">if</span> (oldValuesMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">            valuesMap = oldValuesMap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建次级 Key</span></span><br><span class="line">    <span class="comment">// 同时检索是否存在过去有同一个 ClassLoader 加载的表示 Supplier&lt;V&gt;</span></span><br><span class="line">    Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));</span><br><span class="line">    Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">    Factory factory = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (supplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// supplier might be a Factory or a CacheValue&lt;V&gt; instance</span></span><br><span class="line">            <span class="comment">// 最终 supplier 将非空，同时调用 .get() 方法获取 Class 类</span></span><br><span class="line">            V value = supplier.get();</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else no supplier in cache</span></span><br><span class="line">        <span class="comment">// or a supplier that returned null (could be a cleared CacheValue</span></span><br><span class="line">        <span class="comment">// or a Factory that wasn't successful in installing the CacheValue)</span></span><br><span class="line">        <span class="comment">// 未找到过去加载的记录</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 懒加载一个 Factory </span></span><br><span class="line">        <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            factory = <span class="keyword">new</span> Factory(key, parameter, subKey, valuesMap);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span><br><span class="line">            supplier = valuesMap.putIfAbsent(subKey, factory);</span><br><span class="line">            <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// successfully installed Factory</span></span><br><span class="line">                supplier = factory;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// else retry with winning supplier</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (valuesMap.replace(subKey, supplier, factory)) &#123;</span><br><span class="line">                <span class="comment">// successfully replaced</span></span><br><span class="line">                <span class="comment">// cleared CacheEntry / unsuccessful Factory</span></span><br><span class="line">                <span class="comment">// with our Factory</span></span><br><span class="line">                supplier = factory;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// retry with current supplier</span></span><br><span class="line">                supplier = valuesMap.get(subKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="comment">// serialize access</span></span><br><span class="line">    <span class="comment">// re-check</span></span><br><span class="line">    Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">    <span class="keyword">if</span> (supplier != <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// something changed while we were waiting:</span></span><br><span class="line">        <span class="comment">// might be that we were replaced by a CacheValue</span></span><br><span class="line">        <span class="comment">// or were removed because of failure -&gt;</span></span><br><span class="line">        <span class="comment">// return null to signal WeakCache.get() to retry</span></span><br><span class="line">        <span class="comment">// the loop</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// else still us (supplier == this)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// create new value</span></span><br><span class="line">    V value = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 触发 valueFactory.apply() 真正的构建</span></span><br><span class="line">        value = Objects.requireNonNull(valueFactory.apply(key, parameter));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123; <span class="comment">// remove us on failure</span></span><br><span class="line">            valuesMap.remove(subKey, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// the only path to reach here is with non-null value</span></span><br><span class="line">    <span class="keyword">assert</span> value != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wrap value with CacheValue (WeakReference)</span></span><br><span class="line">    CacheValue&lt;V&gt; cacheValue = <span class="keyword">new</span> CacheValue&lt;&gt;(value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// put into reverseMap</span></span><br><span class="line">    reverseMap.put(cacheValue, Boolean.TRUE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// try replacing us with CacheValue (this should always succeed)</span></span><br><span class="line">    <span class="keyword">if</span> (!valuesMap.replace(subKey, <span class="keyword">this</span>, cacheValue)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Should not reach here"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// successfully replaced us with new CacheValue -&gt; return the value</span></span><br><span class="line">    <span class="comment">// wrapped by it</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两段代码的内容，都是在反复确认将要构建的生成类是否在过去曾经创建过，如果是，则直接返回过去构建的类实例;<br>否则才会尝试创建，并最终将这个构建的类也进行缓存。</p><p>下面这段代码来自于 <code>Proxy</code> 的内部类 <code>ProxyClassFactory</code><br>这部分，也终于开始了对代理类字节码的统筹性构造的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 校验当前接口是由同一个 ClassLoader (将要用来加载新的代理类)加载的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class&lt;?&gt; interfaceClass = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            interfaceClass = Class.forName(intf.getName(), <span class="keyword">false</span>, loader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (interfaceClass != intf) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    intf + <span class="string">" is not visible from class loader"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 校验当前 Class 对象确实是一个接口</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    interfaceClass.getName() + <span class="string">" is not an interface"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 校验当前接口没有被要求重复进行代理增强</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (interfaceSet.put(interfaceClass, Boolean.TRUE) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"repeated interface: "</span> + interfaceClass.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String proxyPkg = <span class="keyword">null</span>;     <span class="comment">// 生成的代理类所属的 package</span></span><br><span class="line">    <span class="keyword">int</span> accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果代理的接口是非 PUBLIC ，那么生成的代理类的接口将与这个非 PUBLIC 接口</span></span><br><span class="line"><span class="comment">     * 在同一个包下。</span></span><br><span class="line"><span class="comment">     * 如果代理的接口有多个非 PUBLIC ，且分别位于不同的包下，那么抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">        <span class="keyword">int</span> flags = intf.getModifiers();</span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">            accessFlags = Modifier.FINAL;</span><br><span class="line">            String name = intf.getName();</span><br><span class="line">            <span class="keyword">int</span> n = name.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">            String pkg = ((n == -<span class="number">1</span>) ? <span class="string">""</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                proxyPkg = pkg;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                        <span class="string">"non-public interfaces from different packages"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果代理的接口全是 PUBLIC 的，那么使用默认的包 com.sun.proxy</span></span><br><span class="line">    <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// if no non-public proxy interfaces, use com.sun.proxy package</span></span><br><span class="line">        proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">"."</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 为将要生成的代理类选择一个全限定名</span></span><br><span class="line"><span class="comment">     * 规则是 包名 + "$Proxy" + &lt;唯一递增的id, 从0开始编号&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">    String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 生成一个特殊的代理类的字节码</span></span><br><span class="line"><span class="comment">     * byte[] proxyClassFile 就等同于 .class 文件的全部二进制内容。</span></span><br><span class="line"><span class="comment">     * 与 .class 文件的区别就在于一个写在了外存上，另一个完全在内存中创建</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">            proxyName, interfaces, accessFlags);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 调用 ClassLoader 的 defineClass0(...) 方法加载字节码内容，构造 Class 对象</span></span><br><span class="line"><span class="comment">          * 本来 defineClass0(...) 方法是定义在 ClassLoader 中，但这里额外声明了一个本地方法 defineClass0(...)</span></span><br><span class="line"><span class="comment">          * 想来实现也是类似的，最终的目的也是加载 Class </span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        <span class="keyword">return</span> defineClass0(loader, proxyName,</span><br><span class="line">                proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * A ClassFormatError here means that (barring bugs in the</span></span><br><span class="line"><span class="comment">         * proxy class generation code) there was some other</span></span><br><span class="line"><span class="comment">         * invalid aspect of the arguments supplied to the proxy</span></span><br><span class="line"><span class="comment">         * class creation (such as virtual machine limitations</span></span><br><span class="line"><span class="comment">         * exceeded).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在完成基础性的校验，并构造了生成类的类名等内容后，<br><code>ProxyGenerator.generateProxyClass</code> 将开始构造 <a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html" target="_blank" rel="noopener">ClassFile</a> 的具体内容。</p><p>关于这部分生成字节码的内容，请在了解了 ClassFile 的基础性内容之后，在自行学习，内容全部在 ProxyGenerator 类中。</p><p>这部分的规则是(在构建新的代理生成类时):</p><ul><li>额外添加三个 Object 的方法 (<code>hashCode</code>, <code>equals</code>, <code>toString</code>)</li><li>逐一读取所有需要增强的接口的方法，并对重复方法进行判断; 如果方法名相同，入参数量与类型相同，但返回参数不同，则抛出异常</li><li>在遍历所有接口的方法的时候，同时也将为新的生成类构造新的字段(内容就是通过反射获取该方法)</li><li>最后将新的生成类将要包含的所有字段与方法进行构造，同时维护一个常量池内容</li><li>输出这些内容的二进制表示 byte[];</li></ul><h2 id="如何对方法增强"><a href="#如何对方法增强" class="headerlink" title="如何对方法增强"></a>如何对方法增强</h2><p>想必上了上一节，虽然对 Java 动态代理的调用链有了一定的了解。</p><p>但是，究竟 Proxy 是如何完成对实现类方法的增强呢？</p><p>也许我们需要先看一下生成类 .class 文件的一些内容来对这个命题形成基础性的影响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Code <span class="title">getCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Code)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m4, (Object[])<span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">        <span class="keyword">throw</span> var2;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，生成类的 <code>getCode()</code> 方法几乎没有什么实质性的内容, 只是 <code>super.h.invoke(...)</code> 。</p><p><code>h</code> 实例变量是什么？<code>InvocationHandler</code> 的一个实例对象。</p><p>事实上，Java Proxy 生成类的每个方法结构几乎都是类似的。方法体的内容就是通过实例持有的 <code>h</code> 变量分发实际的操作指令</p><p>至于 h 的具体内容。:) 有编程者自定义，并在 Proxy 生成字节码，并被 ClassLoader 加载后，在准备实例化的时候作为构造参数进行传入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ICodeFactory factory = (ICodeFactory) clazz.getConstructor(<span class="keyword">new</span> Class[] &#123; InvocationHandler.class &#125;).newInstance(<span class="keyword">new</span> Object[] &#123; handler &#125;);</span><br></pre></td></tr></table></figure><p>至于具体将做哪些增强，调用例如上例的 <code>ICodeFactory</code> 的那个实现类的方法，全部有使用者自定义。</p><h2 id="生成类的反编译结果"><a href="#生成类的反编译结果" class="headerlink" title="生成类的反编译结果"></a>生成类的反编译结果</h2><p>仍然以本文开始的 ICodeFactory 的增强为例，看一下究竟通过 Java Proxy 动态代理生成的字节码的反编译结果究竟是什么？<br>并以此来对这种动态代理机制形成更为直观的印象</p><p>在 Java 源代码中，虽然默认不会输出生成类的二进制内容，但是，仍然预留了打印 .class 文件的可选项。</p><p>有兴趣的同学可以看一下 <code>ProxyGenerator.saveGeneratedFiles</code> 字段的内容，这就决定是在构造代理类后是否存储到外存中。</p><p>想要看到代理类的字节码，直接通过在 Java 执行程序中添加一行代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</span><br></pre></td></tr></table></figure><p>或者在启动程序的 <code>java</code> 命令下添加参数</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dsun.misc.ProxyGenerator.saveGeneratedFiles=<span class="literal">true</span>`</span><br></pre></td></tr></table></figure><p>至于生成类将打印在哪，首先必然是在项目所属的目录下。有上一节中构造生成类全限定名的内容，根据包名的规则去寻找即可。(具体不再详述)</p><p>直接通过 IDEA, Eclipse 或者其它工具，对生成类 .class 文件进行反编译可以查看到整个生成类的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sun.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"><span class="keyword">import</span> me.fangfeng.jdk.proxy.Code;</span><br><span class="line"><span class="keyword">import</span> me.fangfeng.jdk.proxy.ICodeFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">ICodeFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Code <span class="title">getCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Code)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m4, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(Code var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m4 = Class.forName(<span class="string">"me.fangfeng.jdk.proxy.ICodeFactory"</span>).getMethod(<span class="string">"getCode"</span>);</span><br><span class="line">            m3 = Class.forName(<span class="string">"me.fangfeng.jdk.proxy.ICodeFactory"</span>).getMethod(<span class="string">"setCode"</span>, Class.forName(<span class="string">"me.fangfeng.jdk.proxy.Code"</span>));</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Java 整个生态里面, 通用的有两类动态代理的应用: Java Proxy 与 CGlib 代理。&lt;/p&gt;
&lt;p&gt;从宽泛的区别来说，Java Proxy 只能对接口进行增强，而 CGlib 同时适用于类和接口的增强。&lt;br&gt;而且，业内普遍的认知是，CGlib 动态代理较之于 Java Proxy 在生成字节码的速度上也更为高效。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://DorMOUSE-None.github.io/tags/Java/"/>
    
      <category term="Proxy" scheme="https://DorMOUSE-None.github.io/tags/Proxy/"/>
    
  </entry>
  
  <entry>
    <title>如何方便地获取 CGlib 生成类</title>
    <link href="https://DorMOUSE-None.github.io/2018-07-13-How-to-easily-get-CGlib-generated-code/"/>
    <id>https://DorMOUSE-None.github.io/2018-07-13-How-to-easily-get-CGlib-generated-code/</id>
    <published>2018-07-12T16:00:00.000Z</published>
    <updated>2018-07-13T12:55:17.325Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h2><p><strong>命令行使用</strong></p><p>在 java 启动命令中添加参数配置项 <code>-Dcglib.debugLocation=&lt;Custom Path&gt;</code></p><p><strong>编码实现</strong></p><p>在执行 CGlib 获取新生成类之前，调用 <code>System.setProperty(&quot;cglib.debugLocation&quot;, &lt;Custom Path&gt;)</code></p><a id="more"></a><h2 id="如何游刃有余地-Debug-掺杂-CGlib-生成类的调用链"><a href="#如何游刃有余地-Debug-掺杂-CGlib-生成类的调用链" class="headerlink" title="如何游刃有余地 Debug 掺杂 CGlib 生成类的调用链"></a>如何游刃有余地 Debug 掺杂 CGlib 生成类的调用链</h2><p>经常会遇到，项目中不经意间就遇到了 CGlib 代理，然后对调用链的 Debug 就开始出现断层。继而，对对象或实例变量的跟踪就显得一头雾水。</p><p>特别是在不了解生成类到底是增强了那些内容的时候，甚至可能连调用链都跟踪不下去了 T_T 。</p><p>通过 <strong>配置参数</strong> 一节的内容，你就可以在你理想的目录 <code>&lt;Custom Path&gt;</code> 下看到<strong>所谓黑盒</strong>中生成类的完成内容了。</p><p>下面的内容，将简单地介绍如何配合 CGlib 生成类的内容实现: 保证 Debug 的每一步骤可见; 保证 Debug 的过程不会出现<em>黑盒</em>。</p><h3 id="确定-lt-Custom-Path-gt-下哪个文件是原有-Java-类的生成类"><a href="#确定-lt-Custom-Path-gt-下哪个文件是原有-Java-类的生成类" class="headerlink" title="确定 &lt;Custom Path&gt; 下哪个文件是原有 Java 类的生成类"></a>确定 <code>&lt;Custom Path&gt;</code> 下哪个文件是原有 Java 类的生成类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getClassName</span><span class="params">(String prefix, String source, Object key, Predicate names)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prefix == <span class="keyword">null</span>) &#123;</span><br><span class="line">        prefix = <span class="string">"net.sf.cglib.empty.Object"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prefix.startsWith(<span class="string">"java"</span>)) &#123;</span><br><span class="line">        prefix = <span class="string">"$"</span> + prefix;</span><br><span class="line">    &#125;</span><br><span class="line">    String base =</span><br><span class="line">        prefix + <span class="string">"$$"</span> +</span><br><span class="line">        source.substring(source.lastIndexOf(<span class="string">'.'</span>) + <span class="number">1</span>) +</span><br><span class="line">        getTag() + <span class="string">"$$"</span> +</span><br><span class="line">        Integer.toHexString(STRESS_HASH_CODE ? <span class="number">0</span> : key.hashCode());</span><br><span class="line">    String attempt = base;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (names.evaluate(attempt))</span><br><span class="line">        attempt = base + <span class="string">"_"</span> + index++;</span><br><span class="line">    <span class="keyword">return</span> attempt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CGlib 默认的类名生成策略下，生成类的全限定名将结合原文件的全限定名决定。</p><p>通常命名如下: <code>&lt;原 Java 类全限定名&gt;$$&lt;类似 EnhancerByCGlib&gt;$$&lt;生成类核心内容的 hash 值&gt;_&lt;index[可能存在]&gt;</code></p><p>例如: 原有 Java 类全限定名为 me.fangfeng.Test ，则生成类名可能为 <code>me.fangfeng.Test$$EnhancerByCGlib$$ab1203aa</code></p><p>当然，通常情况下会存在一个类名形如 <code>me.fangfeng.Test$$FastClassBySpring$$...</code> 的类，这是作为生成类 <code>me.fangfeng.Test$$EnhancerByCGlib$$ab1203aa</code> 的辅助类来使用。</p><h3 id="简单了解生成类下的调用关系"><a href="#简单了解生成类下的调用关系" class="headerlink" title="简单了解生成类下的调用关系"></a>简单了解生成类下的调用关系</h3><p>Java 代码触发被增强的类，将首先调用生成类。但是，这是没办法进行 Debug 的，因为这个生成类的字节码缺少 SourceFile 属性，同时缺少 LineNumberTable 属性。</p><p>但是，这并不影响对调用链的跟踪。</p><p>CGlib 的增强，所有的增强逻辑都是以 Callback 实现类的形式来提供的。同时在 CGlib 生成类中也有 Callback 的实例变量来持有这些注入的 Callback 。</p><p><strong>原有 Java 类</strong></p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1ft8e7kr7qvj30sc0j0wh4.jpg" alt="LogonService.java"></p><p><strong>对应的生成类</strong></p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1ft8e9ww4hqj31hg0oojzv.jpg" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1ft8eanb6c9j31j00lgn1e.jpg" alt=""></p><p><strong>跟踪 LogonService.addLogon(String var1) 演示</strong></p><p>当前 LogonService 的生成类全限定名为me.fangfeng.transactionBugs.LogonService$$EnhancerBySpringCGLIB$$bfc1dc3.class; 以下简称为 LogonSerivce$$bfc1dc3 </p><ol><li><p>首先，配置 <code>cglib.debugLocation</code> 参数，值 = 项目生成的 .class 路径</p></li><li><p>无断点直接运行一次需要处理的逻辑</p></li><li><p>找到 LogonSerive$$bfc1dc3.class, 随意打上一个看似有效的断点</p></li><li><p>在各处打上必要的断点，开始进行真正的调试工作</p></li><li><p>代码执行到 LogonService$$bfc1dc3.class, 虽然没有真正进入断点位置, 但是可以看到这个 LogonService$$bfc1dc3 实例的实例变量信息</p></li></ol><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1ft8eq1be61j319w0bwtde.jpg" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1ft8egtg1naj31ji0fmgp2.jpg" alt=""></p><p>比照生成类代码中 addLogon(String var1) 方法体的内容以及展示的实例变量信息。可以看到生成类调用的 Callback 实例是 <code>CGLIB$CALLBACK_0</code><br>类型是 CglibAopProxy 的静态内部私有类 DynamicAdvisedInterceptor 。</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1ft8eu91oscj31gq0ayju5.jpg" alt=""></p><p>在 intercept(…) 上打个断点，跳过生成类 addLogon(String var1) 方法的下一个调用方法就是 intercept(…) </p><p><strong>而且事实上，CGlib 生成类的内容基本也就是对调用方法进行的一种转发</strong></p><ol start="6"><li>继续 Debug ，对于生成类的内容，人肉了解并定位到触发的 Callback 实例或者 super.Xxx() 方法。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;配置参数&quot;&gt;&lt;a href=&quot;#配置参数&quot; class=&quot;headerlink&quot; title=&quot;配置参数&quot;&gt;&lt;/a&gt;配置参数&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;命令行使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 java 启动命令中添加参数配置项 &lt;code&gt;-Dcglib.debugLocation=&amp;lt;Custom Path&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编码实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在执行 CGlib 获取新生成类之前，调用 &lt;code&gt;System.setProperty(&amp;quot;cglib.debugLocation&amp;quot;, &amp;lt;Custom Path&amp;gt;)&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="CGlib" scheme="https://DorMOUSE-None.github.io/tags/CGlib/"/>
    
      <category term="tools" scheme="https://DorMOUSE-None.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>CGlib Enhancer 主流程源码解析</title>
    <link href="https://DorMOUSE-None.github.io/2018-07-10-CGlib-Enhancer/"/>
    <id>https://DorMOUSE-None.github.io/2018-07-10-CGlib-Enhancer/</id>
    <published>2018-07-09T16:00:00.000Z</published>
    <updated>2018-07-10T08:22:13.833Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此博文写作的目的: </p><ul><li>(Core) 通过了解 CGlib Enhancer 的整个调用链，了解其对于唯一依赖的 ASM 库的调用方式。</li><li>基于 Enhancer 对已有字节码进行增强的进一步理解与掌握。</li></ul><a id="more"></a><h2 id="Enhancer"><a href="#Enhancer" class="headerlink" title="Enhancer"></a>Enhancer</h2><p>从这篇不是官方但更胜于官方文档的 <a href="http://mydailyjava.blogspot.com/2013/11/cglib-missing-manual.html" target="_blank" rel="noopener">CGlib Guide</a> 来看，它首先提到的第一个类就是 Enhancer。<br>其被用于创建 Java 代理类，相较于 Java 标准库的 Proxy 类，它<strong>特别地</strong>，能够支持那些没有实现接口的类的代理工作。</p><h3 id="Enhancer-简单示例展示"><a href="#Enhancer-简单示例展示" class="headerlink" title="Enhancer 简单示例展示"></a>Enhancer 简单示例展示</h3><p>针对现有的 SampleClass 类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用 CGlib 的 Enhancer 对 SampleClass 进行增强，下列操作的目的在于将 test(String) 方法的返回值改写成 “Hello cglib!”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFixedValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// new 一个 Enhancer 实例</span></span><br><span class="line">    Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">    <span class="comment">// 声明使用的父类是 SampleClass</span></span><br><span class="line">    enhancer.setSuperclass(SampleClass.class);</span><br><span class="line">    <span class="comment">// 设置回调方法 - 回调方法实现为 FixedValue (固定值) .</span></span><br><span class="line">    enhancer.setCallback(<span class="keyword">new</span> FixedValue() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">loadObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Hello cglib!"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 创建 SampleClass 的代理子类实例</span></span><br><span class="line">    SampleClass proxy = (SampleClass) enhancer.create();</span><br><span class="line">    Assert.assertEquals(<span class="string">"Hello cglib!"</span>, proxy.test(<span class="keyword">null</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单测试上述代码，可以了解到确实，代理类的 test(String) 方法的返回值被改写了。<br>那么，究竟这种操作是如何实现的？下面👇将进行具体的探究。</p><h2 id="调用链跟踪"><a href="#调用链跟踪" class="headerlink" title="调用链跟踪"></a>调用链跟踪</h2><h3 id="高度抽象的时序图"><a href="#高度抽象的时序图" class="headerlink" title="高度抽象的时序图"></a>高度抽象的时序图</h3><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1ft4ifuo997j31jh0st42t.jpg" alt="Enhancer 调用链 时序图"></p><p><em>下列内容将根据时序图进行组织，根据调用编号(1,2,3…)进行展开</em></p><h3 id="Seq-1"><a href="#Seq-1" class="headerlink" title="Seq 1."></a>Seq 1.</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    classOnly = <span class="keyword">false</span>;</span><br><span class="line">    argumentTypes = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> createHelper();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">create</span><span class="params">(Class[] argumentTypes, Object[] arguments)</span> </span>&#123;</span><br><span class="line">    classOnly = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (argumentTypes == <span class="keyword">null</span> || arguments == <span class="keyword">null</span> || argumentTypes.length != arguments.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Arguments must be non-null and of equal length"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.argumentTypes = argumentTypes;</span><br><span class="line">    <span class="keyword">this</span>.arguments = arguments;</span><br><span class="line">    <span class="keyword">return</span> createHelper();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述两个 <code>create(...)</code> 方法。结合上一节的使用示例，可以看到 <code>create()</code> 对应的<strong>无参构造</strong>。<br>存在无参构造，那么<strong>有参的构造方法</strong>显然也是应该被支持id。<code>create(Class[], Object[])</code> 正是为了这个目标而存在。通过提供参数类型数组和参数实例数组，可以唯一地定位及调用代理类的特定构造方法。</p><p>这个方法比较简单，只是将 Enhancer 作为一个数据内容的持有者，重置了新代理类将使用的构造函数参数内容，之后就直接调用了 <code>createHelper()</code> 。</p><h3 id="Seq-2"><a href="#Seq-2" class="headerlink" title="Seq 2."></a>Seq 2.</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">createHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对预声明的回调方法进行验证，要求 [多个回调就必须存在 CallbackFilter 作为调度器]</span></span><br><span class="line">    preValidate();</span><br><span class="line">    <span class="comment">// 构建一个对这类增强操作唯一定位的 key</span></span><br><span class="line">    Object key = KEY_FACTORY.newInstance((superclass != <span class="keyword">null</span>) ? superclass.getName() : <span class="keyword">null</span>,</span><br><span class="line">            ReflectUtils.getNames(interfaces),</span><br><span class="line">            filter == ALL_ZERO ? <span class="keyword">null</span> : <span class="keyword">new</span> WeakCacheKey&lt;CallbackFilter&gt;(filter),</span><br><span class="line">            callbackTypes,</span><br><span class="line">            useFactory,</span><br><span class="line">            interceptDuringConstruction,</span><br><span class="line">            serialVersionUID);</span><br><span class="line">    <span class="keyword">this</span>.currentKey = key;</span><br><span class="line">    <span class="comment">// 调用父类通过的 create(...) 方法</span></span><br><span class="line">    Object result = <span class="keyword">super</span>.create(key);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Seq-3"><a href="#Seq-3" class="headerlink" title="Seq 3."></a>Seq 3.</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">create</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取用于 加载 生成类 的 ClassLoader</span></span><br><span class="line">        ClassLoader loader = getClassLoader();</span><br><span class="line">        <span class="comment">// 从缓存中加载 这个 ClassLoader 过去加载的相关数据</span></span><br><span class="line">        Map&lt;ClassLoader, ClassLoaderData&gt; cache = CACHE;</span><br><span class="line">        ClassLoaderData data = cache.get(loader);</span><br><span class="line">        <span class="comment">// 如果在 缓存 中找不到，则初始化构造关于这个 ClassLoader 的数据实例</span></span><br><span class="line">        <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 同步</span></span><br><span class="line">            <span class="keyword">synchronized</span> (AbstractClassGenerator.class) &#123;</span><br><span class="line">                <span class="comment">// 进入同步块后的 再次确认，避免重复初始化构建</span></span><br><span class="line">                cache = CACHE;</span><br><span class="line">                data = cache.get(loader);</span><br><span class="line">                <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 构建新的 缓存，拷贝原有的缓存集的内容</span></span><br><span class="line">                    Map&lt;ClassLoader, ClassLoaderData&gt; newCache = <span class="keyword">new</span> WeakHashMap&lt;ClassLoader, ClassLoaderData&gt;(cache);</span><br><span class="line">                    <span class="comment">// 初始化 ClassLoaderData ，真正的构造操作</span></span><br><span class="line">                    data = <span class="keyword">new</span> ClassLoaderData(loader);</span><br><span class="line">                    <span class="comment">// 添加到缓存中</span></span><br><span class="line">                    newCache.put(loader, data);</span><br><span class="line">                    CACHE = newCache;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        Object obj = data.get(<span class="keyword">this</span>, getUseCache());</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">            <span class="comment">// 初次实例化操作，就是 Class 利用反射来进行实例化</span></span><br><span class="line">            <span class="keyword">return</span> firstInstance((Class) obj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 非初次实例化，则是从 ClassLoaderData 中得到的之前维护的内容</span></span><br><span class="line">        <span class="keyword">return</span> nextInstance(obj);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CodeGenerationException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分内容比较多，且是调用链比较重要的一环。<strong>Seq 4.</strong> 和 <strong>Seq 5.</strong> 将作为其子内容进行调用，但为了本博文的结构完整， <em>Seq 4. &amp; Seq5.</em> 的标题与 <em>Seq 3.</em> 标题同级</p><h3 id="Seq-4"><a href="#Seq-4" class="headerlink" title="Seq 4."></a>Seq 4.</h3><p>首先应该认识到，每个被加载的 Class ，在 <code>equal</code> 的判断过程中，依据的是同一个 ClassLoader 加载的同一 Class 才被认为是相同的，否则即使 Class 是同一个，但仍会被认为是不同的(由不同的 ClassLoader 加载)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ClassLoader t = classLoader;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">        t = getDefaultClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">        t = getClass().getClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">        t = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot determine classloader"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，在这部分中，首先需要确定的是由哪个 ClassLoader 进行加载的工作。<code>getClassLoader()</code> 的确定顺序是:</p><ol><li>具体实现类声明的 <strong>默认 ClassLoader</strong> 为第一优先级</li><li>加载当前类(这里是 Enhancer) 的 ClassLoader 为第二优先级</li><li><strong>当前线程上下文 ClassLoader</strong> 为第三优先级</li><li>抛出异常</li></ol><p>回到 <strong>Seq 3.</strong> 的内容，<br>下一步是对当前这个<strong>AbstractClassGenerator</strong> 维护的 CACHE 进行处理，如果在 CACHE 中能够得到以确定的 ClassLoader 为 Key 的键值对，则直接获取 ClassLoader 对应的值，否则将进行初始化构建一个新的 ClassLoaderData 作为这个 ClassLoader 的值。</p><h3 id="Seq-5"><a href="#Seq-5" class="headerlink" title="Seq 5."></a>Seq 5.</h3><p>在构建 ClassLoaderData 的过程中，最重要的一步:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassLoaderData</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ClassLoader 不可为空</span></span><br><span class="line">    <span class="keyword">if</span> (classLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"classLoader == null is not yet supported"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建 ClassLoader 的弱引用</span></span><br><span class="line">    <span class="keyword">this</span>.classLoader = <span class="keyword">new</span> WeakReference&lt;ClassLoader&gt;(classLoader);</span><br><span class="line">    <span class="comment">// 写了个后置调用的函数，用于懒加载，只有调用了 load.apply(...) 才会构建 生成类</span></span><br><span class="line">    Function&lt;AbstractClassGenerator, Object&gt; load =</span><br><span class="line">            <span class="keyword">new</span> Function&lt;AbstractClassGenerator, Object&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">apply</span><span class="params">(AbstractClassGenerator gen)</span> </span>&#123;</span><br><span class="line">                    Class klass = gen.generate(ClassLoaderData.<span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">return</span> gen.wrapCachedClass(klass);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">    generatedClasses = <span class="keyword">new</span> LoadingCache&lt;AbstractClassGenerator, Object, Object&gt;(GET_KEY, load);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建了一个 Function 实例，这个 Function 作为函数式接口，预定义执行的具体流程，但由上下文确定具体的调用时刻。</p><h3 id="Seq-6"><a href="#Seq-6" class="headerlink" title="Seq 6."></a>Seq 6.</h3><p>在正确得到了 ClassLoader 对应的 ClassLoaderData 之后，ClassLoaderData 的 <code>get(...)</code> 方法将在特定的 ClassLoader 之下，进行更具体的加载新生成类的工作。<br>当然，这里的前提是新的生成类的字节码已经被构建:)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(AbstractClassGenerator gen, <span class="keyword">boolean</span> useCache)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标记为不使用缓存，直接构建 新的生成类</span></span><br><span class="line">    <span class="keyword">if</span> (!useCache) &#123;</span><br><span class="line">      <span class="keyword">return</span> gen.generate(ClassLoaderData.<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用缓冲的情况</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      Object cachedValue = generatedClasses.get(gen);</span><br><span class="line">      <span class="keyword">return</span> gen.unwrapCachedValue(cachedValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>gen.generate(ClassLoaderData.this)</code> 这段代码在 <code>get(...)</code> 方法和上一小节 <code>ClassLoaderData(...)</code> 构造方法的 Function 函数式实例都出现了。</p><p>实际上，这也是触发 ClassLoader 来加载动态生成的新 Class 的唯一入口。</p><p><em>判断逻辑</em> 的 <code>else</code> 内容的唯一区别就在于其构建的是一个加载缓存，将真正触发 gen.generate(ClassLoaderData.this) 的逻辑延迟。(不过，最终也还是会进行调用的，:) 这是毋庸置疑的)。</p><h3 id="Seq-7"><a href="#Seq-7" class="headerlink" title="Seq 7."></a>Seq 7.</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Class <span class="title">generate</span><span class="params">(ClassLoaderData data)</span> </span>&#123;</span><br><span class="line">    Class gen;</span><br><span class="line">    Object save = CURRENT.get();</span><br><span class="line">    CURRENT.set(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 拿到用于加载生成类的 ClassLoader</span></span><br><span class="line">        ClassLoader classLoader = data.getClassLoader();</span><br><span class="line">        <span class="keyword">if</span> (classLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"ClassLoader is null while trying to define class "</span> +</span><br><span class="line">                    getClassName() + <span class="string">". It seems that the loader has been expired from a weak reference somehow. "</span> +</span><br><span class="line">                    <span class="string">"Please file an issue at cglib's issue tracker."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构建一个合法的 生成类 的类名(非重复)</span></span><br><span class="line">        <span class="keyword">synchronized</span> (classLoader) &#123;</span><br><span class="line">          String name = generateClassName(data.getUniqueNamePredicate());</span><br><span class="line">          data.reserveName(name);</span><br><span class="line">          <span class="keyword">this</span>.setClassName(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (attemptLoad) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 尝试直接通过 ClassLoader 进行加载</span></span><br><span class="line">                gen = classLoader.loadClass(getClassName());</span><br><span class="line">                <span class="keyword">return</span> gen;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 策略下的生成类构建方法</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = strategy.generate(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 通过解析字节码的形式获取 生成类的 className</span></span><br><span class="line">        String className = ClassNameReader.getClassName(<span class="keyword">new</span> ClassReader(b));</span><br><span class="line">        ProtectionDomain protectionDomain = getProtectionDomain();</span><br><span class="line">        <span class="keyword">synchronized</span> (classLoader) &#123; <span class="comment">// just in case</span></span><br><span class="line">            <span class="comment">// 反射的形式加载 Class 类</span></span><br><span class="line">            <span class="keyword">if</span> (protectionDomain == <span class="keyword">null</span>) &#123;</span><br><span class="line">                gen = ReflectUtils.defineClass(className, b, classLoader);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                gen = ReflectUtils.defineClass(className, b, classLoader, protectionDomain);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> gen;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CodeGenerationException(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        CURRENT.set(save);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法，就是操作字节码，加载 Class 的核心调度方法。</p><p>可以看到 <code>generateClassName(...)</code> 方法将构建一个当前 ClassLoader 下唯一, 不重复的新的类名。</p><p><code>strategy.generate(this)</code> 将通过特定策略实现的形式生成新的字节码</p><p><code>ReflectUtils.defineClass(className, b, classLoader)</code> 将使用反射使得 ClassLoader 来加载这个新的生成类。</p><h3 id="Seq-8"><a href="#Seq-8" class="headerlink" title="Seq 8."></a>Seq 8.</h3><p>生成新的不重复类名这部分不做过多陈述，可以简单进行了解，并熟悉 CGlib 默认的新类名的命名规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultNamePolicy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getClassName</span><span class="params">(String prefix, String source, Object key, Predicate names)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prefix == <span class="keyword">null</span>) &#123;</span><br><span class="line">        prefix = <span class="string">"net.sf.cglib.empty.Object"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prefix.startsWith(<span class="string">"java"</span>)) &#123;</span><br><span class="line">        prefix = <span class="string">"$"</span> + prefix;</span><br><span class="line">    &#125;</span><br><span class="line">    String base =</span><br><span class="line">        prefix + <span class="string">"$$"</span> +</span><br><span class="line">        source.substring(source.lastIndexOf(<span class="string">'.'</span>) + <span class="number">1</span>) +</span><br><span class="line">        getTag() + <span class="string">"$$"</span> +</span><br><span class="line">        Integer.toHexString(STRESS_HASH_CODE ? <span class="number">0</span> : key.hashCode());</span><br><span class="line">    String attempt = base;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (names.evaluate(attempt))</span><br><span class="line">        attempt = base + <span class="string">"_"</span> + index++;</span><br><span class="line">    <span class="keyword">return</span> attempt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Seq-9"><a href="#Seq-9" class="headerlink" title="Seq 9."></a>Seq 9.</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下列是 DefaultGeneratorStrategy 的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] generate(ClassGenerator cg) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    DebuggingClassWriter cw = getClassVisitor();</span><br><span class="line">    transform(cg).generateClass(cw);</span><br><span class="line">    <span class="keyword">return</span> transform(cw.toByteArray());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Seq-10"><a href="#Seq-10" class="headerlink" title="Seq 10."></a>Seq 10.</h3><p>调用 <code>generateClass(ClassVisitor)</code> 将获得到新类的字节码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateClass</span><span class="params">(ClassVisitor v)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 确定生成类的 父类</span></span><br><span class="line">    Class sc = (superclass == <span class="keyword">null</span>) ? Object.class : superclass;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父类标识符不可以为 final</span></span><br><span class="line">    <span class="keyword">if</span> (TypeUtils.isFinal(sc.getModifiers()))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot subclass final class "</span> + sc.getName());</span><br><span class="line">    <span class="comment">// 获取父类直接声明的构造方法</span></span><br><span class="line">    List constructors = <span class="keyword">new</span> ArrayList(Arrays.asList(sc.getDeclaredConstructors()));</span><br><span class="line">    filterConstructors(sc, constructors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Order is very important: must add superclass, then</span></span><br><span class="line">    <span class="comment">// its superclass chain, then each interface and</span></span><br><span class="line">    <span class="comment">// its superinterfaces.</span></span><br><span class="line">    List actualMethods = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    List interfaceMethods = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">final</span> Set forcePublic = <span class="keyword">new</span> HashSet();</span><br><span class="line">    <span class="comment">// 从父类中提取各种信息</span></span><br><span class="line">    getMethods(sc, interfaces, actualMethods, interfaceMethods, forcePublic);</span><br><span class="line"></span><br><span class="line">    List methods = CollectionUtils.transform(actualMethods, <span class="keyword">new</span> Transformer() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">            Method method = (Method)value;</span><br><span class="line">            <span class="keyword">int</span> modifiers = Constants.ACC_FINAL</span><br><span class="line">                | (method.getModifiers()</span><br><span class="line">                   &amp; ~Constants.ACC_ABSTRACT</span><br><span class="line">                   &amp; ~Constants.ACC_NATIVE</span><br><span class="line">                   &amp; ~Constants.ACC_SYNCHRONIZED);</span><br><span class="line">            <span class="keyword">if</span> (forcePublic.contains(MethodWrapper.create(method))) &#123;</span><br><span class="line">                modifiers = (modifiers &amp; ~Constants.ACC_PROTECTED) | Constants.ACC_PUBLIC;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ReflectUtils.getMethodInfo(method, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    ClassEmitter e = <span class="keyword">new</span> ClassEmitter(v);</span><br><span class="line">    <span class="keyword">if</span> (currentData == <span class="keyword">null</span>) &#123;</span><br><span class="line">    e.begin_class(Constants.V1_2,</span><br><span class="line">                  Constants.ACC_PUBLIC,</span><br><span class="line">                  getClassName(),</span><br><span class="line">                  Type.getType(sc),</span><br><span class="line">                  (useFactory ?</span><br><span class="line">                   TypeUtils.add(TypeUtils.getTypes(interfaces), FACTORY) :</span><br><span class="line">                   TypeUtils.getTypes(interfaces)),</span><br><span class="line">                  Constants.SOURCE_FILE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        e.begin_class(Constants.V1_2,</span><br><span class="line">                Constants.ACC_PUBLIC,</span><br><span class="line">                getClassName(),</span><br><span class="line">                <span class="keyword">null</span>,</span><br><span class="line">                <span class="keyword">new</span> Type[]&#123;FACTORY&#125;,</span><br><span class="line">                Constants.SOURCE_FILE);</span><br><span class="line">    &#125;</span><br><span class="line">    List constructorInfo = CollectionUtils.transform(constructors, MethodInfoTransformer.getInstance());</span><br><span class="line"></span><br><span class="line">    e.declare_field(Constants.ACC_PRIVATE, BOUND_FIELD, Type.BOOLEAN_TYPE, <span class="keyword">null</span>);</span><br><span class="line">    e.declare_field(Constants.ACC_PUBLIC | Constants.ACC_STATIC, FACTORY_DATA_FIELD, OBJECT_TYPE, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (!interceptDuringConstruction) &#123;</span><br><span class="line">        e.declare_field(Constants.ACC_PRIVATE, CONSTRUCTED_FIELD, Type.BOOLEAN_TYPE, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    e.declare_field(Constants.PRIVATE_FINAL_STATIC, THREAD_CALLBACKS_FIELD, THREAD_LOCAL, <span class="keyword">null</span>);</span><br><span class="line">    e.declare_field(Constants.PRIVATE_FINAL_STATIC, STATIC_CALLBACKS_FIELD, CALLBACK_ARRAY, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (serialVersionUID != <span class="keyword">null</span>) &#123;</span><br><span class="line">        e.declare_field(Constants.PRIVATE_FINAL_STATIC, Constants.SUID_FIELD_NAME, Type.LONG_TYPE, serialVersionUID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; callbackTypes.length; i++) &#123;</span><br><span class="line">        e.declare_field(Constants.ACC_PRIVATE, getCallbackField(i), callbackTypes[i], <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// This is declared private to avoid "public field" pollution</span></span><br><span class="line">    e.declare_field(Constants.ACC_PRIVATE | Constants.ACC_STATIC, CALLBACK_FILTER_FIELD, OBJECT_TYPE, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentData == <span class="keyword">null</span>) &#123;</span><br><span class="line">        emitMethods(e, methods, actualMethods);</span><br><span class="line">        emitConstructors(e, constructorInfo);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        emitDefaultConstructor(e);</span><br><span class="line">    &#125;</span><br><span class="line">    emitSetThreadCallbacks(e);</span><br><span class="line">    emitSetStaticCallbacks(e);</span><br><span class="line">    emitBindCallbacks(e);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (useFactory || currentData != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] keys = getCallbackKeys();</span><br><span class="line">        emitNewInstanceCallbacks(e);</span><br><span class="line">        emitNewInstanceCallback(e);</span><br><span class="line">        emitNewInstanceMultiarg(e, constructorInfo);</span><br><span class="line">        emitGetCallback(e, keys);</span><br><span class="line">        emitSetCallback(e, keys);</span><br><span class="line">        emitGetCallbacks(e);</span><br><span class="line">        emitSetCallbacks(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    e.end_class();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>generateClass(...)</code> 执行的操作和 ASM 库的 ClassVisitor 访问 Class 文件结构的流程基本类似。</p><p>从上述截取到的部分代码，例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e.begin_class(Constants.V1_2, Constants.ACC_PUBLIC, getClassName(), Type.getType(sc), </span><br><span class="line">        (useFactory ? TypeUtils.add(TypeUtils.getTypes(interfaces), FACTORY) : TypeUtils.getTypes(interfaces)),</span><br><span class="line">        Constants.SOURCE_FILE);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.declare_field(Constants.PRIVATE_FINAL_STATIC, THREAD_CALLBACKS_FIELD, THREAD_LOCAL, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>都与 <code>classVisitor.visit(...)</code> 以及 <code>classVisitor.visitField(...)</code> 相当类似。而事实上，这些方法的具体实现也确实调用了 cv.visitXxx(…) 。<br>毕竟，作为 CGlib 唯一依赖的库，ASM 还是可以说是难以替代的(既然已经有了可用的轮子，又何必重复造呢?)</p><h2 id="构造的实例"><a href="#构造的实例" class="headerlink" title="构造的实例"></a>构造的实例</h2><p>下面将展示通过 CGlib 生成的新的类(由于生成的是字节码，懒得再自行解析 ClassFile 的内容，所有直接用 <code>IDEA</code> 做了字节码的解析)</p><p><strong>首先展示的需要进行增强的 SampleClass 的具体内容</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>用于增强的简单代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略部分代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">    enhancer.setSuperclass(SampleClass.class);</span><br><span class="line">    enhancer.setCallback(<span class="keyword">new</span> FixedValue() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">loadObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Hello cglib!"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    SampleClass proxy = (SampleClass) enhancer.create();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态生成的新的类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不用过多关注，只是 CGlib 保证生成类与原有的类一定属于同一包下，偷懒直接把 SampleClass 写在 CGlib 项目里了</span></span><br><span class="line"><span class="keyword">package</span> net.sf.cglib.samples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Callback;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Factory;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.FixedValue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新的类名，通过 $$EnhancerByCGLIB 以及 $$7cd64b81(这个是哈希值) 对类名进行唯一区分 </span></span><br><span class="line"><span class="comment"> * 如果还是重复了，在动态生成前会进行类名的检测，并通过增加序号 "_&lt;index&gt;" 的形式进行进一步区分</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 可以看到新生成的类继承了 SampleClass </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span>$$<span class="title">EnhancerByCGLIB</span>$$7<span class="title">cd64b81</span> <span class="keyword">extends</span> <span class="title">SampleClass</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> CGLIB$BOUND;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object CGLIB$FACTORY_DATA;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal CGLIB$THREAD_CALLBACKS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Callback[] CGLIB$STATIC_CALLBACKS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定一个在增强中声明的 Callback 实例</span></span><br><span class="line">    <span class="keyword">private</span> FixedValue CGLIB$CALLBACK_0;</span><br><span class="line">    <span class="comment">// 绑定一个静态的回调调度实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object CGLIB$CALLBACK_FILTER;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> CGLIB$STATICHOOK1() &#123;</span><br><span class="line">        CGLIB$THREAD_CALLBACKS = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 对 test(String) 的方法的增强</span></span><br><span class="line"><span class="comment">      */</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">test</span><span class="params">(String var1)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在方法块中拿到 Callback 实例</span></span><br><span class="line">        FixedValue var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        <span class="comment">// 为空则尝试获取</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.CGLIB$CALLBACK_0 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发回调实例的方法获得返回值</span></span><br><span class="line">        <span class="keyword">return</span> (String)var10000.loadObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 由于此次增强只声明了一个 Callback</span></span><br><span class="line"><span class="comment">      * 因此所有方法的增强都相同, 都是调用这个回调方法获取</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> </span>&#123;</span><br><span class="line">        FixedValue var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.CGLIB$CALLBACK_0 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object var2 = var10000.loadObject();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 但是，此处会尝试强制转型</span></span><br><span class="line"><span class="comment">         * 同时在最终执行失败的时候直接抛出运行时异常</span></span><br><span class="line"><span class="comment">         * 毕竟上面增强的时候返回固定值 "Hello, cglib!"</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> var2 == <span class="keyword">null</span> ? <span class="keyword">false</span> : (Boolean)var2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FixedValue var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.CGLIB$CALLBACK_0 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (String)var10000.loadObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FixedValue var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.CGLIB$CALLBACK_0 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object var1 = var10000.loadObject();</span><br><span class="line">        <span class="keyword">return</span> var1 == <span class="keyword">null</span> ? <span class="number">0</span> : ((Number)var1).intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        FixedValue var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.CGLIB$CALLBACK_0 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var10000.loadObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SampleClass$$EnhancerByCGLIB$$<span class="number">7</span>cd64b81() &#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> CGLIB$SET_THREAD_CALLBACKS(Callback[] var0) &#123;</span><br><span class="line">        CGLIB$THREAD_CALLBACKS.set(var0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> CGLIB$SET_STATIC_CALLBACKS(Callback[] var0) &#123;</span><br><span class="line">        CGLIB$STATIC_CALLBACKS = var0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> CGLIB$BIND_CALLBACKS(Object var0) &#123;</span><br><span class="line">        SampleClass$$EnhancerByCGLIB$$<span class="number">7</span>cd64b81 var1 = (SampleClass$$EnhancerByCGLIB$$<span class="number">7</span>cd64b81)var0;</span><br><span class="line">        <span class="keyword">if</span> (!var1.CGLIB$BOUND) &#123;</span><br><span class="line">            var1.CGLIB$BOUND = <span class="keyword">true</span>;</span><br><span class="line">            Object var10000 = CGLIB$THREAD_CALLBACKS.get();</span><br><span class="line">            <span class="keyword">if</span> (var10000 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                var10000 = CGLIB$STATIC_CALLBACKS;</span><br><span class="line">                <span class="keyword">if</span> (CGLIB$STATIC_CALLBACKS == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var1.CGLIB$CALLBACK_0 = (FixedValue)((Callback[])var10000)[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(Callback[] var1)</span> </span>&#123;</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS(var1);</span><br><span class="line">        SampleClass$$EnhancerByCGLIB$$<span class="number">7</span>cd64b81 var10000 = <span class="keyword">new</span> SampleClass$$EnhancerByCGLIB$$<span class="number">7</span>cd64b81();</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS((Callback[])<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> var10000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(Callback var1)</span> </span>&#123;</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS(<span class="keyword">new</span> Callback[]&#123;var1&#125;);</span><br><span class="line">        SampleClass$$EnhancerByCGLIB$$<span class="number">7</span>cd64b81 var10000 = <span class="keyword">new</span> SampleClass$$EnhancerByCGLIB$$<span class="number">7</span>cd64b81();</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS((Callback[])<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> var10000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(Class[] var1, Object[] var2, Callback[] var3)</span> </span>&#123;</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS(var3);</span><br><span class="line">        SampleClass$$EnhancerByCGLIB$$<span class="number">7</span>cd64b81 var10000 = <span class="keyword">new</span> SampleClass$$EnhancerByCGLIB$$<span class="number">7</span>cd64b81;</span><br><span class="line">        <span class="keyword">switch</span>(var1.length) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            var10000.&lt;init&gt;();</span><br><span class="line">            CGLIB$SET_THREAD_CALLBACKS((Callback[])<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> var10000;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Constructor not found"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Callback <span class="title">getCallback</span><span class="params">(<span class="keyword">int</span> var1)</span> </span>&#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">        FixedValue var10000;</span><br><span class="line">        <span class="keyword">switch</span>(var1) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            var10000 = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var10000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCallback</span><span class="params">(<span class="keyword">int</span> var1, Callback var2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(var1) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">this</span>.CGLIB$CALLBACK_0 = (FixedValue)var2;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Callback[] getCallbacks() &#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Callback[]&#123;<span class="keyword">this</span>.CGLIB$CALLBACK_0&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCallbacks</span><span class="params">(Callback[] var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.CGLIB$CALLBACK_0 = (FixedValue)var1[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        CGLIB$STATICHOOK1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的生成类可以看出来，CGlib 所进行的增强，是在不直接对原有的方法体内容进行改造的基础上(例如上面的 test(String) 方法，没有直接改写成 <code>return &quot;Hello, cglib!</code> 的形式)，对方法执行之前入参或者方法执行之后的返回值进行一定的处理。</p><p>主要使用的形式就是将回调实例与原有方法进行绑定，并通过调用回调方法来实现方法的增强。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;此博文写作的目的: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(Core) 通过了解 CGlib Enhancer 的整个调用链，了解其对于唯一依赖的 ASM 库的调用方式。&lt;/li&gt;
&lt;li&gt;基于 Enhancer 对已有字节码进行增强的进一步理解与掌握。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="ASM" scheme="https://DorMOUSE-None.github.io/tags/ASM/"/>
    
      <category term="CGlib" scheme="https://DorMOUSE-None.github.io/tags/CGlib/"/>
    
  </entry>
  
  <entry>
    <title>Java 安全访问与权限控制</title>
    <link href="https://DorMOUSE-None.github.io/2018-07-04-JDK-Permission/"/>
    <id>https://DorMOUSE-None.github.io/2018-07-04-JDK-Permission/</id>
    <published>2018-07-03T16:00:00.000Z</published>
    <updated>2018-07-04T12:12:25.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><p><em>本文只是对 Java 安全访问与权限控制的基础性探究。</em></p><p><strong>本节与全文内容无关，如无兴趣阅读，可以跳过</strong></p><p>了解 Java 安全访问相关内容的初衷，是准备在项目中利用 Java 标准库提供的 ServiceLoader 对 SPI 实现类进行”自动发现”和加载。<br>这对于将本项目作为二方库来依赖的上层项目将更为方便，只需要</p><ol><li>在 <code>META-INF.services</code> 目录下配置被命名为 SPI 接口全限定名的文件及添加相关内容</li><li>由项目的注册管理器触发下列 Java 代码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ServiceLoader&lt;XxxPolicy&gt; xxxPolicyServiceLoader = ServiceLoader.load(XxxPolicy.class);</span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;XxxPolicy&gt; it = xxxPolicyServiceLoader.iterator(); it.hasNext(); ) &#123;</span><br><span class="line">        XxxPolicy xxxPolicy = it.next();</span><br><span class="line">        <span class="comment">// ... more code ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就可以完成一个新的 SPI 策略的注册工作。</p><p>但是，在尝试实现，了解了 ServiceLoader 源码，以及 DriverManager 和 mysql-connection-java-<version>.jar 在注册 Driver 相关的代码。<br>发现怎么也绕不开 Java 安全访问相关的内容。诸如下列这段来自 DriverManager.loadInitialDrivers() 的代码:</version></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</span><br><span class="line">        Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(driversIterator.hasNext()) &#123;</span><br><span class="line">            driversIterator.next();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Throwable t) &#123;</span><br><span class="line">                <span class="comment">// Do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>诸如 AccessController, Permission, SecurityManager 的代码始终是一个绕不开的主旋律。</p><p>为了探究这部分控制对项目中 ServiceLoader 的真正作用以及其编码意义，开始了对本文所描述的主体内容的初步了解。</p><a id="more"></a><h2 id="从现象开始…"><a href="#从现象开始…" class="headerlink" title="从现象开始…"></a>从现象开始…</h2><p>在通过 <code>java</code> 命令执行本地代码时，偶尔/经常会出现文件I/O操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(System.getSecurityManager());</span><br><span class="line"></span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"/Users/fangfeng/test.in"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> chr; (chr = fis.read()) != -<span class="number">1</span>;) &#123;</span><br><span class="line">        System.out.print((<span class="keyword">char</span>) chr);</span><br><span class="line">    &#125;</span><br><span class="line">    fis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>诸如上面这段代码，意在读取外部路径下 <code>test.in</code> 文件(不要放在项目路径下，文本内容为 <code>0123456789</code>)。当然，还包括打印 System.getSecurityManager().toString() 。</p><p>正常情况下，这都是能够执行成功，结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">null</span><br><span class="line">0123456789</span><br></pre></td></tr></table></figure><p>但是，通过在命令行 <code>java</code> 中添加选项 <code>-Djava.security.manager</code>，再次执行代码，结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java.lang.SecurityManager@4e25154f</span><br><span class="line">Exception in thread &quot;main&quot; java.security.AccessControlException: access denied (&quot;java.io.FilePermission&quot; &quot;/Users/fangfeng/test.in&quot; &quot;read&quot;)</span><br><span class="line">at java.security.AccessControlContext.checkPermission(AccessControlContext.java:472)</span><br><span class="line">at java.security.AccessController.checkPermission(AccessController.java:884)</span><br><span class="line">at java.lang.SecurityManager.checkPermission(SecurityManager.java:549)</span><br><span class="line">at java.lang.SecurityManager.checkRead(SecurityManager.java:888)</span><br><span class="line">at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:127)</span><br><span class="line">at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:93)</span><br><span class="line">at me.fangfeng.security.SecurityTest.main(SecurityTest.java:16)</span><br></pre></td></tr></table></figure><p>现在已经能够获取到 <code>System.getSecuriryManager</code> 的实例。<br>但是想要读取 <code>test.in</code> 文件却失败了，表现为 access denied（访问被拒绝）。</p><p>现在，在用户目录下(这里是 /Users/fangfeng, 不同系统不同用户请做相应修改) 添加 <code>.java.policy</code> 文件，添加下列文本:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grant &#123;</span><br><span class="line">    permission java.io.FilePermission &quot;/Users/fangfeng/test.in&quot;, &quot;read&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再次 <code>java -Djava.security.manager &lt;class&#39;s path&gt;</code>，不仅能够得到 SecurityManager 的实例，同时也读取到了文本内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.SecurityManager@3af49f1c</span><br><span class="line">0123456789</span><br></pre></td></tr></table></figure><hr><p>到此为止，应该已经能够感受到 Java 对安全访问的控制在文件I/O上的体现了。</p><h2 id="安全控制下的操作"><a href="#安全控制下的操作" class="headerlink" title="安全控制下的操作"></a>安全控制下的操作</h2><p><strong>在开始下列内容之前，需要提前了解一个前提:</strong><br><strong>Java 对操作权限的控制是通过检查当前线程操作上下文的代码是否存在要求的操作权限实现的(除了特权的声明以及其它还需要控制别的线程上下文权限的情况)</strong></p><p>上一节演示了权限控制下本地代码对本地资源的访问。但是，安全控制真的有必要吗？</p><ul><li>就本地程序而言，不必要。事实上，Java 也确实是这么做的。平时在本地利用 <code>java</code> 命令执行程序，都不会受到任何限制。Java 启动时默认不会装载 SecurityManager，也就不会触发对各种操作的权限验证。</li><li>可如果程序运行与网络上其它程序交互，甚至直接加载来自网络的字节码。那么，权限控制确实是有必要的。至少，如果不存在权限控制，来自网络的恶意代码访问整台机器的任意资源都将畅通无阻。</li></ul><h3 id="SecurityManager"><a href="#SecurityManager" class="headerlink" title="SecurityManager"></a>SecurityManager</h3><p>SecurityManager 是整个访问控制的管理器和基本入口。所有涉及到权限控制的代码，都会类似地存在下列这般的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SecurityManager security = System.getSecurityManager();</span><br><span class="line"><span class="comment">// 如果系统存在安全管理器</span></span><br><span class="line"><span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用 SecurityManager 中以 check 开头的方法</span></span><br><span class="line">    security.checkXxx(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>security.checkXxx(...)</code> 是没有返回值的(除了 checkTopLevelWindow)；对于没有操作权限的代码，直接抛出异常</p><p>至于到底在 check 什么，Java 中定义了包括文件(File)、套接字(Socket)、网络(Net)、安全性(Security)、运行时(Runtime)、属性(Property)、AWT、反射(Reflect)和可序列化(Serializable) 九类权限。</p><p>通常，security.checkXxx(…) 方法将构造一个 XxxPermission(…) 对象来调用 SecurityManager 提供的统一方法 checkPermission(Permission) 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以 checkRead(name) 为例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkRead</span><span class="params">(String file)</span> </span>&#123;</span><br><span class="line">    checkPermission(<span class="keyword">new</span> FilePermission(file, SecurityConstants.FILE_READ_ACTION));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 checkPermission(Permission) 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkPermission</span><span class="params">(Permission perm)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接调用 访问控制器 来对权限进行鉴别</span></span><br><span class="line">    java.security.AccessController.checkPermission(perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AccessController"><a href="#AccessController" class="headerlink" title="AccessController"></a>AccessController</h3><p>AccessController 用于与访问控制相关的操作和决定。</p><blockquote><p>AccessController 类用于以下三个目的：</p><p>基于当前生效的安全策略决定是允许还是拒绝对关键系统资源的访问<br>将代码标记为享有“特权”，从而影响后续访问决定，以及<br>获取当前调用上下文的“快照”，这样便可以相对于已保存的上下文作出其他上下文的访问控制决定</p></blockquote><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>总的来说，Java 的访问控制就是通过针对不同的操作构建不同的 Permission 对象，然后通过与 AccessControllerContent 持有的各代码的权限进行比对，<br>从而判断代码是否存在相应的访问权限。</p><p><em>所谓的Permission判断将是对当前线程的调用栈的每个调用者逐一倒序递归，判断是否拥有权限。如果其中的某个代码被声明为 Privileged，则直接认为是拥有权限</em></p><p><strong>更多的关于 checkPermission(…) 调用相关的内容，可以自行查阅资料进行学习，在此不做过多陈述。:)</strong></p><h2 id="为操作赋权"><a href="#为操作赋权" class="headerlink" title="为操作赋权"></a>为操作赋权</h2><p>上一节讲完了如果对当前项目配置了 SecurityManager ，将对各种敏感操作进行访问控制，并且将根据整个调用链被赋予的权限来决定是允许执行还是抛出 access denied。</p><p>但是，究竟怎么才能够给 code 赋予权限呢？</p><p>回顾前一节的内容，在基本探究中，其实一个能够看到<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grant &#123;</span><br><span class="line">    permission java.io.FilePermission <span class="string">"/Users/fangfeng/test.in"</span>, <span class="string">"read"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这就是一种赋权的操作。</p><p>通过在指定的文件中写入符合特定规则的代码，来完成对 code 的赋权。<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/PolicyFiles.html" target="_blank" rel="noopener">Default Policy Implementation and Policy File Syntax</a></p><p>在项目启动的时候，默认就会读取 $JAVA_HOME/jre/lib/security/java.policy 以及 ${user.home}/.java.policy 两个文件的赋权内容，并做缓存给后面代码使用。</p><p>当然，Java 也提供指定自定义的赋权文件，通过 -Djava.security.policy=<policy file=""> 或者 -Djava.security.policy==<policy file=""> 。</policy></policy></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1]. Java Document - Security. <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/security/index.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;绪论&quot;&gt;&lt;a href=&quot;#绪论&quot; class=&quot;headerlink&quot; title=&quot;绪论&quot;&gt;&lt;/a&gt;绪论&lt;/h2&gt;&lt;p&gt;&lt;em&gt;本文只是对 Java 安全访问与权限控制的基础性探究。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本节与全文内容无关，如无兴趣阅读，可以跳过&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;了解 Java 安全访问相关内容的初衷，是准备在项目中利用 Java 标准库提供的 ServiceLoader 对 SPI 实现类进行”自动发现”和加载。&lt;br&gt;这对于将本项目作为二方库来依赖的上层项目将更为方便，只需要&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 &lt;code&gt;META-INF.services&lt;/code&gt; 目录下配置被命名为 SPI 接口全限定名的文件及添加相关内容&lt;/li&gt;
&lt;li&gt;由项目的注册管理器触发下列 Java 代码&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ServiceLoader&amp;lt;XxxPolicy&amp;gt; xxxPolicyServiceLoader = ServiceLoader.load(XxxPolicy.class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (Iterator&amp;lt;XxxPolicy&amp;gt; it = xxxPolicyServiceLoader.iterator(); it.hasNext(); ) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        XxxPolicy xxxPolicy = it.next();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// ... more code ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;就可以完成一个新的 SPI 策略的注册工作。&lt;/p&gt;
&lt;p&gt;但是，在尝试实现，了解了 ServiceLoader 源码，以及 DriverManager 和 mysql-connection-java-&lt;version&gt;.jar 在注册 Driver 相关的代码。&lt;br&gt;发现怎么也绕不开 Java 安全访问相关的内容。诸如下列这段来自 DriverManager.loadInitialDrivers() 的代码:&lt;/version&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;AccessController.doPrivileged(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; PrivilegedAction&amp;lt;Void&amp;gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Void &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ServiceLoader&amp;lt;Driver&amp;gt; loadedDrivers = ServiceLoader.load(Driver.class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Iterator&amp;lt;Driver&amp;gt; driversIterator = loadedDrivers.iterator();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(driversIterator.hasNext()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            driversIterator.next();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt;(Throwable t) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// Do nothing&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;诸如 AccessController, Permission, SecurityManager 的代码始终是一个绕不开的主旋律。&lt;/p&gt;
&lt;p&gt;为了探究这部分控制对项目中 ServiceLoader 的真正作用以及其编码意义，开始了对本文所描述的主体内容的初步了解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://DorMOUSE-None.github.io/tags/Java/"/>
    
      <category term="Security" scheme="https://DorMOUSE-None.github.io/tags/Security/"/>
    
      <category term="Permission" scheme="https://DorMOUSE-None.github.io/tags/Permission/"/>
    
  </entry>
  
  <entry>
    <title>ASM-VerifyError错误信息解决</title>
    <link href="https://DorMOUSE-None.github.io/2018-06-28-ASM-VerifyError/"/>
    <id>https://DorMOUSE-None.github.io/2018-06-28-ASM-VerifyError/</id>
    <published>2018-06-27T16:00:00.000Z</published>
    <updated>2018-06-28T10:46:48.114Z</updated>
    
    <content type="html"><![CDATA[<h2 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.VerifyError: <span class="class"><span class="keyword">class</span> <span class="title">net</span>.<span class="title">sf</span>.<span class="title">cglib</span>.<span class="title">core</span>.<span class="title">DebuggingClassWriter</span> <span class="title">overrides</span> <span class="title">final</span> <span class="title">method</span> <span class="title">visit</span>.(<span class="title">IILjava</span>/<span class="title">lang</span>/<span class="title">String</span></span>;Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;)V</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>项目依赖的 </p><ul><li>CGlib 版本是 2.2.2</li><li>ASM 版本是 3.3.1</li></ul><h2 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h2><p>前两天刚粗略通读了 ASM ，结果就遇上这样一个问题。</p><p>从 <code>net.sf.cglib.core.DebuggingClassWriter</code> 看，这是 CGlib 的一个实现类</p><p>从描述 <code>overrides final method visit.(IILjava/lang/String;Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;)V</code><br>以及 DebuggingClassWriter 类的字节码反编译结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DebuggingClassWriter</span> <span class="keyword">extends</span> <span class="title">ClassWriter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> version, <span class="keyword">int</span> access, String name, String signature, String superName, String[] interfaces)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.className = name.replace(<span class="string">'/'</span>, <span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">this</span>.superName = superName.replace(<span class="string">'/'</span>, <span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">super</span>.visit(version, access, name, signature, superName, interfaces);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至少应该是 visit(…) 方法要重载的父类的被声明为 final 的 ClassWriter.visit(…) 才导致的问题。</p><p>但是从 ASM 3.3.1 版本的 ClassWriter 类可以看到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> var1, <span class="keyword">int</span> var2, String var3, String var4, String var5, String[] var6)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>visit 方法并没有被声明为 final 。</p><p>但是，结合一定的背景知识，ASM 项目在加入了 OW2 组织后的新版本(asm-3.3.1 是未加入 OW2 前的最后一个版本)，<br>ClassWriter 类的所有 visitXxx(…) 方法都被添加了 <code>final</code> 限制。</p><p>因此，怀疑是项目实际依赖了高版本的 asm (asm 4.x 及以上)</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>经过确认，由于整个项目依赖关系复杂，有其它项目引入了 asm-4.1.jar。<br>而且由于使用 MAVEN 进行项目依赖管理，asm-4.1.jar 与依赖树根的深度更浅，<br>因此，最终打包的 war 里面确实引入了 asm-4.1.jar 。导致了这个问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;报错信息&quot;&gt;&lt;a href=&quot;#报错信息&quot; class=&quot;headerlink&quot; title=&quot;报错信息&quot;&gt;&lt;/a&gt;报错信息&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;java.lang.VerifyError: &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;net&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;sf&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;cglib&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;core&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;DebuggingClassWriter&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;overrides&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;visit&lt;/span&gt;.(&lt;span class=&quot;title&quot;&gt;IILjava&lt;/span&gt;/&lt;span class=&quot;title&quot;&gt;lang&lt;/span&gt;/&lt;span class=&quot;title&quot;&gt;String&lt;/span&gt;&lt;/span&gt;;Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;)V&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://DorMOUSE-None.github.io/tags/Java/"/>
    
      <category term="ASM" scheme="https://DorMOUSE-None.github.io/tags/ASM/"/>
    
      <category term="CGlib" scheme="https://DorMOUSE-None.github.io/tags/CGlib/"/>
    
  </entry>
  
  <entry>
    <title>ASM 核心包基本内容漫谈</title>
    <link href="https://DorMOUSE-None.github.io/2018-06-25-ASM-Core/"/>
    <id>https://DorMOUSE-None.github.io/2018-06-25-ASM-Core/</id>
    <published>2018-06-24T16:00:00.000Z</published>
    <updated>2018-06-25T10:16:37.866Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文描述的 ASM 指的是 OW2 ASM</p></blockquote><h2 id="ASM-Core-的结构"><a href="#ASM-Core-的结构" class="headerlink" title="ASM-Core 的结构"></a>ASM-Core 的结构</h2><p><em>首先是一些概述性的内容。</em></p><p>由于 ASM 操作的 JAVA 字节码有严格的格式规定，且即使随着 JVM 标准的升级也极少出现重大调整。<br>因此适用面狭窄的访问者模式在该项目中被大量地使用，并且已经到了丧心病狂的程度:)</p><p>从核心包声明的类来看，主要包括:</p><ol><li><p>ClassReader - 作为结构化对象，将接收(accept)访问者的访问</p></li><li><p>几种访问者抽象类以及相应的实现类</p></li></ol><ul><li>AnnotationVisitor -&gt; AnnotationWriter</li><li>ClassVisitor -&gt; ClassWriter</li><li>FieldVisitor -&gt; FieldWriter</li><li>MethodVisitor -&gt; MethodWriter</li><li>ModuleVisitor -&gt; ModuleWriter</li></ul><ol start="3"><li><p>Opcodes &amp; Constants - ClassFile 中描述的大量常量符号与值</p></li><li><p>其它一些辅助的类</p></li></ol><ul><li>Attribute - 用于处理非标准化的属性(ClassFile 允许<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html" target="_blank" rel="noopener">JVMS</a> 中未定义的 Attribute)</li><li>ByteArray - 动态可自适应的 byte[] (字节数组)</li><li>Context - ClassReader 在被解析(被访问)过程中用于表示“累积状态”的一个类/对象</li><li>Symbol - 用于表示 ClassFile 中描述的 Constant 的基类</li><li>SymbolTable - 用于存储常量池对象</li><li>其它内容省略</li></ul><a id="more"></a><h2 id="ClassFile-文件格式"><a href="#ClassFile-文件格式" class="headerlink" title="ClassFile 文件格式"></a>ClassFile 文件格式</h2><p>本节的内容可以参阅 <a href="https://dormouse-none.github.io/2018-06-11-ASM-ClassReader/">ClassFile 文件格式</a></p><p>ClassFile 是 ASM 操作字节码的基础与前提。在 JVMS 定义了 .class 文件格式之后，ASM 才在此基础上进行了对 ClassFile 的字节码操作。</p><p>因此，无论如何，个人认为在真正开始了解 ASM 之前，通读一遍 ClassFile 文件格式是完全有必要的。并且，在基本了解 ClassFile 内容的基础上，<br>尝试对某个 .class 文件进行手工解析也不失为一种加深理解的途径。</p><h2 id="Visitor-Pattern"><a href="#Visitor-Pattern" class="headerlink" title="Visitor Pattern"></a>Visitor Pattern</h2><p>由于 ASM 的实现采用了偏门的访问者模式。因此，了解访问者模式也是一个必不可少的重要环节。同时在了解后也将为源码阅读者提供更清晰的解读思路。</p><p>《设计模式：可复用面向对象软件的基础》一书的“5.11 VISITOR(访问者)——对象行为型模式”提供了很详尽的解释。</p><p>本人对这方面的不甚了解，推荐自行查找资料。</p><h2 id="ClassReader"><a href="#ClassReader" class="headerlink" title="ClassReader"></a>ClassReader</h2><p>ClassReader 是解析现有的 .class 文件的基本工具。同时，ClassReader 也作为一个内容的持有者，与 SymboleTable 配合，来满足访问者基本的访问需求。</p><p>刨除大量的内部私有方法，ClassReader 对外开放的接口相当简单。最核心的方法仅包括 ClassReader(…) 以及 accetp(…)</p><h3 id="ClassReader-…-构造方法"><a href="#ClassReader-…-构造方法" class="headerlink" title="ClassReader(…) 构造方法"></a>ClassReader(…) 构造方法</h3><p>顾名思义，构造方法用于实例化 ClassReader 对象，包括一些必须的变量的初始化。</p><p>在构造函数中完成的初始化内容包括:</p><ul><li>校验版本号</li><li>存储每个常量池项目的起始偏移量 cpInfoOffsets</li><li>存储每个引导方法的起始偏移量 bootstrapMethodOffsets</li><li>存储最长字符串常量的大小 maxStringLength</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">ClassReader(<span class="keyword">final</span> <span class="keyword">byte</span>[] classFileBuffer, <span class="keyword">final</span> <span class="keyword">int</span> classFileOffset, <span class="keyword">final</span> <span class="keyword">boolean</span> checkClassVersion) &#123;</span><br><span class="line">  <span class="keyword">this</span>.b = classFileBuffer;   <span class="comment">// .class 文件缓存</span></span><br><span class="line">  <span class="comment">// 检查主版本号, 第6,7个字节(从0字节开始计数)</span></span><br><span class="line">  <span class="keyword">if</span> (checkClassVersion &amp;&amp; readShort(classFileOffset + <span class="number">6</span>) &gt; Opcodes.V11) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">        <span class="string">"Unsupported class file major version "</span> + readShort(classFileOffset + <span class="number">6</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建常量池数组，常量池长度的定义 constant_pool_count 在第8,9字节</span></span><br><span class="line">  <span class="keyword">int</span> constantPoolCount = readUnsignedShort(classFileOffset + <span class="number">8</span>);     <span class="comment">// 读取无符号short, 即读取连续两字节作为一个short值</span></span><br><span class="line">  cpInfoOffsets = <span class="keyword">new</span> <span class="keyword">int</span>[constantPoolCount];                         <span class="comment">// 每个常量的偏移位置</span></span><br><span class="line">  cpInfoValues = <span class="keyword">new</span> Object[constantPoolCount];                       <span class="comment">// 每个常量的实例对象</span></span><br><span class="line">  <span class="keyword">int</span> currentCpInfoIndex = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> currentCpInfoOffset = classFileOffset + <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> currentMaxStringLength = <span class="number">0</span>;                                     <span class="comment">// 最长字符串常量</span></span><br><span class="line">  <span class="keyword">while</span> (currentCpInfoIndex &lt; constantPoolCount) &#123;</span><br><span class="line">    cpInfoOffsets[currentCpInfoIndex++] = currentCpInfoOffset + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cpInfoSize;</span><br><span class="line">    <span class="keyword">switch</span> (classFileBuffer[currentCpInfoOffset]) &#123;</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_FIELDREF_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_METHODREF_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_INTERFACE_METHODREF_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_INTEGER_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_FLOAT_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_NAME_AND_TYPE_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_DYNAMIC_TAG:</span><br><span class="line">        cpInfoSize = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_LONG_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_DOUBLE_TAG:</span><br><span class="line">        cpInfoSize = <span class="number">9</span>;</span><br><span class="line">        currentCpInfoIndex++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_UTF8_TAG:</span><br><span class="line">        cpInfoSize = <span class="number">3</span> + readUnsignedShort(currentCpInfoOffset + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (cpInfoSize &gt; currentMaxStringLength) &#123;</span><br><span class="line">          <span class="comment">// The size in bytes of this CONSTANT_Utf8 structure provides a conservative estimate</span></span><br><span class="line">          <span class="comment">// of the length in characters of the corresponding string, and is much cheaper to</span></span><br><span class="line">          <span class="comment">// compute than this exact length.</span></span><br><span class="line">          currentMaxStringLength = cpInfoSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_METHOD_HANDLE_TAG:</span><br><span class="line">        cpInfoSize = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_CLASS_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_STRING_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_METHOD_TYPE_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_PACKAGE_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_MODULE_TAG:</span><br><span class="line">        cpInfoSize = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    currentCpInfoOffset += cpInfoSize;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.maxStringLength = currentMaxStringLength;</span><br><span class="line">  <span class="comment">// The Classfile's access_flags field is just after the last constant pool entry.</span></span><br><span class="line">  <span class="keyword">this</span>.header = currentCpInfoOffset;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取 BootstrapMethods 属性(如果存在)</span></span><br><span class="line">  <span class="keyword">int</span> currentAttributeOffset = getFirstAttributeOffset();</span><br><span class="line">  <span class="keyword">int</span>[] currentBootstrapMethodOffsets = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = readUnsignedShort(currentAttributeOffset - <span class="number">2</span>); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="comment">// 读取每个 attribute_info 的属性名和属性长度</span></span><br><span class="line">    String attributeName = readUTF8(currentAttributeOffset, <span class="keyword">new</span> <span class="keyword">char</span>[maxStringLength]);</span><br><span class="line">    <span class="keyword">int</span> attributeLength = readInt(currentAttributeOffset + <span class="number">2</span>);</span><br><span class="line">    currentAttributeOffset += <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 如果当前属性名为 BootstrapMethods ，则进入处理逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (Constants.BOOTSTRAP_METHODS.equals(attributeName)) &#123;</span><br><span class="line">      <span class="comment">// Read the num_bootstrap_methods field and create an array of this size.</span></span><br><span class="line">      currentBootstrapMethodOffsets = <span class="keyword">new</span> <span class="keyword">int</span>[readUnsignedShort(currentAttributeOffset)];</span><br><span class="line">      <span class="comment">// Compute and store the offset of each 'bootstrap_methods' array field entry.</span></span><br><span class="line">      <span class="keyword">int</span> currentBootstrapMethodOffset = currentAttributeOffset + <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; currentBootstrapMethodOffsets.length; ++j) &#123;</span><br><span class="line">        currentBootstrapMethodOffsets[j] = currentBootstrapMethodOffset;</span><br><span class="line">        <span class="comment">// Skip the bootstrap_method_ref and num_bootstrap_arguments fields (2 bytes each),</span></span><br><span class="line">        <span class="comment">// as well as the bootstrap_arguments array field (of size num_bootstrap_arguments * 2).</span></span><br><span class="line">        currentBootstrapMethodOffset +=</span><br><span class="line">            <span class="number">4</span> + readUnsignedShort(currentBootstrapMethodOffset + <span class="number">2</span>) * <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    currentAttributeOffset += attributeLength;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.bootstrapMethodOffsets = currentBootstrapMethodOffsets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，ClassReader 已经解析了包括 magic, minor version, major version, constant pool 。<br>但是，诸如 field_info, method_info, attribute_info 等仍然没有得到处理。</p><h3 id="accept-…"><a href="#accept-…" class="headerlink" title="accept(…)"></a>accept(…)</h3><p>访问者模式的核心操作就是结构化对象接受(accept)访问者对象实例的访问，并将结构化内容完全暴露给访问者。</p><p>从抽象的方法角度看，可以理解成:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// --- 结构化对象的 accept() 方法 ---</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">  visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 访问者对象的 visit() 方法 ---</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Xxx <span class="title">visit</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 若干关于 element 的读操作 + 其它操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> ClassVisitor classVisitor,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> Attribute[] attributePrototypes,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> <span class="keyword">int</span> parsingOptions)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义 Context 作为辅助类，暂存被访问过程的“累积状态”</span></span><br><span class="line">    Context context = <span class="keyword">new</span> Context();</span><br><span class="line">    context.attributePrototypes = attributePrototypes;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析选项: </span></span><br><span class="line"><span class="comment">     * 1. SKIP_CODE - 不解析 CODE 属性 </span></span><br><span class="line"><span class="comment">     * 2. SKIP_DEBUG - 不解析 DEBUG 相关的属性(例如SourceFile, SourceDebugExtension, LocalVariableTable, LocalVariableTypeTable, LineNumberTable)</span></span><br><span class="line"><span class="comment">     * 4. SKIP_FRAMES - 跳过对 StackMap 和 StackMapTable 属性的解析</span></span><br><span class="line"><span class="comment">     * ...</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    context.parsingOptions = parsingOptions;</span><br><span class="line">    <span class="comment">// 从常量池读取常量所使用的缓冲数字</span></span><br><span class="line">    context.charBuffer = <span class="keyword">new</span> <span class="keyword">char</span>[maxStringLength];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read the access_flags, this_class, super_class, interface_count and interfaces fields.</span></span><br><span class="line">    <span class="comment">// 解析访问控制, 当前类, 父类, 接口数量与接口值等</span></span><br><span class="line">    <span class="keyword">char</span>[] charBuffer = context.charBuffer;</span><br><span class="line">    <span class="keyword">int</span> currentOffset = header;</span><br><span class="line">    <span class="keyword">int</span> accessFlags = readUnsignedShort(currentOffset);</span><br><span class="line">    String thisClass = readClass(currentOffset + <span class="number">2</span>, charBuffer);</span><br><span class="line">    String superClass = readClass(currentOffset + <span class="number">4</span>, charBuffer);</span><br><span class="line">    String[] interfaces = <span class="keyword">new</span> String[readUnsignedShort(currentOffset + <span class="number">6</span>)];</span><br><span class="line">    currentOffset += <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interfaces.length; ++i) &#123;</span><br><span class="line">      interfaces[i] = readClass(currentOffset, charBuffer);</span><br><span class="line">      currentOffset += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read the class attributes (the variables are ordered as in Section 4.7 of the JVMS).</span></span><br><span class="line">    <span class="comment">// Attribute offsets exclude the attribute_name_index and attribute_length fields.</span></span><br><span class="line">    <span class="comment">// - The offset of the InnerClasses attribute, or 0.</span></span><br><span class="line">    <span class="keyword">int</span> innerClassesOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// - The offset of the EnclosingMethod attribute, or 0.</span></span><br><span class="line">    <span class="keyword">int</span> enclosingMethodOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// - The string corresponding to the Signature attribute, or null.</span></span><br><span class="line">    String signature = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// - The string corresponding to the SourceFile attribute, or null.</span></span><br><span class="line">    String sourceFile = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// - The string corresponding to the SourceDebugExtension attribute, or null.</span></span><br><span class="line">    String sourceDebugExtension = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// - The offset of the RuntimeVisibleAnnotations attribute, or 0.</span></span><br><span class="line">    <span class="keyword">int</span> runtimeVisibleAnnotationsOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// - The offset of the RuntimeInvisibleAnnotations attribute, or 0.</span></span><br><span class="line">    <span class="keyword">int</span> runtimeInvisibleAnnotationsOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.</span></span><br><span class="line">    <span class="keyword">int</span> runtimeVisibleTypeAnnotationsOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.</span></span><br><span class="line">    <span class="keyword">int</span> runtimeInvisibleTypeAnnotationsOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// - The offset of the Module attribute, or 0.</span></span><br><span class="line">    <span class="keyword">int</span> moduleOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// - The offset of the ModulePackages attribute, or 0.</span></span><br><span class="line">    <span class="keyword">int</span> modulePackagesOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// - The string corresponding to the ModuleMainClass attribute, or null.</span></span><br><span class="line">    String moduleMainClass = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// - The string corresponding to the NestHost attribute, or null.</span></span><br><span class="line">    String nestHostClass = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// - The offset of the NestMembers attribute, or 0.</span></span><br><span class="line">    <span class="keyword">int</span> nestMembersOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// - The non standard attributes (linked with their &#123;@link Attribute#nextAttribute&#125; field).</span></span><br><span class="line">    <span class="comment">//   This list in the &lt;i&gt;reverse order&lt;/i&gt; or their order in the ClassFile structure.</span></span><br><span class="line">    Attribute attributes = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 Class 持有的属性</span></span><br><span class="line">    <span class="keyword">int</span> currentAttributeOffset = getFirstAttributeOffset();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = readUnsignedShort(currentAttributeOffset - <span class="number">2</span>); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">      <span class="comment">// Read the attribute_info's attribute_name and attribute_length fields.</span></span><br><span class="line">      String attributeName = readUTF8(currentAttributeOffset, charBuffer);</span><br><span class="line">      <span class="keyword">int</span> attributeLength = readInt(currentAttributeOffset + <span class="number">2</span>);</span><br><span class="line">      currentAttributeOffset += <span class="number">6</span>;</span><br><span class="line">      <span class="comment">// The tests are sorted in decreasing frequency order (based on frequencies observed on</span></span><br><span class="line">      <span class="comment">// typical classes).</span></span><br><span class="line">      <span class="keyword">if</span> (Constants.SOURCE_FILE.equals(attributeName)) &#123;</span><br><span class="line">        sourceFile = readUTF8(currentAttributeOffset, charBuffer);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.INNER_CLASSES.equals(attributeName)) &#123;</span><br><span class="line">        innerClassesOffset = currentAttributeOffset;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.ENCLOSING_METHOD.equals(attributeName)) &#123;</span><br><span class="line">        enclosingMethodOffset = currentAttributeOffset;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.NEST_HOST.equals(attributeName)) &#123;</span><br><span class="line">        nestHostClass = readClass(currentAttributeOffset, charBuffer);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.NEST_MEMBERS.equals(attributeName)) &#123;</span><br><span class="line">        nestMembersOffset = currentAttributeOffset;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.SIGNATURE.equals(attributeName)) &#123;</span><br><span class="line">        signature = readUTF8(currentAttributeOffset, charBuffer);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) &#123;</span><br><span class="line">        runtimeVisibleAnnotationsOffset = currentAttributeOffset;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) &#123;</span><br><span class="line">        runtimeVisibleTypeAnnotationsOffset = currentAttributeOffset;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.DEPRECATED.equals(attributeName)) &#123;</span><br><span class="line">        accessFlags |= Opcodes.ACC_DEPRECATED;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.SYNTHETIC.equals(attributeName)) &#123;</span><br><span class="line">        accessFlags |= Opcodes.ACC_SYNTHETIC;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.SOURCE_DEBUG_EXTENSION.equals(attributeName)) &#123;</span><br><span class="line">        sourceDebugExtension =</span><br><span class="line">            readUTF(currentAttributeOffset, attributeLength, <span class="keyword">new</span> <span class="keyword">char</span>[attributeLength]);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) &#123;</span><br><span class="line">        runtimeInvisibleAnnotationsOffset = currentAttributeOffset;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) &#123;</span><br><span class="line">        runtimeInvisibleTypeAnnotationsOffset = currentAttributeOffset;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.MODULE.equals(attributeName)) &#123;</span><br><span class="line">        moduleOffset = currentAttributeOffset;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.MODULE_MAIN_CLASS.equals(attributeName)) &#123;</span><br><span class="line">        moduleMainClass = readClass(currentAttributeOffset, charBuffer);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.MODULE_PACKAGES.equals(attributeName)) &#123;</span><br><span class="line">        modulePackagesOffset = currentAttributeOffset;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.BOOTSTRAP_METHODS.equals(attributeName)) &#123;</span><br><span class="line">        <span class="comment">// This attribute is read in the constructor.</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Attribute attribute =</span><br><span class="line">            readAttribute(</span><br><span class="line">                attributePrototypes,</span><br><span class="line">                attributeName,</span><br><span class="line">                currentAttributeOffset,</span><br><span class="line">                attributeLength,</span><br><span class="line">                charBuffer,</span><br><span class="line">                -<span class="number">1</span>,</span><br><span class="line">                <span class="keyword">null</span>);</span><br><span class="line">        attribute.nextAttribute = attributes;</span><br><span class="line">        attributes = attribute;</span><br><span class="line">      &#125;</span><br><span class="line">      currentAttributeOffset += attributeLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个 .visit() 。让 ClassVisitor 的实现类处理当前类的版本号, 访问控制标志, 当前类, 结构, 父类, 接口</span></span><br><span class="line">    <span class="comment">// 具体 visit() 由实现类随意定制。例如，针对于那些有打印功能的访问者实现类，直接打印也不失为一种有效的访问操作</span></span><br><span class="line">    <span class="comment">// Visit the class declaration. The minor_version and major_version fields start 6 bytes before</span></span><br><span class="line">    <span class="comment">// the first constant pool entry, which itself starts at cpInfoOffsets[1] - 1 (by definition).</span></span><br><span class="line">    classVisitor.visit(</span><br><span class="line">        readInt(cpInfoOffsets[<span class="number">1</span>] - <span class="number">7</span>), accessFlags, thisClass, signature, superClass, interfaces);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问 SourceFile 和 SourceDebugExtenstion 属性</span></span><br><span class="line">    <span class="comment">// Visit the SourceFile and SourceDebugExtenstion attributes.</span></span><br><span class="line">    <span class="keyword">if</span> ((parsingOptions &amp; SKIP_DEBUG) == <span class="number">0</span></span><br><span class="line">        &amp;&amp; (sourceFile != <span class="keyword">null</span> || sourceDebugExtension != <span class="keyword">null</span>)) &#123;</span><br><span class="line">      classVisitor.visitSource(sourceFile, sourceDebugExtension);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Visit the Module, ModulePackages and ModuleMainClass attributes.</span></span><br><span class="line">    <span class="keyword">if</span> (moduleOffset != <span class="number">0</span>) &#123;</span><br><span class="line">      readModule(classVisitor, context, moduleOffset, modulePackagesOffset, moduleMainClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Visit the NestHost attribute.</span></span><br><span class="line">    <span class="keyword">if</span> (nestHostClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">      classVisitor.visitNestHostExperimental(nestHostClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Visit the EnclosingMethod attribute.</span></span><br><span class="line">    <span class="keyword">if</span> (enclosingMethodOffset != <span class="number">0</span>) &#123;</span><br><span class="line">      String className = readClass(enclosingMethodOffset, charBuffer);</span><br><span class="line">      <span class="keyword">int</span> methodIndex = readUnsignedShort(enclosingMethodOffset + <span class="number">2</span>);</span><br><span class="line">      String name = methodIndex == <span class="number">0</span> ? <span class="keyword">null</span> : readUTF8(cpInfoOffsets[methodIndex], charBuffer);</span><br><span class="line">      String type = methodIndex == <span class="number">0</span> ? <span class="keyword">null</span> : readUTF8(cpInfoOffsets[methodIndex] + <span class="number">2</span>, charBuffer);</span><br><span class="line">      classVisitor.visitOuterClass(className, name, type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Visit the RuntimeVisibleAnnotations attribute.</span></span><br><span class="line">    <span class="keyword">if</span> (runtimeVisibleAnnotationsOffset != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);</span><br><span class="line">      <span class="keyword">int</span> currentAnnotationOffset = runtimeVisibleAnnotationsOffset + <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">while</span> (numAnnotations-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Parse the type_index field.</span></span><br><span class="line">        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</span><br><span class="line">        currentAnnotationOffset += <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// Parse num_element_value_pairs and element_value_pairs and visit these values.</span></span><br><span class="line">        currentAnnotationOffset =</span><br><span class="line">            readElementValues(</span><br><span class="line">                classVisitor.visitAnnotation(annotationDescriptor, <span class="comment">/* visible = */</span> <span class="keyword">true</span>),</span><br><span class="line">                currentAnnotationOffset,</span><br><span class="line">                <span class="comment">/* named = */</span> <span class="keyword">true</span>,</span><br><span class="line">                charBuffer);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Visit the RuntimeInvisibleAnnotations attribute.</span></span><br><span class="line">    <span class="keyword">if</span> (runtimeInvisibleAnnotationsOffset != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);</span><br><span class="line">      <span class="keyword">int</span> currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">while</span> (numAnnotations-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Parse the type_index field.</span></span><br><span class="line">        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</span><br><span class="line">        currentAnnotationOffset += <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// Parse num_element_value_pairs and element_value_pairs and visit these values.</span></span><br><span class="line">        currentAnnotationOffset =</span><br><span class="line">            readElementValues(</span><br><span class="line">                classVisitor.visitAnnotation(annotationDescriptor, <span class="comment">/* visible = */</span> <span class="keyword">false</span>),</span><br><span class="line">                currentAnnotationOffset,</span><br><span class="line">                <span class="comment">/* named = */</span> <span class="keyword">true</span>,</span><br><span class="line">                charBuffer);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Visit the RuntimeVisibleTypeAnnotations attribute.</span></span><br><span class="line">    <span class="keyword">if</span> (runtimeVisibleTypeAnnotationsOffset != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);</span><br><span class="line">      <span class="keyword">int</span> currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">while</span> (numAnnotations-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Parse the target_type, target_info and target_path fields.</span></span><br><span class="line">        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);</span><br><span class="line">        <span class="comment">// Parse the type_index field.</span></span><br><span class="line">        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</span><br><span class="line">        currentAnnotationOffset += <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// Parse num_element_value_pairs and element_value_pairs and visit these values.</span></span><br><span class="line">        currentAnnotationOffset =</span><br><span class="line">            readElementValues(</span><br><span class="line">                classVisitor.visitTypeAnnotation(</span><br><span class="line">                    context.currentTypeAnnotationTarget,</span><br><span class="line">                    context.currentTypeAnnotationTargetPath,</span><br><span class="line">                    annotationDescriptor,</span><br><span class="line">                    <span class="comment">/* visible = */</span> <span class="keyword">true</span>),</span><br><span class="line">                currentAnnotationOffset,</span><br><span class="line">                <span class="comment">/* named = */</span> <span class="keyword">true</span>,</span><br><span class="line">                charBuffer);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Visit the RuntimeInvisibleTypeAnnotations attribute.</span></span><br><span class="line">    <span class="keyword">if</span> (runtimeInvisibleTypeAnnotationsOffset != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);</span><br><span class="line">      <span class="keyword">int</span> currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">while</span> (numAnnotations-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Parse the target_type, target_info and target_path fields.</span></span><br><span class="line">        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);</span><br><span class="line">        <span class="comment">// Parse the type_index field.</span></span><br><span class="line">        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</span><br><span class="line">        currentAnnotationOffset += <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// Parse num_element_value_pairs and element_value_pairs and visit these values.</span></span><br><span class="line">        currentAnnotationOffset =</span><br><span class="line">            readElementValues(</span><br><span class="line">                classVisitor.visitTypeAnnotation(</span><br><span class="line">                    context.currentTypeAnnotationTarget,</span><br><span class="line">                    context.currentTypeAnnotationTargetPath,</span><br><span class="line">                    annotationDescriptor,</span><br><span class="line">                    <span class="comment">/* visible = */</span> <span class="keyword">false</span>),</span><br><span class="line">                currentAnnotationOffset,</span><br><span class="line">                <span class="comment">/* named = */</span> <span class="keyword">true</span>,</span><br><span class="line">                charBuffer);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问非标准的属性</span></span><br><span class="line">    <span class="comment">// Visit the non standard attributes.</span></span><br><span class="line">    <span class="keyword">while</span> (attributes != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Copy and reset the nextAttribute field so that it can also be used in ClassWriter.</span></span><br><span class="line">      Attribute nextAttribute = attributes.nextAttribute;</span><br><span class="line">      attributes.nextAttribute = <span class="keyword">null</span>;</span><br><span class="line">      classVisitor.visitAttribute(attributes);</span><br><span class="line">      attributes = nextAttribute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Visit the NestedMembers attribute.</span></span><br><span class="line">    <span class="keyword">if</span> (nestMembersOffset != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> numberOfNestMembers = readUnsignedShort(nestMembersOffset);</span><br><span class="line">      <span class="keyword">int</span> currentNestMemberOffset = nestMembersOffset + <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">while</span> (numberOfNestMembers-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        classVisitor.visitNestMemberExperimental(readClass(currentNestMemberOffset, charBuffer));</span><br><span class="line">        currentNestMemberOffset += <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Visit the InnerClasses attribute.</span></span><br><span class="line">    <span class="keyword">if</span> (innerClassesOffset != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> numberOfClasses = readUnsignedShort(innerClassesOffset);</span><br><span class="line">      <span class="keyword">int</span> currentClassesOffset = innerClassesOffset + <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">while</span> (numberOfClasses-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        classVisitor.visitInnerClass(</span><br><span class="line">            readClass(currentClassesOffset, charBuffer),</span><br><span class="line">            readClass(currentClassesOffset + <span class="number">2</span>, charBuffer),</span><br><span class="line">            readUTF8(currentClassesOffset + <span class="number">4</span>, charBuffer),</span><br><span class="line">            readUnsignedShort(currentClassesOffset + <span class="number">6</span>));</span><br><span class="line">        currentClassesOffset += <span class="number">8</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问字段和方法</span></span><br><span class="line">    <span class="comment">// Visit the fields and methods.</span></span><br><span class="line">    <span class="keyword">int</span> fieldsCount = readUnsignedShort(currentOffset);</span><br><span class="line">    currentOffset += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (fieldsCount-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      currentOffset = readField(classVisitor, context, currentOffset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> methodsCount = readUnsignedShort(currentOffset);</span><br><span class="line">    currentOffset += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (methodsCount-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      currentOffset = readMethod(classVisitor, context, currentOffset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Visit the end of the class.</span></span><br><span class="line">    classVisitor.visitEnd();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>其实，将整个 ClassReader 理解成一个对 .class 字节文件的解析器不失为一种可行的认知。</p><ol><li>在构造方法中完成对 .class 文件 minor_version, major_version 的确认。</li><li>继而完成对整个 Constants_pool 的解析</li><li>以及 BootstarpMethod 属性的定位</li><li>之后在 accept(…) 方法中逐一调用相应的访问者实现类实现对不同内容的访问。</li></ol><p>但是，要注意的是，ClassReader 绝对不会涉及到对其解析的 .class 文件内容的写操作。<br>所有的写操作都基于不同的目的，在 ClassVisitor 中实现。</p><h2 id="ClassVisitor"><a href="#ClassVisitor" class="headerlink" title="ClassVisitor"></a>ClassVisitor</h2><p>Java .class 的访问者，按照严格的顺序规范逐一调用 </p><p>visit<br>[ visitSource ] [ visitModule ][ visitNestHost ][ visitOuterClass ]<br>( visitAnnotation | visitTypeAnnotation | visitAttribute )<em><br>( visitNestMember | visitInnerClass | visitField | visitMethod )</em><br>visitEnd.</p><p>各个 visitXXX 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassVisitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 访问类的首部</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> version, <span class="keyword">final</span> <span class="keyword">int</span> access, <span class="keyword">final</span> String name, <span class="keyword">final</span> String signature, <span class="keyword">final</span> String superName, <span class="keyword">final</span> String[] interfaces)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 访问类的源文件名等</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitSource</span><span class="params">(<span class="keyword">final</span> String source, <span class="keyword">final</span> String debug)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 访问与类关联的模块</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModuleVisitor <span class="title">visitModule</span><span class="params">(<span class="keyword">final</span> String name, <span class="keyword">final</span> <span class="keyword">int</span> access, <span class="keyword">final</span> String version)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitOuterClass</span><span class="params">(<span class="keyword">final</span> String owner, <span class="keyword">final</span> String name, <span class="keyword">final</span> String descriptor)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> AnnotationVisitor <span class="title">visitAnnotation</span><span class="params">(<span class="keyword">final</span> String descriptor, <span class="keyword">final</span> <span class="keyword">boolean</span> visible)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> AnnotationVisitor <span class="title">visitTypeAnnotation</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> <span class="keyword">int</span> typeRef, <span class="keyword">final</span> TypePath typePath, <span class="keyword">final</span> String descriptor, <span class="keyword">final</span> <span class="keyword">boolean</span> visible)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitAttribute</span><span class="params">(<span class="keyword">final</span> Attribute attribute)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitInnerClass</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> String name, <span class="keyword">final</span> String outerName, <span class="keyword">final</span> String innerName, <span class="keyword">final</span> <span class="keyword">int</span> access)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 访问类的变量</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FieldVisitor <span class="title">visitField</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> <span class="keyword">int</span> access,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> String name,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> String descriptor,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> String signature,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> Object value)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 访问类的方法</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> <span class="keyword">int</span> access,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> String name,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> String descriptor,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> String signature,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> String[] exceptions)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitEnd</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随着 visitXxx() 方法的逐一执行，ClassVisitor 将对当前的 .class 文件越来越熟悉，并逐渐补全常量池(由 SymbolTable 持有并维护)</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到此为止，对整个 ClassReader &amp; ClassVisitor 将有一个基础而简单的印象。</p><p>ClassReader 通过对 .class 文件字节码的解析而获得对这个类的具体印象(更多的偏向是随意访问 .class 的各种细节)。</p><p>ClassVisitor 通过 visitXxx(…) 方法，由其它对象(可以是 ClassReader, 也可以直接是 Coder)逐渐对其开放一些 .class 的细节，<br>但需要 ClassVisitor 自行维护获得的内容(如果有必要的话)。由此得到对 .class 全部内容的了解(当然，如果本身 visitXxx() 得到的内容不全，则了解的自然有限)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文描述的 ASM 指的是 OW2 ASM&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;ASM-Core-的结构&quot;&gt;&lt;a href=&quot;#ASM-Core-的结构&quot; class=&quot;headerlink&quot; title=&quot;ASM-Core 的结构&quot;&gt;&lt;/a&gt;ASM-Core 的结构&lt;/h2&gt;&lt;p&gt;&lt;em&gt;首先是一些概述性的内容。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;由于 ASM 操作的 JAVA 字节码有严格的格式规定，且即使随着 JVM 标准的升级也极少出现重大调整。&lt;br&gt;因此适用面狭窄的访问者模式在该项目中被大量地使用，并且已经到了丧心病狂的程度:)&lt;/p&gt;
&lt;p&gt;从核心包声明的类来看，主要包括:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;ClassReader - 作为结构化对象，将接收(accept)访问者的访问&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;几种访问者抽象类以及相应的实现类&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;AnnotationVisitor -&amp;gt; AnnotationWriter&lt;/li&gt;
&lt;li&gt;ClassVisitor -&amp;gt; ClassWriter&lt;/li&gt;
&lt;li&gt;FieldVisitor -&amp;gt; FieldWriter&lt;/li&gt;
&lt;li&gt;MethodVisitor -&amp;gt; MethodWriter&lt;/li&gt;
&lt;li&gt;ModuleVisitor -&amp;gt; ModuleWriter&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;&lt;p&gt;Opcodes &amp;amp; Constants - ClassFile 中描述的大量常量符号与值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其它一些辅助的类&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Attribute - 用于处理非标准化的属性(ClassFile 允许&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JVMS&lt;/a&gt; 中未定义的 Attribute)&lt;/li&gt;
&lt;li&gt;ByteArray - 动态可自适应的 byte[] (字节数组)&lt;/li&gt;
&lt;li&gt;Context - ClassReader 在被解析(被访问)过程中用于表示“累积状态”的一个类/对象&lt;/li&gt;
&lt;li&gt;Symbol - 用于表示 ClassFile 中描述的 Constant 的基类&lt;/li&gt;
&lt;li&gt;SymbolTable - 用于存储常量池对象&lt;/li&gt;
&lt;li&gt;其它内容省略&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://DorMOUSE-None.github.io/tags/Java/"/>
    
      <category term="ASM" scheme="https://DorMOUSE-None.github.io/tags/ASM/"/>
    
      <category term="Visitor Pattern" scheme="https://DorMOUSE-None.github.io/tags/Visitor-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>java-memory-model</title>
    <link href="https://DorMOUSE-None.github.io/2018-06-21-java-memory-model/"/>
    <id>https://DorMOUSE-None.github.io/2018-06-21-java-memory-model/</id>
    <published>2018-06-20T16:00:00.000Z</published>
    <updated>2018-07-11T01:56:37.148Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM-运行时数据区"><a href="#JVM-运行时数据区" class="headerlink" title="JVM 运行时数据区"></a>JVM 运行时数据区</h2><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ft5osi6it1j31kw0ql78e.jpg" alt=""><br><a id="more"></a></p><h3 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h3><p>与操作系统中的PC寄存器功能基本一致。毕竟 JVM 建立的初衷就是模拟一台机器。<br>指向存储在<strong>方法区</strong>的字节码methods_info部分的内存地址。</p><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p><strong>虚拟机栈</strong>用于存储<strong>栈帧</strong></p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>用于支持 native 方法的执行</p><h3 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h3><p>存储在<strong>虚拟机栈</strong>中，主要包括<strong>局部变量表</strong>和<strong>操作数栈</strong>(又称<strong>当前栈帧的操作数栈</strong>)以及<strong>运行时常量池的引用</strong>。</p><p><em>仍然有必要区别两个概念: 操作数 &amp; 指令</em><br><em>指令指使操作数进行相关操作的基本命令</em><br><em>操作数通常指整数、浮点数以及类型引用等</em></p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p><strong>方法区</strong>是多个线程共享的一块区域，主要用于存储I/O操作中读入的类/接口的字节码(ClassFile 文件)<br>包括有 constant_pool, field_info, method_info, attribute_info 等</p><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>用于存储各种类的实例对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JVM-运行时数据区&quot;&gt;&lt;a href=&quot;#JVM-运行时数据区&quot; class=&quot;headerlink&quot; title=&quot;JVM 运行时数据区&quot;&gt;&lt;/a&gt;JVM 运行时数据区&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNc79gy1ft5osi6it1j31kw0ql78e.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://DorMOUSE-None.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://DorMOUSE-None.github.io/tags/JVM/"/>
    
      <category term="Memory Model" scheme="https://DorMOUSE-None.github.io/tags/Memory-Model/"/>
    
  </entry>
  
  <entry>
    <title>ASM - ClassReader 与 Java ClassFile 文件格式</title>
    <link href="https://DorMOUSE-None.github.io/2018-06-11-ASM-ClassReader/"/>
    <id>https://DorMOUSE-None.github.io/2018-06-11-ASM-ClassReader/</id>
    <published>2018-06-10T16:00:00.000Z</published>
    <updated>2018-06-22T08:26:20.743Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-ClassFile-文件格式"><a href="#Java-ClassFile-文件格式" class="headerlink" title="Java ClassFile 文件格式"></a>Java ClassFile 文件格式</h2><p>读了将近一周的时间，勉强算是把 ClassFile 的文件格式给简单的梳理了个脉络。<br><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" target="_blank" rel="noopener">The class File Format(Java SE 8)</a> </p><blockquote><p>u1, u2, u4 分别表示无符号的一字节、二字节、四字节数据(以大端存储)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic;                                   <span class="comment">// 魔数(magic) 固定为 0xCAFEBABE</span></span><br><span class="line">    u2             minor_version;                           <span class="comment">// 次版本号</span></span><br><span class="line">    u2             major_version;                           <span class="comment">// 主版本号</span></span><br><span class="line">    u2             constant_pool_count;                     <span class="comment">// 常量池 constant_pool 的数量 + 1, 最大为 (2&lt;&lt;16 - 1) = 65535</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count<span class="number">-1</span>];    <span class="comment">// 常量池 取值下标为 [1, constant_pool_count)</span></span><br><span class="line">    u2             access_flags;                            <span class="comment">// 对类 or 接口的访问权限和属性的标志的掩码</span></span><br><span class="line">    u2             this_class;                              <span class="comment">// 值为 constant_pool 的有效下标(且 constant_pool[this_class] 的类型为 CONSTANT_Class_info)</span></span><br><span class="line">    u2             super_class;                             <span class="comment">// 值为 0 或者 constant_pool 的有效下标(同上), 如果是 interface, 则该值一定为有效下标</span></span><br><span class="line">    u2             interfaces_count;                        <span class="comment">// 直接父接口的数量</span></span><br><span class="line">    u2             interfaces[interfaces_count];            <span class="comment">// 值必须是 constant_pool 的有效下标, 且 interfaces[i](0≤i&lt;interfaces_count), 指向的类型为 CONSTANT_Class_info)</span></span><br><span class="line">    u2             fields_count;                            <span class="comment">// 字段数量, 统计所有字段, 包括 class variables(静态变量) 和 instance variables(实例变量)</span></span><br><span class="line">    field_info     fields[fields_count];                    <span class="comment">// 字段的详细声明, 不包含继承来的字段</span></span><br><span class="line">    u2             methods_count;                           <span class="comment">// 方法数量</span></span><br><span class="line">    method_info    methods[methods_count];                  <span class="comment">// 方法的详细声明, 不包括继承来的方法</span></span><br><span class="line">    u2             attributes_count;                        <span class="comment">// 属性数量</span></span><br><span class="line">    attribute_info attributes[attributes_count];            <span class="comment">// 属性的详细声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>通过 <code>javac Xxx.java</code> 命令得到的 <code>Xxx.class</code> 文件严格按照定义的 ClassFile 文件格式以8比特的字节为单位进行存储。</p><p><strong>下面的例子都将通过 Trie.java (实际代码见本文最后) 以及其经编译后的文件 Trie.class 做基本的介绍。</strong></p><h3 id="magic-minor-verion-amp-major-version"><a href="#magic-minor-verion-amp-major-version" class="headerlink" title="magic, minor_verion &amp; major_version"></a>magic, minor_verion &amp; major_version</h3><p>通过命令 <code>xxd Trie.class</code> 查看 Trie.class 的十六进制编码，前16字节的内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000000: cafe babe 0000 0034 008f 0a00 2400 4b09  .......4....$.K.</span><br></pre></td></tr></table></figure></p><p>可以看到前4字节的内容 <code>0xcafebabe</code>，没有实际意义，但是作为其是能否被JVM(Java Virtual Machine, Java虚拟机)接收的Class文件的一个校验。</p><p>紧接着的4个字节包括<code>次版本号</code> 和 <code>主版本号</code>，暂时不做深入。</p><h3 id="常量池-constant-pool"><a href="#常量池-constant-pool" class="headerlink" title="常量池 constant_pool"></a>常量池 constant_pool</h3><p>从第10个字节开始(从第0字节开始计数)，连续的两个字节表示常量池中各种 CONSTANT 的总个数+1 (constant_pool_count)。constant_pool_count 只有2字节也就意味着: 常量池的最大常量数量为 (2&lt;&lt;16 - 1) = 65535 (当然，貌似在这个量级上，也从没见过有谁能够维护这样一个大JAVA类文件了)。</p><p>可以看到 constant_pool_count 的内容为 <code>0x008f = 143</code> ，即对于常量池的声明可以认为是 <code>cp_info constant_pool[142]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u1 info[]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用 JDK 自带的 <code>javap</code> 来查看 <code>Trie.class</code> 文件(<code>javap -v Trie.class</code>)，可以对 cp_info 的格式有一个粗浅但形象化的认识(结果见<strong>附录2</strong>)<br>其中第一列的内容 <code>#? = ?</code> <code>#?</code>表示id，<code>= ?</code>表示一个 cp_info 的实际类型，有 <code>cp_info.tag</code> 指定，具体映射表为</p><table><thead><tr><th>Constant Type</th><th>Value</th></tr></thead><tbody><tr><td><code>CONSTANT_Class</code></td><td>7</td></tr><tr><td><code>CONSTANT_Fieldref</code></td><td>9</td></tr><tr><td><code>CONSTANT_Methodref</code></td><td>10</td></tr><tr><td><code>CONSTANT_InterfaceMethodref</code></td><td>11</td></tr><tr><td><code>CONSTANT_String</code></td><td>8</td></tr><tr><td><code>CONSTANT_Integer</code></td><td>3</td></tr><tr><td><code>CONSTANT_Float</code></td><td>4</td></tr><tr><td><code>CONSTANT_Long</code></td><td>5</td></tr><tr><td><code>CONSTANT_Double</code></td><td>6</td></tr><tr><td><code>CONSTANT_NameAndType</code></td><td>12</td></tr><tr><td><code>CONSTANT_Utf8</code></td><td>1</td></tr><tr><td><code>CONSTANT_MethodHandle</code></td><td>15</td></tr><tr><td><code>CONSTANT_MethodType</code></td><td>16</td></tr><tr><td><code>CONSTANT_InvokeDynamic</code></td><td>18</td></tr><tr><td><code>CONSTANT_Module</code></td><td>19</td></tr><tr><td><code>CONSTANT_Package</code></td><td>20</td></tr></tbody></table><p>在 Java ClassFile 的格式定义中，同时定义了每种 <code>CONSTANT</code> 的长度与格式。<br>例如:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Class_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 name_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Fieldref_info &#123;</span><br><span class="line">     u1 tag;</span><br><span class="line">     u2 class_index;</span><br><span class="line">     u2 name_and_type_index;</span><br><span class="line">&#125;</span><br><span class="line">CONSTANT_Methodref_info &#123;</span><br><span class="line">  u1 tag;</span><br><span class="line">  u2 class_index;</span><br><span class="line">  u2 name_and_type_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多的 <code>CONSTANT_XXX</code> 的格式定义见 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4" target="_blank" rel="noopener">ClassFile CONSTANT_XXX 结构</a></p><p>简单解析一下 cp_info[1]。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000: cafe babe 0000 0034 008f 0a00 2400 4b09  .......4....$.K.</span><br><span class="line"></span><br><span class="line">#1 = Methodref          #36.#75       // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br></pre></td></tr></table></figure></p><p><code>cp_info[1].tag = 0x0a = 10</code>，即 cp_info[1] 的类型为 Methodref 。<br>之后就直接套用 <code>CONSTANT_Methodref_info</code> 的数据结构定义的格式<br><code>cp_info[1].class_index = 0x0024 = 36</code>，即 cp_info[1].class_index 表示的类名指向常量池第 36 个元素表示的类<br><code>cp_info[1].name_and_type_index = 0x004b = 75</code>。表示指向的是常量池第 75 个元素表示的 NameAndType 结构</p><p>对于这部分内容的理解，如果觉得有能够阅读英文文档，可以参考 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" target="_blank" rel="noopener">The Java® Virtual Machine Specification Chap 4.</a><br>否则，可以选择 <a href="http://icyfenix.iteye.com/blog/1256329" target="_blank" rel="noopener">Java 虚拟机规范(Java SE 7 版) 第四章</a><br>并尝试根据经编译后.class文件的二进制码进行人工解析，以加深对此的理解。</p><h3 id="more…"><a href="#more…" class="headerlink" title="more…"></a>more…</h3><p>更多内容于此基本类似，均属于已经被严格预定义的规范化格式，对此进行解析即可得到相应的内容。</p><h2 id="ASM-概览"><a href="#ASM-概览" class="headerlink" title="ASM 概览"></a>ASM 概览</h2><h3 id="包结构"><a href="#包结构" class="headerlink" title="包结构"></a>包结构</h3><p>asm, asm-analysis, asm-commons, asm-tree, asm-util, asm-xml 模块基于 Maven 的组织形式，并包含有单元测试的内容。</p><p>asm-test 实现了对上述模块的单元测试的整合。</p><p>benchmarks 定义了一些基本的 JMH 基准测试来衡量ASM的表现</p><p>gradle 包含了一些 Gradle 包装器，来辅助 Linux or Windows 脚本的调用请求</p><p>tools 包含两个 Gradle 项目来帮助 ASM 生成 Artifacts 。</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1frywra01upj308g0akmxr.jpg" alt="ASM Structure"></p><h3 id="代码组织形式"><a href="#代码组织形式" class="headerlink" title="代码组织形式"></a>代码组织形式</h3><p><img src="http://asm.ow2.io/asm-package-dependencies.svg" alt="Code Organization"></p><ul><li>org.objectweb.asm 作为核心包，定义了 ASM 访问者 API 以及两个核心类 ClassReader &amp; ClassWriter 来读写编译后的 Java 类。该包不依赖于其他包，且可单独使用</li><li>org.objectweb.asm.signature 提供了读写泛型签名的 API</li><li>org.objectweb.asm.tree 提供了类 DOM API 与类 SAX API。</li><li>org.objectweb.asm.tree.analysis 基于 .tree 提供了静态字节码分析框架</li><li>org.objectweb.asm.commons 提供了一些基于 core 和 tree 包的类适配器。</li><li>org.objectweb.asm.util 提供了一些用于 DEBUG 的访问者类与适配器类</li><li>org.objectweb.asm.xml 目前已经被 @Deprecated 。提供了类文件与 XML 互相转换的能力</li></ul><p>综上，asm 核心包是最为复杂的一个模块，而其它诸如 tree, util, xml 等都只是提供了将 JAVA 类从一种高级表示形态转换为另一种的能力。signature 也相当简单，提供了解析和打印简单语法的能力。</p><h3 id="主要数据结构"><a href="#主要数据结构" class="headerlink" title="主要数据结构"></a>主要数据结构</h3><p>核心包由 28 个类(接口) 组成。如果不考虑 Opcodes 接口, 5 个抽象访问者类(AnnotationVistitor, ClassVisitor, FieldVisitor, MethodVisitor and ModuleVisitor), 6 个工具类(ConstantDynamic, Contants, Handle, Type, TypePath and TypeReference), 剩下 16 个类的由下图提供一个粗略的展示。</p><p><img src="http://asm.ow2.io/asm-package-overview.svg" alt=""></p><p>编译类到访问事件的转换只由一个类 ClassReader 以及辅助类 Context 完成。其逆过程由以 ClassWriter 为核心的其它 14 个类完成。</p><h3 id="ClassReader"><a href="#ClassReader" class="headerlink" title="ClassReader"></a>ClassReader</h3><p>ClassReader 作为 ASM 核心包解析现有 .class 的唯一工具，组织形式相当简单。</p><ul><li>在构造函数中完成对常量池和引导方法的解析<ul><li>存储每个常量池项目的起始偏移量 cpInfoOffsets</li><li>存储每个引导方法的起始偏移量 bootstrapMethodOffsets</li><li>存储最长字符串常量的大小 maxStringLength</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">ClassReader(<span class="keyword">final</span> <span class="keyword">byte</span>[] classFileBuffer, <span class="keyword">final</span> <span class="keyword">int</span> classFileOffset, <span class="keyword">final</span> <span class="keyword">boolean</span> checkClassVersion) &#123;</span><br><span class="line">  <span class="keyword">this</span>.b = classFileBuffer;   <span class="comment">// .class 文件缓存</span></span><br><span class="line">  <span class="comment">// 检查主版本号, 第6,7个字节(从0字节开始计数)</span></span><br><span class="line">  <span class="keyword">if</span> (checkClassVersion &amp;&amp; readShort(classFileOffset + <span class="number">6</span>) &gt; Opcodes.V11) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">        <span class="string">"Unsupported class file major version "</span> + readShort(classFileOffset + <span class="number">6</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建常量池数组，常量池长度的定义 constant_pool_count 在第8,9字节</span></span><br><span class="line">  <span class="keyword">int</span> constantPoolCount = readUnsignedShort(classFileOffset + <span class="number">8</span>);     <span class="comment">// 读取无符号short, 即读取连续两字节作为一个short值</span></span><br><span class="line">  cpInfoOffsets = <span class="keyword">new</span> <span class="keyword">int</span>[constantPoolCount];                         <span class="comment">// 每个常量的偏移位置</span></span><br><span class="line">  cpInfoValues = <span class="keyword">new</span> Object[constantPoolCount];                       <span class="comment">// 每个常量的实例对象</span></span><br><span class="line">  <span class="keyword">int</span> currentCpInfoIndex = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> currentCpInfoOffset = classFileOffset + <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> currentMaxStringLength = <span class="number">0</span>;                                     <span class="comment">// 最长字符串常量</span></span><br><span class="line">  <span class="keyword">while</span> (currentCpInfoIndex &lt; constantPoolCount) &#123;</span><br><span class="line">    cpInfoOffsets[currentCpInfoIndex++] = currentCpInfoOffset + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cpInfoSize;</span><br><span class="line">    <span class="keyword">switch</span> (classFileBuffer[currentCpInfoOffset]) &#123;</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_FIELDREF_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_METHODREF_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_INTERFACE_METHODREF_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_INTEGER_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_FLOAT_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_NAME_AND_TYPE_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_DYNAMIC_TAG:</span><br><span class="line">        cpInfoSize = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_LONG_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_DOUBLE_TAG:</span><br><span class="line">        cpInfoSize = <span class="number">9</span>;</span><br><span class="line">        currentCpInfoIndex++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_UTF8_TAG:</span><br><span class="line">        cpInfoSize = <span class="number">3</span> + readUnsignedShort(currentCpInfoOffset + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (cpInfoSize &gt; currentMaxStringLength) &#123;</span><br><span class="line">          <span class="comment">// The size in bytes of this CONSTANT_Utf8 structure provides a conservative estimate</span></span><br><span class="line">          <span class="comment">// of the length in characters of the corresponding string, and is much cheaper to</span></span><br><span class="line">          <span class="comment">// compute than this exact length.</span></span><br><span class="line">          currentMaxStringLength = cpInfoSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_METHOD_HANDLE_TAG:</span><br><span class="line">        cpInfoSize = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_CLASS_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_STRING_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_METHOD_TYPE_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_PACKAGE_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_MODULE_TAG:</span><br><span class="line">        cpInfoSize = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    currentCpInfoOffset += cpInfoSize;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.maxStringLength = currentMaxStringLength;</span><br><span class="line">  <span class="comment">// The Classfile's access_flags field is just after the last constant pool entry.</span></span><br><span class="line">  <span class="keyword">this</span>.header = currentCpInfoOffset;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取 BootstrapMethods 属性(如果存在)</span></span><br><span class="line">  <span class="keyword">int</span> currentAttributeOffset = getFirstAttributeOffset();</span><br><span class="line">  <span class="keyword">int</span>[] currentBootstrapMethodOffsets = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = readUnsignedShort(currentAttributeOffset - <span class="number">2</span>); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="comment">// 读取每个 attribute_info 的属性名和属性长度</span></span><br><span class="line">    String attributeName = readUTF8(currentAttributeOffset, <span class="keyword">new</span> <span class="keyword">char</span>[maxStringLength]);</span><br><span class="line">    <span class="keyword">int</span> attributeLength = readInt(currentAttributeOffset + <span class="number">2</span>);</span><br><span class="line">    currentAttributeOffset += <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 如果当前属性名为 BootstrapMethods ，则进入处理逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (Constants.BOOTSTRAP_METHODS.equals(attributeName)) &#123;</span><br><span class="line">      <span class="comment">// Read the num_bootstrap_methods field and create an array of this size.</span></span><br><span class="line">      currentBootstrapMethodOffsets = <span class="keyword">new</span> <span class="keyword">int</span>[readUnsignedShort(currentAttributeOffset)];</span><br><span class="line">      <span class="comment">// Compute and store the offset of each 'bootstrap_methods' array field entry.</span></span><br><span class="line">      <span class="keyword">int</span> currentBootstrapMethodOffset = currentAttributeOffset + <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; currentBootstrapMethodOffsets.length; ++j) &#123;</span><br><span class="line">        currentBootstrapMethodOffsets[j] = currentBootstrapMethodOffset;</span><br><span class="line">        <span class="comment">// Skip the bootstrap_method_ref and num_bootstrap_arguments fields (2 bytes each),</span></span><br><span class="line">        <span class="comment">// as well as the bootstrap_arguments array field (of size num_bootstrap_arguments * 2).</span></span><br><span class="line">        currentBootstrapMethodOffset +=</span><br><span class="line">            <span class="number">4</span> + readUnsignedShort(currentBootstrapMethodOffset + <span class="number">2</span>) * <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    currentAttributeOffset += attributeLength;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.bootstrapMethodOffsets = currentBootstrapMethodOffsets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，ClassReader 已经解析了包括 magic, minor version, major version, constant pool 。<br>但是，诸如 field_info, method_info, attribute_info 等仍然没有得到处理。</p><p>这部分的内容在 accept(…) 和 readXXX(…) 中将得到解析。</p><p>主要流程类似:</p><ol><li>读取当前内容的偏移量(相较于整个 byte[])</li><li>解析当前的内容</li><li>调用 visitXXX 方法</li><li>在 visitXXX 方法中进行相关的处理</li><li>visitEnd</li></ol><h2 id="附录1-Trie-java"><a href="#附录1-Trie-java" class="headerlink" title="附录1 Trie.java"></a>附录1 Trie.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.fangfeng.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fangfeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/5/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_ITEM = <span class="number">700000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> AVG_LENGTH = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_NODE = MAX_ITEM * AVG_LENGTH;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> CHAR_NUM = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] nxt = <span class="keyword">new</span> <span class="keyword">int</span>[MAX_NODE][CHAR_NUM];</span><br><span class="line">    <span class="keyword">boolean</span>[] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[MAX_NODE];</span><br><span class="line">    <span class="keyword">int</span> trieIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">long</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmpIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;number != <span class="number">0</span>;number /= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nxt[tmpIndex][(<span class="keyword">int</span>) (number % <span class="number">10</span>)] == <span class="number">0</span>) &#123;</span><br><span class="line">                nxt[tmpIndex][(<span class="keyword">int</span>) (number % <span class="number">10</span>)] = ++trieIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            tmpIndex = nxt[tmpIndex][(<span class="keyword">int</span>) (number % <span class="number">10</span>)];</span><br><span class="line">        &#125;</span><br><span class="line">        flag[tmpIndex] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">query</span><span class="params">(<span class="keyword">long</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmpIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;number != <span class="number">0</span>;number /= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nxt[tmpIndex][(<span class="keyword">int</span>) (number % <span class="number">10</span>)] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tmpIndex = nxt[tmpIndex][(<span class="keyword">int</span>) (number % <span class="number">10</span>)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag[tmpIndex];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> <span class="keyword">throws</span> FileNotFoundException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        String ruleFilePath = args[<span class="number">0</span>];</span><br><span class="line">        String sendFilePath = args[<span class="number">1</span>];</span><br><span class="line">        String outFilePath = args[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        BufferedReader ruleReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(ruleFilePath)));</span><br><span class="line">        BufferedReader sendReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(sendFilePath)));</span><br><span class="line"></span><br><span class="line">        BufferedWriter outWriter = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(outFilePath)));</span><br><span class="line"></span><br><span class="line">        Trie trie = <span class="keyword">new</span> Trie();</span><br><span class="line">        String mobile;</span><br><span class="line">        <span class="keyword">while</span>((mobile = ruleReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            trie.insert(Long.parseLong(mobile));</span><br><span class="line">        &#125;</span><br><span class="line">        ruleReader.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>((mobile = sendReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(trie.query(Long.parseLong(mobile)) == <span class="keyword">false</span>) &#123;</span><br><span class="line">                outWriter.write(mobile);</span><br><span class="line">                outWriter.newLine();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sendReader.close();</span><br><span class="line"></span><br><span class="line">        outWriter.flush();</span><br><span class="line">        outWriter.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(String.format(<span class="string">"exec success! used %d ms"</span>, end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附录2-Constant-pool"><a href="#附录2-Constant-pool" class="headerlink" title="附录2 Constant pool"></a>附录2 Constant pool</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">    #1 = Methodref          #36.#75       // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">    #2 = Fieldref           #23.#76       // me/fangfeng/filter/Trie.MAX_NODE:I</span><br><span class="line">    #3 = Fieldref           #23.#77       // me/fangfeng/filter/Trie.CHAR_NUM:I</span><br><span class="line">    #4 = Class              #49           // &quot;[[I&quot;</span><br><span class="line">    #5 = Fieldref           #23.#78       // me/fangfeng/filter/Trie.nxt:[[I</span><br><span class="line">    #6 = Fieldref           #23.#79       // me/fangfeng/filter/Trie.flag:[Z</span><br><span class="line">    #7 = Fieldref           #23.#80       // me/fangfeng/filter/Trie.trieIndex:I</span><br><span class="line">    #8 = Long               10l</span><br><span class="line">   #10 = Methodref          #81.#82       // java/lang/System.currentTimeMillis:()J</span><br><span class="line">   #11 = Class              #83           // java/io/BufferedReader</span><br><span class="line">   #12 = Class              #84           // java/io/InputStreamReader</span><br><span class="line">   #13 = Class              #85           // java/io/FileInputStream</span><br><span class="line">   #14 = Methodref          #13.#86       // java/io/FileInputStream.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="line">   #15 = Methodref          #12.#87       // java/io/InputStreamReader.&quot;&lt;init&gt;&quot;:(Ljava/io/InputStream;)V</span><br><span class="line">   #16 = Methodref          #11.#88       // java/io/BufferedReader.&quot;&lt;init&gt;&quot;:(Ljava/io/Reader;)V</span><br><span class="line">   #17 = Class              #89           // java/io/BufferedWriter</span><br><span class="line">   #18 = Class              #90           // java/io/OutputStreamWriter</span><br><span class="line">   #19 = Class              #91           // java/io/FileOutputStream</span><br><span class="line">   #20 = Methodref          #19.#86       // java/io/FileOutputStream.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="line">   #21 = Methodref          #18.#92       // java/io/OutputStreamWriter.&quot;&lt;init&gt;&quot;:(Ljava/io/OutputStream;)V</span><br><span class="line">   #22 = Methodref          #17.#93       // java/io/BufferedWriter.&quot;&lt;init&gt;&quot;:(Ljava/io/Writer;)V</span><br><span class="line">   #23 = Class              #94           // me/fangfeng/filter/Trie</span><br><span class="line">   #24 = Methodref          #23.#75       // me/fangfeng/filter/Trie.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #25 = Methodref          #11.#95       // java/io/BufferedReader.readLine:()Ljava/lang/String;</span><br><span class="line">   #26 = Methodref          #96.#97       // java/lang/Long.parseLong:(Ljava/lang/String;)J</span><br><span class="line">   #27 = Methodref          #23.#98       // me/fangfeng/filter/Trie.insert:(J)V</span><br><span class="line">   #28 = Methodref          #11.#99       // java/io/BufferedReader.close:()V</span><br><span class="line">   #29 = Methodref          #23.#100      // me/fangfeng/filter/Trie.query:(J)Z</span><br><span class="line">   #30 = Methodref          #17.#101      // java/io/BufferedWriter.write:(Ljava/lang/String;)V</span><br><span class="line">   #31 = Methodref          #17.#102      // java/io/BufferedWriter.newLine:()V</span><br><span class="line">   #32 = Methodref          #17.#103      // java/io/BufferedWriter.flush:()V</span><br><span class="line">   #33 = Methodref          #17.#99       // java/io/BufferedWriter.close:()V</span><br><span class="line">   #34 = Fieldref           #81.#104      // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #35 = String             #105          // exec success! used %d ms</span><br><span class="line">   #36 = Class              #106          // java/lang/Object</span><br><span class="line">   #37 = Methodref          #96.#107      // java/lang/Long.valueOf:(J)Ljava/lang/Long;</span><br><span class="line">   #38 = Methodref          #108.#109     // java/lang/String.format:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;</span><br><span class="line">   #39 = Methodref          #110.#111     // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #40 = Integer            700000</span><br><span class="line">   #41 = Fieldref           #23.#112      // me/fangfeng/filter/Trie.MAX_ITEM:I</span><br><span class="line">   #42 = Fieldref           #23.#113      // me/fangfeng/filter/Trie.AVG_LENGTH:I</span><br><span class="line">   #43 = Utf8               MAX_ITEM</span><br><span class="line">   #44 = Utf8               I</span><br><span class="line">   #45 = Utf8               AVG_LENGTH</span><br><span class="line">   #46 = Utf8               MAX_NODE</span><br><span class="line">   #47 = Utf8               CHAR_NUM</span><br><span class="line">   #48 = Utf8               nxt</span><br><span class="line">   #49 = Utf8               [[I</span><br><span class="line">   #50 = Utf8               flag</span><br><span class="line">   #51 = Utf8               [Z</span><br><span class="line">   #52 = Utf8               trieIndex</span><br><span class="line">   #53 = Utf8               &lt;init&gt;</span><br><span class="line">   #54 = Utf8               ()V</span><br><span class="line">   #55 = Utf8               Code</span><br><span class="line">   #56 = Utf8               LineNumberTable</span><br><span class="line">   #57 = Utf8               insert</span><br><span class="line">   #58 = Utf8               (J)V</span><br><span class="line">   #59 = Utf8               StackMapTable</span><br><span class="line">   #60 = Utf8               query</span><br><span class="line">   #61 = Utf8               (J)Z</span><br><span class="line">   #62 = Utf8               main</span><br><span class="line">   #63 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">   #64 = Class              #114          // &quot;[Ljava/lang/String;&quot;</span><br><span class="line">   #65 = Class              #115          // java/lang/String</span><br><span class="line">   #66 = Class              #83           // java/io/BufferedReader</span><br><span class="line">   #67 = Class              #89           // java/io/BufferedWriter</span><br><span class="line">   #68 = Class              #94           // me/fangfeng/filter/Trie</span><br><span class="line">   #69 = Utf8               Exceptions</span><br><span class="line">   #70 = Class              #116          // java/io/FileNotFoundException</span><br><span class="line">   #71 = Class              #117          // java/io/IOException</span><br><span class="line">   #72 = Utf8               &lt;clinit&gt;</span><br><span class="line">   #73 = Utf8               SourceFile</span><br><span class="line">   #74 = Utf8               Trie.java</span><br><span class="line">   #75 = NameAndType        #53:#54       // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #76 = NameAndType        #46:#44       // MAX_NODE:I</span><br><span class="line">   #77 = NameAndType        #47:#44       // CHAR_NUM:I</span><br><span class="line">   #78 = NameAndType        #48:#49       // nxt:[[I</span><br><span class="line">   #79 = NameAndType        #50:#51       // flag:[Z</span><br><span class="line">   #80 = NameAndType        #52:#44       // trieIndex:I</span><br><span class="line">   #81 = Class              #118          // java/lang/System</span><br><span class="line">   #82 = NameAndType        #119:#120     // currentTimeMillis:()J</span><br><span class="line">   #83 = Utf8               java/io/BufferedReader</span><br><span class="line">   #84 = Utf8               java/io/InputStreamReader</span><br><span class="line">   #85 = Utf8               java/io/FileInputStream</span><br><span class="line">   #86 = NameAndType        #53:#121      // &quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="line">   #87 = NameAndType        #53:#122      // &quot;&lt;init&gt;&quot;:(Ljava/io/InputStream;)V</span><br><span class="line">   #88 = NameAndType        #53:#123      // &quot;&lt;init&gt;&quot;:(Ljava/io/Reader;)V</span><br><span class="line">   #89 = Utf8               java/io/BufferedWriter</span><br><span class="line">   #90 = Utf8               java/io/OutputStreamWriter</span><br><span class="line">   #91 = Utf8               java/io/FileOutputStream</span><br><span class="line">   #92 = NameAndType        #53:#124      // &quot;&lt;init&gt;&quot;:(Ljava/io/OutputStream;)V</span><br><span class="line">   #93 = NameAndType        #53:#125      // &quot;&lt;init&gt;&quot;:(Ljava/io/Writer;)V</span><br><span class="line">   #94 = Utf8               me/fangfeng/filter/Trie</span><br><span class="line">   #95 = NameAndType        #126:#127     // readLine:()Ljava/lang/String;</span><br><span class="line">   #96 = Class              #128          // java/lang/Long</span><br><span class="line">   #97 = NameAndType        #129:#130     // parseLong:(Ljava/lang/String;)J</span><br><span class="line">   #98 = NameAndType        #57:#58       // insert:(J)V</span><br><span class="line">   #99 = NameAndType        #131:#54      // close:()V</span><br><span class="line">  #100 = NameAndType        #60:#61       // query:(J)Z</span><br><span class="line">  #101 = NameAndType        #132:#121     // write:(Ljava/lang/String;)V</span><br><span class="line">  #102 = NameAndType        #133:#54      // newLine:()V</span><br><span class="line">  #103 = NameAndType        #134:#54      // flush:()V</span><br><span class="line">  #104 = NameAndType        #135:#136     // out:Ljava/io/PrintStream;</span><br><span class="line">  #105 = Utf8               exec success! used %d ms</span><br><span class="line">  #106 = Utf8               java/lang/Object</span><br><span class="line">  #107 = NameAndType        #137:#138     // valueOf:(J)Ljava/lang/Long;</span><br><span class="line">  #108 = Class              #115          // java/lang/String</span><br><span class="line">  #109 = NameAndType        #139:#140     // format:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;</span><br><span class="line">  #110 = Class              #141          // java/io/PrintStream</span><br><span class="line">  #111 = NameAndType        #142:#121     // println:(Ljava/lang/String;)V</span><br><span class="line">  #112 = NameAndType        #43:#44       // MAX_ITEM:I</span><br><span class="line">  #113 = NameAndType        #45:#44       // AVG_LENGTH:I</span><br><span class="line">  #114 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #115 = Utf8               java/lang/String</span><br><span class="line">  #116 = Utf8               java/io/FileNotFoundException</span><br><span class="line">  #117 = Utf8               java/io/IOException</span><br><span class="line">  #118 = Utf8               java/lang/System</span><br><span class="line">  #119 = Utf8               currentTimeMillis</span><br><span class="line">  #120 = Utf8               ()J</span><br><span class="line">  #121 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  #122 = Utf8               (Ljava/io/InputStream;)V</span><br><span class="line">  #123 = Utf8               (Ljava/io/Reader;)V</span><br><span class="line">  #124 = Utf8               (Ljava/io/OutputStream;)V</span><br><span class="line">  #125 = Utf8               (Ljava/io/Writer;)V</span><br><span class="line">  #126 = Utf8               readLine</span><br><span class="line">  #127 = Utf8               ()Ljava/lang/String;</span><br><span class="line">  #128 = Utf8               java/lang/Long</span><br><span class="line">  #129 = Utf8               parseLong</span><br><span class="line">  #130 = Utf8               (Ljava/lang/String;)J</span><br><span class="line">  #131 = Utf8               close</span><br><span class="line">  #132 = Utf8               write</span><br><span class="line">  #133 = Utf8               newLine</span><br><span class="line">  #134 = Utf8               flush</span><br><span class="line">  #135 = Utf8               out</span><br><span class="line">  #136 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #137 = Utf8               valueOf</span><br><span class="line">  #138 = Utf8               (J)Ljava/lang/Long;</span><br><span class="line">  #139 = Utf8               format</span><br><span class="line">  #140 = Utf8               (Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;</span><br><span class="line">  #141 = Utf8               java/io/PrintStream</span><br><span class="line">  #142 = Utf8               println</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1]: <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a> “Java Virtual Machine Specification”<br>[2]: <a href="http://icyfenix.iteye.com/blog/1256329" target="_blank" rel="noopener">http://icyfenix.iteye.com/blog/1256329</a> “Java虚拟机规范（Java SE 7 中文版）”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java-ClassFile-文件格式&quot;&gt;&lt;a href=&quot;#Java-ClassFile-文件格式&quot; class=&quot;headerlink&quot; title=&quot;Java ClassFile 文件格式&quot;&gt;&lt;/a&gt;Java ClassFile 文件格式&lt;/h2&gt;&lt;p&gt;读了将近一周的时间，勉强算是把 ClassFile 的文件格式给简单的梳理了个脉络。&lt;br&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/html/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The class File Format(Java SE 8)&lt;/a&gt; &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;u1, u2, u4 分别表示无符号的一字节、二字节、四字节数据(以大端存储)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ClassFile &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u4             magic;                                   &lt;span class=&quot;comment&quot;&gt;// 魔数(magic) 固定为 0xCAFEBABE&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u2             minor_version;                           &lt;span class=&quot;comment&quot;&gt;// 次版本号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u2             major_version;                           &lt;span class=&quot;comment&quot;&gt;// 主版本号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u2             constant_pool_count;                     &lt;span class=&quot;comment&quot;&gt;// 常量池 constant_pool 的数量 + 1, 最大为 (2&amp;lt;&amp;lt;16 - 1) = 65535&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cp_info        constant_pool[constant_pool_count&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;];    &lt;span class=&quot;comment&quot;&gt;// 常量池 取值下标为 [1, constant_pool_count)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u2             access_flags;                            &lt;span class=&quot;comment&quot;&gt;// 对类 or 接口的访问权限和属性的标志的掩码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u2             this_class;                              &lt;span class=&quot;comment&quot;&gt;// 值为 constant_pool 的有效下标(且 constant_pool[this_class] 的类型为 CONSTANT_Class_info)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u2             super_class;                             &lt;span class=&quot;comment&quot;&gt;// 值为 0 或者 constant_pool 的有效下标(同上), 如果是 interface, 则该值一定为有效下标&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u2             interfaces_count;                        &lt;span class=&quot;comment&quot;&gt;// 直接父接口的数量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u2             interfaces[interfaces_count];            &lt;span class=&quot;comment&quot;&gt;// 值必须是 constant_pool 的有效下标, 且 interfaces[i](0≤i&amp;lt;interfaces_count), 指向的类型为 CONSTANT_Class_info)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u2             fields_count;                            &lt;span class=&quot;comment&quot;&gt;// 字段数量, 统计所有字段, 包括 class variables(静态变量) 和 instance variables(实例变量)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    field_info     fields[fields_count];                    &lt;span class=&quot;comment&quot;&gt;// 字段的详细声明, 不包含继承来的字段&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u2             methods_count;                           &lt;span class=&quot;comment&quot;&gt;// 方法数量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    method_info    methods[methods_count];                  &lt;span class=&quot;comment&quot;&gt;// 方法的详细声明, 不包括继承来的方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u2             attributes_count;                        &lt;span class=&quot;comment&quot;&gt;// 属性数量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    attribute_info attributes[attributes_count];            &lt;span class=&quot;comment&quot;&gt;// 属性的详细声明&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>区块链技术概述</title>
    <link href="https://DorMOUSE-None.github.io/2018-03-01-%E5%8C%BA%E5%9D%97%E9%93%BE%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
    <id>https://DorMOUSE-None.github.io/2018-03-01-区块链简单介绍/</id>
    <published>2018-02-28T16:00:00.000Z</published>
    <updated>2018-06-14T01:24:24.421Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fs8oc4ri7qj30mq055aap.jpg" alt="区块链简单结构"></p><center><small>图1. 区块链简单结构</small></center><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1foxcpmmpfhj31kw107n2e.jpg" alt="Merkle tree"></p><center><small>图2. 单个区块的抽象结构</small></center><a id="more"></a><h2 id="基本工作流程"><a href="#基本工作流程" class="headerlink" title="基本工作流程"></a>基本工作流程</h2><h3 id="新交易发起流程"><a href="#新交易发起流程" class="headerlink" title="新交易发起流程"></a>新交易发起流程</h3><ol><li>用户通过公/私钥与区块链网络进行交互</li><li>处理用户交易的节点向网络邻节点广播用户交易</li><li>邻节点验证交易的有效性；可信，继续向其它邻节点广播；不可信，丢弃。</li></ol><h3 id="新区块产生流程"><a href="#新区块产生流程" class="headerlink" title="新区块产生流程"></a>新区块产生流程</h3><ol><li>矿工尝试将一个时间区间内的交易进行打包形成新区块（怎么打包，看下文）</li><li>生产出新区块的矿工节点向网络广播新区块</li><li>收到新区块的网络节点验证该区块的有效性</li></ol><p><a href="https://blockchain.info/zh-cn" target="_blank" rel="noopener">比特币区块浏览器</a>      更多<a href="https://en.wikipedia.org/wiki/Metric_prefix" target="_blank" rel="noopener">国际单位制前缀</a></p><h2 id="网络共识"><a href="#网络共识" class="headerlink" title="网络共识"></a>网络共识</h2><p>所有区块链网络节点需要对交易以及其在新区块里面的顺序达成一致（交易的有效性以及交易的打包顺序）。</p><p>可能出现：</p><ul><li>女巫攻击——单一实体以多重身份重复对新区块结果进行表决（少数人抓住了网络的投票权）</li><li><a href="https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">拜占庭将军问题</a>——分布式对等网络的通信容错问题<ul><li>不同的计算机通过通讯交换信息达成共识而按照同一套协作策略行动<ul><li>成员计算机可能出错而发送错误信息</li><li>网络的不可靠性</li><li>从而影响网络共识的达成，破坏一致性。</li></ul></li><li>不解决的话可能导致——区块链分叉</li></ul></li></ul><p>解决方案：</p><ul><li>工作量证明（proof-of-work, PoW），权益证明(proof-of-stake, PoS)，白名单机制（仅适用于私有网络）等</li><li>实用拜占庭容错算法</li></ul><h3 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h3><p>网络共识机制的实现导致了：</p><ol><li>交易吞吐量</li><li>更高的交易时延。交易确认时间（只有打包的新区块中才交易才会被承认）。</li></ol><p>共识机制的伸缩可以一定程度上解决上述问题</p><h2 id="资产交易"><a href="#资产交易" class="headerlink" title="资产交易"></a>资产交易</h2><p>简单交易状态描述，以集中式数据库为例</p><p>假设初始状态为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-------------------------</span><br><span class="line">| 资产类型 | 所有者 | 数量 |</span><br><span class="line">-------------------------</span><br><span class="line">|   CNY   |  防风  |  10 |</span><br><span class="line">-------------------------</span><br><span class="line">|   CNY   |  红薯  |  0  |</span><br><span class="line">-------------------------</span><br></pre></td></tr></table></figure><p>防风 向 红薯 转账 2 CNY </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-------------------------</span><br><span class="line">| 资产类型 | 所有者 | 数量 |</span><br><span class="line">-------------------------</span><br><span class="line">|   CNY   |  防风  |  8  |</span><br><span class="line">-------------------------</span><br><span class="line">|   CNY   |  红薯  |  2  |</span><br><span class="line">-------------------------</span><br></pre></td></tr></table></figure><p>数据库中相应记录的更改完成了资产的交易过程。</p><p>在区块链中，仍然将分布式链看作是一个达成共识的集中式数据库</p><p>那么现在的初始状态可以表示成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---------------------------------</span><br><span class="line">| 资产类型 |     所有者     | 数量 |</span><br><span class="line">---------------------------------</span><br><span class="line">|   IOTA  |  防风 pub_key  | 10  |</span><br><span class="line">---------------------------------</span><br></pre></td></tr></table></figure><p>现在的所有者由公钥表示，想要修改记录必须提供对应的密钥。</p><p>例如，防风 向 红薯 转账 2 IOTA ，需要提供防风的私钥和红薯的公钥。交易记录修改结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---------------------------------</span><br><span class="line">| 资产类型 |     所有者     | 数量 |</span><br><span class="line">---------------------------------</span><br><span class="line">                                 被删除了         |   IOTA  |  防风 pub_key  | 10  |</span><br><span class="line">---------------------------------</span><br><span class="line">|   IOTA  |  红薯 pub_key  |  2  |</span><br><span class="line">---------------------------------</span><br><span class="line">|   IOTA  |  防风 pub_key  |  8  |</span><br></pre></td></tr></table></figure><p>交易的概念流程：</p><ol><li>定位防风所有的资产记录行</li><li>删除该行前验证密钥</li><li>确认该记录没有被别的交易使用（双花问题，双重交易）</li><li>写入新的正确的记录（红薯获得的资产 &amp; 防风剩余的资产），确保交易前与交易后资产总额不变</li></ol><p>上面的模型 —— 基于比特币的交易模型(UTXO <em>model</em>)</p><p><strong>适合于数字标记资产的传输与追踪</strong></p><ul><li>概念：UTXO (unspent transaction outputs) 未花费的交易输出：数据库现有的记录</li></ul><p>-——————————–</p><p>另一种模型常用于智能合约 —— 基于账号的模型(account-based <em>model</em>)</p><p><strong>提供了建立多步骤执行的基本机制</strong> </p><h3 id="资产如何产生"><a href="#资产如何产生" class="headerlink" title="资产如何产生"></a>资产如何产生</h3><ul><li>比特币：<ul><li>矿工节点允许在挖出的新节点中加入一种 coinbase 类型的交易（不存在交易输入，新资产数额有比特币链提前定义）</li></ul></li><li>在创始新代币的时候全额发行</li><li>其它机制</li></ul><h2 id="区块链特性"><a href="#区块链特性" class="headerlink" title="区块链特性"></a>区块链特性</h2><ol><li>一种健壮的、真正的分布式对等系统，它能容忍节点故障。</li><li>能够识别冲突和分叉并自动解决的网络，以便收敛到单一的、公认的唯一状态。（区块链永远选择最长的分支来达成网络上的共识）</li><li>网络活动的透明性、可验证性、可审计性。我们能获取可验证的过程，无论它们是否交换和跟踪数字资产，还是数据驱动的交互。每一个行为，都存有公开的与网络交互的记录，并以此来消除人为的矛盾。</li><li>这是一种可以标记不同信息的触发者的方法，并且能够在没有中央权威的情况下强制执行。</li><li>这是一个使得不信任双方根据可预测的、确定性的方式交互的系统。</li></ol><h2 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h2><p>自动化地执行一系列合约条款的交易协议</p><p>智能合约是存储在区块链中的脚本（认识上可以与关系型数据库的存储过程类似）。</p><p>以基于账号的模型为例对合约执行进行描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">假设定义一个合约，包括三个方法</span><br><span class="line"></span><br><span class="line">(1) “存储”——合约的“存款”功能允许 防风（通过防风的密钥验证）将若干单位的X存入合约中；</span><br><span class="line">(2) “交易”——“交易”功能允许任何人向合约发送5单位Y，并从合约持有的X中返回1单位给交易方；</span><br><span class="line">(3) “撤销”——“撤销”功能允许 防风 取出合约中存有的所有资产。</span><br><span class="line"></span><br><span class="line">请注意，上述“存款”和“撤销”功能被限制为只允许被 防风（实际上是防风的私钥）调用。当然，这只有由于上述合约由防风制定。若人为的制定一个所有人都能调用任何功能的合约也是允许的（虽然这在事实上没有意义）。</span><br></pre></td></tr></table></figure><p>那么在基于账户的模型下，可以认为 拥有“存储”、“交易”、“撤销”方法的合约持有一个单独的账户（与用户所持有的账户等价）。</p><p>在上述合约下，这个账户将可能持有一定数量的资产。除了只能按照预定的合约步骤对资产进行处置之外，其它与用户持有的账户别无二致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __</span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _</span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tKfTcgy1fs8oc4ri7qj30mq055aap.jpg&quot; alt=&quot;区块链简单结构&quot;&gt;&lt;/p&gt;
&lt;center&gt;&lt;small&gt;图1. 区块链简单结构&lt;/small&gt;&lt;/center&gt;



&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tNc79gy1foxcpmmpfhj31kw107n2e.jpg&quot; alt=&quot;Merkle tree&quot;&gt;&lt;/p&gt;
&lt;center&gt;&lt;small&gt;图2. 单个区块的抽象结构&lt;/small&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="BlockChain" scheme="https://DorMOUSE-None.github.io/tags/BlockChain/"/>
    
      <category term="Smart Contract" scheme="https://DorMOUSE-None.github.io/tags/Smart-Contract/"/>
    
  </entry>
  
  <entry>
    <title>Spring JDBC 源码学习</title>
    <link href="https://DorMOUSE-None.github.io/2018-01-15-Spring-JDBC-Code-Reading/"/>
    <id>https://DorMOUSE-None.github.io/2018-01-15-Spring-JDBC-Code-Reading/</id>
    <published>2018-01-14T16:00:00.000Z</published>
    <updated>2018-06-14T01:24:16.070Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>在学习 Spring-JDBC 之前，我们有必要从 Java 原生提供的 JDBC 开始，对 JDBC 操作的一整套完整的流程有一个清晰的概念。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * copied from https://www.tutorialspoint.com/jdbc/jdbc-sample-code.htm</span></span><br><span class="line"><span class="comment"> * updated by DorMOUSENone</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//STEP 1. 引入必须的包</span></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line"><span class="comment">// JDBC 驱动名 与 DB URL </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String JDBC_DRIVER = <span class="string">"com.mysql.jdbc.Driver"</span>;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DB_URL = <span class="string">"jdbc:mysql://&lt;host&gt;:&lt;port&gt;/&lt;dbName&gt;"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数据库登录验证 (用户名、密码等)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String USER = <span class="string">"username"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String PASS = <span class="string">"password"</span>;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">Statement stmt = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//STEP 2: 注册驱动(注册到驱动管理器 DriverManager 类中)</span></span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//STEP 3: 创建一个连接</span></span><br><span class="line">          System.out.println(<span class="string">"Connecting to database..."</span>);</span><br><span class="line">          conn = DriverManager.getConnection(DB_URL,USER,PASS);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//STEP 4: 执行一个查询</span></span><br><span class="line">          System.out.println(<span class="string">"Creating statement..."</span>);</span><br><span class="line">          stmt = conn.createStatement();</span><br><span class="line">          String sql;</span><br><span class="line">          sql = <span class="string">"SELECT id, first, last, age FROM Employees"</span>;</span><br><span class="line">          ResultSet rs = stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//STEP 5: 将结果从结果集(ResultSet)中取出</span></span><br><span class="line">          <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">             <span class="comment">//根据列名逐一取出数据</span></span><br><span class="line">             <span class="keyword">int</span> id  = rs.getInt(<span class="string">"id"</span>);</span><br><span class="line">             <span class="keyword">int</span> age = rs.getInt(<span class="string">"age"</span>);</span><br><span class="line">             String first = rs.getString(<span class="string">"first"</span>);</span><br><span class="line">             String last = rs.getString(<span class="string">"last"</span>);</span><br><span class="line"></span><br><span class="line">             <span class="comment">//展示结果</span></span><br><span class="line">             System.out.print(<span class="string">"ID: "</span> + id);</span><br><span class="line">             System.out.print(<span class="string">", Age: "</span> + age);</span><br><span class="line">             System.out.print(<span class="string">", First: "</span> + first);</span><br><span class="line">             System.out.println(<span class="string">", Last: "</span> + last);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//STEP 6: 清理环境</span></span><br><span class="line">          rs.close();</span><br><span class="line">          stmt.close();</span><br><span class="line">          conn.close();</span><br><span class="line">       &#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">          <span class="comment">//处理 JDBC 错误</span></span><br><span class="line">          se.printStackTrace();</span><br><span class="line">       &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">          <span class="comment">//处理 Class.forName() 引起的错误</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">       &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">          <span class="comment">// finally 代码库来关闭资源</span></span><br><span class="line">          <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(stmt!=<span class="keyword">null</span>)</span><br><span class="line">                stmt.close();</span><br><span class="line">          &#125;<span class="keyword">catch</span>(SQLException se2)&#123;</span><br><span class="line">          &#125;<span class="comment">// 不做任何处理</span></span><br><span class="line">          <span class="keyword">try</span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(conn!=<span class="keyword">null</span>)</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">               se.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">"Goodbye!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的通用 JDBC 代码可以看到，利用 Java 原生提供的 java.sql.* 包可以完成注册驱动，创建连接，执行查询，处理结果等一系列一整套操作。</p><p>而 Spring-JDBC 对于 Java 原生提供的 JDBC ，对一系列数据及操作进行了整合：</p><ol><li>实现了 DataSource 接口，用于整合数据源配置，将各种零散的属性值（诸如 URL、用户名、 密码等）整合成完整的一个对象，便于重用；也实现了 getConnection(…) 接口，便于直接通过 DataSource 获取连接。</li><li>对执行查询的流程进行了封装。</li><li>对结果集的处理提供了多种接口，针对不同的应用场景可自由选择所必须的实现类。例如直接通过 JDBC 获得 Bean ，而无需如上例 39-42 行所示，逐一编码进行提取。</li></ol><p>本节提供对《Spring-JDBC 源码学习》完整学习过程的一个梳理：</p><ol><li><a href="http://blog.csdn.net/dormousenone/article/details/79035440" target="_blank" rel="noopener">JdbcTemplate</a> 一节作为学习 Spring-jdbc 的切入点，是 org.springframework.jdbc.core 包中的核心类，是一个提供不同场景下数据库操作的模板类。主要描述其持有的属性 DataSource 等以及其实现的方法。</li><li><a href="http://blog.csdn.net/dormousenone/article/details/79037012" target="_blank" rel="noopener">DataSource</a> 一节承接 JdbcTemplate 一节，提供 Spring-jdbc 对数据源的一个包装与应用。同时描述其核心方法 getConnection(…) 的实现。</li><li><a href="http://blog.csdn.net/dormousenone/article/details/79042212" target="_blank" rel="noopener">DriverManager</a> 描述其对不同数据库供应商提供的驱动的管理与使用方法。同时简单描述通过具体驱动获得一个连接的实现。</li><li><a href="http://blog.csdn.net/dormousenone/article/details/79046865" target="_blank" rel="noopener">PreparedStatement &amp; CallableStatement</a> 一节主要表述 Spring-jdbc 如何对执行查询的流程进行了封装。特别是对于 PreparedStatement 与 CallableStatement 这类预置可变 SQL 语句，在执行前必须对其中可变参数进行补全的 Statement 。</li><li><a href="http://blog.csdn.net/dormousenone/article/details/79062275" target="_blank" rel="noopener">ResultSet</a> 描述 Spring-jdbc 如何对结果集进行处理，提供了多种不同的接口实现不同的处理逻辑。这种封装后的操作可以极大地简化直接使用 Java 原生 JDBC 所必须的硬编码提取数据的问题。</li></ol><h2 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h2><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fn90ghu9ufj30ki0jm75t.jpg" alt=""></p><p>JdbcTemplate 类作为 org.springframework.core 包下的核心类，对 Java 实现的 JDBC 进行了一定程度的封装，可以简化 JDBC 的使用，同时避免许多常见的错误。由该类来执行 JDBC 工作流，应用程序只需要提供 SQL 语句就可以获得 DB 执行结果（😀，当然实际操作上没有描述的这么简单）。</p><p><strong>使用 JdbcTemplate 类只需要实现两个回调接口 PreparedStatementCreator (创建一个 PreparedStatement，给定连接，提供 SQL 语句以及必要的参数), ResultSetExtractor (用于花式获取结果集)。当然，不实现上述两个接口也可以进行简单的数据库操作，比如只通过 JdbcTemplate 获取一个连接(Connection) 或者执行一个静态 SQL Update。</strong></p><p><em>看不懂无所谓，先继续向下看，会做更详细的讲解。</em></p><h3 id="JdbcAccessor"><a href="#JdbcAccessor" class="headerlink" title="JdbcAccessor"></a>JdbcAccessor</h3><p>首先了解 JdbcTemplate 的实现，JdbcTemplate 继承了 JdbcAccessor 抽象类，该抽象类有两个主要属性—— <strong>DataSource dataSource</strong> &amp; <strong>SQLExceptionTranslator exceptionTranslator</strong> ，以及一个懒加载标识符 <strong>lazyInit</strong> 。</p><p>其中，</p><ul><li>DataSource 可以认为是一个存储有与数据库相关的属性实例，主要方法包括 <code>Connection getConnection()</code> &amp; <code>Connection getConnection(String username, String password)</code> 。</li><li>SQLExceptionTranslator 利用策略模式将 Java 定义的 SQLException 转换成 Spring 声明的 DataAccessException。</li></ul><p>JdbcAccessor 实现的 InitializingBean 接口，InitializingBean 接口为 Bean 提供了一个初始化实例的方法 —— afterPropertiesSet() 方法，凡是继承该接口的类，一般都在类构造方法中执行该方法。同样的，声明初始化实例调用的方法还可采用 <code>&lt;bean id=&quot;&quot; class=&quot;&quot; init-method=&quot;myInitMethod&quot;/&gt;</code> 在初始化 bean 时执行 myInitMethod() 方法。具体执行顺序为 ：</p><ol><li>bean 的属性注入</li><li>调用 afterPropertiesSet() 方法</li><li>执行 myInitMethod() 方法</li></ol><p>此处继承该接口是为了实现 DataSource 验证以及 SQLExceptionTranslator 的懒加载 OR NOT 的选择。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (getDataSource() == <span class="keyword">null</span>) &#123;<span class="comment">// 判断是否注入了 DataSource</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Property 'dataSource' is required"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!isLazyInit()) &#123;<span class="comment">// 根据懒加载标识符选择执行与否</span></span><br><span class="line">getExceptionTranslator();<span class="comment">// 获取一个 SQLExceptionTranslator 实例</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法在 BeanFactory 完成该 bean 的依赖注入后执行，将首先判断 DataSource 是否已经被注入，再根据懒加载标识符来决定是否实例化一个 SQLExceptionTranslator 。</p><h3 id="JdbcOperations"><a href="#JdbcOperations" class="headerlink" title="JdbcOperations"></a>JdbcOperations</h3><p>同时，JdbcTemplate 类实现了 JdbcOperations 接口，该接口定义了基本的 JDBC 操作。基本方法如下：</p><ol><li><code>&lt;T&gt; T execute(ConnectionCallback&lt;T&gt; action);</code></li><li><code>&lt;T&gt; T execute(StatementCallback&lt;T&gt; action);</code></li><li><code>&lt;T&gt; T execute(PreparedStatementCreator psc, PreparedStatementCallback&lt;T&gt; action);</code></li><li><code>&lt;T&gt; T execute(CallableStatementCreator csc, CallableStatementCallback&lt;T&gt; action);</code></li></ol><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fncp2ncqd6j31j00au0uv.jpg" alt=""></p><p>其它的 execute(…) , query(…), update(…) 等最终都将调用上述 4 种方法其一来完成目的。</p><p>详细观察上述方法的入参， ConnectionCallback, StatementCallback, PreparedStatementCallback 和 CallableStatementCallback 四个 Callback 接口，分别都是函数式接口，其中的唯一方法 doInXXX() 将在 execute() 中被调用，以此实现获得 ResultSet 并返回 Result 。execute 中调用 doInXXX() 的通用代码如下 （以 Statement 为例）：</p><p><em>对于不理解<strong>回调</strong>的同学，请自行了解概念</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(StatementCallback&lt;T&gt; action)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line"><span class="comment">// 通过工具类 DataSourceUtils 获取一个连接</span></span><br><span class="line">  Connection con = DataSourceUtils.getConnection(obtainDataSource());</span><br><span class="line">  <span class="comment">// 一个 Statement 空实例，PreparedStatement, CallableStatement 类似</span></span><br><span class="line">Statement stmt = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">stmt = con.createStatement();<span class="comment">// 通过连接(Connection)获取一个 Statement</span></span><br><span class="line">applyStatementSettings(stmt);<span class="comment">// 配置 Statement 参数</span></span><br><span class="line">      <span class="comment">// 回调执行 doInXXX() 方法, 并获得 result</span></span><br><span class="line">T result = action.doInStatement(stmt);</span><br><span class="line">handleWarnings(stmt);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line"><span class="comment">// Release Connection early, to avoid potential connection pool deadlock</span></span><br><span class="line"><span class="comment">// in the case when the exception translator hasn't been initialized yet.</span></span><br><span class="line">String sql = getSql(action);</span><br><span class="line">JdbcUtils.closeStatement(stmt);</span><br><span class="line">stmt = <span class="keyword">null</span>;</span><br><span class="line">DataSourceUtils.releaseConnection(con, getDataSource());</span><br><span class="line">con = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">throw</span> translateException(<span class="string">"StatementCallback"</span>, sql, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">JdbcUtils.closeStatement(stmt);</span><br><span class="line">DataSourceUtils.releaseConnection(con, getDataSource());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 Statement, PreparedStatement, CallableStatement 的区别，首先下图表现了三个接口的继承关系。</p><ul><li>Statement 可以支持静态 SQL 语句</li><li>PreparedStatement 支持可变参数的 SQL 语句</li><li>CallableStatement 支持可变参数的 SQL 语句，并且支持定制 DB 的输出结果</li></ul><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fncpaec17yj30ew0hcdh7.jpg" alt=""></p><h2 id="DataSource"><a href="#DataSource" class="headerlink" title="DataSource"></a>DataSource</h2><p>上一节在粗略地了解了 JdbcTemplate 提供的方法之后，下面先来对 DataSource 做一点了解。</p><h3 id="Java-提供的-DataSource-定义"><a href="#Java-提供的-DataSource-定义" class="headerlink" title="Java 提供的 DataSource 定义"></a>Java 提供的 DataSource 定义</h3><p>DataSource 是 Java 核心库提供的接口。位于 javax.sql package 下。</p><p>DataSource 接口可以被视作是一个提供物理 DB 实例连接(Connection) 的工厂，通过 DataSource 持有的各种属性（包括 DB Url, Username, Password 等）来获取一个连接(Connection) 。DataSource 接口有三种不同的实现方案：</p><ol><li>最基本的实现——生产一个标准连接(Connection) 对象</li><li>连接池方案——生产会被自动添加到连接池的对象</li><li>分布式事物实现——生产一个可以支持分布式事物，并默认被添加到连接池的连接对象</li></ol><p>包括两个对外提供连接(Connection) 对象的方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="function">Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure><p>其父接口 CommonDataSource 提供设置/获取 LogWriter，登录 DB 超时时间和获取父 Logger 的方法。</p><h3 id="Spring-JDBC-扩展的-DataSource-定义"><a href="#Spring-JDBC-扩展的-DataSource-定义" class="headerlink" title="Spring-JDBC 扩展的 DataSource 定义"></a>Spring-JDBC 扩展的 DataSource 定义</h3><p>在 Spring-jdbc 下，DataSources 最顶级的类是 AbstractDataSource ，对 DataSource 的所有父接口方法做了实现。但保留 getConnection() 方法由子类实现。</p><p>在 AbstractDriverBasedDataSource 中，定义了大量的参数，诸如 url, username 等，这些都被用来定位并定义与数据库实例的连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDriverBasedDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> String catalog;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> String schema;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="comment">// 可以看到此处有一个 Properties 类</span></span><br><span class="line">   <span class="keyword">private</span> Properties connectionProperties;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 省略若干方法</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">      <span class="comment">// 调用内部方法 getConnectionFromDriver()</span></span><br><span class="line"><span class="keyword">return</span> getConnectionFromDriver(getUsername(), getPassword());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">      <span class="comment">// 调用内部方法 getConnectionFromDriver()</span></span><br><span class="line"><span class="keyword">return</span> getConnectionFromDriver(username, password);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 定义了一个获取 Connection 的方法，由 getConnection() 方法调用，</span></span><br><span class="line">   <span class="comment">// 此方法主要是将属性做了一个整合</span></span><br><span class="line">   <span class="comment">// 具体获取 Connection 的逻辑仍然下放到子类实现 见 40 行</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> Connection <span class="title">getConnectionFromDriver</span><span class="params">(@Nullable String username, @Nullable String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">Properties mergedProps = <span class="keyword">new</span> Properties();</span><br><span class="line">Properties connProps = getConnectionProperties();</span><br><span class="line"><span class="keyword">if</span> (connProps != <span class="keyword">null</span>) &#123;</span><br><span class="line">mergedProps.putAll(connProps);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (username != <span class="keyword">null</span>) &#123;</span><br><span class="line">mergedProps.setProperty(<span class="string">"user"</span>, username);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (password != <span class="keyword">null</span>) &#123;</span><br><span class="line">mergedProps.setProperty(<span class="string">"password"</span>, password);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 获取 Connection 逻辑下放</span></span><br><span class="line">Connection con = getConnectionFromDriver(mergedProps);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.catalog != <span class="keyword">null</span>) &#123;</span><br><span class="line">con.setCatalog(<span class="keyword">this</span>.catalog);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.schema != <span class="keyword">null</span>) &#123;</span><br><span class="line">con.setSchema(<span class="keyword">this</span>.schema);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> con;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 该类中获取 Connection 的方法是抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Connection <span class="title">getConnectionFromDriver</span><span class="params">(Properties props)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整合方案为将除 url 外的所有参数整合在同一个 Properties 对象中 (其中，Properties 可以被认为是一个线程安全的 Hash Map) 。最终调用 <code>Connection getConnectionFromDriver(Properties props)</code> 获取连接。</p><p>AbstractDriverBasedDataSource 抽象类的两个子类 DriverManagerDataSource 和 SimpleDriverDataSource 都以不同方式获得了连接(Connection)，但总结而言，获取连接(Connection) 的任务被委托给了 Driver 来实现（其中，Driver 有 Java 定义接口，并由各数据库提供商提供，例如 MySQL 提供了 mysql-connector-java-XXX.jar 来完成针对相应数据库的具体实现）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ----------------------------</span></span><br><span class="line"><span class="comment">// SimpleDriverDataSource 的实现</span></span><br><span class="line"><span class="comment">// ----------------------------</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Connection <span class="title">getConnectionFromDriver</span><span class="params">(Properties props)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">Driver driver = getDriver();</span><br><span class="line">String url = getUrl();</span><br><span class="line">Assert.notNull(driver, <span class="string">"Driver must not be null"</span>);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Creating new JDBC Driver Connection to ["</span> + url + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 哈哈，重点在这... driver 在该类中被预先注入</span></span><br><span class="line"><span class="keyword">return</span> driver.connect(url, props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------</span></span><br><span class="line"><span class="comment">// DriverManagerDataSource 的实现</span></span><br><span class="line"><span class="comment">// -----------------------------</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Connection <span class="title">getConnectionFromDriver</span><span class="params">(Properties props)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">String url = getUrl();</span><br><span class="line">Assert.state(url != <span class="keyword">null</span>, <span class="string">"'url' not set"</span>);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Creating new JDBC DriverManager Connection to ["</span> + url + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 调了个内部函数</span></span><br><span class="line"><span class="keyword">return</span> getConnectionFromDriverManager(url, props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Connection <span class="title">getConnectionFromDriverManager</span><span class="params">(String url, Properties props)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// 委托给 DriverManager 类来获取连接</span></span><br><span class="line">    <span class="comment">// DriverManager 的主要操作是遍历在该管理类中注册的 Driver</span></span><br><span class="line">    <span class="comment">// 每个 Driver 实例都去尝试一下，能不能获得一个连接</span></span><br><span class="line">    <span class="comment">// 第一次在某个 Driver 中拿到一个连接即返回连接 (Connection)</span></span><br><span class="line"><span class="keyword">return</span> DriverManager.getConnection(url, props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简要的类图如下：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fncrgqcjqoj31es15ajxj.jpg" alt=""></p><h2 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h2><p>上面提到 DataSource 获取连接(Connection) 的操作实质上将委托具体的 Driver 来提供 Connection 。有两种不同的方式，包括经由 DriverManager 遍历所有处于管理下的 Driver 尝试获取连接，或者在 DataSource 实例中直接声明一个特定的 Driver 来获取连接。</p><p>对于获取连接的具体操作，挖坑-待填。只描述简单的数据库供应商提供的 Driver 如何与 java 相联系。</p><p>###在 DriverManager 中注册 Driver 实例</p><p>通常在与数据库交互逻辑的 Java 代码中，都会有 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code> (此处以 MySQL 提供的 mysql-connector-java-XXX.jar 为例，下同）的代码块，加载指定的 com.mysql.jdbc.Driver 为 java.lang.Class 类。</p><p><em>当然，在 JDBC 4.0 标准下，可以不必再显示声明 <code>Class.forName(&quot;&quot;)</code> 语句，Driver 也同样会在 DriverManager 初始化时自动注册。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Class 类中对于 forName(String className) 的方法</span></span><br><span class="line"><span class="comment">// 作用为返回一个 java.lang.Class 实例。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;...&#125;</span><br></pre></td></tr></table></figure><p>同时， JVM 在加载类的过程中会执行类中的 static 代码块。下述 row 10 ~ 16 的代码片段将被执行。唯一的逻辑就是 new 一个 com.mysql.jdbc.Driver 实例，并将实例注册(registerDriver) 到 <strong>java.sql.DriverManager</strong> 中。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mysql.jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">extends</span> <span class="title">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">sql</span>.<span class="title">Driver</span> </span>&#123;</span><br><span class="line"><span class="comment">// ~ Static fields/initializers</span></span><br><span class="line"><span class="comment">// ---------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Register ourselves with the DriverManager</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't register driver!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ~ Constructors</span></span><br><span class="line"><span class="comment">// -----------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Construct a new driver and register it with DriverManager</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment"> *             if a database error occurs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="comment">// Required for Class.forName().newInstance()</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面再来看一下 DriverManager 中的 registerDriver() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DriverManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// DriverManager 维护一个线程安全的 Driver 列表</span></span><br><span class="line">  <span class="comment">// 此处的 DriverInfo 里面即包装了 Driver </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = </span><br><span class="line">      <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在 DriverManager 中注册 Driver</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">registerDriver</span><span class="params">(java.sql.Driver driver)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        registerDriver(driver, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">registerDriver</span><span class="params">(java.sql.Driver driver,</span></span></span><br><span class="line"><span class="function"><span class="params">            DriverAction da)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 如果当前 Driver 不在列表中，即添加到列表。 */</span></span><br><span class="line">        <span class="keyword">if</span>(driver != <span class="keyword">null</span>) &#123;</span><br><span class="line">            registeredDrivers.addIfAbsent(<span class="keyword">new</span> DriverInfo(driver, da));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// This is for compatibility with the original DriverManager</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"registerDriver: "</span> + driver);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过-DriverManager-获取连接-Connection"><a href="#通过-DriverManager-获取连接-Connection" class="headerlink" title="通过 DriverManager 获取连接(Connection)"></a>通过 DriverManager 获取连接(Connection)</h3><p>上一节有提到过可以通过 DriverManager 来遍历获取连接，也可以直接声明具体 Driver 并获取连接。下面代码展示的是通过 DriverManager 获取连接的操作。 <del>哈哈哈，反正最后都是由具体驱动实现获取连接。</del></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DriverManager</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取连接的 public 接口 (1)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(String url,</span></span></span><br><span class="line"><span class="function"><span class="params">java.util.Properties info)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取连接的 public 接口 (2)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(String url,</span></span></span><br><span class="line"><span class="function"><span class="params">        String user, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        java.util.Properties info = <span class="keyword">new</span> java.util.Properties();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">            info.put(<span class="string">"user"</span>, user);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (password != <span class="keyword">null</span>) &#123;</span><br><span class="line">            info.put(<span class="string">"password"</span>, password);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 获取连接的 public 接口 (3)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(String url)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        java.util.Properties info = <span class="keyword">new</span> java.util.Properties();</span><br><span class="line">        <span class="keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 获取连接的内部逻辑实现</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        String url, java.util.Properties info, Class&lt;?&gt; caller)</span> </span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * When callerCl is null, we should check the application's</span></span><br><span class="line"><span class="comment">         * (which is invoking this class indirectly)</span></span><br><span class="line"><span class="comment">         * classloader, so that the JDBC driver class outside rt.jar</span></span><br><span class="line"><span class="comment">         * can be loaded from here.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ClassLoader callerCL = caller != <span class="keyword">null</span> ? caller.getClassLoader() : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span>(DriverManager.class) &#123;</span><br><span class="line">            <span class="comment">// synchronize loading of the correct classloader.</span></span><br><span class="line">            <span class="keyword">if</span> (callerCL == <span class="keyword">null</span>) &#123;</span><br><span class="line">                callerCL = Thread.currentThread().getContextClassLoader();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// url 是定位 DBMS 最重要的参数，不能为空</span></span><br><span class="line">        <span class="keyword">if</span>(url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"The url cannot be null"</span>, <span class="string">"08001"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"DriverManager.getConnection(\""</span> + url + <span class="string">"\")"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 遍历所有注册的 Driver ，并都尝试获取连接(Connection)</span></span><br><span class="line">        SQLException reason = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(DriverInfo aDriver : registeredDrivers) &#123;</span><br><span class="line">          <span class="comment">// 判断注册的 Driver 是否由 ClassLoader callerCL 加载，不是则跳过</span></span><br><span class="line">            <span class="keyword">if</span>(isDriverAllowed(aDriver.driver, callerCL)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    println(<span class="string">"    trying "</span> + aDriver.driver.getClass().getName());</span><br><span class="line">                    <span class="comment">// 获取连接，:) 还是由 driver 实例自行提供</span></span><br><span class="line">                  Connection con = aDriver.driver.connect(url, info);</span><br><span class="line">                    <span class="keyword">if</span> (con != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// Success!</span></span><br><span class="line">                        println(<span class="string">"getConnection returning "</span> + </span><br><span class="line">                                aDriver.driver.getClass().getName());</span><br><span class="line">                        <span class="keyword">return</span> (con);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (reason == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        reason = ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                println(<span class="string">"    skipping: "</span> + aDriver.getClass().getName());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果运行到下列代码，则表明获取连接失败，抛出错误</span></span><br><span class="line">        <span class="keyword">if</span> (reason != <span class="keyword">null</span>)    &#123;</span><br><span class="line">            println(<span class="string">"getConnection failed: "</span> + reason);</span><br><span class="line">            <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"getConnection: no suitable driver found for "</span>+ url);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"No suitable driver found for "</span>+ url, <span class="string">"08001"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>简单的提一嘴，Connection 仍然只是一个针对 Java -&gt; DB Server 的上层接口，如果想要更深层次地了解 Connection 与 DB Server 的交互，可以尝试去看一下 com.mysql.jdbc.MysqlIO 类，MySQL 实现的 JDBC4Connection 类也是在使用该类来实现对 DB Server 交互。（哈哈，只看过 MySQL 提供的 Driver 包）。</em></p><h2 id="PreparedStatement-amp-CallableStatement"><a href="#PreparedStatement-amp-CallableStatement" class="headerlink" title="PreparedStatement &amp; CallableStatement"></a>PreparedStatement &amp; CallableStatement</h2><p>在了解了 DataSource 获取连接(Connection) 的实质以及 JdbcTemplate 的通用接口之后，使用 Spring-jdbc 进行数据库相关的操作可以直截了当的利用如下代码进行实现（此处仅展示通过 Java 硬编码的形式进行实现，XML 配置方法类似）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 定义数据源</span></span><br><span class="line">DriverManagerDataSource dataSource = <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">  <span class="comment">// 配置参数</span></span><br><span class="line">dataSource.setUrl(<span class="string">"jdbc:mysql://&lt;host&gt;:&lt;port&gt;/&lt;dbName&gt;?&lt;props&gt;"</span>);</span><br><span class="line">   dataSource.setUsername(<span class="string">"&lt;username&gt;"</span>);</span><br><span class="line">    dataSource.setPassword(<span class="string">"&lt;passwd&gt;"</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 实例化一个 JDBC 工具类</span></span><br><span class="line">  JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">  <span class="comment">// 执行相关 CRUD 操作</span></span><br><span class="line">  jdbcTemplate.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回顾第一节所讲的 JdbcTemplate 的 4 个基础方法：</p><ol><li><code>&lt;T&gt; T execute(ConnectionCallback&lt;T&gt; action);</code></li><li><code>&lt;T&gt; T execute(StatementCallback&lt;T&gt; action);</code></li><li><code>&lt;T&gt; T execute(PreparedStatementCreator psc, PreparedStatementCallback&lt;T&gt; action);</code></li><li><code>&lt;T&gt; T execute(CallableStatementCreator csc, CallableStatementCallback&lt;T&gt; action);</code></li></ol><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fndsm5tl7aj30zg0byq47.jpg" alt=""></p><p>四个基础方法都有一个特定的回调函数将通过预配置的 DataSource 得到的 Connection 或 更进一步的 Statement or PreparedStatement or CallableStatement 作为入参来执行定义的唯一方法。</p><p>以 <code>&lt;T&gt; T execute(StatementCallback&lt;T&gt; action);</code> 为例来了解一下方法的核心逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(StatementCallback&lt;T&gt; action)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line"><span class="comment">// 通过工具类 DataSourceUtils 获取一个连接</span></span><br><span class="line">  Connection con = DataSourceUtils.getConnection(obtainDataSource());</span><br><span class="line">  <span class="comment">// 一个 Statement 空实例，PreparedStatement, CallableStatement 类似</span></span><br><span class="line">Statement stmt = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">stmt = con.createStatement();<span class="comment">// 通过连接(Connection)获取一个 Statement</span></span><br><span class="line">applyStatementSettings(stmt);<span class="comment">// 配置 Statement 参数</span></span><br><span class="line">      <span class="comment">// 回调执行 doInXXX() 方法, 并获得 result</span></span><br><span class="line">T result = action.doInStatement(stmt);</span><br><span class="line">handleWarnings(stmt);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span>() &#123;</span><br><span class="line">      </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，对于 PreparedStatement 和 CallableStatement 而言，获取一个 <em>XXX</em>Statement 的方式就有所不同了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 Statement 实例</span></span><br><span class="line">Statement stmt = con.createStatement();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 PreparedStatement 实例</span></span><br><span class="line"><span class="comment">// psc 是一个 PreparedStatementCreator 接口实现的实例</span></span><br><span class="line">PreparedStatement ps = psc.createPreparedStatement(con);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 CallableStatement 实例</span></span><br><span class="line"><span class="comment">// csc 是一个 CallableStatementCreator 接口实现的实例</span></span><br><span class="line">CallableStatement cs = csc.createCallableStatement(con);</span><br></pre></td></tr></table></figure><p>可以看到 Statement 直接通过 Connection 获取实例，但是 PreparedStatement 和 CallableStatement 就有所不同，其区别就在于 PreparedStatement 和 CallableStatement 两个 Statement 都是可以定制入参的，更甚者， CallableStatement 可以定制 DB 执行结果的出参。当然，核心还是 <code>con.prepareStatement() OR con.prepareCall()</code> 方法，只不过是将获取 XXXStatement 的操作下放给 XXXStatementCreator 实例类实现，给予使用者重复的自主权，同时也是逻辑解耦的一种操作。</p><p>例如：</p><p>SimplePreparedStatementCreator 这个 PreparedStatementCreator 接口的实现类，只是简单的调用了 <code>con.prepareStatement(sql)</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePreparedStatementCreator</span> </span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">PreparedStatementCreator</span>, <span class="title">SqlProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String sql;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">createPreparedStatement</span><span class="params">(Connection con)</span> </span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> con.prepareStatement(<span class="keyword">this</span>.sql);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于 PreparedStatementCreatorImpl ，在 createPreparedStatement(Connection con) 的实现上，又添加了更多的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PreparedStatementCreatorImpl</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">PreparedStatementCreator</span>, <span class="title">PreparedStatementSetter</span>, <span class="title">SqlProvider</span>, <span class="title">ParameterDisposer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String actualSql;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;?&gt; parameters;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">createPreparedStatement</span><span class="params">(Connection con)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">PreparedStatement ps;</span><br><span class="line"><span class="keyword">if</span> (generatedKeysColumnNames != <span class="keyword">null</span> || returnGeneratedKeys) &#123;</span><br><span class="line"><span class="keyword">if</span> (generatedKeysColumnNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// 获取一个 PreparedStatement 实例，下同</span></span><br><span class="line">ps = con.prepareStatement(<span class="keyword">this</span>.actualSql, </span><br><span class="line">                                          generatedKeysColumnNames);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ps = con.prepareStatement(<span class="keyword">this</span>.actualSql, </span><br><span class="line">                                         PreparedStatement.RETURN_GENERATED_KEYS);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (resultSetType == ResultSet.TYPE_FORWARD_ONLY </span><br><span class="line">                 &amp;&amp; !updatableResults) &#123;</span><br><span class="line">ps = con.prepareStatement(<span class="keyword">this</span>.actualSql);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ps = con.prepareStatement(<span class="keyword">this</span>.actualSql, resultSetType,</span><br><span class="line">updatableResults ? ResultSet.CONCUR_UPDATABLE : </span><br><span class="line">                                      ResultSet.CONCUR_READ_ONLY);</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">// 将可变 SQL (例如 SELECT * FROM msg WHERE id = ?) 的 ? 用实际参数替换</span></span><br><span class="line">setValues(ps);</span><br><span class="line"><span class="keyword">return</span> ps;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述两种 PreparedStatementCreator 接口的不同实现，也可以从另一种角度理解到，函数式接口将获取目标出参的具体逻辑交给使用者定义，给予了使用者充分的自主权，同时也是一种业务逻辑的解耦。</p><p>在上面代码 PreparedStatementCreatorImpl 类的实现中，我们看到第 32 行代码 <code>setValue(ps)</code> 。此处的方法是由接口 PreparedStatementSetter 定义的。主要目的是将可变 SQL 中的 ? 参数用实际参数进行一个替换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以 SQL (SELECT * FROM msg WHERE id = ? AND day = ?) 为例</span></span><br><span class="line"><span class="comment">/** 纯 Java 核心库的实现 PreparedStatement 参数注入 */</span></span><br><span class="line">ps.setInt(<span class="number">1</span>, <span class="number">1763</span>);</span><br><span class="line">ps.setString(<span class="number">2</span>, <span class="string">"2018-01-01"</span>);</span><br><span class="line">ps.executeQuery();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 以 Spring-jdbc 实现 PreparedStatement 参数注入 */</span></span><br><span class="line"><span class="comment">// setValues() 由接口 PreparedStatementSetter 定义，封装了注入参数的具体实现逻辑</span></span><br><span class="line"><span class="comment">// 可以由使用者自行定义</span></span><br><span class="line">setValues(ps);</span><br><span class="line">ps.executeQuery();</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fndyybh4q1j31kw0u3afx.jpg" alt=""></p><p>上面类图表示了 PreparedStatementSetter 及其实现类的相关依赖。</p><p>Setter 的主要目标即为对 SQL 中的 ? 参数进行注入。</p><p><del>个人精力有限，对Spring-jdbc在Statement上对参数注入的回调理解有限。</del></p><h2 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h2><p>在前几节已经提到讲了数据源、驱动管理器以及 Statement 之后，利用 JDBC 的最重要的目的就是对 DB 进行操作，并获得预期结果。对于查询语句而言，结果应该是若干记录行；就更新语句而言，结果可能是影响的行数。而 Spring-jdbc 对 ResultSet 额外进行的封装，即是将原本散乱的结果进行一个整合，例如整合成一个(一组)完整的 Bean 来进行展示。</p><p>在 JdbcTemplate 中，四个基本方法入参都包括一个回调接口，而在执行回调获得 ResultSet 之后，方法并不是直接返回，而是进行了一定的操作。</p><p>以一个 PreparedStatementCallback 的实例类为例，在 doInPreparedStatement() 方法中，获得了 ResultSet ，但是仍通过 rse.extractData(rs) 语句进行了处理后再返回结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">doInPreparedStatement</span><span class="params">(PreparedStatement ps)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">// 声明一个 ResultSet </span></span><br><span class="line">ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (pss != <span class="keyword">null</span>) &#123;<span class="comment">// setValues() 方法填充 PreparedStatement 中的可变参数 ? </span></span><br><span class="line">pss.setValues(ps);</span><br><span class="line">&#125;</span><br><span class="line">rs = ps.executeQuery();<span class="comment">// 执行查询 sql ，获取结果</span></span><br><span class="line"><span class="keyword">return</span> rse.extractData(rs);<span class="comment">// 重点... 该语句一定是对结果进行了一些操作.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">JdbcUtils.closeResultSet(rs);</span><br><span class="line"><span class="keyword">if</span> (pss <span class="keyword">instanceof</span> ParameterDisposer) &#123;</span><br><span class="line">((ParameterDisposer) pss).cleanupParameters();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在来看一下究竟在返回结果前进行了什么操作。</p><p>由于是一个回调接口的实现类，rse 应该在外部方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">query</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">PreparedStatementCreator psc, @Nullable <span class="keyword">final</span> PreparedStatementSetter pss, </span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">final</span> ResultSetExtractor&lt;T&gt; rse)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> execute(psc, <span class="keyword">new</span> PreparedStatementCallback&lt;T&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">doInPreparedStatement</span><span class="params">(PreparedStatement ps)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">...</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 rse 是一个 ResultSetExtractor<t> 的实例。从名称上可以看出 Extractor 即为提取器，结果集提取器。</t></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 函数式接口，提供的唯一方法为 extractData(...) */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResultSetExtractor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">T <span class="title">extractData</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException, DataAccessException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fndzz0pqnrj31a60i676v.jpg" alt=""></p><p>Spring-jdbc 中现有的实现有三个类，其中 RowCallbackHandlerResultSetExtractor 和 RowMapperResultSetExtractor 两个类从上面类图及命名即可看出，两个是作为一个适配器而存在的，将 extractData() 进行转换，分别由 RowCallbackHandler 和 RowMapper 实例进行具体操作。而 AbstractLobStreamingResultSetExtractor 类从名称上看，也是一个类似流操作的实现类(其中的 Lob 指的是 DB 中的 BLOB 与 CLOB 类型，在 Spring-jdbc 中也加入了额外的支持) 。</p><h3 id="RowCallbackHandler"><a href="#RowCallbackHandler" class="headerlink" title="RowCallbackHandler"></a>RowCallbackHandler</h3><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fnh2uw3a0aj30h20jeta4.jpg" alt=""></p><p>从名称上看，这是一个与 ResultSet 结果集行相关的回调接口。processRow(ResultSet rs) 方法将处理行相关的逻辑。</p><p>从它的一个实现类 RowCountCallbackHandler 来说，其最主要的私有属性 rowCount 即是统计 ResultSet 的结果行数。下面是一个具体使用的该类的案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">    DriverManagerDataSource dataSource = <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">    dataSource.setUrl(<span class="string">"jdbc:mysql://&lt;host&gt;:&lt;port&gt;/&lt;dbName&gt;"</span>);</span><br><span class="line">    dataSource.setUsername(<span class="string">"&lt;username&gt;"</span>);</span><br><span class="line">    dataSource.setPassword(<span class="string">"&lt;password&gt;"</span>);</span><br><span class="line"></span><br><span class="line">    JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    RowCountCallbackHandler rcch = <span class="keyword">new</span> RowCountCallbackHandler();</span><br><span class="line"></span><br><span class="line">    jdbcTemplate.query(<span class="string">"SELECT * FROM info WHERE id='2018'"</span>, (RowCallbackHandler) rcch);</span><br><span class="line"></span><br><span class="line">  System.out.println(rcch.getRowCount());<span class="comment">//获取结果集行数</span></span><br><span class="line">    System.out.println(rcch.getColumnCount());<span class="comment">// 获取结果集列数</span></span><br><span class="line">    <span class="keyword">for</span> (String arg : rcch.getColumnNames()) &#123;<span class="comment">// 打印结果集每一列名称</span></span><br><span class="line">        System.out.println(<span class="string">"ColumnNames : "</span> + arg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : rcch.getColumnTypes()) &#123;<span class="comment">// 打印结果集每一列类型(Types 为枚举类)</span></span><br><span class="line">        System.out.println(<span class="string">"ColumnTypes : "</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体查看 RowCountCallbackHandler 类的 processRow() 方法可以看到，其获取列相关信息都来自于 ResultSetMetaData 。而结果行数来源于 Iterator 迭代。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processRow</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.rowCount == <span class="number">0</span>) &#123;</span><br><span class="line">ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line"><span class="keyword">this</span>.columnCount = rsmd.getColumnCount();</span><br><span class="line"><span class="keyword">this</span>.columnTypes = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.columnCount];</span><br><span class="line"><span class="keyword">this</span>.columnNames = <span class="keyword">new</span> String[<span class="keyword">this</span>.columnCount];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.columnCount; i++) &#123;</span><br><span class="line"><span class="keyword">this</span>.columnTypes[i] = rsmd.getColumnType(i + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">this</span>.columnNames[i] = JdbcUtils.lookupColumnName(rsmd, i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// could also get column names</span></span><br><span class="line">&#125;</span><br><span class="line">processRow(rs, <span class="keyword">this</span>.rowCount++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RowMapper"><a href="#RowMapper" class="headerlink" title="RowMapper"></a>RowMapper</h3><p>上面 RowCallbackHandler 接口从逻辑上划分是用于处理 ResultSet 元数据信息的。而 RowMapper 较上一个接口而言，有更高的实用性。</p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fnh3h739kaj30z60nago4.jpg" alt=""></p><p>特别是其实现类 BeanPropertyRowMapper<t> 可以将散乱的 ResultSet 的结果数据整理成一个个 Object Bean 作为返回结果。而省去了对逐一读取 ResultSet 行记录并填充 Bean 属性的麻烦。</t></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line"></span><br><span class="line">BeanPropertyRowMapper&lt;Model&gt; rowMapper = <span class="keyword">new</span> BeanPropertyRowMapper&lt;&gt;(Model.class);</span><br><span class="line">List&lt;Model&gt; list = jdbcTemplate.query(<span class="string">"SELECT * FROM info WHERE id = '2018'"</span>, rowMapper);</span><br><span class="line"><span class="comment">/** 获得的 Model list 的对应属性将通过 Java 的反射机制进行填充</span></span><br><span class="line"><span class="comment"> *List&lt;Model&gt; list 即结果</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>当然，要求是 Model 类中的属性与 DB table 中的列名保持一致（大小写无要求）。</p><p>而其它两个类的实现也是基于反射机制，实现其相应的业务逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;在学习 Spring-JDBC 之前，我们有必要从 Java 原生提供的 JDBC 开始，对 JDBC 操作的一整套完整的流程有一个清晰的概念。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="https://DorMOUSE-None.github.io/tags/Spring/"/>
    
      <category term="JDBC" scheme="https://DorMOUSE-None.github.io/tags/JDBC/"/>
    
  </entry>
  
</feed>
