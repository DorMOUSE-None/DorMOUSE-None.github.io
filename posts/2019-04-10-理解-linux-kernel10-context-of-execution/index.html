<!DOCTYPE html>
<html lang="zh-cmn-Hans-CN" prefix="og: http://ogp.me/ns#">
  <head>
    <meta charset="utf-8" />
    
    <head>
  <meta charset="utf-8" />
  <meta name="generator" content="Hugo 0.68.3" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="ffutop" />
  <meta property="og:url" content="https://www.ffutop.com/posts/2019-04-10-%E7%90%86%E8%A7%A3-linux-kernel10-context-of-execution/" />
  <link rel="canonical" href="https://www.ffutop.com/posts/2019-04-10-%E7%90%86%E8%A7%A3-linux-kernel10-context-of-execution/" /><link rel="apple-touch-icon" href="favicon.ico" />
  <link rel="icon" href="favicon.ico" />
  <link rel="shortcut" href="favicon.ico" /><link rel="alternate" type="application/atom+xml" href="https://www.ffutop.com/index.xml" title="Utop&#39;s Blog">

  <script type="application/ld+json">
  {
      "@context" : "http://schema.org",
      "@type" : "BlogPosting",
      "mainEntityOfPage": {
           "@type": "WebPage",
           "@id": "https:\/\/www.ffutop.com\/"
      },
      "articleSection" : "posts",
      "name" : "理解 Linux Kernel(10) - Context of Execution",
      "headline" : "理解 Linux Kernel(10) - Context of Execution",
      "description" : "\x3cp\x3e在进行\x3ca href=\x22https:\/\/www.ffutop.com\/2018-10-12-understand-Kernel-4\/\x22\x3e第四篇(任务调度)\x3c\/a\x3e行文描述时，就一直闹不清内核所谓的\x3ccode\x3etask\x3c\/code\x3e的概念。之前一直将其与进程(process)的概念等同视之。但这又导致了线程的概念无处安置（毕竟在计算机科学的概念中，线程作为进程的子集存在，负责程序执行）。不过，现在这个疑惑总算得到了合理的解释：\x3cstrong\x3e我们错误地将理论和实践不加区分地混淆了\x3c\/strong\x3e。内核开发社区与学术界的合作在整个内核开发历史上并没有想象中的频繁，正相反，学术界对内核代码的贡献不到1%[1]。如果想要将进程\/线程的思想代入内核，并逐一印证，那么过程将非常痛苦并最终一无所获。所谓进程\/线程，在内核中只有一个概念——执行的上下文(Context of Execution)，任何想要对进程\/线程概念进行区分的行为都将是作茧自缚[2]。同时，\x3ccode\x3etask\x3c\/code\x3e 也就是 \x3ccode\x3eContext of Execution\x3c\/code\x3e 概念在实现上的表征。\x3c\/p\x3e",
      "inLanguage" : "zh-cmn-Hans-CN",
      "author" : "ffutop",
      "creator" : "ffutop",
      "publisher": "ffutop",
      "accountablePerson" : "ffutop",
      "copyrightHolder" : "ffutop",
      "copyrightYear" : "2019",
      "datePublished": "2019-04-10 00:00:00 \x2b0000 UTC",
      "dateModified" : "2019-04-10 00:00:00 \x2b0000 UTC",
      "url" : "https:\/\/www.ffutop.com\/posts\/2019-04-10-%E7%90%86%E8%A7%A3-linux-kernel10-context-of-execution\/",
      "keywords" : [ "Linux","Kernel","COE", ]
  }
</script>
<title>理解 Linux Kernel(10) - Context of Execution - Utop&#39;s Blog</title>
  <meta property="og:title" content="理解 Linux Kernel(10) - Context of Execution - Utop&#39;s Blog" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="在进行第四篇(任务调度)行文描述时，就一直闹不清内核所谓的task的概念。之前一直将其与进程(process)的概念等同视之。但这又导致了线程的概念无处安置（毕竟在计算机科学的概念中，线程作为进程的子集存在，负责程序执行）。不过，现在这个疑惑总算得到了合理的解释：我们错误地将理论和实践不加区分地混淆了。内核开发社区与学术界的合作在整个内核开发历史上并没有想象中的频繁，正相反，学术界对内核代码的贡献不到1%[1]。如果想要将进程/线程的思想代入内核，并逐一印证，那么过程将非常痛苦并最终一无所获。所谓进程/线程，在内核中只有一个概念——执行的上下文(Context of Execution)，任何想要对进程/线程概念进行区分的行为都将是作茧自缚[2]。同时，task 也就是 Context of Execution 概念在实现上的表征。" />
  <meta name="description" content="在进行第四篇(任务调度)行文描述时，就一直闹不清内核所谓的task的概念。之前一直将其与进程(process)的概念等同视之。但这又导致了线程的概念无处安置（毕竟在计算机科学的概念中，线程作为进程的子集存在，负责程序执行）。不过，现在这个疑惑总算得到了合理的解释：我们错误地将理论和实践不加区分地混淆了。内核开发社区与学术界的合作在整个内核开发历史上并没有想象中的频繁，正相反，学术界对内核代码的贡献不到1%[1]。如果想要将进程/线程的思想代入内核，并逐一印证，那么过程将非常痛苦并最终一无所获。所谓进程/线程，在内核中只有一个概念——执行的上下文(Context of Execution)，任何想要对进程/线程概念进行区分的行为都将是作茧自缚[2]。同时，task 也就是 Context of Execution 概念在实现上的表征。" />
  <meta property="og:locale" content="zh-cmn-Hans-CN" />

  <link rel="stylesheet" href="/css/flexboxgrid-6.3.1.min.css" />
  <link rel="stylesheet" href="/css/github-markdown.css" />
  <link rel="stylesheet" href="/css/highlight/tomorrow.min.css" />
  <link rel="stylesheet" href="/css/index.css">
  <link href="/index.xml" rel="alternate" type="application/rss+xml"
    title="Utop&#39;s Blog">
  
  <link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker|Bree+Serif" rel="stylesheet">
  
  

  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-92258941-1"></script>
</head>

     
  </head>
  <body>
    
  <article class="post Chinese" id="article">
    <div class="row">
      <div class="col-xs-12">
        <div class="site-header">
          
<header>
  <div class="signatures site-title">
    <a href="/">FFUTOP</a>
  </div>
</header>
<div class="row end-xs">
  
  
</div>
<div class="header-line"></div>

        </div>
        <header class="post-header">
          <h1 class="post-title">理解 Linux Kernel(10) - Context of Execution</h1>
          
          <div class="row post-desc">
            <div class="col-xs-6">
              
              <time class="post-date" datetime="2019-04-10 00:00:00 UTC">
                10 Apr 2019
              </time>
              
            </div>
            <div class="col-xs-6">
              
              <div class="post-author">
                <a target="_blank" href="https://www.ffutop.com/">@ffutop</a>
              </div>
              
            </div>
          </div>
          
        </header>

        <div class="post-content markdown-body">
          
          <p>在进行<a href="https://www.ffutop.com/2018-10-12-understand-Kernel-4/">第四篇(任务调度)</a>行文描述时，就一直闹不清内核所谓的<code>task</code>的概念。之前一直将其与进程(process)的概念等同视之。但这又导致了线程的概念无处安置（毕竟在计算机科学的概念中，线程作为进程的子集存在，负责程序执行）。不过，现在这个疑惑总算得到了合理的解释：<strong>我们错误地将理论和实践不加区分地混淆了</strong>。内核开发社区与学术界的合作在整个内核开发历史上并没有想象中的频繁，正相反，学术界对内核代码的贡献不到1%[1]。如果想要将进程/线程的思想代入内核，并逐一印证，那么过程将非常痛苦并最终一无所获。所谓进程/线程，在内核中只有一个概念——执行的上下文(Context of Execution)，任何想要对进程/线程概念进行区分的行为都将是作茧自缚[2]。同时，<code>task</code> 也就是 <code>Context of Execution</code> 概念在实现上的表征。</p>
<p>执行的上下文(Context of Execution, COE)，记录了所有程序执行中的状态，包括：CPU状态（寄存器信息等）、MMU状态（页映射）、权限状态（uid、gid等）和一些公共属性（打开的文件、信号处理函数等）。对比理论上的进程/线程概念，粗略地讲就是同一线程组的线程各自持有CPU状态而共享其它状态，而认为两进程不共享任何状态。当然，在内核的概念里，进程/线程只是COE共享部分状态中的一个特例。</p>
<h2 id="fork-clone">fork, clone</h2>
<p>如果用进程/线程的概念来看，内核提供了 <code>fork</code> 来完成进程的复制，提供了 <code>clone</code> 来处理线程的拷贝，另外还有 <code>vfork</code> , <code>kernel_thread</code> 等。</p>
<p><strong>syscall fork</strong></p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">asmlinkage <span style="color:#902000">int</span> <span style="color:#06287e">sys_fork</span>(<span style="color:#007020;font-weight:bold">struct</span> pt_regs regs)
{
    <span style="color:#007020;font-weight:bold">return</span> do_fork(SIGCHLD, regs.esp, <span style="color:#666">&amp;</span>regs, <span style="color:#40a070">0</span>, <span style="color:#007020">NULL</span>, <span style="color:#007020">NULL</span>);
}
</code></pre></div><p><strong>syscall clone</strong></p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">asmlinkage <span style="color:#902000">int</span> <span style="color:#06287e">sys_clone</span>(<span style="color:#007020;font-weight:bold">struct</span> pt_regs regs)
{
    <span style="color:#902000">unsigned</span> <span style="color:#902000">long</span> clone_flags;
    <span style="color:#902000">unsigned</span> <span style="color:#902000">long</span> newsp;
    <span style="color:#902000">int</span> __user <span style="color:#666">*</span>parent_tidptr, <span style="color:#666">*</span>child_tidptr;
    
    clone_flags <span style="color:#666">=</span> regs.ebx;
    newsp <span style="color:#666">=</span> regs.ecx;
    parent_tidptr <span style="color:#666">=</span> (<span style="color:#902000">int</span> __user <span style="color:#666">*</span>)regs.edx;
    child_tidptr <span style="color:#666">=</span> (<span style="color:#902000">int</span> __user <span style="color:#666">*</span>)regs.edi;
    <span style="color:#007020;font-weight:bold">if</span> (<span style="color:#666">!</span>newsp)
        newsp <span style="color:#666">=</span> regs.esp;
    <span style="color:#007020;font-weight:bold">return</span> do_fork(clone_flags, newsp, <span style="color:#666">&amp;</span>regs, <span style="color:#40a070">0</span>, parent_tidptr, child_tidptr);
}
</code></pre></div><p><strong>syscall vfork</strong></p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">asmlinkage <span style="color:#902000">int</span> <span style="color:#06287e">sys_vfork</span>(<span style="color:#007020;font-weight:bold">struct</span> pt_regs regs)
{
    <span style="color:#007020;font-weight:bold">return</span> do_fork(CLONE_VFORK <span style="color:#666">|</span> CLONE_VM <span style="color:#666">|</span> SIGCHLD, regs.esp, <span style="color:#666">&amp;</span>regs, <span style="color:#40a070">0</span>, <span style="color:#007020">NULL</span>, <span style="color:#007020">NULL</span>);
}
</code></pre></div><p><strong>kernel function: kernel_thread</strong></p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#902000">int</span> <span style="color:#06287e">kernel_thread</span>(<span style="color:#902000">int</span> (<span style="color:#666">*</span>fn)(<span style="color:#902000">void</span> <span style="color:#666">*</span>), <span style="color:#902000">void</span> <span style="color:#666">*</span> arg, <span style="color:#902000">unsigned</span> <span style="color:#902000">long</span> flags)
{
    <span style="color:#60a0b0;font-style:italic">// ...
</span><span style="color:#60a0b0;font-style:italic"></span>    <span style="color:#007020;font-weight:bold">return</span> do_fork(flags <span style="color:#666">|</span> CLONE_VM <span style="color:#666">|</span> CLONE_UNTRACED, <span style="color:#40a070">0</span>, <span style="color:#666">&amp;</span>regs, <span style="color:#40a070">0</span>, <span style="color:#007020">NULL</span>, <span style="color:#007020">NULL</span>);
}
</code></pre></div><p><code>fork</code>, <code>clone</code>, <code>vfork</code> 的入参怎么和日常使用的系统调用入参不同？且看：</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">	.macro PTREGSCALL label, func, arg
	.globl <span style="">\</span>label
<span style="">\</span><span style="color:#002070;font-weight:bold">label</span>:
	leaq <span style="">\</span>func(<span style="color:#666">%</span>rip),<span style="color:#666">%</span>rax
	leaq <span style="color:#666">-</span>ARGOFFSET<span style="color:#666">+</span><span style="color:#40a070">8</span>(<span style="color:#666">%</span>rsp),<span style="">\</span>arg	<span style="color:#60a0b0;font-style:italic">/* 8 for return address */</span>
	jmp  ia32_ptregs_common
	.endm

	CFI_STARTPROC32

	PTREGSCALL stub32_rt_sigreturn, sys32_rt_sigreturn, <span style="color:#666">%</span>rdi
	PTREGSCALL stub32_sigreturn, sys32_sigreturn, <span style="color:#666">%</span>rdi
	PTREGSCALL stub32_sigaltstack, sys32_sigaltstack, <span style="color:#666">%</span>rdx
	PTREGSCALL stub32_sigsuspend, sys32_sigsuspend, <span style="color:#666">%</span>rcx
	PTREGSCALL stub32_execve, sys32_execve, <span style="color:#666">%</span>rcx
	PTREGSCALL stub32_fork, sys_fork, <span style="color:#666">%</span>rdi
	PTREGSCALL stub32_clone, sys32_clone, <span style="color:#666">%</span>rdx
	PTREGSCALL stub32_vfork, sys_vfork, <span style="color:#666">%</span>rdi
	PTREGSCALL stub32_iopl, sys_iopl, <span style="color:#666">%</span>rsi
	PTREGSCALL stub32_rt_sigsuspend, sys_rt_sigsuspend, <span style="color:#666">%</span>rdx

ENTRY(ia32_ptregs_common)
	popq <span style="color:#666">%</span>r11
	CFI_ENDPROC
	CFI_STARTPROC32	simple
	CFI_SIGNAL_FRAME
	CFI_DEF_CFA	rsp,SS<span style="color:#666">+</span><span style="color:#40a070">8</span><span style="color:#666">-</span>ARGOFFSET
	CFI_REL_OFFSET	rax,RAX<span style="color:#666">-</span>ARGOFFSET
	CFI_REL_OFFSET	rcx,RCX<span style="color:#666">-</span>ARGOFFSET
	CFI_REL_OFFSET	rdx,RDX<span style="color:#666">-</span>ARGOFFSET
	CFI_REL_OFFSET	rsi,RSI<span style="color:#666">-</span>ARGOFFSET
	CFI_REL_OFFSET	rdi,RDI<span style="color:#666">-</span>ARGOFFSET
	CFI_REL_OFFSET	rip,RIP<span style="color:#666">-</span>ARGOFFSET
<span style="color:#60a0b0;font-style:italic">/*	CFI_REL_OFFSET	cs,CS-ARGOFFSET*/</span>
<span style="color:#60a0b0;font-style:italic">/*	CFI_REL_OFFSET	rflags,EFLAGS-ARGOFFSET*/</span>
	CFI_REL_OFFSET	rsp,RSP<span style="color:#666">-</span>ARGOFFSET
<span style="color:#60a0b0;font-style:italic">/*	CFI_REL_OFFSET	ss,SS-ARGOFFSET*/</span>
	SAVE_REST
	call <span style="color:#666">*%</span>rax
	RESTORE_REST
	jmp  ia32_sysret	<span style="color:#60a0b0;font-style:italic">/* misbalances the return cache */</span>
	CFI_ENDPROC
END(ia32_ptregs_common)
</code></pre></div><p>进行系统调用时的处理逻辑统一地将这些内容进行了整合，并将CPU状态（所有通用寄存器状态）维护到 <code>struct pt_regs</code> 数据块中。总结起来，三种系统调用最终都委托给 <code>do_fork</code> 进行实现，只是在参数的选择方面做了不同的预处理。这在用户层的函数原型上就更为明显，<code>fork</code> 和 <code>vfork</code> 都不允许参数的调用。</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">pid_t <span style="color:#06287e">fork</span>(<span style="color:#902000">void</span>);

<span style="color:#60a0b0;font-style:italic">/* for x86-32 */</span>
<span style="color:#902000">long</span> <span style="color:#06287e">clone</span>(<span style="color:#902000">unsigned</span> <span style="color:#902000">long</span> flags, <span style="color:#902000">void</span> <span style="color:#666">*</span>child_stack,
        <span style="color:#902000">int</span> <span style="color:#666">*</span>ptid, <span style="color:#902000">unsigned</span> <span style="color:#902000">long</span> newtls,
        <span style="color:#902000">int</span> <span style="color:#666">*</span>ctid);

pid_t <span style="color:#06287e">vfork</span>(<span style="color:#902000">void</span>);
</code></pre></div><p>再看看 <code>flags</code> 有哪些值可选。</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#60a0b0;font-style:italic">/*
</span><span style="color:#60a0b0;font-style:italic"> * cloning flags:
</span><span style="color:#60a0b0;font-style:italic"> */</span>
<span style="color:#007020">#define CSIGNAL		0x000000ff	</span><span style="color:#60a0b0;font-style:italic">/* signal mask to be sent at exit */</span><span style="color:#007020">
</span><span style="color:#007020">#define CLONE_VM	0x00000100	</span><span style="color:#60a0b0;font-style:italic">/* set if VM shared between processes */</span><span style="color:#007020">
</span><span style="color:#007020">#define CLONE_FS	0x00000200	</span><span style="color:#60a0b0;font-style:italic">/* set if fs info shared between processes */</span><span style="color:#007020">
</span><span style="color:#007020">#define CLONE_FILES	0x00000400	</span><span style="color:#60a0b0;font-style:italic">/* set if open files shared between processes */</span><span style="color:#007020">
</span><span style="color:#007020">#define CLONE_SIGHAND	0x00000800	</span><span style="color:#60a0b0;font-style:italic">/* set if signal handlers and blocked signals shared */</span><span style="color:#007020">
</span><span style="color:#007020">#define CLONE_PTRACE	0x00002000	</span><span style="color:#60a0b0;font-style:italic">/* set if we want to let tracing continue on the child too */</span><span style="color:#007020">
</span><span style="color:#007020">#define CLONE_VFORK	0x00004000	</span><span style="color:#60a0b0;font-style:italic">/* set if the parent wants the child to wake it up on mm_release */</span><span style="color:#007020">
</span><span style="color:#007020">#define CLONE_PARENT	0x00008000	</span><span style="color:#60a0b0;font-style:italic">/* set if we want to have the same parent as the cloner */</span><span style="color:#007020">
</span><span style="color:#007020">#define CLONE_THREAD	0x00010000	</span><span style="color:#60a0b0;font-style:italic">/* Same thread group? */</span><span style="color:#007020">
</span><span style="color:#007020">#define CLONE_NEWNS	0x00020000	</span><span style="color:#60a0b0;font-style:italic">/* New namespace group? */</span><span style="color:#007020">
</span><span style="color:#007020">#define CLONE_SYSVSEM	0x00040000	</span><span style="color:#60a0b0;font-style:italic">/* share system V SEM_UNDO semantics */</span><span style="color:#007020">
</span><span style="color:#007020">#define CLONE_SETTLS	0x00080000	</span><span style="color:#60a0b0;font-style:italic">/* create a new TLS for the child */</span><span style="color:#007020">
</span><span style="color:#007020">#define CLONE_PARENT_SETTID	0x00100000	</span><span style="color:#60a0b0;font-style:italic">/* set the TID in the parent */</span><span style="color:#007020">
</span><span style="color:#007020">#define CLONE_CHILD_CLEARTID	0x00200000	</span><span style="color:#60a0b0;font-style:italic">/* clear the TID in the child */</span><span style="color:#007020">
</span><span style="color:#007020">#define CLONE_DETACHED		0x00400000	</span><span style="color:#60a0b0;font-style:italic">/* Unused, ignored */</span><span style="color:#007020">
</span><span style="color:#007020">#define CLONE_UNTRACED		0x00800000	</span><span style="color:#60a0b0;font-style:italic">/* set if the tracing process can&#39;t force CLONE_PTRACE on this clone */</span><span style="color:#007020">
</span><span style="color:#007020">#define CLONE_CHILD_SETTID	0x01000000	</span><span style="color:#60a0b0;font-style:italic">/* set the TID in the child */</span><span style="color:#007020">
</span><span style="color:#007020">#define CLONE_STOPPED		0x02000000	</span><span style="color:#60a0b0;font-style:italic">/* Start in stopped state */</span><span style="color:#007020">
</span><span style="color:#007020">#define CLONE_NEWUTS		0x04000000	</span><span style="color:#60a0b0;font-style:italic">/* New utsname group? */</span><span style="color:#007020">
</span><span style="color:#007020">#define CLONE_NEWIPC		0x08000000	</span><span style="color:#60a0b0;font-style:italic">/* New ipcs */</span><span style="color:#007020">
</span><span style="color:#007020">#define CLONE_NEWUSER		0x10000000	</span><span style="color:#60a0b0;font-style:italic">/* New user namespace */</span><span style="color:#007020">
</span><span style="color:#007020">#define CLONE_NEWPID		0x20000000	</span><span style="color:#60a0b0;font-style:italic">/* New pid namespace */</span><span style="color:#007020">
</span><span style="color:#007020">#define CLONE_NEWNET		0x40000000	</span><span style="color:#60a0b0;font-style:italic">/* New network namespace */</span><span style="color:#007020">
</span></code></pre></div><p><code>xxx shared between processes</code> ，描述即将被创建的新任务将进行哪些状态/资源的共享，而哪些状态需要进行拷贝。</p>
<h3 id="do_fork"><code>do_fork</code></h3>
<p>先看看核心的 <code>do_fork</code> 的逻辑。</p>
<p><em>Hint: 下列代码经过大量的删减</em></p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#902000">long</span> <span style="color:#06287e">do_fork</span>(<span style="color:#902000">unsigned</span> <span style="color:#902000">long</span> clone_flags,
        <span style="color:#902000">unsigned</span> <span style="color:#902000">long</span> stack_start,
        <span style="color:#007020;font-weight:bold">struct</span> pt_regs <span style="color:#666">*</span>regs,
        <span style="color:#902000">unsigned</span> <span style="color:#902000">long</span> stack_size,
        <span style="color:#902000">int</span> __user <span style="color:#666">*</span>parent_tidptr,
        <span style="color:#902000">int</span> __user <span style="color:#666">*</span>child_tidptr)
{
    p <span style="color:#666">=</span> copy_process(clone_flags, stack_start, regs, stack_size, child_tidptr, <span style="color:#007020">NULL</span>);
    <span style="color:#007020;font-weight:bold">if</span> (<span style="color:#666">!</span>IS_ERR(p)) {
        nr <span style="color:#666">=</span> (clone_flags <span style="color:#666">&amp;</span> CLONE_NEWPID) <span style="color:#666">?</span>
            task_pid_nr_ns(p, current<span style="color:#666">-&gt;</span>nsproxy<span style="color:#666">-&gt;</span>pid_ns) <span style="color:#666">:</span>
                task_pid_vnr(p);
        <span style="color:#007020;font-weight:bold">if</span> (<span style="color:#666">!</span>(clone_flags <span style="color:#666">&amp;</span> CLONE_STOPPED))
            wake_up_new_task(p, clone_flags);
        <span style="color:#007020;font-weight:bold">else</span>
            p<span style="color:#666">-&gt;</span>state <span style="color:#666">=</span> TASK_STOPPED;
    } <span style="color:#007020;font-weight:bold">else</span> {
        nr <span style="color:#666">=</span> PTR_ERR(p);
    }
    <span style="color:#007020;font-weight:bold">return</span> nr;
}
</code></pre></div><div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#007020;font-weight:bold">static</span> <span style="color:#007020;font-weight:bold">struct</span> task_struct <span style="color:#666">*</span><span style="color:#06287e">copy_process</span>(<span style="color:#902000">unsigned</span> <span style="color:#902000">long</span> clone_flags,
                    <span style="color:#902000">unsigned</span> <span style="color:#902000">long</span> stack_start,
                    <span style="color:#007020;font-weight:bold">struct</span> pt_regs <span style="color:#666">*</span>regs,
                    <span style="color:#902000">unsigned</span> <span style="color:#902000">long</span> stack_size,
                    <span style="color:#902000">int</span> __user <span style="color:#666">*</span>child_tidptr,
                    <span style="color:#007020;font-weight:bold">struct</span> pid <span style="color:#666">*</span>pid)
{
    <span style="color:#60a0b0;font-style:italic">/* 预分配 task_struct 数据结构空间 */</span>
    retval <span style="color:#666">=</span> security_task_create(clone_flags);
    <span style="color:#60a0b0;font-style:italic">/* 复制 current 的 task_struct 数据结构 */</span>
    p <span style="color:#666">=</span> dup_task_struct(current);

    <span style="color:#007020;font-weight:bold">if</span> (nr_threads <span style="color:#666">&gt;=</span> max_threads)
    	<span style="color:#007020;font-weight:bold">goto</span> bad_fork_cleanup_count;

    <span style="color:#60a0b0;font-style:italic">/* 针对多核CPU，为新任务分配CPU */</span>
    sched_fork(p, clone_flags);
    <span style="color:#60a0b0;font-style:italic">/* 复制 thread_info 数据结构及线程栈 */</span>
    retval <span style="color:#666">=</span> copy_thread(<span style="color:#40a070">0</span>, clone_flags, stack_start, stack_size, p, regs);

    <span style="color:#60a0b0;font-style:italic">/* 分配新的 pid */</span>
    p<span style="color:#666">-&gt;</span>pid <span style="color:#666">=</span> pid_nr(pid);
    <span style="color:#60a0b0;font-style:italic">/* thread group id = new pid */</span>
    p<span style="color:#666">-&gt;</span>tgid <span style="color:#666">=</span> p<span style="color:#666">-&gt;</span>pid;
    <span style="color:#60a0b0;font-style:italic">/* 如果标志是 CLONE_THREAD，tgid = 父任务id */</span>
    <span style="color:#007020;font-weight:bold">if</span> (clone_flags <span style="color:#666">&amp;</span> CLONE_THREAD)
    	p<span style="color:#666">-&gt;</span>tgid <span style="color:#666">=</span> current<span style="color:#666">-&gt;</span>tgid;

    p<span style="color:#666">-&gt;</span>set_child_tid <span style="color:#666">=</span> (clone_flags <span style="color:#666">&amp;</span> CLONE_CHILD_SETTID) <span style="color:#666">?</span> <span style="color:#002070;font-weight:bold">child_tidptr</span> : <span style="color:#007020">NULL</span>;
    p<span style="color:#666">-&gt;</span>clear_child_tid <span style="color:#666">=</span> (clone_flags <span style="color:#666">&amp;</span> CLONE_CHILD_CLEARTID) <span style="color:#666">?</span> <span style="color:#002070;font-weight:bold">child_tidptr</span>: <span style="color:#007020">NULL</span>;
    <span style="color:#60a0b0;font-style:italic">/*
</span><span style="color:#60a0b0;font-style:italic">     * sigaltstack should be cleared when sharing the same VM
</span><span style="color:#60a0b0;font-style:italic">     */</span>
    <span style="color:#007020;font-weight:bold">if</span> ((clone_flags <span style="color:#666">&amp;</span> (CLONE_VM<span style="color:#666">|</span>CLONE_VFORK)) <span style="color:#666">==</span> CLONE_VM)
    	p<span style="color:#666">-&gt;</span>sas_ss_sp <span style="color:#666">=</span> p<span style="color:#666">-&gt;</span>sas_ss_size <span style="color:#666">=</span> <span style="color:#40a070">0</span>;

    <span style="color:#60a0b0;font-style:italic">/* ok, now we should be set up.. */</span>
    p<span style="color:#666">-&gt;</span>exit_signal <span style="color:#666">=</span> (clone_flags <span style="color:#666">&amp;</span> CLONE_THREAD) <span style="color:#666">?</span> <span style="color:#666">-</span><span style="color:#40a070">1</span> <span style="color:#666">:</span> (clone_flags <span style="color:#666">&amp;</span> CSIGNAL);
    p<span style="color:#666">-&gt;</span>pdeath_signal <span style="color:#666">=</span> <span style="color:#40a070">0</span>;
    p<span style="color:#666">-&gt;</span>exit_state <span style="color:#666">=</span> <span style="color:#40a070">0</span>;

    <span style="color:#60a0b0;font-style:italic">/*
</span><span style="color:#60a0b0;font-style:italic">     * Ok, make it visible to the rest of the system.
</span><span style="color:#60a0b0;font-style:italic">     * We dont wake it up yet.
</span><span style="color:#60a0b0;font-style:italic">     */</span>
    p<span style="color:#666">-&gt;</span>group_leader <span style="color:#666">=</span> p;
    INIT_LIST_HEAD(<span style="color:#666">&amp;</span>p<span style="color:#666">-&gt;</span>thread_group);
    INIT_LIST_HEAD(<span style="color:#666">&amp;</span>p<span style="color:#666">-&gt;</span>ptrace_children);
    INIT_LIST_HEAD(<span style="color:#666">&amp;</span>p<span style="color:#666">-&gt;</span>ptrace_list);

    p<span style="color:#666">-&gt;</span>cpus_allowed <span style="color:#666">=</span> current<span style="color:#666">-&gt;</span>cpus_allowed;
    <span style="color:#007020;font-weight:bold">if</span> (unlikely(<span style="color:#666">!</span>cpu_isset(task_cpu(p), p<span style="color:#666">-&gt;</span>cpus_allowed) <span style="color:#666">||</span>
    		<span style="color:#666">!</span>cpu_online(task_cpu(p))))
    	set_task_cpu(p, smp_processor_id());

    <span style="color:#60a0b0;font-style:italic">/* CLONE_PARENT re-uses the old parent */</span>
    <span style="color:#007020;font-weight:bold">if</span> (clone_flags <span style="color:#666">&amp;</span> (CLONE_PARENT<span style="color:#666">|</span>CLONE_THREAD))
    	p<span style="color:#666">-&gt;</span>real_parent <span style="color:#666">=</span> current<span style="color:#666">-&gt;</span>real_parent;
    <span style="color:#007020;font-weight:bold">else</span>
    	p<span style="color:#666">-&gt;</span>real_parent <span style="color:#666">=</span> current;
    p<span style="color:#666">-&gt;</span>parent <span style="color:#666">=</span> p<span style="color:#666">-&gt;</span>real_parent;

    spin_lock(<span style="color:#666">&amp;</span>current<span style="color:#666">-&gt;</span>sighand<span style="color:#666">-&gt;</span>siglock);

    <span style="color:#007020;font-weight:bold">if</span> (clone_flags <span style="color:#666">&amp;</span> CLONE_THREAD) {
    	p<span style="color:#666">-&gt;</span>group_leader <span style="color:#666">=</span> current<span style="color:#666">-&gt;</span>group_leader;
    	list_add_tail_rcu(<span style="color:#666">&amp;</span>p<span style="color:#666">-&gt;</span>thread_group, <span style="color:#666">&amp;</span>p<span style="color:#666">-&gt;</span>group_leader<span style="color:#666">-&gt;</span>thread_group);

    	<span style="color:#007020;font-weight:bold">if</span> (<span style="color:#666">!</span>cputime_eq(current<span style="color:#666">-&gt;</span>signal<span style="color:#666">-&gt;</span>it_virt_expires,
    			cputime_zero) <span style="color:#666">||</span>
    	    <span style="color:#666">!</span>cputime_eq(current<span style="color:#666">-&gt;</span>signal<span style="color:#666">-&gt;</span>it_prof_expires,
    			cputime_zero) <span style="color:#666">||</span>
    	    current<span style="color:#666">-&gt;</span>signal<span style="color:#666">-&gt;</span>rlim[RLIMIT_CPU].rlim_cur <span style="color:#666">!=</span> RLIM_INFINITY <span style="color:#666">||</span>
    	    <span style="color:#666">!</span>list_empty(<span style="color:#666">&amp;</span>current<span style="color:#666">-&gt;</span>signal<span style="color:#666">-&gt;</span>cpu_timers[<span style="color:#40a070">0</span>]) <span style="color:#666">||</span>
    	    <span style="color:#666">!</span>list_empty(<span style="color:#666">&amp;</span>current<span style="color:#666">-&gt;</span>signal<span style="color:#666">-&gt;</span>cpu_timers[<span style="color:#40a070">1</span>]) <span style="color:#666">||</span>
    	    <span style="color:#666">!</span>list_empty(<span style="color:#666">&amp;</span>current<span style="color:#666">-&gt;</span>signal<span style="color:#666">-&gt;</span>cpu_timers[<span style="color:#40a070">2</span>])) {
    		<span style="color:#60a0b0;font-style:italic">/*
</span><span style="color:#60a0b0;font-style:italic">    		 * Have child wake up on its first tick to check
</span><span style="color:#60a0b0;font-style:italic">    		 * for process CPU timers.
</span><span style="color:#60a0b0;font-style:italic">    		 */</span>
    		p<span style="color:#666">-&gt;</span>it_prof_expires <span style="color:#666">=</span> jiffies_to_cputime(<span style="color:#40a070">1</span>);
    	}
    }

    <span style="color:#007020;font-weight:bold">if</span> (likely(p<span style="color:#666">-&gt;</span>pid)) {
    	add_parent(p);
    	<span style="color:#007020;font-weight:bold">if</span> (unlikely(p<span style="color:#666">-&gt;</span>ptrace <span style="color:#666">&amp;</span> PT_PTRACED))
    		__ptrace_link(p, current<span style="color:#666">-&gt;</span>parent);

    	<span style="color:#007020;font-weight:bold">if</span> (thread_group_leader(p)) {
    		<span style="color:#007020;font-weight:bold">if</span> (clone_flags <span style="color:#666">&amp;</span> CLONE_NEWPID)
    			p<span style="color:#666">-&gt;</span>nsproxy<span style="color:#666">-&gt;</span>pid_ns<span style="color:#666">-&gt;</span>child_reaper <span style="color:#666">=</span> p;

    		p<span style="color:#666">-&gt;</span>signal<span style="color:#666">-&gt;</span>tty <span style="color:#666">=</span> current<span style="color:#666">-&gt;</span>signal<span style="color:#666">-&gt;</span>tty;
    		set_task_pgrp(p, task_pgrp_nr(current));
    		set_task_session(p, task_session_nr(current));
    		attach_pid(p, PIDTYPE_PGID, task_pgrp(current));
    		attach_pid(p, PIDTYPE_SID, task_session(current));
    		list_add_tail_rcu(<span style="color:#666">&amp;</span>p<span style="color:#666">-&gt;</span>tasks, <span style="color:#666">&amp;</span>init_task.tasks);
    		__get_cpu_var(process_counts)<span style="color:#666">++</span>;
    	}
    	attach_pid(p, PIDTYPE_PID, pid);
    	nr_threads<span style="color:#666">++</span>;
    }

    total_forks<span style="color:#666">++</span>;
    spin_unlock(<span style="color:#666">&amp;</span>current<span style="color:#666">-&gt;</span>sighand<span style="color:#666">-&gt;</span>siglock);
    write_unlock_irq(<span style="color:#666">&amp;</span>tasklist_lock);
    proc_fork_connector(p);
    cgroup_post_fork(p);
    <span style="color:#007020;font-weight:bold">return</span> p;
}
</code></pre></div><p>根据入参配置的 <code>flags</code> ，<code>copy_process</code> 确定了新任务与父任务共享的状态，以及一些需要拷贝的状态。</p>
<ul>
<li><code>fork</code> 产生一个新的任务，与父任务不存在任何资源共享的情况。</li>
<li><code>clone</code> 可高度定制化的系统调用，几乎可以自由组合定制新的任务</li>
<li><code>vfork</code> 历史原因而存在的系统调用，设计目的在于一般 <code>fork</code> 之后都将调用 <code>execve</code> 来执行全新的任务，也就导致了 <code>fork</code> 所做的拷贝全部白费，因此搞了个轻量级的 <code>vfork</code> 来避免做内存的拷贝。</li>
</ul>
<blockquote>
<p><strong>VFORK</strong>
Historic description
Under Linux, fork(2) is implemented using copy-on-write pages, so the only penalty incurred by fork(2) is the time and memory required to duplicate the  parent&rsquo;s page tables, and to create a unique task structure for the child.  However, in the bad old days a fork(2) would require making a complete copy of the caller&rsquo;s data space, often needlessly, since usually immediately afterward an exec(3) is done.  Thus, for greater efficiency, BSD introduced  the  vfork() system call, which did not fully copy the address space of the parent process, but borrowed the parent&rsquo;s memory and thread of control until a call to execve(2) or an exit occurred.  The parent process was suspended while the child was using its resources.   The  use  of vfork() was tricky: for example, not modifying data in the parent process depended on knowing which variables were held in a register.</p>
</blockquote>
<h2 id="pid-tgid">pid, tgid</h2>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#60a0b0;font-style:italic">/* 分配新的 pid */</span>
p<span style="color:#666">-&gt;</span>pid <span style="color:#666">=</span> pid_nr(pid);
<span style="color:#60a0b0;font-style:italic">/* thread group id = new pid */</span>
p<span style="color:#666">-&gt;</span>tgid <span style="color:#666">=</span> p<span style="color:#666">-&gt;</span>pid;
<span style="color:#60a0b0;font-style:italic">/* 如果标志是 CLONE_THREAD，tgid = 父任务id */</span>
<span style="color:#007020;font-weight:bold">if</span> (clone_flags <span style="color:#666">&amp;</span> CLONE_THREAD)
	p<span style="color:#666">-&gt;</span>tgid <span style="color:#666">=</span> current<span style="color:#666">-&gt;</span>tgid;
</code></pre></div><p><code>pid</code> 作为每个 <code>task</code> 的唯一标识符存在。<code>tgid</code> 用于指代线程组id，从代码上看也就是进程主线程id。（请原谅我又用了进程/线程的表述）</p>
<p>看着没有问题？当然不可能。这段代码可是意味着 <code>pid</code> 唯一啊，这可不符合日常表述啊。对于系统的终端用户来讲，一个进程可以有一个或多个线程。<code>pid</code> 可是一直被翻译成进程ID(process id)。难道？</p>
<p>这就是本质实现与表面功夫的差别啦。<code>pid_t getpid(void);</code>, <code>pid_t gettid(void);</code> 两个系统调用分别被用来提供进程ID和线程ID（请仔细思考下代码实现和对外展示的差距）。</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#60a0b0;font-style:italic">/**
</span><span style="color:#60a0b0;font-style:italic"> * sys_getpid - return the thread group id of the current process
</span><span style="color:#60a0b0;font-style:italic"> *
</span><span style="color:#60a0b0;font-style:italic"> * Note, despite the name, this returns the tgid not the pid.  The tgid and
</span><span style="color:#60a0b0;font-style:italic"> * the pid are identical unless CLONE_THREAD was specified on clone() in
</span><span style="color:#60a0b0;font-style:italic"> * which case the tgid is the same in all threads of the same group.
</span><span style="color:#60a0b0;font-style:italic"> *
</span><span style="color:#60a0b0;font-style:italic"> * This is SMP safe as current-&gt;tgid does not change.
</span><span style="color:#60a0b0;font-style:italic"> */</span>
asmlinkage <span style="color:#902000">long</span> <span style="color:#06287e">sys_getpid</span>(<span style="color:#902000">void</span>)
{
	<span style="color:#007020;font-weight:bold">return</span> task_tgid_vnr(current);
}
</code></pre></div><div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#60a0b0;font-style:italic">/* Thread ID - the internal kernel &#34;pid&#34; */</span>
asmlinkage <span style="color:#902000">long</span> <span style="color:#06287e">sys_gettid</span>(<span style="color:#902000">void</span>)
{
	<span style="color:#007020;font-weight:bold">return</span> task_pid_vnr(current);
}
</code></pre></div><p>这样就好懂多了吧。用户态通过系统调用取到的 <code>pid</code>, <code>tid</code> 已经经过了一层加工，分别映射着内核实现的 <code>tgid</code>, <code>pid</code> 。</p>
<p><em>额外地：想通过 <code>ps</code> 查看进程/线程可以使用 <code>ps -eLf</code></em></p>
<h2 id="schedule">schedule</h2>
<p>再来回顾下任务调度是如何实现的。与<a href="https://www.ffutop.com/2018-10-12-understand-Kernel-4/">第四篇 任务调度</a>描述的并无太大不同。要说最大的区分，就是早期版本与时下版本顺时的演进。当然，还有就是多核CPU下的SMP调度。</p>
<p>至于多核下的所谓进程/线程如何调度。内核根本认识不到进程/线程的概念，唯一的只有任务(task, or COE)。而每个用户所认为的线程在内核的认识下也是一个任务。因此，所谓用户认识到的多线程并发执行在多核CPU下也就完全是可行的。</p>
<h2 id="concept-of-thread">concept of Thread</h2>
<p>且不论Linux内核没有线程概念的前提，线程的定义总是存在的，而满足其定义的实现，也就可以被称为“线程”。哪些要素组成了线程呢？</p>
<ol>
<li>线程是与其它代码共享进程地址空间的最小执行流</li>
<li>诸如栈、寄存器信息、本地线程数据需要保持独立</li>
<li>互斥锁(Mutex)、条件变量(Condition Variable)、线程间同步管理的支持</li>
<li>&hellip;</li>
</ol>
<p>既然都说了Linux内核没有线程概念，现在却又开始提，这不是打脸嘛？OK，具体情况是：内核本身不支持线程，甚至没有线程概念。但其通过GLIBC的NPTL(Native POSIX Thread Library)支持了线程。</p>
<blockquote>
<p>在Linux内核2.6出现之前任务是(最小)可调度的对象，当时的Linux不真正支持线程。但是Linux内核有一个系统调用指令<code>clone()</code>，这个指令将产生一个调用方任务的拷贝，而且这个拷贝可以与原任务使用同一地址空间。LinuxThreads计划使用这个系统调用来提供一个内核级别的线程支持。但是这个解决方法与真正的POSIX标准有一些不兼容的地方，尤其是在信号处理、进程调度和进程间同步原语方面。
<em>Copied From <a href="https://en.wikipedia.org/wiki/Native_POSIX_Thread_Library">Wikipedia NPTL</a></em></p>
</blockquote>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g1x9mjuahnj31400u0doi.jpg" alt="Linux 架构"></p>
<h2 id="thread-model">Thread Model</h2>
<p>最后，聊聊线程模型。相信各位不管懂或不懂，至少都听说过 1:1, N:1, M:N 线程模型。至于究竟这些模型是怎么回事呢？且看：</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g1xhulou5bj30go08zglv.jpg" alt="Thread Model"></p>
<h3 id="11-model">1:1 Model</h3>
<p>最简单的线程模型，也是内核通过NPTL最容易实现的一种模型。每个通过 <code>clone</code> 产生的新任务（当然，至少要符合共享内存等线程定义）对应用程序来说就是一个新线程。所谓的用户级线程和内核级线程，在 1:1 模型中就是同一个任务，只是新任务在被内核 <code>clone</code> 之后，又由NPTL做了进一步的管理，因此在形式上看似有用户级/内核级之分。</p>
<h3 id="n1-model">N:1 Model</h3>
<p>N:1 线程模型又称为“用户级线程模型”。在这种模型下，线程的概念由用户态代码进行支持，包括用来管理线程的用户空间调度器以及以非阻塞模式捕捉和处理I/O机制。使用N:1模型的好处在于其上下文切换的代价几乎为零，毕竟这是纯用户态的。当然，缺点也比较明显：由于对内核来说，认为这只是单个任务，也就无法充分利用多核CPU的特性。</p>
<h3 id="mn-model">M:N Model</h3>
<p>有没有方式整合1:1模型和N:1模型，让内核意识到有几个任务，但又存在更多的线程在用户级执行呢？当然也是可行，但如何协调调度又是费事费力的实现了。</p>
<h2 id="threads-vs-events">Threads vs Events</h2>
<p>线程怎么又和事件扯上关系了呢？先来回顾下任务调度的几种模式：</p>
<ol>
<li>串行，每个任务依次执行，不存在任务调度</li>
<li>抢占式，通过时钟中断决定是否切换任务</li>
<li>协作式，只有当任务主动放弃对CPU的占用，才能轮到下一个任务。</li>
</ol>
<p>对于用户级线程来说，内核无法意识到这些线程的存在，硬件发起的所有中断又都被内核捕获。因此，想要实现抢占式是不可能完成的任务（至少以本人目前所知是不可能的）。故协作式线程调度是用户级线程的唯一选择。而协作式就意味着是由线程硬编码主动放弃任务执行（<code>yield</code> / <code>schedule</code> / etc.）。如此这般，与事件驱动下，不同代码片之间的调度又是何其相似。当然，只是开个玩笑，如果都一样了，直接用事件驱动不就OK了。线程之所以是线程，有其独特的定义在。不过不再细说，可以参考 <a href="https://courses.cs.vt.edu/cs5204/fall09-kafura/Presentations/Threads-VS-Events.pdf">Threads vs Events</a></p>
<h2 id="参考">参考</h2>
<p>[1]. Mauerer W. Professional Linux kernel architecture[M]. John Wiley &amp; Sons, 2010.
[2]. <a href="https://lkml.iu.edu/hypermail/linux/kernel/9608/0191.html">Linus Torvalds. Re: proc fs and shared pids</a>[EL/OL]. Aug 6th, 1996.
[3]. <a href="https://randu.org/tutorials/threads/">Multithreaded Programming (POSIX pthreads Tutorial)</a>[EL/OL].
[4]. <a href="https://blog.csdn.net/u012432778/article/details/47378321">线程模型</a>[EL/OL].
[5]. <a href="https://www.evanjones.ca/software/threading.html">Implementing a Thread Library on Linux</a>[EL/OL]. Dec 10th, 2003.</p>
<h2 id="用户级线程资料参考">用户级线程资料参考</h2>
<p>[1]. <code>man makecontext</code> &amp; <code>man swapcontext</code>
[2]. <a href="https://github.com/brianwatling/libfiber">Libfiber</a>
[3]. <a href="https://github.com/dramesh/GTThreads"><strong>所谓的</strong>抢占式用户线程实现</a></p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-plain" data-lang="plain">  __                    __                  
 / _| __ _ _ __   __ _ / _| ___ _ __   __ _ 
| |_ / _` | &#39;_ \ / _` | |_ / _ \ &#39;_ \ / _` |
|  _| (_| | | | | (_| |  _|  __/ | | | (_| |
|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |
                 |___/                |___/ 
</code></pre></div>
        </div>

        <div class="row middle-xs">
          <div class="col-xs-12">
            
            <div class="post-category">
              <a href="/categories/%e6%8a%80%e6%9c%af/">
                技术
              </a>
            </div>
            
          </div>
        </div>
        <div class="row">
          <div class="col-xs-12">
            
          </div>
        </div>

        
        

<div class="releated-content">
  <h3>Related Posts</h3>
  <ul>
    
    <li><a href="/posts/2019-03-25-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E8%BF%9B%E7%A8%8B%E5%A0%86%E6%A0%88/">如何获取运行时进程堆栈</a></li>
    
    <li><a href="/posts/2019-03-05-%E7%90%86%E8%A7%A3-linux-kernel-9-io-multiplexing/">理解 Linux Kernel (9) - IO Multiplexing</a></li>
    
    <li><a href="/posts/2019-01-15-%E7%90%86%E8%A7%A3-linux-kernel-8-%E7%BD%91%E7%BB%9C/">理解 Linux Kernel (8) - 网络</a></li>
    
  </ul>
</div>

        
        
        <div style="height: 50px;"></div>
        
        <div class="post-comments">
          <div id="disqus_thread"></div>
<script>
  window.addEventListener("load", () => {
    (function() {
      
      var d = document,
        s = d.createElement("script");
      s.src = "https://ffutop.disqus.com/embed.js";
      s.setAttribute("data-timestamp", +new Date());
      (d.head || d.body).appendChild(s);
    })();
  });
</script>
<noscript
  >Please enable JavaScript to view the
  <a href="https://disqus.com/?ref_noscript"
    >comments powered by Disqus.</a
  ></noscript
>

        </div>
        
        

        <div class="site-footer">
  
  <div class="site-footer-item">
    <a href="/posts/" target="_blank">Posts</a>
  </div>
  
  <div class="site-footer-item">
    <a href="/index.xml" target="_blank">RSS</a>
  </div>
  
  <div class="site-footer-item">
    <a href="https://github.com/ffutop" target="_blank">Github</a>
  </div>
  
  <div class="site-footer-item">
    <a href="/about/" target="_blank">About</a>
  </div>
  
  
</div>

      </div>
    </div>
  </article>

  <script src="/js/highlight.pack.js"></script>


<script>
  hljs.initHighlightingOnLoad();
  
  
  
    
    
  
</script>

  

 
  </body>
</html>
