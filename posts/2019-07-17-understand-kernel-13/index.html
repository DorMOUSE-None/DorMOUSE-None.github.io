<!DOCTYPE html>
<html lang="zh-cmn-Hans-CN" prefix="og: http://ogp.me/ns#">
  <head>
    <meta charset="utf-8" />
    
    <head>
  <meta charset="utf-8" />
  <meta name="generator" content="Hugo 0.68.3" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="ffutop" />
  <meta property="og:url" content="https://www.ffutop.com/posts/2019-07-17-understand-kernel-13/" />
  <link rel="canonical" href="https://www.ffutop.com/posts/2019-07-17-understand-kernel-13/" /><link rel="apple-touch-icon" href="favicon.ico" />
  <link rel="icon" href="favicon.ico" />
  <link rel="shortcut" href="favicon.ico" /><link rel="alternate" type="application/atom+xml" href="https://www.ffutop.com/index.xml" title="Utop&#39;s Blog">

  <script type="application/ld+json">
  {
      "@context" : "http://schema.org",
      "@type" : "BlogPosting",
      "mainEntityOfPage": {
           "@type": "WebPage",
           "@id": "https://www.ffutop.com/"
      },
      "articleSection" : "posts",
      "name" : "理解 Linux Kernel (13) - 虚拟内存",
      "headline" : "理解 Linux Kernel (13) - 虚拟内存",
      "description" : "\u003cp\u003e几乎每个进程都有独立的虚拟地址空间，这是一个逻辑上的概念，用于建立进程对进程存储资源的认知。对于 32 位机，虚拟地址空间的大小通常是 4GB；对于 64 位机，最大可以达到 $2^{64}$ Bytes 。\u003c/p\u003e\n\u003cp\u003e本篇便是为了看看虚拟地址空间究竟如何被内核管理，又是怎样和物理内存、文件等资源关联。\u003c/p\u003e",
      "inLanguage" : "zh-cmn-Hans-CN",
      "author" : "ffutop",
      "creator" : "ffutop",
      "publisher": "ffutop",
      "accountablePerson" : "ffutop",
      "copyrightHolder" : "ffutop",
      "copyrightYear" : "2019",
      "datePublished": "2019-07-17T00:00:00Z",
      "dateModified" : "2019-07-17T00:00:00Z",
      "url" : "https://www.ffutop.com/posts/2019-07-17-understand-kernel-13/",
      "keywords" : [ "Linux","Kernel","vm","mmap", ]
  }
</script>
<title>理解 Linux Kernel (13) - 虚拟内存 - Utop&#39;s Blog</title>
  <meta property="og:title" content="理解 Linux Kernel (13) - 虚拟内存 - Utop&#39;s Blog" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="几乎每个进程都有独立的虚拟地址空间，这是一个逻辑上的概念，用于建立进程对进程存储资源的认知。对于 32 位机，虚拟地址空间的大小通常是 4GB；对于 64 位机，最大可以达到 $2^{64}$ Bytes 。
本篇便是为了看看虚拟地址空间究竟如何被内核管理，又是怎样和物理内存、文件等资源关联。" />
  <meta name="description" content="几乎每个进程都有独立的虚拟地址空间，这是一个逻辑上的概念，用于建立进程对进程存储资源的认知。对于 32 位机，虚拟地址空间的大小通常是 4GB；对于 64 位机，最大可以达到 $2^{64}$ Bytes 。
本篇便是为了看看虚拟地址空间究竟如何被内核管理，又是怎样和物理内存、文件等资源关联。" />
  <meta property="og:locale" content="zh-cmn-Hans-CN" />

  <link rel="stylesheet" href="/css/flexboxgrid-6.3.1.min.css" />
  <link rel="stylesheet" href="/css/github-markdown.css" />
  <link rel="stylesheet" href="/css/highlight/tomorrow.min.css" />
  <link rel="stylesheet" href="/css/index.css">
  <link href="/index.xml" rel="alternate" type="application/rss+xml"
    title="Utop&#39;s Blog">
  
  <link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker|Bree+Serif" rel="stylesheet">
  
  
  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-92258941-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


  
</head>

     
  </head>
  <body>
    
  <article class="post Chinese" id="article">
    <div class="row">
      <div class="col-xs-12">
        <div class="site-header">
          
<header>
  <div class="signatures site-title">
    <a href="/">FFUTOP</a>
  </div>
</header>
<div class="row end-xs">
  
  
</div>
<div class="header-line"></div>

        </div>
        <header class="post-header">
          <h1 class="post-title">理解 Linux Kernel (13) - 虚拟内存</h1>
          
          <div class="row post-desc">
            <div class="col-xs-6">
              
              <time class="post-date" datetime="2019-07-17 00:00:00 UTC">
                17 Jul 2019
              </time>
              
            </div>
            <div class="col-xs-6">
              
              <div class="post-author">
                <a target="_blank" href="https://www.ffutop.com/">@ffutop</a>
              </div>
              
            </div>
          </div>
          
        </header>

        <div class="post-content markdown-body">
          
          <p>几乎每个进程都有独立的虚拟地址空间，这是一个逻辑上的概念，用于建立进程对进程存储资源的认知。对于 32 位机，虚拟地址空间的大小通常是 4GB；对于 64 位机，最大可以达到 $2^{64}$ Bytes 。</p>
<p>本篇便是为了看看虚拟地址空间究竟如何被内核管理，又是怎样和物理内存、文件等资源关联。</p>
<h2 id="启动新进程">启动新进程</h2>
<p>虚拟地址空间与进程挂钩，在进程数据结构 <code>task_struct</code> 中由一个重要的参数 <code>mm_struct</code> 来维护。</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#007020;font-weight:bold">struct</span> mm_struct {
    <span style="color:#007020;font-weight:bold">struct</span> vm_area_struct <span style="color:#666">*</span> mmap;        <span style="color:#60a0b0;font-style:italic">/* list of VMAs */</span>
    <span style="color:#007020;font-weight:bold">struct</span> rb_root mm_rb;
    <span style="color:#902000">unsigned</span> <span style="color:#902000">long</span> mmap_base;        <span style="color:#60a0b0;font-style:italic">/* base of mmap area */</span>
    <span style="color:#902000">unsigned</span> <span style="color:#902000">long</span> task_size;        <span style="color:#60a0b0;font-style:italic">/* size of task vm space */</span>
    pgd_t <span style="color:#666">*</span> pgd;
    atomic_t mm_count;            <span style="color:#60a0b0;font-style:italic">/* How many references to &#34;struct mm_struct&#34; (users count as 1) */</span>
    <span style="color:#902000">int</span> map_count;                <span style="color:#60a0b0;font-style:italic">/* number of VMAs */</span>

    <span style="color:#902000">unsigned</span> <span style="color:#902000">long</span> start_code, end_code, start_data, end_data;
    <span style="color:#902000">unsigned</span> <span style="color:#902000">long</span> start_brk, brk, start_stack;
    <span style="color:#902000">unsigned</span> <span style="color:#902000">long</span> arg_start, arg_end, env_start, env_end;

    <span style="color:#007020;font-weight:bold">struct</span> file <span style="color:#666">*</span>exe_file;

    <span style="color:#60a0b0;font-style:italic">/* ... some code omitted ... */</span>
};
</code></pre></div><p><code>start_code</code>, <code>end_code</code> 描述的是任务的可执行文件在虚拟内存地址中所处的区间。<code>start_data</code>, <code>end_data</code> 描述可执行文件的数据段，通常情况下与 <code>start_code</code>, <code>end_code</code> 指向同一段，只不过 rwx 的权限控制不同罢了。</p>
<p><code>start_brk</code> 和 <code>brk</code> 共同描述堆的起末点，通过 <code>syscall brk</code> 可以调整 <code>brk</code> 的值，也就是在运行过程中调整堆的大小。</p>
<p><code>arg_start</code>, <code>arg_end</code>, <code>env_start</code>, <code>env_end</code> 分别描述命令参数和环境变量在虚拟内存地址中所处的位置。</p>
<p><img src="https://img.ffutop.com/EEF5961B-F971-4329-A7DB-B531B329397B.png" alt=""></p>
<p>新任务的启动，通常是通过 <code>fork</code>, <code>clone</code> 等系统调用拷贝父任务几乎所有的状态和资源指针，然后通过 <code>execve</code> 系统调用替换可执行文件，重置虚拟内存等其他相关资源。</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#60a0b0;font-style:italic">/* Hint: 省略了一些无关代码 */</span>

<span style="color:#60a0b0;font-style:italic">/* execve 系统调用的入口 */</span>
SYSCALL_DEFINE3(execve,
        <span style="color:#007020;font-weight:bold">const</span> <span style="color:#902000">char</span> __user <span style="color:#666">*</span>, filename,
        <span style="color:#007020;font-weight:bold">const</span> <span style="color:#902000">char</span> __user <span style="color:#666">*</span><span style="color:#007020;font-weight:bold">const</span> __user <span style="color:#666">*</span>, argv,
        <span style="color:#007020;font-weight:bold">const</span> <span style="color:#902000">char</span> __user <span style="color:#666">*</span><span style="color:#007020;font-weight:bold">const</span> __user <span style="color:#666">*</span>, envp)
{
    <span style="color:#007020;font-weight:bold">struct</span> filename <span style="color:#666">*</span>path <span style="color:#666">=</span> getname(filename);
    error <span style="color:#666">=</span> do_execve(path<span style="color:#666">-&gt;</span>name, argv, envp);
    putname(path);
    <span style="color:#007020;font-weight:bold">return</span> error;
}

<span style="color:#902000">int</span> do_execve(<span style="color:#007020;font-weight:bold">const</span> <span style="color:#902000">char</span> <span style="color:#666">*</span>filename,
    <span style="color:#007020;font-weight:bold">const</span> <span style="color:#902000">char</span> __user <span style="color:#666">*</span><span style="color:#007020;font-weight:bold">const</span> __user <span style="color:#666">*</span>__argv,
    <span style="color:#007020;font-weight:bold">const</span> <span style="color:#902000">char</span> __user <span style="color:#666">*</span><span style="color:#007020;font-weight:bold">const</span> __user <span style="color:#666">*</span>__envp)
{
    <span style="color:#007020;font-weight:bold">struct</span> user_arg_ptr argv <span style="color:#666">=</span> { .ptr.native <span style="color:#666">=</span> __argv };
    <span style="color:#007020;font-weight:bold">struct</span> user_arg_ptr envp <span style="color:#666">=</span> { .ptr.native <span style="color:#666">=</span> __envp };
    <span style="color:#007020;font-weight:bold">return</span> <span style="color:#06287e">do_execve_common</span>(filename, argv, envp);
}

<span style="color:#007020;font-weight:bold">static</span> <span style="color:#902000">int</span> do_execve_common(<span style="color:#007020;font-weight:bold">const</span> <span style="color:#902000">char</span> <span style="color:#666">*</span>filename,
                <span style="color:#007020;font-weight:bold">struct</span> user_arg_ptr argv,
                <span style="color:#007020;font-weight:bold">struct</span> user_arg_ptr envp)
{
    <span style="color:#60a0b0;font-style:italic">// 检测 ulimit 限制的进程总数
</span><span style="color:#60a0b0;font-style:italic"></span>
    <span style="color:#60a0b0;font-style:italic">// 选择合适的 CPU 核以运行新任务
</span><span style="color:#60a0b0;font-style:italic"></span>    sched_exec();

    <span style="color:#60a0b0;font-style:italic">// 建立一个临时的栈内存来支持任务启动
</span><span style="color:#60a0b0;font-style:italic"></span>    retval <span style="color:#666">=</span> bprm_mm_init(bprm);

    bprm<span style="color:#666">-&gt;</span>argc <span style="color:#666">=</span> count(argv, MAX_ARG_STRINGS);
    bprm<span style="color:#666">-&gt;</span>envc <span style="color:#666">=</span> count(envp, MAX_ARG_STRINGS);

    retval <span style="color:#666">=</span> prepare_binprm(bprm);

    <span style="color:#60a0b0;font-style:italic">// 从用户空间拷贝字符串 （可执行文件路径、环境变量、启动参数）
</span><span style="color:#60a0b0;font-style:italic"></span>    retval <span style="color:#666">=</span> copy_strings_kernel(<span style="color:#40a070">1</span>, <span style="color:#666">&amp;</span>bprm<span style="color:#666">-&gt;</span>filename, bprm);
    retval <span style="color:#666">=</span> copy_strings(bprm<span style="color:#666">-&gt;</span>envc, envp, bprm);
    retval <span style="color:#666">=</span> copy_strings(bprm<span style="color:#666">-&gt;</span>argc, argv, bprm);

    <span style="color:#60a0b0;font-style:italic">// 根据可执行文件的格式，选择合适的加载函数 （例如 load_elf_binary）
</span><span style="color:#60a0b0;font-style:italic"></span>    retval <span style="color:#666">=</span> search_binary_handler(bprm);

    <span style="color:#60a0b0;font-style:italic">/* execve succeeded */</span>
    current<span style="color:#666">-&gt;</span>fs<span style="color:#666">-&gt;</span>in_exec <span style="color:#666">=</span> <span style="color:#40a070">0</span>;
    current<span style="color:#666">-&gt;</span>in_execve <span style="color:#666">=</span> <span style="color:#40a070">0</span>;
    acct_update_integrals(current);
    free_bprm(bprm);
    <span style="color:#007020;font-weight:bold">if</span> (displaced)
        put_files_struct(displaced);
    <span style="color:#007020;font-weight:bold">return</span> retval;
}
</code></pre></div><p>整体而言，<code>execve</code> 在完成了大量 check 的工作之后，把核心的加载流程委托给特定于可执行文件的加载模块来完成。以 ELF 文件格式为例，整体流程如下：</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-plain" data-lang="plain">|-- sys_execve
    |-- do_execve
        |-- do_execve_common
            |-- sched_exec
                |-- bprm_mm_init
                |-- prepare_binprm
                    |-- kernel_read
                |-- search_binary_handler
                    |-- load_elf_binary
                |-- acct_update_integrals
</code></pre></div><div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#60a0b0;font-style:italic">/* From fs/binfmt_elf.c */</span>
<span style="color:#007020;font-weight:bold">static</span> <span style="color:#902000">int</span> <span style="color:#06287e">load_elf_binary</span>(<span style="color:#007020;font-weight:bold">struct</span> linux_binprm <span style="color:#666">*</span>bprm)
{
    <span style="color:#60a0b0;font-style:italic">/* 获取可执行文件的头 128 B，已经由 kernel_read 提前读取到内存了 */</span>
	loc<span style="color:#666">-&gt;</span>elf_ex <span style="color:#666">=</span> <span style="color:#666">*</span>((<span style="color:#007020;font-weight:bold">struct</span> elfhdr <span style="color:#666">*</span>)bprm<span style="color:#666">-&gt;</span>buf);

    <span style="color:#60a0b0;font-style:italic">/* 确认是否是 ELF 文件格式，比较文件格式魔数。#define ELFMAG &#34;\177ELF&#34; */</span>
	<span style="color:#007020;font-weight:bold">if</span> (memcmp(loc<span style="color:#666">-&gt;</span>elf_ex.e_ident, ELFMAG, SELFMAG) <span style="color:#666">!=</span> <span style="color:#40a070">0</span>)
		<span style="color:#007020;font-weight:bold">goto</span> out;

	<span style="color:#007020;font-weight:bold">if</span> (loc<span style="color:#666">-&gt;</span>elf_ex.e_type <span style="color:#666">!=</span> ET_EXEC <span style="color:#666">&amp;&amp;</span> loc<span style="color:#666">-&gt;</span>elf_ex.e_type <span style="color:#666">!=</span> ET_DYN)
		<span style="color:#007020;font-weight:bold">goto</span> out;
	<span style="color:#007020;font-weight:bold">if</span> (<span style="color:#666">!</span>elf_check_arch(<span style="color:#666">&amp;</span>loc<span style="color:#666">-&gt;</span>elf_ex))
		<span style="color:#007020;font-weight:bold">goto</span> out;
	<span style="color:#007020;font-weight:bold">if</span> (<span style="color:#666">!</span>bprm<span style="color:#666">-&gt;</span>file<span style="color:#666">-&gt;</span>f_op <span style="color:#666">||</span> <span style="color:#666">!</span>bprm<span style="color:#666">-&gt;</span>file<span style="color:#666">-&gt;</span>f_op<span style="color:#666">-&gt;</span>mmap)
		<span style="color:#007020;font-weight:bold">goto</span> out;

    <span style="color:#60a0b0;font-style:italic">/* 读取所有的 elf header data */</span>
	retval <span style="color:#666">=</span> kernel_read(bprm<span style="color:#666">-&gt;</span>file, loc<span style="color:#666">-&gt;</span>elf_ex.e_phoff,
			     (<span style="color:#902000">char</span> <span style="color:#666">*</span>)elf_phdata, size);

    <span style="color:#60a0b0;font-style:italic">/* 设置新的可执行文件结构 */</span>
	setup_new_exec(bprm);

    <span style="color:#60a0b0;font-style:italic">/* 在虚拟地址空间设置启动参数 */</span>
	retval <span style="color:#666">=</span> setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),
				 executable_stack);
	
	current<span style="color:#666">-&gt;</span>mm<span style="color:#666">-&gt;</span>start_stack <span style="color:#666">=</span> bprm<span style="color:#666">-&gt;</span>p;
    
    <span style="color:#60a0b0;font-style:italic">/* 将 ELF text、code、bss 段等迁移到虚拟地址空间合适的位置 */</span>

    <span style="color:#60a0b0;font-style:italic">/* 设置 brk 的位置 */</span>
	retval <span style="color:#666">=</span> set_brk(elf_bss, elf_brk);

    <span style="color:#60a0b0;font-style:italic">/* 设置 mm_struct 关于 text、data、stack 的参数 */</span>
	current<span style="color:#666">-&gt;</span>mm<span style="color:#666">-&gt;</span>end_code <span style="color:#666">=</span> end_code;
	current<span style="color:#666">-&gt;</span>mm<span style="color:#666">-&gt;</span>start_code <span style="color:#666">=</span> start_code;
	current<span style="color:#666">-&gt;</span>mm<span style="color:#666">-&gt;</span>start_data <span style="color:#666">=</span> start_data;
	current<span style="color:#666">-&gt;</span>mm<span style="color:#666">-&gt;</span>end_data <span style="color:#666">=</span> end_data;
	current<span style="color:#666">-&gt;</span>mm<span style="color:#666">-&gt;</span>start_stack <span style="color:#666">=</span> bprm<span style="color:#666">-&gt;</span>p;

<span style="color:#007020">#ifdef arch_randomize_brk
</span><span style="color:#007020"></span>	<span style="color:#007020;font-weight:bold">if</span> ((current<span style="color:#666">-&gt;</span>flags <span style="color:#666">&amp;</span> PF_RANDOMIZE) <span style="color:#666">&amp;&amp;</span> (randomize_va_space <span style="color:#666">&gt;</span> <span style="color:#40a070">1</span>)) {
		current<span style="color:#666">-&gt;</span>mm<span style="color:#666">-&gt;</span>brk <span style="color:#666">=</span> current<span style="color:#666">-&gt;</span>mm<span style="color:#666">-&gt;</span>start_brk <span style="color:#666">=</span>
			arch_randomize_brk(current<span style="color:#666">-&gt;</span>mm);
<span style="color:#007020">#ifdef CONFIG_COMPAT_BRK
</span><span style="color:#007020"></span>		current<span style="color:#666">-&gt;</span>brk_randomized <span style="color:#666">=</span> <span style="color:#40a070">1</span>;
<span style="color:#007020">#endif
</span><span style="color:#007020"></span>	}
<span style="color:#007020">#endif
</span><span style="color:#007020"></span>
	start_thread(regs, elf_entry, bprm<span style="color:#666">-&gt;</span>p);
	retval <span style="color:#666">=</span> <span style="color:#40a070">0</span>;
}

<span style="color:#60a0b0;font-style:italic">/* From fs/exec.c */</span>
<span style="color:#902000">void</span> <span style="color:#06287e">setup_new_exec</span>(<span style="color:#007020;font-weight:bold">struct</span> linux_binprm <span style="color:#666">*</span> bprm)
{
    <span style="color:#60a0b0;font-style:italic">/* 根据 CPU 架构选择 mmap 布局方式 */</span>
	arch_pick_mmap_layout(current<span style="color:#666">-&gt;</span>mm);

    <span style="color:#60a0b0;font-style:italic">/* 配置信号栈 */</span>
	current<span style="color:#666">-&gt;</span>sas_ss_sp <span style="color:#666">=</span> current<span style="color:#666">-&gt;</span>sas_ss_size <span style="color:#666">=</span> <span style="color:#40a070">0</span>;

	set_task_comm(current, bprm<span style="color:#666">-&gt;</span>tcomm);

	current<span style="color:#666">-&gt;</span>mm<span style="color:#666">-&gt;</span>task_size <span style="color:#666">=</span> TASK_SIZE;

	current<span style="color:#666">-&gt;</span>self_exec_id<span style="color:#666">++</span>;
			
	flush_signal_handlers(current, <span style="color:#40a070">0</span>);
	do_close_on_exec(current<span style="color:#666">-&gt;</span>files);
}

<span style="color:#60a0b0;font-style:italic">/* From arch/x86/mm/mmap.c */</span>
<span style="color:#902000">void</span> <span style="color:#06287e">arch_pick_mmap_layout</span>(<span style="color:#007020;font-weight:bold">struct</span> mm_struct <span style="color:#666">*</span>mm)
{
	<span style="color:#007020;font-weight:bold">if</span> (mmap_is_legacy()) {
		mm<span style="color:#666">-&gt;</span>mmap_base <span style="color:#666">=</span> mmap_legacy_base();
		mm<span style="color:#666">-&gt;</span>get_unmapped_area <span style="color:#666">=</span> arch_get_unmapped_area;
		mm<span style="color:#666">-&gt;</span>unmap_area <span style="color:#666">=</span> arch_unmap_area;
	} <span style="color:#007020;font-weight:bold">else</span> {
        <span style="color:#60a0b0;font-style:italic">/* 新的 mmap 是从靠近 stack 的高地址开始，向低地址延伸的 */</span>
		mm<span style="color:#666">-&gt;</span>mmap_base <span style="color:#666">=</span> mmap_base();
		mm<span style="color:#666">-&gt;</span>get_unmapped_area <span style="color:#666">=</span> arch_get_unmapped_area_topdown;
		mm<span style="color:#666">-&gt;</span>unmap_area <span style="color:#666">=</span> arch_unmap_area_topdown;
	}
}
</code></pre></div><p>从传统的 mmap 配置方式，<code>mmap_base</code> 被配置为 <code>TASK_SIZE / 3</code> 。在 x86 32bit CPU 上，<code>TASK_SIZE</code> 通常被配置为 3GB （剩下的 1GB 的虚拟地址空间作为内核空间使用）。在整个 ELF 文件的加载过程中，<code>mm_struct</code> 依照既定的值或者经由计算得到的值被逐一填充。组成了一段涵盖可执行文件代码段、数据段、堆、栈、mmap 区域等的虚拟内存空间。</p>
<h2 id="堆的增长">堆的增长</h2>
<p>抛却我们所熟知的 malloc、free 等内存申请与释放函数。从 <code>mm_struct</code> 可以看到三块可用的内存区域——堆、mmap 区域、栈。</p>
<p>堆的增长与缩减通过 <code>brk</code>, <code>sbrk</code> 两个系统调用来完成。</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">SYSCALL_DEFINE1(brk, <span style="color:#902000">unsigned</span> <span style="color:#902000">long</span>, brk)
{
	<span style="color:#60a0b0;font-style:italic">/* Ok, looks good - let it rip. */</span>
	<span style="color:#007020;font-weight:bold">if</span> (do_brk(oldbrk, newbrk<span style="color:#666">-</span>oldbrk) <span style="color:#666">!=</span> oldbrk)
		<span style="color:#007020;font-weight:bold">goto</span> out;
}

<span style="color:#60a0b0;font-style:italic">/* From mm/mmap.c */</span>
<span style="color:#007020;font-weight:bold">static</span> <span style="color:#902000">unsigned</span> <span style="color:#902000">long</span> do_brk(<span style="color:#902000">unsigned</span> <span style="color:#902000">long</span> addr, <span style="color:#902000">unsigned</span> <span style="color:#902000">long</span> len)
{
	<span style="color:#007020;font-weight:bold">struct</span> mm_struct <span style="color:#666">*</span> mm <span style="color:#666">=</span> current<span style="color:#666">-&gt;</span>mm;
	<span style="color:#007020;font-weight:bold">struct</span> vm_area_struct <span style="color:#666">*</span> vma, <span style="color:#666">*</span> prev;
	<span style="color:#902000">unsigned</span> <span style="color:#902000">long</span> flags;
	<span style="color:#007020;font-weight:bold">struct</span> rb_node <span style="color:#666">**</span> rb_link, <span style="color:#666">*</span> rb_parent;
	pgoff_t pgoff <span style="color:#666">=</span> addr <span style="color:#666">&gt;&gt;</span> PAGE_SHIFT;
	<span style="color:#902000">int</span> error;

	len <span style="color:#666">=</span> PAGE_ALIGN(len);
	<span style="color:#007020;font-weight:bold">if</span> (<span style="color:#666">!</span>len)
		<span style="color:#007020;font-weight:bold">return</span> addr;

	flags <span style="color:#666">=</span> VM_DATA_DEFAULT_FLAGS <span style="color:#666">|</span> VM_ACCOUNT <span style="color:#666">|</span> mm<span style="color:#666">-&gt;</span>def_flags;

	error <span style="color:#666">=</span> get_unmapped_area(<span style="color:#007020">NULL</span>, addr, len, <span style="color:#40a070">0</span>, MAP_FIXED);
	<span style="color:#007020;font-weight:bold">if</span> (error <span style="color:#666">&amp;</span> <span style="color:#666">~</span>PAGE_MASK)
		<span style="color:#007020;font-weight:bold">return</span> error;

    <span style="color:#60a0b0;font-style:italic">/* 锁，保证同一时间只有一个任务在操作虚拟内存空间分配 */</span>
	verify_mm_writelocked(mm);

	<span style="color:#60a0b0;font-style:italic">/*
</span><span style="color:#60a0b0;font-style:italic">	 * Clear old maps.  this also does some error checking for us
</span><span style="color:#60a0b0;font-style:italic">	 */</span>
 <span style="color:#002070;font-weight:bold">munmap_back</span>:
	<span style="color:#007020;font-weight:bold">if</span> (find_vma_links(mm, addr, addr <span style="color:#666">+</span> len, <span style="color:#666">&amp;</span>prev, <span style="color:#666">&amp;</span>rb_link, <span style="color:#666">&amp;</span>rb_parent)) {
		<span style="color:#007020;font-weight:bold">if</span> (do_munmap(mm, addr, len))
			<span style="color:#007020;font-weight:bold">return</span> <span style="color:#666">-</span>ENOMEM;
		<span style="color:#007020;font-weight:bold">goto</span> munmap_back;
	}

	<span style="color:#60a0b0;font-style:italic">/* Check against address space limits *after* clearing old maps... */</span>
	<span style="color:#007020;font-weight:bold">if</span> (<span style="color:#666">!</span>may_expand_vm(mm, len <span style="color:#666">&gt;&gt;</span> PAGE_SHIFT))
		<span style="color:#007020;font-weight:bold">return</span> <span style="color:#666">-</span>ENOMEM;

	<span style="color:#007020;font-weight:bold">if</span> (mm<span style="color:#666">-&gt;</span>map_count <span style="color:#666">&gt;</span> sysctl_max_map_count)
		<span style="color:#007020;font-weight:bold">return</span> <span style="color:#666">-</span>ENOMEM;

	<span style="color:#007020;font-weight:bold">if</span> (security_vm_enough_memory_mm(mm, len <span style="color:#666">&gt;&gt;</span> PAGE_SHIFT))
		<span style="color:#007020;font-weight:bold">return</span> <span style="color:#666">-</span>ENOMEM;

	<span style="color:#60a0b0;font-style:italic">/* Can we just expand an old private anonymous mapping? */</span>
	vma <span style="color:#666">=</span> vma_merge(mm, prev, addr, addr <span style="color:#666">+</span> len, flags,
					<span style="color:#007020">NULL</span>, <span style="color:#007020">NULL</span>, pgoff, <span style="color:#007020">NULL</span>);
	<span style="color:#007020;font-weight:bold">if</span> (vma)
		<span style="color:#007020;font-weight:bold">goto</span> out;

    <span style="color:#60a0b0;font-style:italic">/* 创建一个新的匿名映射结构，brk 说到底就是一种特殊的 mmap */</span>
	vma <span style="color:#666">=</span> kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);
	<span style="color:#007020;font-weight:bold">if</span> (<span style="color:#666">!</span>vma) {
		vm_unacct_memory(len <span style="color:#666">&gt;&gt;</span> PAGE_SHIFT);
		<span style="color:#007020;font-weight:bold">return</span> <span style="color:#666">-</span>ENOMEM;
	}

    <span style="color:#60a0b0;font-style:italic">/* 向 vma 列表添加新的虚拟内存段记录 */</span>
	INIT_LIST_HEAD(<span style="color:#666">&amp;</span>vma<span style="color:#666">-&gt;</span>anon_vma_chain);
	vma<span style="color:#666">-&gt;</span>vm_mm <span style="color:#666">=</span> mm;
	vma<span style="color:#666">-&gt;</span>vm_start <span style="color:#666">=</span> addr;
	vma<span style="color:#666">-&gt;</span>vm_end <span style="color:#666">=</span> addr <span style="color:#666">+</span> len;
	vma<span style="color:#666">-&gt;</span>vm_pgoff <span style="color:#666">=</span> pgoff;
	vma<span style="color:#666">-&gt;</span>vm_flags <span style="color:#666">=</span> flags;
	vma<span style="color:#666">-&gt;</span>vm_page_prot <span style="color:#666">=</span> vm_get_page_prot(flags);
	vma_link(mm, vma, prev, rb_link, rb_parent);
<span style="color:#002070;font-weight:bold">out</span>:
	perf_event_mmap(vma);
	mm<span style="color:#666">-&gt;</span>total_vm <span style="color:#666">+=</span> len <span style="color:#666">&gt;&gt;</span> PAGE_SHIFT;
	<span style="color:#007020;font-weight:bold">if</span> (flags <span style="color:#666">&amp;</span> VM_LOCKED)
		mm<span style="color:#666">-&gt;</span>locked_vm <span style="color:#666">+=</span> (len <span style="color:#666">&gt;&gt;</span> PAGE_SHIFT);
	<span style="color:#007020;font-weight:bold">return</span> addr;
}
</code></pre></div><p><code>mm_struct</code> 通过 <code>brk</code> 参数维护了堆的边界，<code>brk</code> 系统调用的作用就是对这个参数进行调整，从而让任务所能够使用的虚拟内存扩大。另一方面，这个 <code>brk</code> 的实现就等同于是 <code>mmap</code> 的一个压缩版，只是去掉了对文件等内容的直接映射罢了（mmap 的实现稍后呈现）。</p>
<h2 id="匿名地址空间映射">匿名地址空间映射</h2>
<p><code>mmap</code> 一直被描述为一种直接内存映射文件的方式，区别于 <code>read</code>, <code>write</code> ，对它的核心定义就是高效。</p>
<p>通常来说，读写都涉及到至少 2 次内存间的数据拷贝。</p>
<ol>
<li>磁盘与内存缓冲区之间的数据拷贝</li>
<li>内核数据区与用户数据区之间的数据拷贝</li>
</ol>
<p>内核暴露了两种 <code>mmap</code> 系统调用的接口，根据处理器架构的不同，做了不同的适配实现，一般来说都是一种实现委托另一种的形式。这里以 x86 为例。</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">SYSCALL_DEFINE1(old_mmap, <span style="color:#007020;font-weight:bold">struct</span> mmap_arg_struct __user <span style="color:#666">*</span>, arg)
{
    <span style="color:#007020;font-weight:bold">struct</span> mmap_arg_struct a;

    <span style="color:#007020;font-weight:bold">if</span> (copy_from_user(<span style="color:#666">&amp;</span>a, arg, <span style="color:#007020;font-weight:bold">sizeof</span>(a)))
        <span style="color:#007020;font-weight:bold">return</span> <span style="color:#666">-</span>EFAULT;
    <span style="color:#007020;font-weight:bold">if</span> (a.offset <span style="color:#666">&amp;</span> <span style="color:#666">~</span>PAGE_MASK)
        <span style="color:#007020;font-weight:bold">return</span> <span style="color:#666">-</span>EINVAL;

    <span style="color:#60a0b0;font-style:italic">// 委托 mmap_pgoff 来实现
</span><span style="color:#60a0b0;font-style:italic"></span>    <span style="color:#007020;font-weight:bold">return</span> <span style="color:#06287e">sys_mmap_pgoff</span>(a.addr, a.len, a.prot, a.flags, a.fd,
                  a.offset <span style="color:#666">&gt;&gt;</span> PAGE_SHIFT);
}

SYSCALL_DEFINE6(mmap_pgoff, <span style="color:#902000">unsigned</span> <span style="color:#902000">long</span>, addr, <span style="color:#902000">unsigned</span> <span style="color:#902000">long</span>, len,
        <span style="color:#902000">unsigned</span> <span style="color:#902000">long</span>, prot, <span style="color:#902000">unsigned</span> <span style="color:#902000">long</span>, flags,
        <span style="color:#902000">unsigned</span> <span style="color:#902000">long</span>, fd, <span style="color:#902000">unsigned</span> <span style="color:#902000">long</span>, pgoff)
{
    <span style="color:#007020;font-weight:bold">struct</span> file <span style="color:#666">*</span>file <span style="color:#666">=</span> <span style="color:#007020">NULL</span>;
    <span style="color:#902000">unsigned</span> <span style="color:#902000">long</span> retval <span style="color:#666">=</span> <span style="color:#666">-</span>EBADF;

    <span style="color:#007020;font-weight:bold">if</span> (<span style="color:#666">!</span>(flags <span style="color:#666">&amp;</span> MAP_ANONYMOUS)) {
        <span style="color:#60a0b0;font-style:italic">// 非匿名映射，意味着一定与文件做映射（这是广义上的文件）
</span><span style="color:#60a0b0;font-style:italic"></span>        <span style="color:#60a0b0;font-style:italic">// ... some code omitted ...
</span><span style="color:#60a0b0;font-style:italic"></span>        file <span style="color:#666">=</span> fget(fd);
    } <span style="color:#007020;font-weight:bold">else</span> <span style="color:#007020;font-weight:bold">if</span> (flags <span style="color:#666">&amp;</span> MAP_HUGETLB) {
        <span style="color:#60a0b0;font-style:italic">// 使用大内存页
</span><span style="color:#60a0b0;font-style:italic"></span>        <span style="color:#60a0b0;font-style:italic">// ... some code omitted ...
</span><span style="color:#60a0b0;font-style:italic"></span>    }

    flags <span style="color:#666">&amp;=</span> <span style="color:#666">~</span>(MAP_EXECUTABLE <span style="color:#666">|</span> MAP_DENYWRITE);

    retval <span style="color:#666">=</span> vm_mmap_pgoff(file, addr, len, prot, flags, pgoff);
    <span style="color:#007020;font-weight:bold">if</span> (file)
        fput(file);
    <span style="color:#007020;font-weight:bold">return</span> retval;
}
</code></pre></div><p><code>vm_mmap_pgoff</code> 是一个 wrapper，来构建临界区代码</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#902000">unsigned</span> <span style="color:#902000">long</span> <span style="color:#06287e">vm_mmap_pgoff</span>(<span style="color:#007020;font-weight:bold">struct</span> file <span style="color:#666">*</span>file, <span style="color:#902000">unsigned</span> <span style="color:#902000">long</span> addr,
    <span style="color:#902000">unsigned</span> <span style="color:#902000">long</span> len, <span style="color:#902000">unsigned</span> <span style="color:#902000">long</span> prot,
    <span style="color:#902000">unsigned</span> <span style="color:#902000">long</span> flag, <span style="color:#902000">unsigned</span> <span style="color:#902000">long</span> pgoff)
{
    <span style="color:#902000">unsigned</span> <span style="color:#902000">long</span> ret;
    <span style="color:#007020;font-weight:bold">struct</span> mm_struct <span style="color:#666">*</span>mm <span style="color:#666">=</span> current<span style="color:#666">-&gt;</span>mm;
    <span style="color:#902000">unsigned</span> <span style="color:#902000">long</span> populate;

    ret <span style="color:#666">=</span> security_mmap_file(file, prot, flag);
    <span style="color:#007020;font-weight:bold">if</span> (<span style="color:#666">!</span>ret) {
        down_write(<span style="color:#666">&amp;</span>mm<span style="color:#666">-&gt;</span>mmap_sem);
        <span style="color:#60a0b0;font-style:italic">// 临界区
</span><span style="color:#60a0b0;font-style:italic"></span>        ret <span style="color:#666">=</span> do_mmap_pgoff(file, addr, len, prot, flag, pgoff,
                    <span style="color:#666">&amp;</span>populate);
        up_write(<span style="color:#666">&amp;</span>mm<span style="color:#666">-&gt;</span>mmap_sem);
        <span style="color:#007020;font-weight:bold">if</span> (populate)
            mm_populate(ret, populate);
    }
    <span style="color:#007020;font-weight:bold">return</span> ret;
}
</code></pre></div><p><code>do_mmap_pgoff</code> 基于 flags 进行了大量的检查工作，确保 mmap 得到可靠的映射结果。其核心的逻辑又是分别依赖于函数 <code>get_unmapped_area</code> 和 <code>mmap_region</code>。</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#902000">unsigned</span> <span style="color:#902000">long</span> <span style="color:#06287e">do_mmap_pgoff</span>(<span style="color:#007020;font-weight:bold">struct</span> file <span style="color:#666">*</span>file, <span style="color:#902000">unsigned</span> <span style="color:#902000">long</span> addr,
            <span style="color:#902000">unsigned</span> <span style="color:#902000">long</span> len, <span style="color:#902000">unsigned</span> <span style="color:#902000">long</span> prot,
            <span style="color:#902000">unsigned</span> <span style="color:#902000">long</span> flags, <span style="color:#902000">unsigned</span> <span style="color:#902000">long</span> pgoff,
            <span style="color:#902000">unsigned</span> <span style="color:#902000">long</span> <span style="color:#666">*</span>populate)
{
    <span style="color:#007020;font-weight:bold">struct</span> mm_struct <span style="color:#666">*</span> mm <span style="color:#666">=</span> current<span style="color:#666">-&gt;</span>mm;
    <span style="color:#007020;font-weight:bold">struct</span> inode <span style="color:#666">*</span>inode;
    vm_flags_t vm_flags;

    <span style="color:#666">*</span>populate <span style="color:#666">=</span> <span style="color:#40a070">0</span>;

    <span style="color:#007020;font-weight:bold">if</span> (<span style="color:#666">!</span>(flags <span style="color:#666">&amp;</span> MAP_FIXED))
        <span style="color:#60a0b0;font-style:italic">// 低于 vm addr 硬下限，改成一个可用的最小地址
</span><span style="color:#60a0b0;font-style:italic"></span>        addr <span style="color:#666">=</span> round_hint_to_min(addr);

    <span style="color:#60a0b0;font-style:italic">// 地址对齐
</span><span style="color:#60a0b0;font-style:italic"></span>    len <span style="color:#666">=</span> PAGE_ALIGN(len);

    <span style="color:#60a0b0;font-style:italic">// 规避地址溢出的问题 
</span><span style="color:#60a0b0;font-style:italic"></span>    <span style="color:#007020;font-weight:bold">if</span> ((pgoff <span style="color:#666">+</span> (len <span style="color:#666">&gt;&gt;</span> PAGE_SHIFT)) <span style="color:#666">&lt;</span> pgoff)
        <span style="color:#007020;font-weight:bold">return</span> <span style="color:#666">-</span>EOVERFLOW;

    <span style="color:#60a0b0;font-style:italic">// 达到系统参数 mmap 映射数上限?
</span><span style="color:#60a0b0;font-style:italic"></span>    <span style="color:#007020;font-weight:bold">if</span> (mm<span style="color:#666">-&gt;</span>map_count <span style="color:#666">&gt;</span> sysctl_max_map_count)
        <span style="color:#007020;font-weight:bold">return</span> <span style="color:#666">-</span>ENOMEM;

    <span style="color:#60a0b0;font-style:italic">// 取一个未被映射的地址
</span><span style="color:#60a0b0;font-style:italic"></span>    addr <span style="color:#666">=</span> get_unmapped_area(file, addr, len, pgoff, flags);
    <span style="color:#60a0b0;font-style:italic">// 地址对齐
</span><span style="color:#60a0b0;font-style:italic"></span>    <span style="color:#007020;font-weight:bold">if</span> (addr <span style="color:#666">&amp;</span> <span style="color:#666">~</span>PAGE_MASK)
        <span style="color:#007020;font-weight:bold">return</span> addr;

    vm_flags <span style="color:#666">=</span> calc_vm_prot_bits(prot) <span style="color:#666">|</span> calc_vm_flag_bits(flags) <span style="color:#666">|</span>
            mm<span style="color:#666">-&gt;</span>def_flags <span style="color:#666">|</span> VM_MAYREAD <span style="color:#666">|</span> VM_MAYWRITE <span style="color:#666">|</span> VM_MAYEXEC;

    <span style="color:#60a0b0;font-style:italic">// MLOCK 相关操作，如果置位，可以保持映射的物理内存块不会被移出内存
</span><span style="color:#60a0b0;font-style:italic"></span>
    inode <span style="color:#666">=</span> file <span style="color:#666">?</span> file_inode(file) <span style="color:#666">:</span> <span style="color:#007020">NULL</span>;

    <span style="color:#007020;font-weight:bold">if</span> (file) {
        <span style="color:#007020;font-weight:bold">switch</span> (flags <span style="color:#666">&amp;</span> MAP_TYPE) {
        <span style="color:#007020;font-weight:bold">case</span> <span style="color:#002070;font-weight:bold">MAP_SHARED</span>:    <span style="color:#60a0b0;font-style:italic">// 共享标志，此时对文件内容的修改对其它任务可见
</span><span style="color:#60a0b0;font-style:italic"></span>            <span style="color:#007020;font-weight:bold">if</span> ((prot<span style="color:#666">&amp;</span>PROT_WRITE) <span style="color:#666">&amp;&amp;</span> <span style="color:#666">!</span>(file<span style="color:#666">-&gt;</span>f_mode<span style="color:#666">&amp;</span>FMODE_WRITE))
                <span style="color:#007020;font-weight:bold">return</span> <span style="color:#666">-</span>EACCES;
            <span style="color:#007020;font-weight:bold">if</span> (IS_APPEND(inode) <span style="color:#666">&amp;&amp;</span> (file<span style="color:#666">-&gt;</span>f_mode <span style="color:#666">&amp;</span> FMODE_WRITE))
                <span style="color:#007020;font-weight:bold">return</span> <span style="color:#666">-</span>EACCES;
            <span style="color:#60a0b0;font-style:italic">// 确保此文件未被其它任务锁定
</span><span style="color:#60a0b0;font-style:italic"></span>            <span style="color:#007020;font-weight:bold">if</span> (locks_verify_locked(inode))
                <span style="color:#007020;font-weight:bold">return</span> <span style="color:#666">-</span>EAGAIN;
            vm_flags <span style="color:#666">|=</span> VM_SHARED <span style="color:#666">|</span> VM_MAYSHARE;
            <span style="color:#007020;font-weight:bold">if</span> (<span style="color:#666">!</span>(file<span style="color:#666">-&gt;</span>f_mode <span style="color:#666">&amp;</span> FMODE_WRITE))
                vm_flags <span style="color:#666">&amp;=</span> <span style="color:#666">~</span>(VM_MAYWRITE <span style="color:#666">|</span> VM_SHARED);
            
            <span style="color:#60a0b0;font-style:italic">/* fall through */</span>
        <span style="color:#007020;font-weight:bold">case</span> <span style="color:#002070;font-weight:bold">MAP_PRIVATE</span>:
            <span style="color:#007020;font-weight:bold">if</span> (<span style="color:#666">!</span>(file<span style="color:#666">-&gt;</span>f_mode <span style="color:#666">&amp;</span> FMODE_READ))
                <span style="color:#007020;font-weight:bold">return</span> <span style="color:#666">-</span>EACCES;
            <span style="color:#007020;font-weight:bold">if</span> (file<span style="color:#666">-&gt;</span>f_path.mnt<span style="color:#666">-&gt;</span>mnt_flags <span style="color:#666">&amp;</span> MNT_NOEXEC) {
                <span style="color:#007020;font-weight:bold">if</span> (vm_flags <span style="color:#666">&amp;</span> VM_EXEC)
                    <span style="color:#007020;font-weight:bold">return</span> <span style="color:#666">-</span>EPERM;
                vm_flags <span style="color:#666">&amp;=</span> <span style="color:#666">~</span>VM_MAYEXEC;
            }

            <span style="color:#007020;font-weight:bold">if</span> (<span style="color:#666">!</span>file<span style="color:#666">-&gt;</span>f_op <span style="color:#666">||</span> <span style="color:#666">!</span>file<span style="color:#666">-&gt;</span>f_op<span style="color:#666">-&gt;</span>mmap)
                <span style="color:#007020;font-weight:bold">return</span> <span style="color:#666">-</span>ENODEV;
            <span style="color:#007020;font-weight:bold">break</span>;

        <span style="color:#007020;font-weight:bold">default</span><span style="color:#666">:</span>
            <span style="color:#007020;font-weight:bold">return</span> <span style="color:#666">-</span>EINVAL;
        }
    } <span style="color:#007020;font-weight:bold">else</span> {
        <span style="color:#007020;font-weight:bold">switch</span> (flags <span style="color:#666">&amp;</span> MAP_TYPE) {
        <span style="color:#007020;font-weight:bold">case</span> <span style="color:#002070;font-weight:bold">MAP_SHARED</span>:    <span style="color:#60a0b0;font-style:italic">// 共享标志，此时对这段内存内容的修改对其它任务可见
</span><span style="color:#60a0b0;font-style:italic"></span>            <span style="color:#60a0b0;font-style:italic">// 因此不能有偏移量
</span><span style="color:#60a0b0;font-style:italic"></span>            pgoff <span style="color:#666">=</span> <span style="color:#40a070">0</span>;
            vm_flags <span style="color:#666">|=</span> VM_SHARED <span style="color:#666">|</span> VM_MAYSHARE;
            <span style="color:#007020;font-weight:bold">break</span>;
        <span style="color:#007020;font-weight:bold">case</span> <span style="color:#002070;font-weight:bold">MAP_PRIVATE</span>:
            pgoff <span style="color:#666">=</span> addr <span style="color:#666">&gt;&gt;</span> PAGE_SHIFT;
            <span style="color:#007020;font-weight:bold">break</span>;
        <span style="color:#007020;font-weight:bold">default</span><span style="color:#666">:</span>
            <span style="color:#007020;font-weight:bold">return</span> <span style="color:#666">-</span>EINVAL;
        }
    }

    addr <span style="color:#666">=</span> mmap_region(file, addr, len, vm_flags, pgoff);
    <span style="color:#007020;font-weight:bold">return</span> addr;
}
</code></pre></div><p><code>get_unmapped_area</code> 负责从虚拟地址空间中寻找一块合适的空间用于映射。根据是否指定 addr，是否做文件映射，分别又走向不同的逻辑分支。具体实现不再细数。函数的执行结果，就是得到可用的起始地址信息。</p>
<p><code>mmap_region</code> 做的是维护一个新的 vma 数据结构。根据实际场景，会涉及到释放冲突的 mmap 区域，合并直接衔接的 mmap 区块，更新映射文件的信息等。最终会将新的 vma 添加到 <code>mm_struct</code> 维护的红黑树及链表中。额外的，还有一些统计的工作，以及内存超卖等的策略实施。</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#902000">unsigned</span> <span style="color:#902000">long</span> <span style="color:#06287e">mmap_region</span>(<span style="color:#007020;font-weight:bold">struct</span> file <span style="color:#666">*</span>file, <span style="color:#902000">unsigned</span> <span style="color:#902000">long</span> addr,
        <span style="color:#902000">unsigned</span> <span style="color:#902000">long</span> len, vm_flags_t vm_flags, <span style="color:#902000">unsigned</span> <span style="color:#902000">long</span> pgoff)
{
    <span style="color:#007020;font-weight:bold">struct</span> mm_struct <span style="color:#666">*</span>mm <span style="color:#666">=</span> current<span style="color:#666">-&gt;</span>mm;
    <span style="color:#007020;font-weight:bold">struct</span> vm_area_struct <span style="color:#666">*</span>vma, <span style="color:#666">*</span>prev;
    <span style="color:#902000">int</span> correct_wcount <span style="color:#666">=</span> <span style="color:#40a070">0</span>;
    <span style="color:#902000">int</span> error;
    <span style="color:#007020;font-weight:bold">struct</span> rb_node <span style="color:#666">**</span>rb_link, <span style="color:#666">*</span>rb_parent;
    <span style="color:#902000">unsigned</span> <span style="color:#902000">long</span> charged <span style="color:#666">=</span> <span style="color:#40a070">0</span>;
    <span style="color:#007020;font-weight:bold">struct</span> inode <span style="color:#666">*</span>inode <span style="color:#666">=</span>  file <span style="color:#666">?</span> file_inode(file) <span style="color:#666">:</span> <span style="color:#007020">NULL</span>;

    error <span style="color:#666">=</span> <span style="color:#666">-</span>ENOMEM;
    <span style="color:#60a0b0;font-style:italic">/* 如果新的 mmap 区域早已经被映射，则释放掉老的映射 */</span>
<span style="color:#002070;font-weight:bold">munmap_back</span>:
    <span style="color:#007020;font-weight:bold">if</span> (find_vma_links(mm, addr, addr <span style="color:#666">+</span> len, <span style="color:#666">&amp;</span>prev, <span style="color:#666">&amp;</span>rb_link, <span style="color:#666">&amp;</span>rb_parent)) {
        <span style="color:#007020;font-weight:bold">if</span> (do_munmap(mm, addr, len))
            <span style="color:#007020;font-weight:bold">return</span> <span style="color:#666">-</span>ENOMEM;
        <span style="color:#007020;font-weight:bold">goto</span> munmap_back;
    }

    <span style="color:#60a0b0;font-style:italic">/*
</span><span style="color:#60a0b0;font-style:italic">     * 确认物理内存是否足够用于支撑虚拟内存
</span><span style="color:#60a0b0;font-style:italic">     * 根据不同的 overcommit (内存超卖) 策略会有不同的结论。
</span><span style="color:#60a0b0;font-style:italic">     */</span>
    <span style="color:#007020;font-weight:bold">if</span> (accountable_mapping(file, vm_flags)) {
        charged <span style="color:#666">=</span> len <span style="color:#666">&gt;&gt;</span> PAGE_SHIFT;
        <span style="color:#007020;font-weight:bold">if</span> (security_vm_enough_memory_mm(mm, charged))
            <span style="color:#007020;font-weight:bold">return</span> <span style="color:#666">-</span>ENOMEM;
        vm_flags <span style="color:#666">|=</span> VM_ACCOUNT;
    }

    <span style="color:#60a0b0;font-style:italic">/* 如果新的映射区域能与老的映射区域相连，则合并两个映射区域*/</span>
    vma <span style="color:#666">=</span> vma_merge(mm, prev, addr, addr <span style="color:#666">+</span> len, vm_flags, <span style="color:#007020">NULL</span>, file, pgoff, <span style="color:#007020">NULL</span>);
    <span style="color:#007020;font-weight:bold">if</span> (vma)    <span style="color:#60a0b0;font-style:italic">// 如果能合并，则跳到 out 处
</span><span style="color:#60a0b0;font-style:italic"></span>        <span style="color:#007020;font-weight:bold">goto</span> out;

    <span style="color:#60a0b0;font-style:italic">// 为 vma 结构申请一块内存
</span><span style="color:#60a0b0;font-style:italic"></span>    vma <span style="color:#666">=</span> kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);
    <span style="color:#007020;font-weight:bold">if</span> (<span style="color:#666">!</span>vma) {
        error <span style="color:#666">=</span> <span style="color:#666">-</span>ENOMEM;
        <span style="color:#007020;font-weight:bold">goto</span> unacct_error;
    }

    vma<span style="color:#666">-&gt;</span>vm_mm <span style="color:#666">=</span> mm;
    vma<span style="color:#666">-&gt;</span>vm_start <span style="color:#666">=</span> addr;
    vma<span style="color:#666">-&gt;</span>vm_end <span style="color:#666">=</span> addr <span style="color:#666">+</span> len;
    vma<span style="color:#666">-&gt;</span>vm_flags <span style="color:#666">=</span> vm_flags;
    vma<span style="color:#666">-&gt;</span>vm_page_prot <span style="color:#666">=</span> vm_get_page_prot(vm_flags);
    vma<span style="color:#666">-&gt;</span>vm_pgoff <span style="color:#666">=</span> pgoff;
    INIT_LIST_HEAD(<span style="color:#666">&amp;</span>vma<span style="color:#666">-&gt;</span>anon_vma_chain);

    error <span style="color:#666">=</span> <span style="color:#666">-</span>EINVAL;    <span style="color:#60a0b0;font-style:italic">/* when rejecting VM_GROWSDOWN|VM_GROWSUP */</span>

    <span style="color:#60a0b0;font-style:italic">/* 如果做文件映射，需要额外地维护文件的结构，声明其与一块 mmap 区域关联 */</span>
    <span style="color:#007020;font-weight:bold">if</span> (file) {
        <span style="color:#007020;font-weight:bold">if</span> (vm_flags <span style="color:#666">&amp;</span> (VM_GROWSDOWN<span style="color:#666">|</span>VM_GROWSUP))
            <span style="color:#007020;font-weight:bold">goto</span> free_vma;
        <span style="color:#007020;font-weight:bold">if</span> (vm_flags <span style="color:#666">&amp;</span> VM_DENYWRITE) {
            error <span style="color:#666">=</span> deny_write_access(file);
            <span style="color:#007020;font-weight:bold">if</span> (error)
                <span style="color:#007020;font-weight:bold">goto</span> free_vma;
            correct_wcount <span style="color:#666">=</span> <span style="color:#40a070">1</span>;
        }
        vma<span style="color:#666">-&gt;</span>vm_file <span style="color:#666">=</span> get_file(file);
        error <span style="color:#666">=</span> file<span style="color:#666">-&gt;</span>f_op<span style="color:#666">-&gt;</span>mmap(file, vma);
        <span style="color:#007020;font-weight:bold">if</span> (error)
            <span style="color:#007020;font-weight:bold">goto</span> unmap_and_free_vma;
        WARN_ON_ONCE(addr <span style="color:#666">!=</span> vma<span style="color:#666">-&gt;</span>vm_start);

        addr <span style="color:#666">=</span> vma<span style="color:#666">-&gt;</span>vm_start;
        pgoff <span style="color:#666">=</span> vma<span style="color:#666">-&gt;</span>vm_pgoff;
        vm_flags <span style="color:#666">=</span> vma<span style="color:#666">-&gt;</span>vm_flags;
    } <span style="color:#007020;font-weight:bold">else</span> <span style="color:#007020;font-weight:bold">if</span> (vm_flags <span style="color:#666">&amp;</span> VM_SHARED) {
        <span style="color:#007020;font-weight:bold">if</span> (unlikely(vm_flags <span style="color:#666">&amp;</span> (VM_GROWSDOWN<span style="color:#666">|</span>VM_GROWSUP)))
            <span style="color:#007020;font-weight:bold">goto</span> free_vma;
        error <span style="color:#666">=</span> shmem_zero_setup(vma);
        <span style="color:#007020;font-weight:bold">if</span> (error)
            <span style="color:#007020;font-weight:bold">goto</span> free_vma;
    }

    <span style="color:#60a0b0;font-style:italic">// 将新的 vma 结构维护到 mm 红黑树及链表上
</span><span style="color:#60a0b0;font-style:italic"></span>    vma_link(mm, vma, prev, rb_link, rb_parent);
    file <span style="color:#666">=</span> vma<span style="color:#666">-&gt;</span>vm_file;

    <span style="color:#60a0b0;font-style:italic">/* Once vma denies write, undo our temporary denial count */</span>
    <span style="color:#007020;font-weight:bold">if</span> (correct_wcount)
        atomic_inc(<span style="color:#666">&amp;</span>inode<span style="color:#666">-&gt;</span>i_writecount);
<span style="color:#002070;font-weight:bold">out</span>:
    perf_event_mmap(vma);

    vm_stat_account(mm, vm_flags, file, len <span style="color:#666">&gt;&gt;</span> PAGE_SHIFT);
    <span style="color:#007020;font-weight:bold">if</span> (vm_flags <span style="color:#666">&amp;</span> VM_LOCKED) {
        <span style="color:#007020;font-weight:bold">if</span> (<span style="color:#666">!</span>((vm_flags <span style="color:#666">&amp;</span> VM_SPECIAL) <span style="color:#666">||</span> is_vm_hugetlb_page(vma) <span style="color:#666">||</span>
                    vma <span style="color:#666">==</span> get_gate_vma(current<span style="color:#666">-&gt;</span>mm)))
            mm<span style="color:#666">-&gt;</span>locked_vm <span style="color:#666">+=</span> (len <span style="color:#666">&gt;&gt;</span> PAGE_SHIFT);
        <span style="color:#007020;font-weight:bold">else</span>
            vma<span style="color:#666">-&gt;</span>vm_flags <span style="color:#666">&amp;=</span> <span style="color:#666">~</span>VM_LOCKED;
    }

    <span style="color:#007020;font-weight:bold">if</span> (file)
        uprobe_mmap(vma);

    <span style="color:#007020;font-weight:bold">return</span> addr;
}
</code></pre></div><p>到此为止，基本上一个新的 mmap 区域的申请就完成了。不过，由于内核内存管理模块将缺页等操作提取并后置，这里都没有看到操作物理内存，只有逻辑上的为申请的虚拟内存划分区域，记录状态。不过，这恰恰也是内核高效的一个体现。如果申请虚拟内存直接跟物理内存挂钩，首先是两类内存逻辑上的耦合，其次是过度浪费（申请和使用通常是割裂的，再就是有时是申请了但不会进行使用），再次就是效率了。所以，很多时候写惯了 C 代码，用 malloc 大量申请内存，却看到系统的可用内存几乎没有变化，就是这个道理；另外 Java 堆的申请也类似于这种，如果申请了 2GB 的 Java 堆，一般来说从内核来看，是申请了 2 GB 大小的 anon mmap 区域，初始是不会与物理内存挂钩，等到 GC 发生时，会发现即使清理了垃圾，系统可用内存还是没有增加（这是 2GB 都处于 JVM 管理之下了，虽然从虚拟机看来已经清理出了内存，但系统并不会意识到这一点）</p>
<h2 id="小结">小结</h2>
<p>关于虚拟内存，还有相当多的内容等待揭开。比如文件映射中如何保证内存中的文件与磁盘中的文件的高效同步；不同策略下内存超卖的表现；缺页场景下虚拟内存与物理内存的映射&hellip;</p>
<p>浅尝，后续有时间再继续翻看。</p>
        </div>

        <div class="row middle-xs">
          <div class="col-xs-12">
            
            <div class="post-category">
              <a href="/categories/%e6%8a%80%e6%9c%af/">
                技术
              </a>
            </div>
            
          </div>
        </div>
        <div class="row">
          <div class="col-xs-12">
            
          </div>
        </div>

        
        

<div class="releated-content">
  <h3>Related Posts</h3>
  <ul>
    
    <li><a href="/posts/2019-06-18-understand-kernel-12/">理解 Linux Kernel (12) - Linux 容器化技术</a></li>
    
    <li><a href="/posts/2019-06-02-ftrace/">跟踪内核函数的工具—— Ftrace</a></li>
    
    <li><a href="/posts/2019-05-27-understand-kernel-11/">理解 Linux Kernel (11) - 进程间通信</a></li>
    
  </ul>
</div>

        
        
        <div style="height: 50px;"></div>
        
        <div class="post-comments">
          <div id="disqus_thread"></div>
<script>
  window.addEventListener("load", () => {
    (function() {
      
      var d = document,
        s = d.createElement("script");
      s.src = "https://ffutop.disqus.com/embed.js";
      s.setAttribute("data-timestamp", +new Date());
      (d.head || d.body).appendChild(s);
    })();
  });
</script>
<noscript
  >Please enable JavaScript to view the
  <a href="https://disqus.com/?ref_noscript"
    >comments powered by Disqus.</a
  ></noscript
>

        </div>
        
        

        <div class="site-footer">
  
  <div class="site-footer-item">
    <a href="/posts/" target="_blank">Posts</a>
  </div>
  
  <div class="site-footer-item">
    <a href="/index.xml" target="_blank">RSS</a>
  </div>
  
  <div class="site-footer-item">
    <a href="https://github.com/ffutop" target="_blank">Github</a>
  </div>
  
  <div class="site-footer-item">
    <a href="/about/" target="_blank">About</a>
  </div>
  
  
</div>

      </div>
    </div>
  </article>

  <script src="/js/highlight.pack.js"></script>


<script>
  hljs.initHighlightingOnLoad();
  
  
  
    
    
  
</script>

  

 
  </body>
</html>
