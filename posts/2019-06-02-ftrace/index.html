<!DOCTYPE html>
<html lang="zh-cmn-Hans-CN" prefix="og: http://ogp.me/ns#">
  <head>
    <meta charset="utf-8" />
    
    <head>
  <meta charset="utf-8" />
  <meta name="generator" content="Hugo 0.68.3" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="ffutop" />
  <meta property="og:url" content="https://www.ffutop.com/posts/2019-06-02-ftrace/" />
  <link rel="canonical" href="https://www.ffutop.com/posts/2019-06-02-ftrace/" /><link rel="apple-touch-icon" href="favicon.ico" />
  <link rel="icon" href="favicon.ico" />
  <link rel="shortcut" href="favicon.ico" /><link rel="alternate" type="application/atom+xml" href="https://www.ffutop.com/index.xml" title="Utop&#39;s Blog">

  <script type="application/ld+json">
  {
      "@context" : "http://schema.org",
      "@type" : "BlogPosting",
      "mainEntityOfPage": {
           "@type": "WebPage",
           "@id": "https://www.ffutop.com/"
      },
      "articleSection" : "posts",
      "name" : "跟踪内核函数的工具—— Ftrace",
      "headline" : "跟踪内核函数的工具—— Ftrace",
      "description" : "\u003cp\u003e前两天仿照 \u003ccode\u003estrings\u003c/code\u003e 工具写了个打印进程运行时堆栈可打印字符的工具 \u003ca href=\"https://github.com/DorMOUSE-None/ff-proc-utils/blob/master/ffstrings.c\"\u003effstrings\u003c/a\u003e 。结果没几天就被告知在 CentOS 上跑不通(uid: root, errno: EPERM):\u0026lt;\u003c/p\u003e\n\u003cp\u003e在反复调试无果之后，希望得到一种可以跟踪内核执行流的工具。功夫不负有心人，在内核文档中找到了—— \u003ccode\u003eftrace\u003c/code\u003e 。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eFtrace 是位于内核内部的跟踪器，可以用来调试和分析发生在用户空间（内核空间）之外的延迟和性能问题。\u003c/p\u003e\n\u003cp\u003e虽然 Ftrace 是一款函数跟踪器，但也支持基于其它目的的跟踪，例如：跟踪上下文切换、跟踪高优先级任务的执行时间等等。另外还可以通过插件的方式自定义更多的跟踪。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e当然，目前仅仅是做简单的介绍。毕竟最初的目的是为了确认 \u003ccode\u003effstrings\u003c/code\u003e 出现 \u003ccode\u003eEPERM\u003c/code\u003e 的原因。\u003c/p\u003e",
      "inLanguage" : "zh-cmn-Hans-CN",
      "author" : "ffutop",
      "creator" : "ffutop",
      "publisher": "ffutop",
      "accountablePerson" : "ffutop",
      "copyrightHolder" : "ffutop",
      "copyrightYear" : "2019",
      "datePublished": "2019-06-02T00:00:00Z",
      "dateModified" : "2019-06-02T00:00:00Z",
      "url" : "https://www.ffutop.com/posts/2019-06-02-ftrace/",
      "keywords" : [ "Linux","Kernel","ftrace", ]
  }
</script>
<title>跟踪内核函数的工具—— Ftrace</title>
  <meta property="og:title" content="跟踪内核函数的工具—— Ftrace" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="前两天仿照 strings 工具写了个打印进程运行时堆栈可打印字符的工具 ffstrings 。结果没几天就被告知在 CentOS 上跑不通(uid: root, errno: EPERM):&lt;
在反复调试无果之后，希望得到一种可以跟踪内核执行流的工具。功夫不负有心人，在内核文档中找到了—— ftrace 。

Ftrace 是位于内核内部的跟踪器，可以用来调试和分析发生在用户空间（内核空间）之外的延迟和性能问题。
虽然 Ftrace 是一款函数跟踪器，但也支持基于其它目的的跟踪，例如：跟踪上下文切换、跟踪高优先级任务的执行时间等等。另外还可以通过插件的方式自定义更多的跟踪。

当然，目前仅仅是做简单的介绍。毕竟最初的目的是为了确认 ffstrings 出现 EPERM 的原因。" />
  <meta name="description" content="前两天仿照 strings 工具写了个打印进程运行时堆栈可打印字符的工具 ffstrings 。结果没几天就被告知在 CentOS 上跑不通(uid: root, errno: EPERM):&lt;
在反复调试无果之后，希望得到一种可以跟踪内核执行流的工具。功夫不负有心人，在内核文档中找到了—— ftrace 。

Ftrace 是位于内核内部的跟踪器，可以用来调试和分析发生在用户空间（内核空间）之外的延迟和性能问题。
虽然 Ftrace 是一款函数跟踪器，但也支持基于其它目的的跟踪，例如：跟踪上下文切换、跟踪高优先级任务的执行时间等等。另外还可以通过插件的方式自定义更多的跟踪。

当然，目前仅仅是做简单的介绍。毕竟最初的目的是为了确认 ffstrings 出现 EPERM 的原因。" />
  <meta property="og:locale" content="zh-cmn-Hans-CN" />

  <link rel="stylesheet" href="/css/flexboxgrid-6.3.1.min.css" />
  <link rel="stylesheet" href="/css/index.css">

  

  <link href="/index.xml" rel="alternate" type="application/rss+xml"
    title="Utop&#39;s Blog">
  
  <link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker|Bree+Serif" rel="stylesheet">
  
  

  
  
</head>

     
  </head>
  <body>
    
  <article class="post Chinese" id="article">
    <div class="row">
      <div class="col-xs-12">
        <div class="site-header">
          
<header>
  <div class="signatures site-title">
    <a href="/">FFUTOP</a>
  </div>
</header>
<div class="row end-xs">
  
  
</div>
<div class="header-line"></div>

        </div>
        <header class="post-header">
          <h1 class="post-title">跟踪内核函数的工具—— Ftrace</h1>
          
          <div class="row post-desc">
            <div class="col-xs-6">
              
              <time class="post-date" datetime="2019-06-02 00:00:00 UTC">
                02 Jun 2019
              </time>
              
            </div>
            <div class="col-xs-6">
              
              <div class="post-author">
                <a target="_blank" href="https://www.ffutop.com/">@ffutop</a>
              </div>
              
            </div>
          </div>
          
        </header>

        <div class="post-content markdown-body">
          
          <p>前两天仿照 <code>strings</code> 工具写了个打印进程运行时堆栈可打印字符的工具 <a href="https://github.com/DorMOUSE-None/ff-proc-utils/blob/master/ffstrings.c">ffstrings</a> 。结果没几天就被告知在 CentOS 上跑不通(uid: root, errno: EPERM):&lt;</p>
<p>在反复调试无果之后，希望得到一种可以跟踪内核执行流的工具。功夫不负有心人，在内核文档中找到了—— <code>ftrace</code> 。</p>
<blockquote>
<p>Ftrace 是位于内核内部的跟踪器，可以用来调试和分析发生在用户空间（内核空间）之外的延迟和性能问题。</p>
<p>虽然 Ftrace 是一款函数跟踪器，但也支持基于其它目的的跟踪，例如：跟踪上下文切换、跟踪高优先级任务的执行时间等等。另外还可以通过插件的方式自定义更多的跟踪。</p>
</blockquote>
<p>当然，目前仅仅是做简单的介绍。毕竟最初的目的是为了确认 <code>ffstrings</code> 出现 <code>EPERM</code> 的原因。</p>
<h2 id="启用-ftrace">启用 Ftrace</h2>
<p><code>Ftrace</code> 自版本 2.6.28 开始加入内核。首先要做的就是确保内核已经集成了 <code>Ftrace</code> 。当然，目前的内核版本都已经到 5.X 了，而且云服务器的普及，相信已经没有太多还在使用7、8年前 Linux 发行版的机器了吧 :)</p>
<p><code>Ftrace</code> 使用 debugfs 文件系统以文件的形式来维护控制项和跟踪器输出。一般来说，这个文件系统将挂载在 <code>/sys/kernel/debug</code> 目录下。如果没有找到，那就主动先挂载上 debugfs 文件系统：</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">mount -t debugfs nodev /sys/kernel/debug
</code></pre></div><p>挂载文件系统之后，可以检查下 <code>/sys/kernel/debug/tracing</code> 目录，这里就是 <code>Ftrace</code> 全部的可配置项和输出。</p>
<p>几个重要的文件包括：</p>
<ul>
<li><code>current_tracer</code>, 配置当前跟踪器进行哪些项目的跟踪</li>
<li><code>available_tracers</code>, 当前内核支持的所有跟踪项目</li>
<li><code>tracing_on</code>, 开启/关闭跟踪器 (0 表示关闭, 1 表示开启)</li>
<li><code>trace</code>, 用户可读的跟踪结果文件</li>
<li><code>trace_pipe</code>, 与 <code>trace</code> 文件静态呈现的形式相对，里面的数据只能消费一次</li>
<li><code>trace_options</code>, 配置输出文件的格式</li>
<li><code>tracing_max_latency</code>, 记录最大延时</li>
<li><code>buffer_size_kb</code>, 用于设置单个CPU使用的跟踪器缓存大小。跟踪器缓存使用环形缓存，老的缓存会在空间不足时被新缓存覆盖</li>
<li><code>tracing_cpumask</code>, 用来配置需要监控的CPU</li>
<li><code>set_ftrace_filter</code>, 显示指定跟踪特定的函数</li>
<li><code>set_ftrace_notrace</code>, 与 <code>set_ftrace_filter</code> 功能恰好相反</li>
<li><code>set_ftrace_pid</code>, 只跟踪特定的任务</li>
<li><code>set_graph_function</code>, 设置要清晰显示调用关系的函数，以 C 语言缩进式地呈现</li>
<li><code>available_filter_functions</code>, 显示目前可以跟踪的所有内核函数</li>
</ul>
<h2 id="使用-ftrace">使用 Ftrace</h2>
<p>配置 <code>current_tracer</code> ，跟踪内核所有函数的调用</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">$ <span style="color:#007020">echo</span> <span style="color:#007020;font-weight:bold">function</span> &gt; current_tracer
</code></pre></div><p>配置 <code>tracing_enabled</code>，开启跟踪器</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">$ <span style="color:#007020">echo</span> <span style="color:#40a070">1</span> &gt; tracing_on
</code></pre></div><p>查看 <code>trace</code> 文件中记录的跟踪器输出</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">$ head -15 trace
<span style="color:#60a0b0;font-style:italic"># tracer: function</span>
#
<span style="color:#60a0b0;font-style:italic">#                              _-----=&gt; irqs-off</span>
<span style="color:#60a0b0;font-style:italic">#                             / _----=&gt; need-resched</span>
<span style="color:#60a0b0;font-style:italic">#                            | / _---=&gt; hardirq/softirq</span>
<span style="color:#60a0b0;font-style:italic">#                            || / _--=&gt; preempt-depth</span>
<span style="color:#60a0b0;font-style:italic">#                            ||| /     delay</span>
<span style="color:#60a0b0;font-style:italic">#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span>
<span style="color:#60a0b0;font-style:italic">#              | |       |   ||||       |         |</span>
             zsh-23126 <span style="color:#666">[</span>000<span style="color:#666">]</span> d... 5252243.233084: do_syscall_64 &lt;-entry_SYSCALL_64_after_hwframe
             zsh-23126 <span style="color:#666">[</span>000<span style="color:#666">]</span> .... 5252243.233084: SyS_rt_sigprocmask &lt;-do_syscall_64
             zsh-23126 <span style="color:#666">[</span>000<span style="color:#666">]</span> .... 5252243.233084: sigprocmask &lt;-SyS_rt_sigprocmask
             zsh-23126 <span style="color:#666">[</span>000<span style="color:#666">]</span> .... 5252243.233084: __set_current_blocked &lt;-sigprocmask
             zsh-23126 <span style="color:#666">[</span>000<span style="color:#666">]</span> .... 5252243.233084: _raw_spin_lock_irq &lt;-__set_current_blocked
             zsh-23126 <span style="color:#666">[</span>000<span style="color:#666">]</span> d... 5252243.233085: __set_task_blocked &lt;-__set_current_blocked
</code></pre></div><p>OK，如果觉得这个结果并不直观，可以重新配置 <code>current_tracer</code>，使用 <code>function_graph</code></p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">$ <span style="color:#007020">echo</span> function_graph &gt; current_tracer
$ head -15 trace
<span style="color:#60a0b0;font-style:italic"># tracer: function_graph</span>
#
<span style="color:#60a0b0;font-style:italic"># CPU  DURATION                  FUNCTION CALLS</span>
<span style="color:#60a0b0;font-style:italic"># |     |   |                     |   |   |   |</span>
 0<span style="color:#666">)</span>               |      __fdget_pos<span style="color:#666">()</span> <span style="color:#666">{</span>
 0<span style="color:#666">)</span>   0.072 us    |        __fget_light<span style="color:#666">()</span>;
 0<span style="color:#666">)</span>   0.377 us    |      <span style="color:#666">}</span>
 0<span style="color:#666">)</span>               |      vfs_read<span style="color:#666">()</span> <span style="color:#666">{</span>
 0<span style="color:#666">)</span>               |        rw_verify_area<span style="color:#666">()</span> <span style="color:#666">{</span>
 0<span style="color:#666">)</span>               |          security_file_permission<span style="color:#666">()</span> <span style="color:#666">{</span>
 0<span style="color:#666">)</span>               |            apparmor_file_permission<span style="color:#666">()</span> <span style="color:#666">{</span>
 0<span style="color:#666">)</span>               |              common_file_perm<span style="color:#666">()</span> <span style="color:#666">{</span>
 0<span style="color:#666">)</span>   0.079 us    |                aa_file_perm<span style="color:#666">()</span>;
 0<span style="color:#666">)</span>   0.480 us    |              <span style="color:#666">}</span>
 0<span style="color:#666">)</span>   0.877 us    |            <span style="color:#666">}</span>
</code></pre></div><h2 id="跟踪应用程序的系统调用">跟踪应用程序的系统调用</h2>
<p>虽然 <code>strace</code> 就可以打印出任务的每个系统调用，但是，它所能完成的仅仅只是对每个系统调用及结果进行记录，而无法看到系统调用内部究竟发生了什么。而 ftrace 可以很好的完成这一点。当然，这需要一点点编码量。</p>
<p>回到最初的命题，执行 <code>ffstrings</code> 过程中，抛出了 <code>EPERM</code> 错误码。首先使用 <code>strace</code> 进行定位，究竟是哪个系统调用出了问题</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">$ strace ./ffstrings &lt;PID&gt;
<span style="color:#60a0b0;font-style:italic"># ... omitted output</span>
read<span style="color:#666">(</span>4, 0x7f9ac2970000, 1024<span style="color:#666">)</span>           <span style="color:#666">=</span> -1 EPERM <span style="color:#666">(</span>Operation not permitted<span style="color:#666">)</span>
<span style="color:#60a0b0;font-style:italic"># ... omitted output</span>
</code></pre></div><p>修改应用程序代码，添加两个新的函数 (<code>trace_on</code>, <code>trace_off</code>)。</p>
<p><em>Hint: 这段代码的健壮性并不好，请各位多担待</em></p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#902000">int</span> trace_fd <span style="color:#666">=</span> <span style="color:#666">-</span><span style="color:#40a070">1</span>;
<span style="color:#902000">int</span> marker_fd <span style="color:#666">=</span> <span style="color:#666">-</span><span style="color:#40a070">1</span>;
<span style="color:#902000">char</span> <span style="color:#666">*</span>debugfs <span style="color:#666">=</span> <span style="color:#4070a0">&#34;/sys/kernel/debug&#34;</span>;

<span style="color:#902000">void</span> <span style="color:#06287e">trace_on</span>()
{
	<span style="color:#902000">char</span> path[<span style="color:#40a070">256</span>];

	strcpy(path, debugfs);  <span style="color:#60a0b0;font-style:italic">/* BEWARE buffer overflow */</span>
	strcat(path,<span style="color:#4070a0">&#34;/tracing/tracing_on&#34;</span>);
	trace_fd <span style="color:#666">=</span> open(path, O_WRONLY);
	<span style="color:#007020;font-weight:bold">if</span> (trace_fd <span style="color:#666">&gt;=</span> <span style="color:#40a070">0</span>)
		write(trace_fd, <span style="color:#4070a0">&#34;1&#34;</span>, <span style="color:#40a070">1</span>);

	strcpy(path, debugfs);
	strcat(path,<span style="color:#4070a0">&#34;/tracing/trace_marker&#34;</span>);
	marker_fd <span style="color:#666">=</span> open(path, O_WRONLY);
    <span style="color:#007020;font-weight:bold">if</span> (marker_fd <span style="color:#666">&gt;=</span> <span style="color:#40a070">0</span>)
	    write(marker_fd, <span style="color:#4070a0">&#34;In critical area</span><span style="color:#4070a0;font-weight:bold">\n</span><span style="color:#4070a0">&#34;</span>, <span style="color:#40a070">17</span>);
}

<span style="color:#902000">void</span> <span style="color:#06287e">trace_off</span>()
{
    <span style="color:#007020;font-weight:bold">if</span> (marker_fd <span style="color:#666">&gt;=</span> <span style="color:#40a070">0</span>)
	    write(marker_fd, <span style="color:#4070a0">&#34;Out critical area</span><span style="color:#4070a0;font-weight:bold">\n</span><span style="color:#4070a0">&#34;</span>, <span style="color:#40a070">17</span>);
    write(trace_fd, <span style="color:#4070a0">&#34;0&#34;</span>, <span style="color:#40a070">1</span>);
    close(trace_fd);
    close(marker_fd);
    trace_fd <span style="color:#666">=</span> <span style="color:#666">-</span><span style="color:#40a070">1</span>;
    marker_fd <span style="color:#666">=</span> <span style="color:#666">-</span><span style="color:#40a070">1</span>;
}
</code></pre></div><p>在问题代码前后执行这两个新的函数</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">trace_on();
<span style="color:#902000">char</span> c <span style="color:#666">=</span> getc(mem);
trace_off();
</code></pre></div><p>再去从 <code>trace</code> 文件中取一下执行结果（局部结果）</p>
<p><img src="https://img.ffutop.com/669F0256-7612-48E5-9069-292D4E687660.png" alt=""></p>
<p>到此为止，就可以简单的实现对内核函数的跟踪。</p>
<p>不过，这仅仅只能看到内核函数调用，具体的调用关系，还是得拿到相应版本的内核代码仔细研读研读。毕竟，内核代码的改动也是相当频繁的，不同版本调用关系会出现很大的变化。</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-plain" data-lang="plain">  __                    __                  
 / _| __ _ _ __   __ _ / _| ___ _ __   __ _ 
| |_ / _` | &#39;_ \ / _` | |_ / _ \ &#39;_ \ / _` |
|  _| (_| | | | | (_| |  _|  __/ | | | (_| |
|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |
                 |___/                |___/ 
</code></pre></div>
        </div>

        <div class="row middle-xs">
          <div class="col-xs-12">
            
            <div class="post-category">
              <a href="/categories/%e6%8a%80%e6%9c%af/">
                技术
              </a>
            </div>
            
          </div>
        </div>
        <div class="row">
          <div class="col-xs-12">
            
          </div>
        </div>

        
        

<div class="releated-content">
  <h3>Related Posts</h3>
  <ul>
    
    <li><a href="/posts/2019-05-27-understand-kernel-11/">理解 Linux Kernel (11) - 进程间通信</a></li>
    
    <li><a href="/posts/2019-04-10-understand-kernel-10/">理解 Linux Kernel(10) - Context of Execution</a></li>
    
    <li><a href="/posts/2019-03-25-mem-dump/">如何获取运行时进程堆栈</a></li>
    
  </ul>
</div>

        
        
        <div style="height: 50px;"></div>
        
        <div class="post-comments">
          <div id="disqus_thread"></div>
<script>
  window.addEventListener("load", () => {
    (function() {
      
      var d = document,
        s = d.createElement("script");
      s.src = "https://ffutop.disqus.com/embed.js";
      s.setAttribute("data-timestamp", +new Date());
      (d.head || d.body).appendChild(s);
    })();
  });
</script>
<noscript
  >Please enable JavaScript to view the
  <a href="https://disqus.com/?ref_noscript"
    >comments powered by Disqus.</a
  ></noscript
>

        </div>
        
        

        <div class="site-footer">
  
  <div class="site-footer-item">
    <a href="/posts/" target="_blank">Posts</a>
  </div>
  
  <div class="site-footer-item">
    <a href="/index.xml" target="_blank">RSS</a>
  </div>
  
  <div class="site-footer-item">
    <a href="https://github.com/ffutop" target="_blank">Github</a>
  </div>
  
  <div class="site-footer-item">
    <a href="/about/" target="_blank">About</a>
  </div>
   
  
  
</div>

      </div>
    </div>
  </article>

  <script src="/js/highlight.pack.js"></script>


<script>
  hljs.initHighlightingOnLoad();
  
  
  
    
    
  
</script>

  

 
  </body>
</html>
