<!DOCTYPE html>
<html lang="zh-cn">
<head>
  
    <title>JNI 引发的堆外内存泄露 :: Utop&#39;s Blog</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="本以为写写异构代码也不算一件难事。毕竟做 Java 开发，日常也写些 C 代码，无论如何也不至于到棘手到地步。哪曾想，JNI 开发不难，但问题颇多。
为了排查一个 JNI 的堆外内存泄露问题，简直是绞尽脑汁而不得其门。最后查找的问题原因也特别简单，但凡认真学习了 JNI 开发都能够避免。
问题代码类似于下列代码：
#include &amp;quot;Main.h&amp;quot; JNIEXPORT void JNICALL Java_Main_sayHi (JNIEnv *env, jobject jobj, jstring jstr) { const char *str = (*env)-&amp;gt;GetStringUTFChars(env, jstr, 0); int len = (*env)-&amp;gt;GetStringUTFLength(env, jstr); // ... some code omitted return ; } "/>
<meta name="keywords" content="BLOG"/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="https://dormouse-none.github.io/posts/2019-07-06-jni_problem/" />


<link rel="stylesheet" href="https://dormouse-none.github.io/assets/style.css">

  <link rel="stylesheet" href="https://dormouse-none.github.io/assets/blue.css">






<link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://dormouse-none.github.io/img/apple-touch-icon-144-precomposed.png">

<link rel="shortcut icon" href="https://dormouse-none.github.io/favicon.ico">



<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="JNI 引发的堆外内存泄露 :: Utop&#39;s Blog — " />
<meta name="twitter:description" content="本以为写写异构代码也不算一件难事。毕竟做 Java 开发，日常也写些 C 代码，无论如何也不至于到棘手到地步。哪曾想，JNI 开发不难，但问题颇多。
为了排查一个 JNI 的堆外内存泄露问题，简直是绞尽脑汁而不得其门。最后查找的问题原因也特别简单，但凡认真学习了 JNI 开发都能够避免。
问题代码类似于下列代码：
#include &amp;quot;Main.h&amp;quot; JNIEXPORT void JNICALL Java_Main_sayHi (JNIEnv *env, jobject jobj, jstring jstr) { const char *str = (*env)-&amp;gt;GetStringUTFChars(env, jstr, 0); int len = (*env)-&amp;gt;GetStringUTFLength(env, jstr); // ... some code omitted return ; } " />
<meta name="twitter:site" content="https://dormouse-none.github.io/" />
<meta name="twitter:creator" content="fangfeng" />
<meta name="twitter:image" content="">


<meta property="og:locale" content="zh-cn" />
<meta property="og:type" content="article" />
<meta property="og:title" content="JNI 引发的堆外内存泄露 :: Utop&#39;s Blog — ">
<meta property="og:description" content="本以为写写异构代码也不算一件难事。毕竟做 Java 开发，日常也写些 C 代码，无论如何也不至于到棘手到地步。哪曾想，JNI 开发不难，但问题颇多。
为了排查一个 JNI 的堆外内存泄露问题，简直是绞尽脑汁而不得其门。最后查找的问题原因也特别简单，但凡认真学习了 JNI 开发都能够避免。
问题代码类似于下列代码：
#include &amp;quot;Main.h&amp;quot; JNIEXPORT void JNICALL Java_Main_sayHi (JNIEnv *env, jobject jobj, jstring jstr) { const char *str = (*env)-&amp;gt;GetStringUTFChars(env, jstr, 0); int len = (*env)-&amp;gt;GetStringUTFLength(env, jstr); // ... some code omitted return ; } " />
<meta property="og:url" content="https://dormouse-none.github.io/posts/2019-07-06-jni_problem/" />
<meta property="og:site_name" content="JNI 引发的堆外内存泄露" />
<meta property="og:image" content="">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2019-07-06 00:00:00 &#43;0000 UTC" />










<script async src="https://www.googletagmanager.com/gtag/js?id=UA-92258941-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', "UA-92258941-1");
</script>



</head>
<body class="">


<div class="container">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    ffutop
  </div>
</a>

    </div>
    <div class="menu-trigger">menu</div>
  </div>
  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">关于</a></li>
        
      
        
          <li><a href="/archives">归档</a></li>
        
      
      
    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">关于</a></li>
      
    
      
        <li><a href="/archives">归档</a></li>
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="https://dormouse-none.github.io/posts/2019-07-06-jni_problem/">JNI 引发的堆外内存泄露</a></h1>
  <div class="post-meta">
      
    <span class="post-date">
      2019-07-06
    </span>
    
    
    <span class="post-author">::
      fangfeng
    </span>
    
  </div>

  
  <span class="post-tags">
    
    #<a href="https://dormouse-none.github.io/tags/jni/">JNI</a>&nbsp;
    
    #<a href="https://dormouse-none.github.io/tags/memory-leak/">memory leak</a>&nbsp;
    
  </span>
  

  

  <div class="post-content">
    <p>本以为写写异构代码也不算一件难事。毕竟做 Java 开发，日常也写些 C 代码，无论如何也不至于到棘手到地步。哪曾想，JNI 开发不难，但问题颇多。</p>

<p>为了排查一个 JNI 的堆外内存泄露问题，简直是绞尽脑汁而不得其门。最后查找的问题原因也特别简单，但凡认真学习了 JNI 开发都能够避免。</p>

<p>问题代码类似于下列代码：</p>

<pre><code class="language-c">#include &quot;Main.h&quot;

JNIEXPORT void JNICALL Java_Main_sayHi (JNIEnv *env, jobject jobj, jstring jstr)
{
    const char *str = (*env)-&gt;GetStringUTFChars(env, jstr, 0);
    int len = (*env)-&gt;GetStringUTFLength(env, jstr);

    // ... some code omitted 

    return ;
}
</code></pre>

<h2 id="问题表现">问题表现</h2>

<p>最初的表现很明显，2核4G的机器，2GB的 Java 堆，最终物理内存不够用，导致 Java 进程被强制杀掉。几乎毫无疑问，就是 Java 堆外内存引发的问题。不过遗憾的是，物理内存不够用，没有留下足够多的堆栈详情。另外找了一台快要把内存打满的机器，打印信息。</p>

<pre><code class="language-sh">$ pmap -x 27765 | sort -n -k3 | tail -n 50
00007f460c9ac000   55632   23896   23896 rw---   [ anon ]
00007f45d0000000   38980   38980   38980 rw---   [ anon ]
00007f45dc000000   45980   39512   39512 rw---   [ anon ]
00007f45e0000000   46120   39652   39652 rw---   [ anon ]
00007f45d4000000   42160   41744   41744 rw---   [ anon ]
00007f45c8000000   45992   45992   45992 rw---   [ anon ]
00007f4610000000   48896   48872   48872 rwx--   [ anon ]
00007f45f8000000   51084   51084   51084 rw---   [ anon ]
00007f4600000000   52328   52328   52328 rw---   [ anon ]
00007f4608000000   58332   55452   55452 rw---   [ anon ]
00000000014f8000   57036   56908   56908 rw---   [ anon ]
00007f45d8000000   63760   57292   57292 rw---   [ anon ]
00007f45e8000000   58488   58488   58488 rw---   [ anon ]
00007f4604000000   59912   59912   59912 rw---   [ anon ]
00007f45fc000000   60080   60080   60080 rw---   [ anon ]
00007f45e4000000   64460   64452   64452 rw---   [ anon ]
00007f45f4000000   65072   65072   65072 rw---   [ anon ]
00007f4620000000   65536   65536   65536 rw---   [ anon ]
0000000080000000 2105600 2008240 2008240 rw---   [ anon ]   # 2GB 的 Java 堆
total kB         4885820 3040036 3030476
</code></pre>

<p>比较多的内存块都在 64M 左右大小。确实也很明显，就是申请的内存没有得到释放。</p>

<h2 id="问题排查">问题排查</h2>

<p>C 不似 Java，没有 Garbage Collection 。所有申请的内存都必须主动进行释放。唯一的问题就是 <code>GetStringUTFChars</code> 得到的内存是否会被 JVM 统一管理。</p>

<p>结果当然是不会，虽然是 Java 与 C 衔接的胶水代码，但这部分得到的内存需要自行管理。不过，JNI 也提供了函数来进行释放。</p>

<pre><code class="language-c">/* from src/share/vm/prims/jni.cpp */
JNI_ENTRY(const char*, jni_GetStringUTFChars(JNIEnv *env, jstring string, jboolean *isCopy))
  JNIWrapper(&quot;GetStringUTFChars&quot;);
  char* result = NULL;
  oop java_string = JNIHandles::resolve_non_null(string);
  if (java_lang_String::value(java_string) != NULL) {
    size_t length = java_lang_String::utf8_length(java_string);
    /* 申请堆内存 */
    result = AllocateHeap(length + 1, mtInternal, 0, AllocFailStrategy::RETURN_NULL);
    if (result != NULL) {
      java_lang_String::as_utf8_string(java_string, result, (int) length + 1);
      if (isCopy != NULL) {
        *isCopy = JNI_TRUE;
      }
    }
  }
  return result;
JNI_END

/* from src/share/vm/memory/allocation.inline.hpp */
inline char* AllocateHeap(size_t size, MEMFLAGS flags,
    const NativeCallStack&amp; stack,
    AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM) {
    // 申请内存
    char* p = (char*) os::malloc(size, flags, stack);
#ifdef ASSERT
    if (PrintMallocFree) trace_heap_malloc(size, &quot;AllocateHeap&quot;, p);
#endif
    if (p == NULL &amp;&amp; alloc_failmode == AllocFailStrategy::EXIT_OOM) {
        vm_exit_out_of_memory(size, OOM_MALLOC_ERROR, &quot;AllocateHeap&quot;);
    }
    return p;
}

/* from src/share/vm/prims/jni.cpp */
JNI_LEAF(void, jni_ReleaseStringUTFChars(JNIEnv *env, jstring str, const char *chars))
  JNIWrapper(&quot;ReleaseStringUTFChars&quot;);
  if (chars != NULL) {
    // 释放内存
    FreeHeap((char*) chars);
  }
);
JNI_END

/* from src/share/vm/memory/allocation.inline.hpp */
inline void FreeHeap(void* p, MEMFLAGS memflags = mtInternal) {
#ifdef ASSERT
    if (PrintMallocFree) trace_heap_free(p);
#endif
    os::free(p, memflags);
}
</code></pre>

<p>从名称就可以看出来，<code>GetStringUTFChars</code> 和 <code>ReleaseStringUTFChars</code> 是相对的方法。而且默认走的都是 Glibc 的 <code>malloc</code> 和 <code>free</code> 。</p>

<h2 id="问题验证">问题验证</h2>

<p>为了验证问题的原因和最终的现象，整了一段代码来测试效果。</p>

<pre><code class="language-java">import java.io.IOException;

public class Main {

    static {
        System.load(&quot;/root/jni/Main.so&quot;);
    }

    private static final String value = &quot;AAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHH&quot;;

    public native void sayHi(String value);

    public static void main(String[] args) throws IOException {
        Main main = new Main();
        while (true)
        {
            for (int i=0;i&lt;100000;i++) {
                char c1 = (char) ('A' + Math.random() * 26);
                char c2 = (char) ('a' + Math.random() * 26);
                main.sayHi(value + c1 + c2);
            }
            System.gc();
            int val = System.in.read();
            if (val == '1')
                break;
        }
    }
}
</code></pre>

<pre><code class="language-c">#include &quot;Main.h&quot;

JNIEXPORT void JNICALL Java_Main_sayHi (JNIEnv *env, jobject jobj, jstring jstr)
{
    const char *str = (*env)-&gt;GetStringUTFChars(env, jstr, 0);
    int len = (*env)-&gt;GetStringUTFLength(env, jstr);
    printf(&quot;%p\n&quot;, str);
#ifdef SUCCESS
    (*env)-&gt;ReleaseStringUTFChars(env, jstr, str);
#endif
    return ;
}
</code></pre>

<p><a href="https://raw.githubusercontent.com/DorMOUSE-None/Repo/master/jni-memory-leak.zip">测试用的源代码</a></p>

<pre><code class="language-sh">$ java Main
$ pmap -x 22690 | sort -n -k3
# ...
00007f0d44000000   65536   65500   65500 rw---   [ anon ]
00007f0d04000000  131072  131068  131068 rw---   [ anon ]
00007f0cc4000000  131072  131072  131072 rw---   [ anon ]
00007f0ccc000000  131072  131072  131072 rw---   [ anon ]
00007f0cd4000000  131072  131072  131072 rw---   [ anon ]
00007f0cdc000000  131072  131072  131072 rw---   [ anon ]
00007f0ce4000000  131072  131072  131072 rw---   [ anon ]
00007f0cec000000  131072  131072  131072 rw---   [ anon ]
00007f0cf4000000  131072  131072  131072 rw---   [ anon ]
00007f0cfc000000  131072  131072  131072 rw---   [ anon ]
total kB         3822700 1293952 1276900 
</code></pre>

<p>确实引起了内存的增长，而将内存 dump 下了之后，也看到了大量字符串。</p>

<pre><code class="language-sh">$ PID=23756; grep rw-p /proc/${PID}/maps | sed -n 's/^\([0-9a-f]*\)-\([0-9a-f]*\) .*$/\1 \2/p' | while read start stop;  \
do \
    gdb --batch --pid ${PID} -ex &quot;dump memory ${PID}-$start-$stop.dump 0x$start 0x$stop&quot;;  \
done 
$ strings 23756-7f6f6c000000-7f6f70000000.dump| grep 'AAAA'
# ...
AAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHVn
AAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHXp
AAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHAAAAABBBBBCCCCCDDDDDEEEEEGGGGGHHHHHFn
</code></pre>

<p>待到添加上 <code>ReleaseStringUTFChars</code> ，申请到内存得到释放，确实解决了这个问题。</p>

<h2 id="总结">总结</h2>

<p>定位问题确实看起来不难，但这种异构代码，真正难点在于定位问题。这期间走了不少的弯路，也无法确定究竟是对是错。毕竟问题的原因多种多样：</p>

<ol>
<li>可能是 Java 代码用了诸如 Zip 等容易出现堆外内存泄露的方法</li>
<li>不当使用 JNI （就像是上文描述的问题）</li>
<li>再有就是第三方 C 库使用不当，或者其本身存在 BUG。</li>
</ol>

<p>这是第一次排查异构代码的问题，颇多难以分辨，无法做定论之事。</p>

<p>再就是 C 的平台相关性实在是太过于严重了，加之本就不太熟悉，搞个编译新的库文件就好一番折腾。</p>

<pre><code class="language-plain">  __                    __                  
 / _| __ _ _ __   __ _ / _| ___ _ __   __ _ 
| |_ / _` | '_ \ / _` | |_ / _ \ '_ \ / _` |
|  _| (_| | | | | (_| |  _|  __/ | | | (_| |
|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |
                 |___/                |___/ 
</code></pre>
  </div>
  
  <div class="pagination">
    <div class="pagination__title">
      <span
        class="pagination__title-h">Read other posts</span>
      <hr />
    </div>
    <div class="pagination__buttons">
      
      <span class="button previous">
        <a href="https://dormouse-none.github.io/posts/2019-07-17-understand-kernel-13/">
          <span class="button__icon">←</span>
          <span class="button__text">理解 Linux Kernel (13) - 虚拟内存</span>
        </a>
      </span>
      
      
      <span class="button next">
        <a href="https://dormouse-none.github.io/posts/2019-06-18-understand-kernel-12/">
          <span class="button__text">理解 Linux Kernel (12) - Linux 容器化技术</span>
          <span class="button__icon">→</span>
        </a>
      </span>
      
    </div>
  </div>
  

  

</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">
        <span>2018-2019 © ffutop</span>
        <span>:: Powered by <a href="http://gohugo.io">Hugo</a></span>
      </div>
    
  </div>
</footer>

<script src="https://dormouse-none.github.io/assets/main.js"></script>
<script src="https://dormouse-none.github.io/assets/prism.js"></script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>






  
</div>

</body>
</html>
