<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on Utop&#39;s Blog</title>
    <link>https://ffutop.github.io/tags/java/</link>
    <description>Recent content in Java on Utop&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>2018-2019 © ffutop</copyright>
    <lastBuildDate>Wed, 27 Feb 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://ffutop.github.io/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>【Java】API 参数误定义的后果</title>
      <link>https://ffutop.github.io/posts/2019-02-27-java-fatal-api/</link>
      <pubDate>Wed, 27 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ffutop.github.io/posts/2019-02-27-java-fatal-api/</guid>
      <description>&lt;p&gt;工程项目中，定义 API 总是一个慎之又慎的操作。不能少，不满足调用方的需求就惨了；也不能多，不然就乱套了，自己维护困难，调用方也开始了自我发挥。虽然足够慎重，但绝大多数都逃不过最终不得不“改” API 的情况。今天要讨论的是在同一个类内同方法名不同参数（入参/出参）的情况。&lt;/p&gt;

&lt;p&gt;想要做到同方法名不同入参，很简单，就是“重载（Overload）”，日常都在使用。不再赘述！&lt;/p&gt;

&lt;p&gt;想要做到同方法名不同出参，答案就不再那么肯定了。当然，如果问把&lt;code&gt;void add(int)&lt;/code&gt; API 改写成 &lt;code&gt;int add(int)&lt;/code&gt;，可能得到的大多数回答都是可以。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java Instrumentation</title>
      <link>https://ffutop.github.io/posts/2018-08-15-java-instrumentation/</link>
      <pubDate>Wed, 15 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ffutop.github.io/posts/2018-08-15-java-instrumentation/</guid>
      <description>&lt;h2 id=&#34;start&#34;&gt;Start&lt;/h2&gt;

&lt;p&gt;从现有的前置知识来说，我们能够认识到两个事实:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Java Class 通过 ClassLoader 进行加载。
通过&lt;code&gt;全限定名&lt;/code&gt;进行区分。当需要加载新的类时，ClassLoader 通过双亲委派机制判断是否已经加载过这个类。
换句话说: Class 一经加载，就不会尝试重复加载 (至少按绝大多数人的认知来说，确实是的)&lt;/li&gt;
&lt;li&gt;有没有可能让被加载的 Class 与物理存储上的 .class 内容不同。
当然也是完全可以做到的。不管怎么说，CGlib 和 Java Proxy 也是一个耳熟能详的概念吧
(虽然可能不了解细节。在此，欢迎学习前置技能 &lt;a href=&#34;https://dormouse-none.github.io/2018-07-10-CGlib-Enhancer/&#34;&gt;CGlib Enhancer 主流程源码解析&lt;/a&gt; 和 &lt;a href=&#34;https://dormouse-none.github.io/2018-07-20-Java-Proxy/&#34;&gt;Java Proxy 源码解析&lt;/a&gt;。不过不影响本文后续内容)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;另一个方面，也许绝大多数人都听说过所谓的&lt;code&gt;热部署&lt;/code&gt;。但是究竟怎么才能做到 &lt;code&gt;热部署&lt;/code&gt;(话题开得有点大哈。Y_Y 本文不讲这个)&lt;/p&gt;

&lt;p&gt;操作字节码一定是一个逃不开的话题，毕竟 Class 就是所谓的被加载到内存的字节码嘛。&lt;/p&gt;

&lt;p&gt;如何操作字节码? ASM, CGlib, Java Proxy, Javassist ? 不过这些都要等到需要被操作的类被加载了才行啊，似乎有点晚&amp;hellip;&lt;/p&gt;

&lt;p&gt;Java 提供了一个可行的机制，用来在 ClassLoader 加载字节码之前完成对操作字节码的目的&lt;/p&gt;

&lt;h2 id=&#34;instrumentation&#34;&gt;Instrumentation&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;java.lang.instrument.Instrumentation&lt;/code&gt; 类为提供直接操作 Java 字节码的又一个途径(虽然 Java Doc 的说明是用来检测 Java 代码的)&lt;/p&gt;

&lt;p&gt;相信我这个说明是没有问题的。毕竟完成对代码检测的途径是直接修改字节码。&lt;/p&gt;

&lt;p&gt;下列有两种方法可以达到目的&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;当 JVM 以指示一个代理类的方式启动时，将传递给代理类的 premain 方法一个 Instrumentation 实例。&lt;/li&gt;
&lt;li&gt;当 JVM 提供某种机制在 JVM 启动之后某一时刻启动代理时，将传递给代理代码的 agentmain 方法一个 Instrumentation 实例。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;话不多说，下面将全部以实例来展现对这种 JVM 检测机制(虽然例子已经脱离了*检测*的目的)的使用&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java 安全访问与权限控制</title>
      <link>https://ffutop.github.io/posts/2018-07-04-jdk-permission/</link>
      <pubDate>Wed, 04 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ffutop.github.io/posts/2018-07-04-jdk-permission/</guid>
      <description>&lt;h2 id=&#34;绪论&#34;&gt;绪论&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;本文只是对 Java 安全访问与权限控制的基础性探究。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;本节与全文内容无关，如无兴趣阅读，可以跳过&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;了解 Java 安全访问相关内容的初衷，是准备在项目中利用 Java 标准库提供的 ServiceLoader 对 SPI 实现类进行&amp;rdquo;自动发现&amp;rdquo;和加载。
这对于将本项目作为二方库来依赖的上层项目将更为方便，只需要
1. 在 &lt;code&gt;META-INF.services&lt;/code&gt; 目录下配置被命名为 SPI 接口全限定名的文件及添加相关内容
2. 由项目的注册管理器触发下列 Java 代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;{
    ServiceLoader&amp;lt;XxxPolicy&amp;gt; xxxPolicyServiceLoader = ServiceLoader.load(XxxPolicy.class);
    for (Iterator&amp;lt;XxxPolicy&amp;gt; it = xxxPolicyServiceLoader.iterator(); it.hasNext(); ) {
        XxxPolicy xxxPolicy = it.next();
        // ... more code ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就可以完成一个新的 SPI 策略的注册工作。&lt;/p&gt;

&lt;p&gt;但是，在尝试实现，了解了 ServiceLoader 源码，以及 DriverManager 和 mysql-connection-java-&lt;version&gt;.jar 在注册 Driver 相关的代码。
发现怎么也绕不开 Java 安全访问相关的内容。诸如下列这段来自 DriverManager.loadInitialDrivers() 的代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;AccessController.doPrivileged(new PrivilegedAction&amp;lt;Void&amp;gt;() {
    public Void run() {

        ServiceLoader&amp;lt;Driver&amp;gt; loadedDrivers = ServiceLoader.load(Driver.class);
        Iterator&amp;lt;Driver&amp;gt; driversIterator = loadedDrivers.iterator();

        try{
            while(driversIterator.hasNext()) {
            driversIterator.next();
            }
        } catch(Throwable t) {
                // Do nothing
        }
        return null;
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;诸如 AccessController, Permission, SecurityManager 的代码始终是一个绕不开的主旋律。&lt;/p&gt;

&lt;p&gt;为了探究这部分控制对项目中 ServiceLoader 的真正作用以及其编码意义，开始了对本文所描述的主体内容的初步了解。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ASM 核心包基本内容漫谈</title>
      <link>https://ffutop.github.io/posts/2018-06-25-asm-core/</link>
      <pubDate>Mon, 25 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ffutop.github.io/posts/2018-06-25-asm-core/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文描述的 ASM 指的是 OW2 ASM&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;asm-core-的结构&#34;&gt;ASM-Core 的结构&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;首先是一些概述性的内容。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;由于 ASM 操作的 JAVA 字节码有严格的格式规定，且即使随着 JVM 标准的升级也极少出现重大调整。
因此适用面狭窄的访问者模式在该项目中被大量地使用，并且已经到了丧心病狂的程度:)&lt;/p&gt;

&lt;p&gt;从核心包声明的类来看，主要包括:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;ClassReader - 作为结构化对象，将接收(accept)访问者的访问&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;几种访问者抽象类以及相应的实现类&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;AnnotationVisitor -&amp;gt; AnnotationWriter&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ClassVisitor -&amp;gt; ClassWriter&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;FieldVisitor -&amp;gt; FieldWriter&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;MethodVisitor -&amp;gt; MethodWriter&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ModuleVisitor -&amp;gt; ModuleWriter&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Opcodes &amp;amp; Constants - ClassFile 中描述的大量常量符号与值&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;其它一些辅助的类&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Attribute - 用于处理非标准化的属性(ClassFile 允许&lt;a href=&#34;https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html&#34;&gt;JVMS&lt;/a&gt; 中未定义的 Attribute)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ByteArray - 动态可自适应的 byte[] (字节数组)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Context - ClassReader 在被解析(被访问)过程中用于表示“累积状态”的一个类/对象&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Symbol - 用于表示 ClassFile 中描述的 Constant 的基类&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;SymbolTable - 用于存储常量池对象&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;其它内容省略&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>java-memory-model</title>
      <link>https://ffutop.github.io/posts/2018-06-21-java-memory-model/</link>
      <pubDate>Thu, 21 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ffutop.github.io/posts/2018-06-21-java-memory-model/</guid>
      <description>&lt;h2 id=&#34;jvm-运行时数据区&#34;&gt;JVM 运行时数据区&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://ws4.sinaimg.cn/large/006tNc79gy1ft5osi6it1j31kw0ql78e.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>