<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Spring JDBC 源码学习 · Utop's Blog</title><meta name="description" content="Spring JDBC 源码学习 - Utop"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://utop.xin/atom.xml" title="Utop's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/DorMOUSE-None" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Spring JDBC 源码学习</h1><div class="post-info">Jun 12, 2018</div><div class="post-content"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>
<p>#Spring JDBC 源码学习</p>
<p>[TOC]</p>
<p>##概览</p>
<p>在学习 Spring-JDBC 之前，我们有必要从 Java 原生提供的 JDBC 开始，对 JDBC 操作的一整套完整的流程有一个清晰的概念。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * copied from https://www.tutorialspoint.com/jdbc/jdbc-sample-code.htm</span></span><br><span class="line"><span class="comment"> * updated by DorMOUSENone</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//STEP 1. 引入必须的包</span></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">	<span class="comment">// JDBC 驱动名 与 DB URL </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String JDBC_DRIVER = <span class="string">"com.mysql.jdbc.Driver"</span>;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DB_URL = <span class="string">"jdbc:mysql://&lt;host&gt;:&lt;port&gt;/&lt;dbName&gt;"</span>;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 数据库登录验证 (用户名、密码等)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String USER = <span class="string">"username"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String PASS = <span class="string">"password"</span>;</span><br><span class="line">   </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Connection conn = <span class="keyword">null</span>;</span><br><span class="line">		Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="comment">//STEP 2: 注册驱动(注册到驱动管理器 DriverManager 类中)</span></span><br><span class="line">			Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//STEP 3: 创建一个连接</span></span><br><span class="line">          	System.out.println(<span class="string">"Connecting to database..."</span>);</span><br><span class="line">          	conn = DriverManager.getConnection(DB_URL,USER,PASS);</span><br><span class="line"></span><br><span class="line">          	<span class="comment">//STEP 4: 执行一个查询</span></span><br><span class="line">          	System.out.println(<span class="string">"Creating statement..."</span>);</span><br><span class="line">          	stmt = conn.createStatement();</span><br><span class="line">          	String sql;</span><br><span class="line">          	sql = <span class="string">"SELECT id, first, last, age FROM Employees"</span>;</span><br><span class="line">          	ResultSet rs = stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">          	<span class="comment">//STEP 5: 将结果从结果集(ResultSet)中取出</span></span><br><span class="line">          	<span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">             	<span class="comment">//根据列名逐一取出数据</span></span><br><span class="line">             	<span class="keyword">int</span> id  = rs.getInt(<span class="string">"id"</span>);</span><br><span class="line">             	<span class="keyword">int</span> age = rs.getInt(<span class="string">"age"</span>);</span><br><span class="line">             	String first = rs.getString(<span class="string">"first"</span>);</span><br><span class="line">             	String last = rs.getString(<span class="string">"last"</span>);</span><br><span class="line"></span><br><span class="line">             	<span class="comment">//展示结果</span></span><br><span class="line">             	System.out.print(<span class="string">"ID: "</span> + id);</span><br><span class="line">             	System.out.print(<span class="string">", Age: "</span> + age);</span><br><span class="line">             	System.out.print(<span class="string">", First: "</span> + first);</span><br><span class="line">             	System.out.println(<span class="string">", Last: "</span> + last);</span><br><span class="line">          	&#125;</span><br><span class="line">          	<span class="comment">//STEP 6: 清理环境</span></span><br><span class="line">          	rs.close();</span><br><span class="line">          	stmt.close();</span><br><span class="line">          	conn.close();</span><br><span class="line">       	&#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">          	<span class="comment">//处理 JDBC 错误</span></span><br><span class="line">          	se.printStackTrace();</span><br><span class="line">       	&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">          	<span class="comment">//处理 Class.forName() 引起的错误</span></span><br><span class="line">          	e.printStackTrace();</span><br><span class="line">       	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">          	<span class="comment">// finally 代码库来关闭资源</span></span><br><span class="line">          	<span class="keyword">try</span>&#123;</span><br><span class="line">            	<span class="keyword">if</span>(stmt!=<span class="keyword">null</span>)</span><br><span class="line">                	stmt.close();</span><br><span class="line">          	&#125;<span class="keyword">catch</span>(SQLException se2)&#123;</span><br><span class="line">          	&#125;<span class="comment">// 不做任何处理</span></span><br><span class="line">          	<span class="keyword">try</span>&#123;</span><br><span class="line">           		<span class="keyword">if</span>(conn!=<span class="keyword">null</span>)</span><br><span class="line">                	conn.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">               	se.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">       	&#125;</span><br><span class="line">       	System.out.println(<span class="string">"Goodbye!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的通用 JDBC 代码可以看到，利用 Java 原生提供的 java.sql.* 包可以完成注册驱动，创建连接，执行查询，处理结果等一系列一整套操作。</p>
<p>而 Spring-JDBC 对于 Java 原生提供的 JDBC ，对一系列数据及操作进行了整合：</p>
<ol>
<li>实现了 DataSource 接口，用于整合数据源配置，将各种零散的属性值（诸如 URL、用户名、 密码等）整合成完整的一个对象，便于重用；也实现了 getConnection(…) 接口，便于直接通过 DataSource 获取连接。</li>
<li>对执行查询的流程进行了封装。</li>
<li>对结果集的处理提供了多种接口，针对不同的应用场景可自由选择所必须的实现类。例如直接通过 JDBC 获得 Bean ，而无需如上例 39-42 行所示，逐一编码进行提取。</li>
</ol>
<p>本节提供对《Spring-JDBC 源码学习》完整学习过程的一个梳理：</p>
<ol>
<li><a href="http://blog.csdn.net/dormousenone/article/details/79035440" target="_blank" rel="noopener">JdbcTemplate</a> 一节作为学习 Spring-jdbc 的切入点，是 org.springframework.jdbc.core 包中的核心类，是一个提供不同场景下数据库操作的模板类。主要描述其持有的属性 DataSource 等以及其实现的方法。</li>
<li><a href="http://blog.csdn.net/dormousenone/article/details/79037012" target="_blank" rel="noopener">DataSource</a> 一节承接 JdbcTemplate 一节，提供 Spring-jdbc 对数据源的一个包装与应用。同时描述其核心方法 getConnection(…) 的实现。</li>
<li><a href="http://blog.csdn.net/dormousenone/article/details/79042212" target="_blank" rel="noopener">DriverManager</a> 描述其对不同数据库供应商提供的驱动的管理与使用方法。同时简单描述通过具体驱动获得一个连接的实现。</li>
<li><a href="http://blog.csdn.net/dormousenone/article/details/79046865" target="_blank" rel="noopener">PreparedStatement &amp; CallableStatement</a> 一节主要表述 Spring-jdbc 如何对执行查询的流程进行了封装。特别是对于 PreparedStatement 与 CallableStatement 这类预置可变 SQL 语句，在执行前必须对其中可变参数进行补全的 Statement 。</li>
<li><a href="http://blog.csdn.net/dormousenone/article/details/79062275" target="_blank" rel="noopener">ResultSet</a> 描述 Spring-jdbc 如何对结果集进行处理，提供了多种不同的接口实现不同的处理逻辑。这种封装后的操作可以极大地简化直接使用 Java 原生 JDBC 所必须的硬编码提取数据的问题。</li>
</ol>
<h2 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h2><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fn90ghu9ufj30ki0jm75t.jpg" alt=""></p>
<p>JdbcTemplate 类作为 org.springframework.core 包下的核心类，对 Java 实现的 JDBC 进行了一定程度的封装，可以简化 JDBC 的使用，同时避免许多常见的错误。由该类来执行 JDBC 工作流，应用程序只需要提供 SQL 语句就可以获得 DB 执行结果（😀，当然实际操作上没有描述的这么简单）。</p>
<p><strong>使用 JdbcTemplate 类只需要实现两个回调接口 PreparedStatementCreator (创建一个 PreparedStatement，给定连接，提供 SQL 语句以及必要的参数), ResultSetExtractor (用于花式获取结果集)。当然，不实现上述两个接口也可以进行简单的数据库操作，比如只通过 JdbcTemplate 获取一个连接(Connection) 或者执行一个静态 SQL Update。</strong></p>
<p><em>看不懂无所谓，先继续向下看，会做更详细的讲解。</em></p>
<h3 id="JdbcAccessor"><a href="#JdbcAccessor" class="headerlink" title="JdbcAccessor"></a>JdbcAccessor</h3><p>首先了解 JdbcTemplate 的实现，JdbcTemplate 继承了 JdbcAccessor 抽象类，该抽象类有两个主要属性—— <strong>DataSource dataSource</strong> &amp; <strong>SQLExceptionTranslator exceptionTranslator</strong> ，以及一个懒加载标识符 <strong>lazyInit</strong> 。</p>
<p>其中，</p>
<ul>
<li>DataSource 可以认为是一个存储有与数据库相关的属性实例，主要方法包括 <code>Connection getConnection()</code> &amp; <code>Connection getConnection(String username, String password)</code> 。</li>
<li>SQLExceptionTranslator 利用策略模式将 Java 定义的 SQLException 转换成 Spring 声明的 DataAccessException。</li>
</ul>
<p>JdbcAccessor 实现的 InitializingBean 接口，InitializingBean 接口为 Bean 提供了一个初始化实例的方法 —— afterPropertiesSet() 方法，凡是继承该接口的类，一般都在类构造方法中执行该方法。同样的，声明初始化实例调用的方法还可采用 <code>&lt;bean id=&quot;&quot; class=&quot;&quot; init-method=&quot;myInitMethod&quot;/&gt;</code> 在初始化 bean 时执行 myInitMethod() 方法。具体执行顺序为 ：</p>
<ol>
<li>bean 的属性注入</li>
<li>调用 afterPropertiesSet() 方法</li>
<li>执行 myInitMethod() 方法</li>
</ol>
<p>此处继承该接口是为了实现 DataSource 验证以及 SQLExceptionTranslator 的懒加载 OR NOT 的选择。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (getDataSource() == <span class="keyword">null</span>) &#123;	<span class="comment">// 判断是否注入了 DataSource</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Property 'dataSource' is required"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!isLazyInit()) &#123;	<span class="comment">// 根据懒加载标识符选择执行与否</span></span><br><span class="line">		getExceptionTranslator();	<span class="comment">// 获取一个 SQLExceptionTranslator 实例</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法在 BeanFactory 完成该 bean 的依赖注入后执行，将首先判断 DataSource 是否已经被注入，再根据懒加载标识符来决定是否实例化一个 SQLExceptionTranslator 。</p>
<p>###JdbcOperations</p>
<p>同时，JdbcTemplate 类实现了 JdbcOperations 接口，该接口定义了基本的 JDBC 操作。基本方法如下：</p>
<ol>
<li><code>&lt;T&gt; T execute(ConnectionCallback&lt;T&gt; action);</code></li>
<li><code>&lt;T&gt; T execute(StatementCallback&lt;T&gt; action);</code></li>
<li><code>&lt;T&gt; T execute(PreparedStatementCreator psc, PreparedStatementCallback&lt;T&gt; action);</code></li>
<li><code>&lt;T&gt; T execute(CallableStatementCreator csc, CallableStatementCallback&lt;T&gt; action);</code></li>
</ol>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fncp2ncqd6j31j00au0uv.jpg" alt=""></p>
<p>其它的 execute(…) , query(…), update(…) 等最终都将调用上述 4 种方法其一来完成目的。</p>
<p>详细观察上述方法的入参， ConnectionCallback, StatementCallback, PreparedStatementCallback 和 CallableStatementCallback 四个 Callback 接口，分别都是函数式接口，其中的唯一方法 doInXXX() 将在 execute() 中被调用，以此实现获得 ResultSet 并返回 Result 。execute 中调用 doInXXX() 的通用代码如下 （以 Statement 为例）：</p>
<p><em>对于不理解<strong>回调</strong>的同学，请自行了解概念</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(StatementCallback&lt;T&gt; action)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">	<span class="comment">// 通过工具类 DataSourceUtils 获取一个连接</span></span><br><span class="line">  	Connection con = DataSourceUtils.getConnection(obtainDataSource());</span><br><span class="line">  	<span class="comment">// 一个 Statement 空实例，PreparedStatement, CallableStatement 类似</span></span><br><span class="line">	Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		stmt = con.createStatement();	<span class="comment">// 通过连接(Connection)获取一个 Statement</span></span><br><span class="line">		applyStatementSettings(stmt);	<span class="comment">// 配置 Statement 参数</span></span><br><span class="line">      	<span class="comment">// 回调执行 doInXXX() 方法, 并获得 result</span></span><br><span class="line">		T result = action.doInStatement(stmt);	</span><br><span class="line">		handleWarnings(stmt);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">		<span class="comment">// Release Connection early, to avoid potential connection pool deadlock</span></span><br><span class="line">		<span class="comment">// in the case when the exception translator hasn't been initialized yet.</span></span><br><span class="line">		String sql = getSql(action);</span><br><span class="line">		JdbcUtils.closeStatement(stmt);</span><br><span class="line">		stmt = <span class="keyword">null</span>;</span><br><span class="line">		DataSourceUtils.releaseConnection(con, getDataSource());</span><br><span class="line">		con = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">throw</span> translateException(<span class="string">"StatementCallback"</span>, sql, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		JdbcUtils.closeStatement(stmt);</span><br><span class="line">		DataSourceUtils.releaseConnection(con, getDataSource());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 Statement, PreparedStatement, CallableStatement 的区别，首先下图表现了三个接口的继承关系。</p>
<ul>
<li>Statement 可以支持静态 SQL 语句</li>
<li>PreparedStatement 支持可变参数的 SQL 语句</li>
<li>CallableStatement 支持可变参数的 SQL 语句，并且支持定制 DB 的输出结果</li>
</ul>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fncpaec17yj30ew0hcdh7.jpg" alt=""></p>
<p>##DataSource</p>
<p>上一节在粗略地了解了 JdbcTemplate 提供的方法之后，下面先来对 DataSource 做一点了解。</p>
<p>###Java 提供的 DataSource 定义</p>
<p>DataSource 是 Java 核心库提供的接口。位于 javax.sql package 下。</p>
<p>DataSource 接口可以被视作是一个提供物理 DB 实例连接(Connection) 的工厂，通过 DataSource 持有的各种属性（包括 DB Url, Username, Password 等）来获取一个连接(Connection) 。DataSource 接口有三种不同的实现方案：</p>
<ol>
<li>最基本的实现——生产一个标准连接(Connection) 对象</li>
<li>连接池方案——生产会被自动添加到连接池的对象</li>
<li>分布式事物实现——生产一个可以支持分布式事物，并默认被添加到连接池的连接对象</li>
</ol>
<p>包括两个对外提供连接(Connection) 对象的方法，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="function">Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure>
<p>其父接口 CommonDataSource 提供设置/获取 LogWriter，登录 DB 超时时间和获取父 Logger 的方法。</p>
<p>###Spring-JDBC 扩展的 DataSource 定义</p>
<p>在 Spring-jdbc 下，DataSources 最顶级的类是 AbstractDataSource ，对 DataSource 的所有父接口方法做了实现。但保留 getConnection() 方法由子类实现。</p>
<p>在 AbstractDriverBasedDataSource 中，定义了大量的参数，诸如 url, username 等，这些都被用来定位并定义与数据库实例的连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDriverBasedDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> String catalog;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> String schema;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="comment">// 可以看到此处有一个 Properties 类</span></span><br><span class="line">   <span class="keyword">private</span> Properties connectionProperties;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 省略若干方法</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">      	<span class="comment">// 调用内部方法 getConnectionFromDriver()</span></span><br><span class="line">		<span class="keyword">return</span> getConnectionFromDriver(getUsername(), getPassword());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">      	<span class="comment">// 调用内部方法 getConnectionFromDriver()</span></span><br><span class="line">		<span class="keyword">return</span> getConnectionFromDriver(username, password);</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 定义了一个获取 Connection 的方法，由 getConnection() 方法调用，</span></span><br><span class="line">   <span class="comment">// 此方法主要是将属性做了一个整合</span></span><br><span class="line">   <span class="comment">// 具体获取 Connection 的逻辑仍然下放到子类实现 见 40 行</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> Connection <span class="title">getConnectionFromDriver</span><span class="params">(@Nullable String username, @Nullable String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">		Properties mergedProps = <span class="keyword">new</span> Properties();</span><br><span class="line">		Properties connProps = getConnectionProperties();</span><br><span class="line">		<span class="keyword">if</span> (connProps != <span class="keyword">null</span>) &#123;</span><br><span class="line">			mergedProps.putAll(connProps);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (username != <span class="keyword">null</span>) &#123;</span><br><span class="line">			mergedProps.setProperty(<span class="string">"user"</span>, username);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (password != <span class="keyword">null</span>) &#123;</span><br><span class="line">			mergedProps.setProperty(<span class="string">"password"</span>, password);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">     	<span class="comment">// 获取 Connection 逻辑下放</span></span><br><span class="line">		Connection con = getConnectionFromDriver(mergedProps);</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.catalog != <span class="keyword">null</span>) &#123;</span><br><span class="line">			con.setCatalog(<span class="keyword">this</span>.catalog);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.schema != <span class="keyword">null</span>) &#123;</span><br><span class="line">			con.setSchema(<span class="keyword">this</span>.schema);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> con;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 该类中获取 Connection 的方法是抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Connection <span class="title">getConnectionFromDriver</span><span class="params">(Properties props)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整合方案为将除 url 外的所有参数整合在同一个 Properties 对象中 (其中，Properties 可以被认为是一个线程安全的 Hash Map) 。最终调用 <code>Connection getConnectionFromDriver(Properties props)</code> 获取连接。</p>
<p>AbstractDriverBasedDataSource 抽象类的两个子类 DriverManagerDataSource 和 SimpleDriverDataSource 都以不同方式获得了连接(Connection)，但总结而言，获取连接(Connection) 的任务被委托给了 Driver 来实现（其中，Driver 有 Java 定义接口，并由各数据库提供商提供，例如 MySQL 提供了 mysql-connector-java-XXX.jar 来完成针对相应数据库的具体实现）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ----------------------------</span></span><br><span class="line"><span class="comment">// SimpleDriverDataSource 的实现</span></span><br><span class="line"><span class="comment">// ----------------------------</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Connection <span class="title">getConnectionFromDriver</span><span class="params">(Properties props)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">	Driver driver = getDriver();</span><br><span class="line">	String url = getUrl();</span><br><span class="line">	Assert.notNull(driver, <span class="string">"Driver must not be null"</span>);</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">"Creating new JDBC Driver Connection to ["</span> + url + <span class="string">"]"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">  	<span class="comment">// 哈哈，重点在这... driver 在该类中被预先注入</span></span><br><span class="line">	<span class="keyword">return</span> driver.connect(url, props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------</span></span><br><span class="line"><span class="comment">// DriverManagerDataSource 的实现</span></span><br><span class="line"><span class="comment">// -----------------------------</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Connection <span class="title">getConnectionFromDriver</span><span class="params">(Properties props)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">	String url = getUrl();</span><br><span class="line">	Assert.state(url != <span class="keyword">null</span>, <span class="string">"'url' not set"</span>);</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">"Creating new JDBC DriverManager Connection to ["</span> + url + <span class="string">"]"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">  	<span class="comment">// 调了个内部函数</span></span><br><span class="line">	<span class="keyword">return</span> getConnectionFromDriverManager(url, props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Connection <span class="title">getConnectionFromDriverManager</span><span class="params">(String url, Properties props)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// 委托给 DriverManager 类来获取连接</span></span><br><span class="line">    <span class="comment">// DriverManager 的主要操作是遍历在该管理类中注册的 Driver</span></span><br><span class="line">    <span class="comment">// 每个 Driver 实例都去尝试一下，能不能获得一个连接</span></span><br><span class="line">    <span class="comment">// 第一次在某个 Driver 中拿到一个连接即返回连接 (Connection)</span></span><br><span class="line">	<span class="keyword">return</span> DriverManager.getConnection(url, props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简要的类图如下：</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fncrgqcjqoj31es15ajxj.jpg" alt=""></p>
<h2 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h2><p>上面提到 DataSource 获取连接(Connection) 的操作实质上将委托具体的 Driver 来提供 Connection 。有两种不同的方式，包括经由 DriverManager 遍历所有处于管理下的 Driver 尝试获取连接，或者在 DataSource 实例中直接声明一个特定的 Driver 来获取连接。</p>
<p>对于获取连接的具体操作，挖坑-待填。只描述简单的数据库供应商提供的 Driver 如何与 java 相联系。</p>
<p>###在 DriverManager 中注册 Driver 实例</p>
<p>通常在与数据库交互逻辑的 Java 代码中，都会有 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code> (此处以 MySQL 提供的 mysql-connector-java-XXX.jar 为例，下同）的代码块，加载指定的 com.mysql.jdbc.Driver 为 java.lang.Class 类。</p>
<p><em>当然，在 JDBC 4.0 标准下，可以不必再显示声明 <code>Class.forName(&quot;&quot;)</code> 语句，Driver 也同样会在 DriverManager 初始化时自动注册。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Class 类中对于 forName(String className) 的方法</span></span><br><span class="line"><span class="comment">// 作用为返回一个 java.lang.Class 实例。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>同时， JVM 在加载类的过程中会执行类中的 static 代码块。下述 row 10 ~ 16 的代码片段将被执行。唯一的逻辑就是 new 一个 com.mysql.jdbc.Driver 实例，并将实例注册(registerDriver) 到 <strong>java.sql.DriverManager</strong> 中。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mysql.jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">extends</span> <span class="title">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">sql</span>.<span class="title">Driver</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ~ Static fields/initializers</span></span><br><span class="line">	<span class="comment">// ---------------------------------------------</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Register ourselves with the DriverManager</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't register driver!"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ~ Constructors</span></span><br><span class="line">	<span class="comment">// -----------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Construct a new driver and register it with DriverManager</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">	 *             if a database error occurs.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">		<span class="comment">// Required for Class.forName().newInstance()</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面再来看一下 DriverManager 中的 registerDriver() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DriverManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// DriverManager 维护一个线程安全的 Driver 列表</span></span><br><span class="line">  	<span class="comment">// 此处的 DriverInfo 里面即包装了 Driver </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = </span><br><span class="line">      	<span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 在 DriverManager 中注册 Driver</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">registerDriver</span><span class="params">(java.sql.Driver driver)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        registerDriver(driver, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">registerDriver</span><span class="params">(java.sql.Driver driver,</span></span></span><br><span class="line"><span class="function"><span class="params">            DriverAction da)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">      	<span class="comment">/* 如果当前 Driver 不在列表中，即添加到列表。 */</span></span><br><span class="line">        <span class="keyword">if</span>(driver != <span class="keyword">null</span>) &#123;</span><br><span class="line">            registeredDrivers.addIfAbsent(<span class="keyword">new</span> DriverInfo(driver, da));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// This is for compatibility with the original DriverManager</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"registerDriver: "</span> + driver);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###通过 DriverManager 获取连接(Connection)</p>
<p>上一节有提到过可以通过 DriverManager 来遍历获取连接，也可以直接声明具体 Driver 并获取连接。下面代码展示的是通过 DriverManager 获取连接的操作。 <del>哈哈哈，反正最后都是由具体驱动实现获取连接。</del></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DriverManager</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 获取连接的 public 接口 (1)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(String url,</span></span></span><br><span class="line"><span class="function"><span class="params">		java.util.Properties info)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取连接的 public 接口 (2)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(String url,</span></span></span><br><span class="line"><span class="function"><span class="params">        String user, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        java.util.Properties info = <span class="keyword">new</span> java.util.Properties();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">            info.put(<span class="string">"user"</span>, user);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (password != <span class="keyword">null</span>) &#123;</span><br><span class="line">            info.put(<span class="string">"password"</span>, password);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 获取连接的 public 接口 (3)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(String url)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        java.util.Properties info = <span class="keyword">new</span> java.util.Properties();</span><br><span class="line">        <span class="keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  	<span class="comment">// 获取连接的内部逻辑实现</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        String url, java.util.Properties info, Class&lt;?&gt; caller)</span> </span></span><br><span class="line"><span class="function">      	<span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * When callerCl is null, we should check the application's</span></span><br><span class="line"><span class="comment">         * (which is invoking this class indirectly)</span></span><br><span class="line"><span class="comment">         * classloader, so that the JDBC driver class outside rt.jar</span></span><br><span class="line"><span class="comment">         * can be loaded from here.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ClassLoader callerCL = caller != <span class="keyword">null</span> ? caller.getClassLoader() : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span>(DriverManager.class) &#123;</span><br><span class="line">            <span class="comment">// synchronize loading of the correct classloader.</span></span><br><span class="line">            <span class="keyword">if</span> (callerCL == <span class="keyword">null</span>) &#123;</span><br><span class="line">                callerCL = Thread.currentThread().getContextClassLoader();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// url 是定位 DBMS 最重要的参数，不能为空</span></span><br><span class="line">        <span class="keyword">if</span>(url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"The url cannot be null"</span>, <span class="string">"08001"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"DriverManager.getConnection(\""</span> + url + <span class="string">"\")"</span>);</span><br><span class="line"></span><br><span class="line">      	<span class="comment">// 遍历所有注册的 Driver ，并都尝试获取连接(Connection)</span></span><br><span class="line">        SQLException reason = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(DriverInfo aDriver : registeredDrivers) &#123;</span><br><span class="line">          	<span class="comment">// 判断注册的 Driver 是否由 ClassLoader callerCL 加载，不是则跳过</span></span><br><span class="line">            <span class="keyword">if</span>(isDriverAllowed(aDriver.driver, callerCL)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    println(<span class="string">"    trying "</span> + aDriver.driver.getClass().getName());</span><br><span class="line">                    <span class="comment">// 获取连接，:) 还是由 driver 实例自行提供</span></span><br><span class="line">                  	Connection con = aDriver.driver.connect(url, info);</span><br><span class="line">                    <span class="keyword">if</span> (con != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// Success!</span></span><br><span class="line">                        println(<span class="string">"getConnection returning "</span> + </span><br><span class="line">                                aDriver.driver.getClass().getName());</span><br><span class="line">                        <span class="keyword">return</span> (con);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (reason == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        reason = ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                println(<span class="string">"    skipping: "</span> + aDriver.getClass().getName());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果运行到下列代码，则表明获取连接失败，抛出错误</span></span><br><span class="line">        <span class="keyword">if</span> (reason != <span class="keyword">null</span>)    &#123;</span><br><span class="line">            println(<span class="string">"getConnection failed: "</span> + reason);</span><br><span class="line">            <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"getConnection: no suitable driver found for "</span>+ url);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"No suitable driver found for "</span>+ url, <span class="string">"08001"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>简单的提一嘴，Connection 仍然只是一个针对 Java -&gt; DB Server 的上层接口，如果想要更深层次地了解 Connection 与 DB Server 的交互，可以尝试去看一下 com.mysql.jdbc.MysqlIO 类，MySQL 实现的 JDBC4Connection 类也是在使用该类来实现对 DB Server 交互。（哈哈，只看过 MySQL 提供的 Driver 包）。</em></p>
<h2 id="PreparedStatement-amp-CallableStatement"><a href="#PreparedStatement-amp-CallableStatement" class="headerlink" title="PreparedStatement &amp; CallableStatement"></a>PreparedStatement &amp; CallableStatement</h2><p>在了解了 DataSource 获取连接(Connection) 的实质以及 JdbcTemplate 的通用接口之后，使用 Spring-jdbc 进行数据库相关的操作可以直截了当的利用如下代码进行实现（此处仅展示通过 Java 硬编码的形式进行实现，XML 配置方法类似）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 定义数据源</span></span><br><span class="line">	DriverManagerDataSource dataSource = <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">  	<span class="comment">// 配置参数</span></span><br><span class="line">	dataSource.setUrl(<span class="string">"jdbc:mysql://&lt;host&gt;:&lt;port&gt;/&lt;dbName&gt;?&lt;props&gt;"</span>);</span><br><span class="line">   	dataSource.setUsername(<span class="string">"&lt;username&gt;"</span>);</span><br><span class="line">    dataSource.setPassword(<span class="string">"&lt;passwd&gt;"</span>);</span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">// 实例化一个 JDBC 工具类</span></span><br><span class="line">  	JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">  	<span class="comment">// 执行相关 CRUD 操作	</span></span><br><span class="line">  	jdbcTemplate.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回顾第一节所讲的 JdbcTemplate 的 4 个基础方法：</p>
<ol>
<li><code>&lt;T&gt; T execute(ConnectionCallback&lt;T&gt; action);</code></li>
<li><code>&lt;T&gt; T execute(StatementCallback&lt;T&gt; action);</code></li>
<li><code>&lt;T&gt; T execute(PreparedStatementCreator psc, PreparedStatementCallback&lt;T&gt; action);</code></li>
<li><code>&lt;T&gt; T execute(CallableStatementCreator csc, CallableStatementCallback&lt;T&gt; action);</code></li>
</ol>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fndsm5tl7aj30zg0byq47.jpg" alt=""></p>
<p>四个基础方法都有一个特定的回调函数将通过预配置的 DataSource 得到的 Connection 或 更进一步的 Statement or PreparedStatement or CallableStatement 作为入参来执行定义的唯一方法。</p>
<p>以 <code>&lt;T&gt; T execute(StatementCallback&lt;T&gt; action);</code> 为例来了解一下方法的核心逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(StatementCallback&lt;T&gt; action)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">	<span class="comment">// 通过工具类 DataSourceUtils 获取一个连接</span></span><br><span class="line">  	Connection con = DataSourceUtils.getConnection(obtainDataSource());</span><br><span class="line">  	<span class="comment">// 一个 Statement 空实例，PreparedStatement, CallableStatement 类似</span></span><br><span class="line">	Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		stmt = con.createStatement();	<span class="comment">// 通过连接(Connection)获取一个 Statement</span></span><br><span class="line">		applyStatementSettings(stmt);	<span class="comment">// 配置 Statement 参数</span></span><br><span class="line">      	<span class="comment">// 回调执行 doInXXX() 方法, 并获得 result</span></span><br><span class="line">		T result = action.doInStatement(stmt);	</span><br><span class="line">		handleWarnings(stmt);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span>() &#123;</span><br><span class="line">      </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，对于 PreparedStatement 和 CallableStatement 而言，获取一个 <em>XXX</em>Statement 的方式就有所不同了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 Statement 实例</span></span><br><span class="line">Statement stmt = con.createStatement();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 PreparedStatement 实例</span></span><br><span class="line"><span class="comment">// psc 是一个 PreparedStatementCreator 接口实现的实例</span></span><br><span class="line">PreparedStatement ps = psc.createPreparedStatement(con);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 CallableStatement 实例</span></span><br><span class="line"><span class="comment">// csc 是一个 CallableStatementCreator 接口实现的实例</span></span><br><span class="line">CallableStatement cs = csc.createCallableStatement(con);</span><br></pre></td></tr></table></figure>
<p>可以看到 Statement 直接通过 Connection 获取实例，但是 PreparedStatement 和 CallableStatement 就有所不同，其区别就在于 PreparedStatement 和 CallableStatement 两个 Statement 都是可以定制入参的，更甚者， CallableStatement 可以定制 DB 执行结果的出参。当然，核心还是 <code>con.prepareStatement() OR con.prepareCall()</code> 方法，只不过是将获取 XXXStatement 的操作下放给 XXXStatementCreator 实例类实现，给予使用者重复的自主权，同时也是逻辑解耦的一种操作。</p>
<p>例如：</p>
<p>SimplePreparedStatementCreator 这个 PreparedStatementCreator 接口的实现类，只是简单的调用了 <code>con.prepareStatement(sql)</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePreparedStatementCreator</span> </span></span><br><span class="line"><span class="class">  	<span class="keyword">implements</span> <span class="title">PreparedStatementCreator</span>, <span class="title">SqlProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String sql;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">createPreparedStatement</span><span class="params">(Connection con)</span> </span></span><br><span class="line"><span class="function">      	<span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> con.prepareStatement(<span class="keyword">this</span>.sql);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而对于 PreparedStatementCreatorImpl ，在 createPreparedStatement(Connection con) 的实现上，又添加了更多的操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PreparedStatementCreatorImpl</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">PreparedStatementCreator</span>, <span class="title">PreparedStatementSetter</span>, <span class="title">SqlProvider</span>, <span class="title">ParameterDisposer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String actualSql;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> List&lt;?&gt; parameters;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">createPreparedStatement</span><span class="params">(Connection con)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">		PreparedStatement ps;</span><br><span class="line">		<span class="keyword">if</span> (generatedKeysColumnNames != <span class="keyword">null</span> || returnGeneratedKeys) &#123;</span><br><span class="line">			<span class="keyword">if</span> (generatedKeysColumnNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">              	<span class="comment">// 获取一个 PreparedStatement 实例，下同</span></span><br><span class="line">				ps = con.prepareStatement(<span class="keyword">this</span>.actualSql, </span><br><span class="line">                                          generatedKeysColumnNames);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				ps = con.prepareStatement(<span class="keyword">this</span>.actualSql, </span><br><span class="line">                                         PreparedStatement.RETURN_GENERATED_KEYS);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (resultSetType == ResultSet.TYPE_FORWARD_ONLY </span><br><span class="line">                 &amp;&amp; !updatableResults) &#123;</span><br><span class="line">			ps = con.prepareStatement(<span class="keyword">this</span>.actualSql);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			ps = con.prepareStatement(<span class="keyword">this</span>.actualSql, resultSetType,</span><br><span class="line">				updatableResults ? ResultSet.CONCUR_UPDATABLE : </span><br><span class="line">                                      ResultSet.CONCUR_READ_ONLY);</span><br><span class="line">		&#125;</span><br><span class="line">      	<span class="comment">// 将可变 SQL (例如 SELECT * FROM msg WHERE id = ?) 的 ? 用实际参数替换</span></span><br><span class="line">		setValues(ps);</span><br><span class="line">		<span class="keyword">return</span> ps;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述两种 PreparedStatementCreator 接口的不同实现，也可以从另一种角度理解到，函数式接口将获取目标出参的具体逻辑交给使用者定义，给予了使用者充分的自主权，同时也是一种业务逻辑的解耦。</p>
<p>在上面代码 PreparedStatementCreatorImpl 类的实现中，我们看到第 32 行代码 <code>setValue(ps)</code> 。此处的方法是由接口 PreparedStatementSetter 定义的。主要目的是将可变 SQL 中的 ? 参数用实际参数进行一个替换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以 SQL (SELECT * FROM msg WHERE id = ? AND day = ?) 为例</span></span><br><span class="line"><span class="comment">/** 纯 Java 核心库的实现 PreparedStatement 参数注入 */</span></span><br><span class="line">ps.setInt(<span class="number">1</span>, <span class="number">1763</span>);</span><br><span class="line">ps.setString(<span class="number">2</span>, <span class="string">"2018-01-01"</span>);</span><br><span class="line">ps.executeQuery();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 以 Spring-jdbc 实现 PreparedStatement 参数注入 */</span></span><br><span class="line"><span class="comment">// setValues() 由接口 PreparedStatementSetter 定义，封装了注入参数的具体实现逻辑</span></span><br><span class="line"><span class="comment">// 可以由使用者自行定义</span></span><br><span class="line">setValues(ps);	</span><br><span class="line">ps.executeQuery();</span><br></pre></td></tr></table></figure>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fndyybh4q1j31kw0u3afx.jpg" alt=""></p>
<p>上面类图表示了 PreparedStatementSetter 及其实现类的相关依赖。</p>
<p>Setter 的主要目标即为对 SQL 中的 ? 参数进行注入。</p>
<p><del>个人精力有限，对Spring-jdbc在Statement上对参数注入的回调理解有限。</del></p>
<h2 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h2><p>在前几节已经提到讲了数据源、驱动管理器以及 Statement 之后，利用 JDBC 的最重要的目的就是对 DB 进行操作，并获得预期结果。对于查询语句而言，结果应该是若干记录行；就更新语句而言，结果可能是影响的行数。而 Spring-jdbc 对 ResultSet 额外进行的封装，即是将原本散乱的结果进行一个整合，例如整合成一个(一组)完整的 Bean 来进行展示。</p>
<p>在 JdbcTemplate 中，四个基本方法入参都包括一个回调接口，而在执行回调获得 ResultSet 之后，方法并不是直接返回，而是进行了一定的操作。</p>
<p>以一个 PreparedStatementCallback 的实例类为例，在 doInPreparedStatement() 方法中，获得了 ResultSet ，但是仍通过 rse.extractData(rs) 语句进行了处理后再返回结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">doInPreparedStatement</span><span class="params">(PreparedStatement ps)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  	<span class="comment">// 声明一个 ResultSet </span></span><br><span class="line">	ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (pss != <span class="keyword">null</span>) &#123;	<span class="comment">// setValues() 方法填充 PreparedStatement 中的可变参数 ? </span></span><br><span class="line">			pss.setValues(ps);</span><br><span class="line">		&#125;</span><br><span class="line">		rs = ps.executeQuery();	<span class="comment">// 执行查询 sql ，获取结果</span></span><br><span class="line">		<span class="keyword">return</span> rse.extractData(rs);	<span class="comment">// 重点... 该语句一定是对结果进行了一些操作.</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		JdbcUtils.closeResultSet(rs);</span><br><span class="line">		<span class="keyword">if</span> (pss <span class="keyword">instanceof</span> ParameterDisposer) &#123;</span><br><span class="line">			((ParameterDisposer) pss).cleanupParameters();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在来看一下究竟在返回结果前进行了什么操作。</p>
<p>由于是一个回调接口的实现类，rse 应该在外部方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">query</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		PreparedStatementCreator psc, @Nullable <span class="keyword">final</span> PreparedStatementSetter pss, </span></span></span><br><span class="line"><span class="function"><span class="params">  		<span class="keyword">final</span> ResultSetExtractor&lt;T&gt; rse)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> execute(psc, <span class="keyword">new</span> PreparedStatementCallback&lt;T&gt;() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> T <span class="title">doInPreparedStatement</span><span class="params">(PreparedStatement ps)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">			...	</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 rse 是一个 ResultSetExtractor<t> 的实例。从名称上可以看出 Extractor 即为提取器，结果集提取器。</t></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 函数式接口，提供的唯一方法为 extractData(...) */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResultSetExtractor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">T <span class="title">extractData</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException, DataAccessException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fndzz0pqnrj31a60i676v.jpg" alt=""></p>
<p>Spring-jdbc 中现有的实现有三个类，其中 RowCallbackHandlerResultSetExtractor 和 RowMapperResultSetExtractor 两个类从上面类图及命名即可看出，两个是作为一个适配器而存在的，将 extractData() 进行转换，分别由 RowCallbackHandler 和 RowMapper 实例进行具体操作。而 AbstractLobStreamingResultSetExtractor 类从名称上看，也是一个类似流操作的实现类(其中的 Lob 指的是 DB 中的 BLOB 与 CLOB 类型，在 Spring-jdbc 中也加入了额外的支持) 。</p>
<h3 id="RowCallbackHandler"><a href="#RowCallbackHandler" class="headerlink" title="RowCallbackHandler"></a>RowCallbackHandler</h3><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fnh2uw3a0aj30h20jeta4.jpg" alt=""></p>
<p>从名称上看，这是一个与 ResultSet 结果集行相关的回调接口。processRow(ResultSet rs) 方法将处理行相关的逻辑。</p>
<p>从它的一个实现类 RowCountCallbackHandler 来说，其最主要的私有属性 rowCount 即是统计 ResultSet 的结果行数。下面是一个具体使用的该类的案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">    DriverManagerDataSource dataSource = <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">    dataSource.setUrl(<span class="string">"jdbc:mysql://&lt;host&gt;:&lt;port&gt;/&lt;dbName&gt;"</span>);</span><br><span class="line">    dataSource.setUsername(<span class="string">"&lt;username&gt;"</span>);</span><br><span class="line">    dataSource.setPassword(<span class="string">"&lt;password&gt;"</span>);</span><br><span class="line"></span><br><span class="line">    JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    RowCountCallbackHandler rcch = <span class="keyword">new</span> RowCountCallbackHandler();</span><br><span class="line"></span><br><span class="line">    jdbcTemplate.query(<span class="string">"SELECT * FROM info WHERE id='2018'"</span>, </span><br><span class="line">                       	(RowCallbackHandler) rcch);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">  	System.out.println(rcch.getRowCount());	<span class="comment">//获取结果集行数</span></span><br><span class="line">    System.out.println(rcch.getColumnCount());	<span class="comment">// 获取结果集列数</span></span><br><span class="line">    <span class="keyword">for</span> (String arg : rcch.getColumnNames()) &#123;	<span class="comment">// 打印结果集每一列名称</span></span><br><span class="line">        System.out.println(<span class="string">"ColumnNames : "</span> + arg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : rcch.getColumnTypes()) &#123;	<span class="comment">// 打印结果集每一列类型(Types 为枚举类)</span></span><br><span class="line">        System.out.println(<span class="string">"ColumnTypes : "</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体查看 RowCountCallbackHandler 类的 processRow() 方法可以看到，其获取列相关信息都来自于 ResultSetMetaData 。而结果行数来源于 Iterator 迭代。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processRow</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.rowCount == <span class="number">0</span>) &#123;</span><br><span class="line">		ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line">		<span class="keyword">this</span>.columnCount = rsmd.getColumnCount();</span><br><span class="line">		<span class="keyword">this</span>.columnTypes = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.columnCount];</span><br><span class="line">		<span class="keyword">this</span>.columnNames = <span class="keyword">new</span> String[<span class="keyword">this</span>.columnCount];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.columnCount; i++) &#123;</span><br><span class="line">			<span class="keyword">this</span>.columnTypes[i] = rsmd.getColumnType(i + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">this</span>.columnNames[i] = JdbcUtils.lookupColumnName(rsmd, i + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// could also get column names</span></span><br><span class="line">	&#125;</span><br><span class="line">	processRow(rs, <span class="keyword">this</span>.rowCount++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RowMapper"><a href="#RowMapper" class="headerlink" title="RowMapper"></a>RowMapper</h3><p>上面 RowCallbackHandler 接口从逻辑上划分是用于处理 ResultSet 元数据信息的。而 RowMapper 较上一个接口而言，有更高的实用性。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fnh3h739kaj30z60nago4.jpg" alt=""></p>
<p>特别是其实现类 BeanPropertyRowMapper<t> 可以将散乱的 ResultSet 的结果数据整理成一个个 Object Bean 作为返回结果。而省去了对逐一读取 ResultSet 行记录并填充 Bean 属性的麻烦。</t></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line"></span><br><span class="line">BeanPropertyRowMapper&lt;Model&gt; rowMapper = <span class="keyword">new</span> BeanPropertyRowMapper&lt;&gt;(Model.class);</span><br><span class="line">List&lt;Model&gt; list = jdbcTemplate.query(</span><br><span class="line">  							<span class="string">"SELECT * FROM info WHERE id = '2018'"</span>, rowMapper);</span><br><span class="line"><span class="comment">/** 获得的 Model list 的对应属性将通过 Java 的反射机制进行填充</span></span><br><span class="line"><span class="comment"> *	List&lt;Model&gt; list 即结果</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>当然，要求是 Model 类中的属性与 DB table 中的列名保持一致（大小写无要求）。</p>
<p>而其它两个类的实现也是基于反射机制，实现其相应的业务逻辑。</p>
<h1 id="Draft…"><a href="#Draft…" class="headerlink" title="Draft…"></a>Draft…</h1><p>利用回调函数的唯一目的，是将具体处理 Sql 的逻辑解耦，提供高度的可定制化，而 JdbcTemplate 类中其它方法都以不同的逻辑实现了回调接口，实现不同的目的。</p>
<p>下面看一下 StatementCallback 接口的其中一个实现 QueryStatementCallback</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">final</span> String sql, <span class="keyword">final</span> ResultSetExtractor&lt;T&gt; rse)</span> </span></span><br><span class="line"><span class="function">  	<span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">	</span><br><span class="line">  	<span class="comment">// 方法内部类，回调接口的主要用法</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">QueryStatementCallback</span> <span class="keyword">implements</span> <span class="title">StatementCallback</span>&lt;<span class="title">T</span>&gt;, <span class="title">SqlProvider</span> </span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="meta">@Nullable</span></span><br><span class="line">      	<span class="comment">// 实现 StatementCallback 接口的唯一方法</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> T <span class="title">doInStatement</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">          	<span class="comment">// 声明一个 ResultSet </span></span><br><span class="line">			ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Statement 执行 sql 语句</span></span><br><span class="line">				rs = stmt.executeQuery(sql);</span><br><span class="line">              	<span class="comment">// 由回调接口所在的方法提供，ResultSetExtractor 的实例</span></span><br><span class="line">                <span class="comment">// 目的是将 ResultSet 中的结果重新整合成目标形式</span></span><br><span class="line">				<span class="keyword">return</span> rse.extractData(rs);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">finally</span> &#123;</span><br><span class="line">				JdbcUtils.closeResultSet(rs);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">getSql</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> sql;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  	</span><br><span class="line">   	<span class="comment">// 执行 &lt;T&gt; T execute(StatementCallback&lt;T&gt; action) 方法</span></span><br><span class="line">	<span class="keyword">return</span> execute(<span class="keyword">new</span> QueryStatementCallback());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p># </p>
<p>上面提到通过 DataSource 获取连接(Connection) 将委托 DriverManager 的静态方法 getConnection(url, props) 来获取连接。</p>
<p>首先，DriverManager 类可以被视为是一个 Driver 管理工具类，包括若干静态方法。主要的方法包括：</p>
<ol>
<li>getConnection(…) </li>
<li>getDriver(String url)</li>
<li>registerDriver(…)</li>
<li>deregisterDriver(Driver driver)</li>
<li>getDrivers()</li>
</ol>
<p>即注册、移除 Driver, 预置参数获取连接。其中，此处的 Driver(驱动) 是指由各个数据库厂商提供的驱动 API 。</p>
<p>常见的调用 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code> 即在声明 MySQL Driver 的同时，执行了静态代码块，下列 12 行可以看到即执行了 <code>registerDriver(new Driver())</code> 方法，将该 Driver 在 Drivers 管理类中进行了注册。</p>
<blockquote>
<p>在 JDBC 4.0 之后不需要用<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>来加载驱动，直接获取连接就可以了，现在这种方式就是使用了 Java 的 SPI 扩展机制来实现。</p>
<p><small>copy from <a href="http://cxis.me/2017/04/17/Java%E4%B8%ADSPI%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">Java 中 SPI 机制深入及源码解析</a></small></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mysql.jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">extends</span> <span class="title">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">sql</span>.<span class="title">Driver</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ~ Static fields/initializers</span></span><br><span class="line">	<span class="comment">// ---------------------------------------------</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Register ourselves with the DriverManager</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't register driver!"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ~ Constructors</span></span><br><span class="line">	<span class="comment">// -----------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Construct a new driver and register it with DriverManager</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">	 *             if a database error occurs.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">		<span class="comment">// Required for Class.forName().newInstance()</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的 getConnection(…) 方法都会对入参进行处理并最终调用 getConnection(String url, Properties info, Class&lt;?&gt; caller) 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Worker method called by the public getConnection() methods.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        String url, java.util.Properties info, Class&lt;?&gt; caller)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    </span><br><span class="line">  	<span class="comment">/* 省略若干代码，作用为预先处理出 ClassLoader */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(DriverInfo aDriver : registeredDrivers) &#123;</span><br><span class="line">        <span class="comment">// If the caller does not have permission to load the driver then</span></span><br><span class="line">        <span class="comment">// skip it.</span></span><br><span class="line">        <span class="keyword">if</span>(isDriverAllowed(aDriver.driver, callerCL)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                println(<span class="string">"    trying "</span> + aDriver.driver.getClass().getName());</span><br><span class="line">                Connection con = aDriver.driver.connect(url, info);</span><br><span class="line">                <span class="keyword">if</span> (con != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Success!</span></span><br><span class="line">                    println(<span class="string">"getConnection returning "</span> + </span><br><span class="line">                            aDriver.driver.getClass().getName());</span><br><span class="line">                    <span class="keyword">return</span> (con);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (reason == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    reason = ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            println(<span class="string">"    skipping: "</span> + aDriver.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到整体的代码框架为 for 获取 DriverManager 类中注册的所有 Driver，并循环对每个 Driver 进行判断，委托 Driver(驱动) 执行 connect(url, info) 方法来获得连接。由此可见，针对不同数据库建立连接的方式都是有所区别的。</p>
<p>##JdbcOperations</p>
<p>在基本了解 Spring-jdbc 获取 Connection(连接) 的方式之后，再来简单的认识一下为 JdbcTemplate 类预定义相关 DB 操作方法的 JdbcOperations 接口。</p>
<p>核心的方法为下列四个，对于核心操作，需要自行实现相关的函数式回调接口。当然，JdbcOperations 接口也定义了大量的一般方法用于直接使用，这些方法一般内部都自行实现了与逻辑相关的回调接口，可直截了当的达成调用者的目的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 直接与 Connection 交互的方法</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该方法通过函数式接口 ConnectionCallback&lt;T&gt; ，在方法内回调接口 ConnectionCallback </span></span><br><span class="line"><span class="comment"> * 的唯一方法 doInConnection(Connection con) 来实现方法内自定义的操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(ConnectionCallback&lt;T&gt; action)</span> <span class="keyword">throws</span> DataAccessException</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 处理静态 SQL 的方法 (java.sql.Statement)</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该方法通过函数式接口 StatementCallback&lt;T&gt;，在方法内回调接口 StatementCallback </span></span><br><span class="line"><span class="comment"> * 的唯一方法 doInStatement(Statement stmt) 来实现方法内自定义的操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(StatementCallback&lt;T&gt; action)</span> <span class="keyword">throws</span> DataAccessException</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 处理预置 Statement 的方法</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该方法通过 PreparedStatementCreator 函数式接口获取一个 PreparedStatement 实例，  </span></span><br><span class="line"><span class="comment"> * PreparedStatementCallback&lt;T&gt; 函数式接口唯一方法  </span></span><br><span class="line"><span class="comment"> * doInPreparedStatement(PreparedStatement ps) 类实现方法内自定义的操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(PreparedStatementCreator psc, PreparedStatementCallback&lt;T&gt; action)</span> <span class="keyword">throws</span> DataAccessException</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 处理可回调 Statements 的方法</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(CallableStatementCreator csc, CallableStatementCallback&lt;T&gt; action)</span> <span class="keyword">throws</span> DataAccessException</span>;</span><br></pre></td></tr></table></figure>
<h2 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h2><p>在 JdbcOperations 接口的方法中，频繁出现各种 Statement 接口，包括 Statement, PreparedStatement, CallableStatement 。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fnbhouegmdj30fy0h6gmy.jpg" alt=""></p>
<p>通过阅读 Statement 接口的源码，可以认识到它提供了执行 SQL 语句和获取结果的基本方法；</p>
<p>而 PreparedStatement 作为继承了 Statement 接口的子接口，添加了处理 IN 参数的方式，具体表现如下： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement pstmt = con.prepareStatement(<span class="string">"UPDATE EMPLOYEES SET SALARY = ? WHERE ID = ?"</span>);</span><br><span class="line">pstmt.setBigDecimal(<span class="number">1</span>, <span class="number">153833.00</span>)</span><br><span class="line">pstmt.setInt(<span class="number">2</span>, <span class="number">110592</span>)</span><br></pre></td></tr></table></figure>
<p>CallableStatement 接口继承了 PreparedStatement 更是提供了处理 OUT 参数的方式。</p>
<h2 id="ResultSet-1"><a href="#ResultSet-1" class="headerlink" title="ResultSet"></a>ResultSet</h2><p>ResultSet 可以类似地理解为类表格组织的数据库结果集，通常通过执行 statement 查询数据库得到。</p>
<p>每个 ResultSet 将会维护一个当前行的游标指针。该指针初始在第一行，每次执行 next() 将移动到下一行，直到返回为 false 表示没有更多行。</p>
<p>同时，默认的 ResultSet 不支持更新，且游标只能从前向后顺次移动。</p>
<p>ResultSet 类主要包括方法有：</p>
<ol>
<li>next() 移动游标到下一行记录</li>
<li>Methods for accessing results by column index</li>
<li>Methods for accessing results by column label</li>
<li>Advanced features</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* A default &lt;code&gt;ResultSet&lt;/code&gt; object is not updatable and</span></span><br><span class="line"><span class="comment">* has a cursor that moves forward only.  Thus, you can</span></span><br><span class="line"><span class="comment">* iterate through it only once and only from the first row to the</span></span><br><span class="line"><span class="comment">* last row. It is possible to</span></span><br><span class="line"><span class="comment">* produce &lt;code&gt;ResultSet&lt;/code&gt; objects that are scrollable and/or</span></span><br><span class="line"><span class="comment">* updatable.  The following code fragment, in which &lt;code&gt;con&lt;/code&gt;</span></span><br><span class="line"><span class="comment">* is a valid &lt;code&gt;Connection&lt;/code&gt; object, illustrates how to make</span></span><br><span class="line"><span class="comment">* a result set that is scrollable and insensitive to updates by others, and</span></span><br><span class="line"><span class="comment">* that is updatable. See &lt;code&gt;ResultSet&lt;/code&gt; fields for other</span></span><br><span class="line"><span class="comment">* options.</span></span><br><span class="line"><span class="comment">* &lt;PRE&gt;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*       Statement stmt = con.createStatement(</span></span><br><span class="line"><span class="comment">*                                      ResultSet.TYPE_SCROLL_INSENSITIVE,</span></span><br><span class="line"><span class="comment">*                                      ResultSet.CONCUR_UPDATABLE);</span></span><br><span class="line"><span class="comment">*       ResultSet rs = stmt.executeQuery("SELECT a, b FROM TABLE2");</span></span><br><span class="line"><span class="comment">*       // rs will be scrollable, will not show changes made by others,</span></span><br><span class="line"><span class="comment">*       // and will be updatable</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;/PRE&gt;</span></span><br><span class="line"><span class="comment">* The &lt;code&gt;ResultSet&lt;/code&gt; interface provides</span></span><br><span class="line"><span class="comment">* &lt;i&gt;getter&lt;/i&gt; methods (&lt;code&gt;getBoolean&lt;/code&gt;, &lt;code&gt;getLong&lt;/code&gt;, and so on)</span></span><br><span class="line"><span class="comment">* for retrieving column values from the current row.</span></span><br><span class="line"><span class="comment">* Values can be retrieved using either the index number of the</span></span><br><span class="line"><span class="comment">* column or the name of the column.  In general, using the</span></span><br><span class="line"><span class="comment">* column index will be more efficient.  Columns are numbered from 1.</span></span><br><span class="line"><span class="comment">* For maximum portability, result set columns within each row should be</span></span><br><span class="line"><span class="comment">* read in left-to-right order, and each column should be read only once.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;P&gt;For the getter methods, a JDBC driver attempts</span></span><br><span class="line"><span class="comment">* to convert the underlying data to the Java type specified in the</span></span><br><span class="line"><span class="comment">* getter method and returns a suitable Java value.  The JDBC specification</span></span><br><span class="line"><span class="comment">* has a table showing the allowable mappings from SQL types to Java types</span></span><br><span class="line"><span class="comment">* that can be used by the &lt;code&gt;ResultSet&lt;/code&gt; getter methods.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;P&gt;Column names used as input to getter methods are case</span></span><br><span class="line"><span class="comment">* insensitive.  When a getter method is called  with</span></span><br><span class="line"><span class="comment">* a column name and several columns have the same name,</span></span><br><span class="line"><span class="comment">* the value of the first matching column will be returned.</span></span><br><span class="line"><span class="comment">* The column name option is</span></span><br><span class="line"><span class="comment">* designed to be used when column names are used in the SQL</span></span><br><span class="line"><span class="comment">* query that generated the result set.</span></span><br><span class="line"><span class="comment">* For columns that are NOT explicitly named in the query, it</span></span><br><span class="line"><span class="comment">* is best to use column numbers. If column names are used, the</span></span><br><span class="line"><span class="comment">* programmer should take care to guarantee that they uniquely refer to</span></span><br><span class="line"><span class="comment">* the intended columns, which can be assured with the SQL &lt;i&gt;AS&lt;/i&gt; clause.</span></span><br><span class="line"><span class="comment">* &lt;P&gt;</span></span><br><span class="line"><span class="comment">* A set of updater methods were added to this interface</span></span><br><span class="line"><span class="comment">* in the JDBC 2.0 API (Java&amp;trade; 2 SDK,</span></span><br><span class="line"><span class="comment">* Standard Edition, version 1.2). The comments regarding parameters</span></span><br><span class="line"><span class="comment">* to the getter methods also apply to parameters to the</span></span><br><span class="line"><span class="comment">* updater methods.</span></span><br><span class="line"><span class="comment">*&lt;P&gt;</span></span><br><span class="line"><span class="comment">* The updater methods may be used in two ways:</span></span><br><span class="line"><span class="comment">* &lt;ol&gt;</span></span><br><span class="line"><span class="comment">* &lt;LI&gt;to update a column value in the current row.  In a scrollable</span></span><br><span class="line"><span class="comment">*     &lt;code&gt;ResultSet&lt;/code&gt; object, the cursor can be moved backwards</span></span><br><span class="line"><span class="comment">*     and forwards, to an absolute position, or to a position</span></span><br><span class="line"><span class="comment">*     relative to the current row.</span></span><br><span class="line"><span class="comment">*     The following code fragment updates the &lt;code&gt;NAME&lt;/code&gt; column</span></span><br><span class="line"><span class="comment">*     in the fifth row of the &lt;code&gt;ResultSet&lt;/code&gt; object</span></span><br><span class="line"><span class="comment">*     &lt;code&gt;rs&lt;/code&gt; and then uses the method &lt;code&gt;updateRow&lt;/code&gt;</span></span><br><span class="line"><span class="comment">*     to update the data source table from which &lt;code&gt;rs&lt;/code&gt; was derived.</span></span><br><span class="line"><span class="comment">* &lt;PRE&gt;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*       rs.absolute(5); // moves the cursor to the fifth row of rs</span></span><br><span class="line"><span class="comment">*       rs.updateString("NAME", "AINSWORTH"); // updates the</span></span><br><span class="line"><span class="comment">*          // &lt;code&gt;NAME&lt;/code&gt; column of row 5 to be &lt;code&gt;AINSWORTH&lt;/code&gt;</span></span><br><span class="line"><span class="comment">*       rs.updateRow(); // updates the row in the data source</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;/PRE&gt;</span></span><br><span class="line"><span class="comment">* &lt;LI&gt;to insert column values into the insert row.  An updatable</span></span><br><span class="line"><span class="comment">*     &lt;code&gt;ResultSet&lt;/code&gt; object has a special row associated with</span></span><br><span class="line"><span class="comment">*     it that serves as a staging area for building a row to be inserted.</span></span><br><span class="line"><span class="comment">*     The following code fragment moves the cursor to the insert row, builds</span></span><br><span class="line"><span class="comment">*     a three-column row, and inserts it into &lt;code&gt;rs&lt;/code&gt; and into</span></span><br><span class="line"><span class="comment">*     the data source table using the method &lt;code&gt;insertRow&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">* &lt;PRE&gt;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*       rs.moveToInsertRow(); // moves cursor to the insert row</span></span><br><span class="line"><span class="comment">*       rs.updateString(1, "AINSWORTH"); // updates the</span></span><br><span class="line"><span class="comment">*          // first column of the insert row to be &lt;code&gt;AINSWORTH&lt;/code&gt;</span></span><br><span class="line"><span class="comment">*       rs.updateInt(2,35); // updates the second column to be &lt;code&gt;35&lt;/code&gt;</span></span><br><span class="line"><span class="comment">*       rs.updateBoolean(3, true); // updates the third column to &lt;code&gt;true&lt;/code&gt;</span></span><br><span class="line"><span class="comment">*       rs.insertRow();</span></span><br><span class="line"><span class="comment">*       rs.moveToCurrentRow();</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;/PRE&gt;</span></span><br><span class="line"><span class="comment">* &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">* &lt;P&gt;A &lt;code&gt;ResultSet&lt;/code&gt; object is automatically closed when the</span></span><br><span class="line"><span class="comment">* &lt;code&gt;Statement&lt;/code&gt; object that</span></span><br><span class="line"><span class="comment">* generated it is closed, re-executed, or used</span></span><br><span class="line"><span class="comment">* to retrieve the next result from a sequence of multiple results.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;P&gt;The number, types and properties of a &lt;code&gt;ResultSet&lt;/code&gt;</span></span><br><span class="line"><span class="comment">* object's columns are provided by the &lt;code&gt;ResultSetMetaData&lt;/code&gt;</span></span><br><span class="line"><span class="comment">* object returned by the &lt;code&gt;ResultSet.getMetaData&lt;/code&gt; method.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @see Statement#executeQuery</span></span><br><span class="line"><span class="comment">* @see Statement#getResultSet</span></span><br><span class="line"><span class="comment">* @see ResultSetMetaData</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ol>
<li>DataSource</li>
<li>Connection</li>
<li>Properties</li>
<li>Statement</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * copied from https://www.tutorialspoint.com/jdbc/jdbc-sample-code.htm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//STEP 1. Import required packages</span></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstExample</span> </span>&#123;</span><br><span class="line">   <span class="comment">// JDBC driver name and database URL</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> String JDBC_DRIVER = <span class="string">"com.mysql.jdbc.Driver"</span>;  </span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> String DB_URL = <span class="string">"jdbc:mysql://localhost/EMP"</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//  Database credentials</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> String USER = <span class="string">"username"</span>;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> String PASS = <span class="string">"password"</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   Connection conn = <span class="keyword">null</span>;</span><br><span class="line">   Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="comment">//STEP 2: Register JDBC driver</span></span><br><span class="line">      Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//STEP 3: Open a connection</span></span><br><span class="line">      System.out.println(<span class="string">"Connecting to database..."</span>);</span><br><span class="line">      conn = DriverManager.getConnection(DB_URL,USER,PASS);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//STEP 4: Execute a query</span></span><br><span class="line">      System.out.println(<span class="string">"Creating statement..."</span>);</span><br><span class="line">      stmt = conn.createStatement();</span><br><span class="line">      String sql;</span><br><span class="line">      sql = <span class="string">"SELECT id, first, last, age FROM Employees"</span>;</span><br><span class="line">      ResultSet rs = stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//STEP 5: Extract data from result set</span></span><br><span class="line">      <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">         <span class="comment">//Retrieve by column name</span></span><br><span class="line">         <span class="keyword">int</span> id  = rs.getInt(<span class="string">"id"</span>);</span><br><span class="line">         <span class="keyword">int</span> age = rs.getInt(<span class="string">"age"</span>);</span><br><span class="line">         String first = rs.getString(<span class="string">"first"</span>);</span><br><span class="line">         String last = rs.getString(<span class="string">"last"</span>);</span><br><span class="line"></span><br><span class="line">         <span class="comment">//Display values</span></span><br><span class="line">         System.out.print(<span class="string">"ID: "</span> + id);</span><br><span class="line">         System.out.print(<span class="string">", Age: "</span> + age);</span><br><span class="line">         System.out.print(<span class="string">", First: "</span> + first);</span><br><span class="line">         System.out.println(<span class="string">", Last: "</span> + last);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//STEP 6: Clean-up environment</span></span><br><span class="line">      rs.close();</span><br><span class="line">      stmt.close();</span><br><span class="line">      conn.close();</span><br><span class="line">   &#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">      <span class="comment">//Handle errors for JDBC</span></span><br><span class="line">      se.printStackTrace();</span><br><span class="line">   &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">      <span class="comment">//Handle errors for Class.forName</span></span><br><span class="line">      e.printStackTrace();</span><br><span class="line">   &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">      <span class="comment">//finally block used to close resources</span></span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(stmt!=<span class="keyword">null</span>)</span><br><span class="line">            stmt.close();</span><br><span class="line">      &#125;<span class="keyword">catch</span>(SQLException se2)&#123;</span><br><span class="line">      &#125;<span class="comment">// nothing we can do</span></span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(conn!=<span class="keyword">null</span>)</span><br><span class="line">            conn.close();</span><br><span class="line">      &#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">         se.printStackTrace();</span><br><span class="line">      &#125;<span class="comment">//end finally try</span></span><br><span class="line">   &#125;<span class="comment">//end try</span></span><br><span class="line">   System.out.println(<span class="string">"Goodbye!"</span>);</span><br><span class="line">&#125;<span class="comment">//end main</span></span><br><span class="line">&#125;<span class="comment">//end FirstExample</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Connection connection = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  	Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		connection = 	</span><br><span class="line">		DriverManager.getConnection(<span class="string">"jdbc:mysql://&lt;url&gt;:3306/&lt;db&gt;"</span>,<span class="string">"rt"</span>,<span class="string">"passwd"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      	e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">     		connection.close();</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article></div></main><footer><div class="paginator"><a href="/2018-03-01-区块链简单介绍/" class="prev">PREV</a><a href="/2018-06-11-ASM-ClassReader/" class="next">NEXT</a></div><div class="copyright"><p>© 2018 <a href="http://utop.xin">Utop</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>