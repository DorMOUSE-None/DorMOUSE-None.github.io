<!DOCTYPE html>
<html lang="zh-cn">
  <head><meta name="generator" content="Hexo 3.8.0">
    
<!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

<meta name="theme-color" content="#f8f5ec">
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="理解 Linux Kernel (13) - 虚拟内存">




  <meta name="keywords" content="Linux, Kernel, vm, mmap, Utop's Blog">










  <link rel="alternate" href="/atom.xml" title="Utop's Blog">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.9.0">



<link rel="canonical" href="https://DorMOUSE-None.github.io/2019-07-17-understand-Kernel-13/">



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css">




  <link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css">



<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.9.0">


<link href="https://fonts.googleapis.com/css?family=Noto+Sans+SC" rel="stylesheet">


<link href="https://fonts.googleapis.com/css?family=Noto+Serif+SC:400,700" rel="stylesheet">


<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">



  


<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-92258941-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-92258941-1');
</script>


  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>





  <script src="//cdn1.lncld.net/static/js/3.1.1/av-min.js"></script>
  <script id="leancloud">
    AV.init({
      appId: "2IQmE2X540kOtTtNPDzsNh3e-9Nh9j0Va",
      appKey: "Vk01nlYJoGnfxJ4HCPUqW7p2"
    });
  </script>




<script>
  window.config = {"title":"Utop's Blog","subtitle":null,"description":null,"author":"Utop","language":"zh-cn","timezone":"Asia/Shanghai","url":"https://DorMOUSE-None.github.io","root":"/","permalink":":title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":0,"pagination_dir":"page","theme":"even","deploy":{"type":"git","repo":"https://github.com/DorMOUSE-None/DorMOUSE-None.github.io.git","branch":"master","name":"DorMOUSE-None","email":"17816873960@163.com"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"math":{"engine":"mathjax","mathjax":{"src":"//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML","config":{"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}}}},"archive_generator":{"per_page":0,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":0},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"sitemap":{"path":"sitemap.xml"},"tag_generator":{"per_page":0},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"since":2018,"favicon":"/favicon.ico","rss":"default","menu":{"Home":"/","Archives":"/archives/","Tags":"/tags","About":"/about"},"color":"Default","toc":true,"fancybox":true,"pjax":true,"copyright":{"enable":true,"license":"<a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\">知识共享署名-非商业性使用 4.0 国际许可协议</a>"},"reward":{"enable":false,"qrCode":{"wechat":null,"alipay":null}},"social":{"email":"dormousenone@gmail.com","stack-overflow":null,"twitter":null,"facebook":null,"linkedin":null,"google":null,"github":"https://github.com/DorMOUSE-None","weibo":null,"zhihu":null,"douban":null,"pocket":null,"tumblr":null,"instagram":null},"leancloud":{"app_id":"2IQmE2X540kOtTtNPDzsNh3e-9Nh9j0Va","app_key":"Vk01nlYJoGnfxJ4HCPUqW7p2"},"baidu_analytics":null,"baidu_verification":null,"google_analytics":"UA-92258941-1","google_verification":null,"disqus_shortname":"utop-blog","changyan":{"appid":null,"appkey":null},"livere_datauid":null,"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"version":"2.9.0"};
</script>

    <title> 理解 Linux Kernel (13) - 虚拟内存 - Utop's Blog </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="mobile-header-logo">
    <a href="/." class="logo">Utop's Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            标签
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            关于
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Utop's Blog</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              标签
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          理解 Linux Kernel (13) - 虚拟内存
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-07-17
        </span>
        
        
        <div class="post-visits" data-url="/2019-07-17-understand-Kernel-13/" data-title="理解 Linux Kernel (13) - 虚拟内存">
            阅读次数 0
          </div>
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#启动新进程"><span class="toc-text">启动新进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆的增长"><span class="toc-text">堆的增长</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#匿名地址空间映射"><span class="toc-text">匿名地址空间映射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol>
    </div>
  </div>



    <div class="post-content">
      
        <p>几乎每个进程都有独立的虚拟地址空间，这是一个逻辑上的概念，用于建立进程对进程存储资源的认知。对于 32 位机，虚拟地址空间的大小通常是 4GB；对于 64 位机，最大可以达到 $2^{64}$ Bytes 。</p>
<p>本篇便是为了看看虚拟地址空间究竟如何被内核管理，又是怎样和物理内存、文件等资源关联。</p>
<a id="more"></a>
<h2 id="启动新进程"><a href="#启动新进程" class="headerlink" title="启动新进程"></a>启动新进程</h2><p>虚拟地址空间与进程挂钩，在进程数据结构 <code>task_struct</code> 中由一个重要的参数 <code>mm_struct</code> 来维护。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">mmap</span>;</span>        <span class="comment">/* list of VMAs */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">mm_rb</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> mmap_base;        <span class="comment">/* base of mmap area */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> task_size;        <span class="comment">/* size of task vm space */</span></span><br><span class="line">    <span class="keyword">pgd_t</span> * pgd;</span><br><span class="line">    <span class="keyword">atomic_t</span> mm_count;            <span class="comment">/* How many references to "struct mm_struct" (users count as 1) */</span></span><br><span class="line">    <span class="keyword">int</span> map_count;                <span class="comment">/* number of VMAs */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> start_code, end_code, start_data, end_data;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> start_brk, brk, start_stack;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> arg_start, arg_end, env_start, env_end;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">exe_file</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... some code omitted ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>start_code</code>, <code>end_code</code> 描述的是任务的可执行文件在虚拟内存地址中所处的区间。<code>start_data</code>, <code>end_data</code> 描述可执行文件的数据段，通常情况下与 <code>start_code</code>, <code>end_code</code> 指向同一段，只不过 rwx 的权限控制不同罢了。</p>
<p><code>start_brk</code> 和 <code>brk</code> 共同描述堆的起末点，通过 <code>syscall brk</code> 可以调整 <code>brk</code> 的值，也就是在运行过程中调整堆的大小。</p>
<p><code>arg_start</code>, <code>arg_end</code>, <code>env_start</code>, <code>env_end</code> 分别描述命令参数和环境变量在虚拟内存地址中所处的位置。</p>
<p><img src="http://img.ffutop.com/EEF5961B-F971-4329-A7DB-B531B329397B.png" alt=""></p>
<p>新任务的启动，通常是通过 <code>fork</code>, <code>clone</code> 等系统调用拷贝父任务几乎所有的状态和资源指针，然后通过 <code>execve</code> 系统调用替换可执行文件，重置虚拟内存等其他相关资源。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Hint: 省略了一些无关代码 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* execve 系统调用的入口 */</span></span><br><span class="line">SYSCALL_DEFINE3(execve,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> __user *, filename,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> __user *<span class="keyword">const</span> __user *, argv,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> __user *<span class="keyword">const</span> __user *, envp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">filename</span> *<span class="title">path</span> = <span class="title">getname</span>(<span class="title">filename</span>);</span></span><br><span class="line">    error = do_execve(path-&gt;name, argv, envp);</span><br><span class="line">    putname(path);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span> __user *<span class="keyword">const</span> __user *__argv,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">char</span> __user *<span class="keyword">const</span> __user *__envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_arg_ptr</span> <span class="title">argv</span> = &#123;</span> .ptr.native = __argv &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_arg_ptr</span> <span class="title">envp</span> = &#123;</span> .ptr.native = __envp &#125;;</span><br><span class="line">    <span class="keyword">return</span> do_execve_common(filename, argv, envp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_execve_common</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct user_arg_ptr argv,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct user_arg_ptr envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检测 ulimit 限制的进程总数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择合适的 CPU 核以运行新任务</span></span><br><span class="line">    sched_exec();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立一个临时的栈内存来支持任务启动</span></span><br><span class="line">    retval = bprm_mm_init(bprm);</span><br><span class="line"></span><br><span class="line">    bprm-&gt;argc = count(argv, MAX_ARG_STRINGS);</span><br><span class="line">    bprm-&gt;envc = count(envp, MAX_ARG_STRINGS);</span><br><span class="line"></span><br><span class="line">    retval = prepare_binprm(bprm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从用户空间拷贝字符串 （可执行文件路径、环境变量、启动参数）</span></span><br><span class="line">    retval = copy_strings_kernel(<span class="number">1</span>, &amp;bprm-&gt;filename, bprm);</span><br><span class="line">    retval = copy_strings(bprm-&gt;envc, envp, bprm);</span><br><span class="line">    retval = copy_strings(bprm-&gt;argc, argv, bprm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据可执行文件的格式，选择合适的加载函数 （例如 load_elf_binary）</span></span><br><span class="line">    retval = search_binary_handler(bprm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* execve succeeded */</span></span><br><span class="line">    current-&gt;fs-&gt;in_exec = <span class="number">0</span>;</span><br><span class="line">    current-&gt;in_execve = <span class="number">0</span>;</span><br><span class="line">    acct_update_integrals(current);</span><br><span class="line">    free_bprm(bprm);</span><br><span class="line">    <span class="keyword">if</span> (displaced)</span><br><span class="line">        put_files_struct(displaced);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体而言，<code>execve</code> 在完成了大量 check 的工作之后，把核心的加载流程委托给特定于可执行文件的加载模块来完成。以 ELF 文件格式为例，整体流程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|-- sys_execve</span><br><span class="line">    |-- do_execve</span><br><span class="line">        |-- do_execve_common</span><br><span class="line">            |-- sched_exec</span><br><span class="line">                |-- bprm_mm_init</span><br><span class="line">                |-- prepare_binprm</span><br><span class="line">                    |-- kernel_read</span><br><span class="line">                |-- search_binary_handler</span><br><span class="line">                    |-- load_elf_binary</span><br><span class="line">                |-- acct_update_integrals</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* From fs/binfmt_elf.c */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">load_elf_binary</span><span class="params">(struct linux_binprm *bprm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 获取可执行文件的头 128 B，已经由 kernel_read 提前读取到内存了 */</span></span><br><span class="line">	loc-&gt;elf_ex = *((struct elfhdr *)bprm-&gt;buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 确认是否是 ELF 文件格式，比较文件格式魔数。#define ELFMAG "\177ELF" */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">memcmp</span>(loc-&gt;elf_ex.e_ident, ELFMAG, SELFMAG) != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (loc-&gt;elf_ex.e_type != ET_EXEC &amp;&amp; loc-&gt;elf_ex.e_type != ET_DYN)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	<span class="keyword">if</span> (!elf_check_arch(&amp;loc-&gt;elf_ex))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	<span class="keyword">if</span> (!bprm-&gt;file-&gt;f_op || !bprm-&gt;file-&gt;f_op-&gt;mmap)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读取所有的 elf header data */</span></span><br><span class="line">	retval = kernel_read(bprm-&gt;file, loc-&gt;elf_ex.e_phoff,</span><br><span class="line">			     (<span class="keyword">char</span> *)elf_phdata, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置新的可执行文件结构 */</span></span><br><span class="line">	setup_new_exec(bprm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在虚拟地址空间设置启动参数 */</span></span><br><span class="line">	retval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),</span><br><span class="line">				 executable_stack);</span><br><span class="line">	</span><br><span class="line">	current-&gt;mm-&gt;start_stack = bprm-&gt;p;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 将 ELF text、code、bss 段等迁移到虚拟地址空间合适的位置 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置 brk 的位置 */</span></span><br><span class="line">	retval = set_brk(elf_bss, elf_brk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置 mm_struct 关于 text、data、stack 的参数 */</span></span><br><span class="line">	current-&gt;mm-&gt;end_code = end_code;</span><br><span class="line">	current-&gt;mm-&gt;start_code = start_code;</span><br><span class="line">	current-&gt;mm-&gt;start_data = start_data;</span><br><span class="line">	current-&gt;mm-&gt;end_data = end_data;</span><br><span class="line">	current-&gt;mm-&gt;start_stack = bprm-&gt;p;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> arch_randomize_brk</span></span><br><span class="line">	<span class="keyword">if</span> ((current-&gt;flags &amp; PF_RANDOMIZE) &amp;&amp; (randomize_va_space &gt; <span class="number">1</span>)) &#123;</span><br><span class="line">		current-&gt;mm-&gt;brk = current-&gt;mm-&gt;start_brk =</span><br><span class="line">			arch_randomize_brk(current-&gt;mm);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPAT_BRK</span></span><br><span class="line">		current-&gt;brk_randomized = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	start_thread(regs, elf_entry, bprm-&gt;p);</span><br><span class="line">	retval = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* From fs/exec.c */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup_new_exec</span><span class="params">(struct linux_binprm * bprm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 根据 CPU 架构选择 mmap 布局方式 */</span></span><br><span class="line">	arch_pick_mmap_layout(current-&gt;mm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 配置信号栈 */</span></span><br><span class="line">	current-&gt;sas_ss_sp = current-&gt;sas_ss_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	set_task_comm(current, bprm-&gt;tcomm);</span><br><span class="line"></span><br><span class="line">	current-&gt;mm-&gt;task_size = TASK_SIZE;</span><br><span class="line"></span><br><span class="line">	current-&gt;self_exec_id++;</span><br><span class="line">			</span><br><span class="line">	flush_signal_handlers(current, <span class="number">0</span>);</span><br><span class="line">	do_close_on_exec(current-&gt;files);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* From arch/x86/mm/mmap.c */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">arch_pick_mmap_layout</span><span class="params">(struct mm_struct *mm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mmap_is_legacy()) &#123;</span><br><span class="line">		mm-&gt;mmap_base = mmap_legacy_base();</span><br><span class="line">		mm-&gt;get_unmapped_area = arch_get_unmapped_area;</span><br><span class="line">		mm-&gt;unmap_area = arch_unmap_area;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 新的 mmap 是从靠近 stack 的高地址开始，向低地址延伸的 */</span></span><br><span class="line">		mm-&gt;mmap_base = mmap_base();</span><br><span class="line">		mm-&gt;get_unmapped_area = arch_get_unmapped_area_topdown;</span><br><span class="line">		mm-&gt;unmap_area = arch_unmap_area_topdown;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从传统的 mmap 配置方式，<code>mmap_base</code> 被配置为 <code>TASK_SIZE / 3</code> 。在 x86 32bit CPU 上，<code>TASK_SIZE</code> 通常被配置为 3GB （剩下的 1GB 的虚拟地址空间作为内核空间使用）。在整个 ELF 文件的加载过程中，<code>mm_struct</code> 依照既定的值或者经由计算得到的值被逐一填充。组成了一段涵盖可执行文件代码段、数据段、堆、栈、mmap 区域等的虚拟内存空间。</p>
<h2 id="堆的增长"><a href="#堆的增长" class="headerlink" title="堆的增长"></a>堆的增长</h2><p>抛却我们所熟知的 malloc、free 等内存申请与释放函数。从 <code>mm_struct</code> 可以看到三块可用的内存区域——堆、mmap 区域、栈。</p>
<p>堆的增长与缩减通过 <code>brk</code>, <code>sbrk</code> 两个系统调用来完成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE1(brk, <span class="keyword">unsigned</span> <span class="keyword">long</span>, brk)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* Ok, looks good - let it rip. */</span></span><br><span class="line">	<span class="keyword">if</span> (do_brk(oldbrk, newbrk-oldbrk) != oldbrk)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* From mm/mmap.c */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">do_brk</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> * <span class="title">mm</span> = <span class="title">current</span>-&gt;<span class="title">mm</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">vma</span>, * <span class="title">prev</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> ** <span class="title">rb_link</span>, * <span class="title">rb_parent</span>;</span></span><br><span class="line">	<span class="keyword">pgoff_t</span> pgoff = addr &gt;&gt; PAGE_SHIFT;</span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">	len = PAGE_ALIGN(len);</span><br><span class="line">	<span class="keyword">if</span> (!len)</span><br><span class="line">		<span class="keyword">return</span> addr;</span><br><span class="line"></span><br><span class="line">	flags = VM_DATA_DEFAULT_FLAGS | VM_ACCOUNT | mm-&gt;def_flags;</span><br><span class="line"></span><br><span class="line">	error = get_unmapped_area(<span class="literal">NULL</span>, addr, len, <span class="number">0</span>, MAP_FIXED);</span><br><span class="line">	<span class="keyword">if</span> (error &amp; ~PAGE_MASK)</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 锁，保证同一时间只有一个任务在操作虚拟内存空间分配 */</span></span><br><span class="line">	verify_mm_writelocked(mm);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Clear old maps.  this also does some error checking for us</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"> munmap_back:</span><br><span class="line">	<span class="keyword">if</span> (find_vma_links(mm, addr, addr + len, &amp;prev, &amp;rb_link, &amp;rb_parent)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (do_munmap(mm, addr, len))</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> munmap_back;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check against address space limits *after* clearing old maps... */</span></span><br><span class="line">	<span class="keyword">if</span> (!may_expand_vm(mm, len &gt;&gt; PAGE_SHIFT))</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mm-&gt;map_count &gt; sysctl_max_map_count)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (security_vm_enough_memory_mm(mm, len &gt;&gt; PAGE_SHIFT))</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Can we just expand an old private anonymous mapping? */</span></span><br><span class="line">	vma = vma_merge(mm, prev, addr, addr + len, flags,</span><br><span class="line">					<span class="literal">NULL</span>, <span class="literal">NULL</span>, pgoff, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (vma)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建一个新的匿名映射结构，brk 说到底就是一种特殊的 mmap */</span></span><br><span class="line">	vma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!vma) &#123;</span><br><span class="line">		vm_unacct_memory(len &gt;&gt; PAGE_SHIFT);</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 向 vma 列表添加新的虚拟内存段记录 */</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;vma-&gt;anon_vma_chain);</span><br><span class="line">	vma-&gt;vm_mm = mm;</span><br><span class="line">	vma-&gt;vm_start = addr;</span><br><span class="line">	vma-&gt;vm_end = addr + len;</span><br><span class="line">	vma-&gt;vm_pgoff = pgoff;</span><br><span class="line">	vma-&gt;vm_flags = flags;</span><br><span class="line">	vma-&gt;vm_page_prot = vm_get_page_prot(flags);</span><br><span class="line">	vma_link(mm, vma, prev, rb_link, rb_parent);</span><br><span class="line">out:</span><br><span class="line">	perf_event_mmap(vma);</span><br><span class="line">	mm-&gt;total_vm += len &gt;&gt; PAGE_SHIFT;</span><br><span class="line">	<span class="keyword">if</span> (flags &amp; VM_LOCKED)</span><br><span class="line">		mm-&gt;locked_vm += (len &gt;&gt; PAGE_SHIFT);</span><br><span class="line">	<span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mm_struct</code> 通过 <code>brk</code> 参数维护了堆的边界，<code>brk</code> 系统调用的作用就是对这个参数进行调整，从而让任务所能够使用的虚拟内存扩大。另一方面，这个 <code>brk</code> 的实现就等同于是 <code>mmap</code> 的一个压缩版，只是去掉了对文件等内容的直接映射罢了（mmap 的实现稍后呈现）。</p>
<h2 id="匿名地址空间映射"><a href="#匿名地址空间映射" class="headerlink" title="匿名地址空间映射"></a>匿名地址空间映射</h2><p><code>mmap</code> 一直被描述为一种直接内存映射文件的方式，区别于 <code>read</code>, <code>write</code> ，对它的核心定义就是高效。</p>
<p>通常来说，读写都涉及到至少 3 次内存间的数据拷贝。</p>
<ol>
<li>磁盘与内存缓冲区之间的数据拷贝</li>
<li>缓冲区与内核数据区之间的数据拷贝</li>
<li>内核数据区与用户数据区之间的数据拷贝</li>
</ol>
<p>内核暴露了两种 <code>mmap</code> 系统调用的接口，根据处理器架构的不同，做了不同的适配实现，一般来说都是一种实现委托另一种的形式。这里以 x86 为例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE1(old_mmap, struct mmap_arg_struct __user *, arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mmap_arg_struct</span> <span class="title">a</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(&amp;a, arg, <span class="keyword">sizeof</span>(a)))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    <span class="keyword">if</span> (a.offset &amp; ~PAGE_MASK)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 委托 mmap_pgoff 来实现</span></span><br><span class="line">    <span class="keyword">return</span> sys_mmap_pgoff(a.addr, a.len, a.prot, a.flags, a.fd,</span><br><span class="line">                  a.offset &gt;&gt; PAGE_SHIFT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE6(mmap_pgoff, <span class="keyword">unsigned</span> <span class="keyword">long</span>, addr, <span class="keyword">unsigned</span> <span class="keyword">long</span>, len,</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span>, prot, <span class="keyword">unsigned</span> <span class="keyword">long</span>, flags,</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span>, fd, <span class="keyword">unsigned</span> <span class="keyword">long</span>, pgoff)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> retval = -EBADF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; MAP_ANONYMOUS)) &#123;</span><br><span class="line">        <span class="comment">// 非匿名映射，意味着一定与文件做映射（这是广义上的文件）</span></span><br><span class="line">        <span class="comment">// ... some code omitted ...</span></span><br><span class="line">        file = fget(fd);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; MAP_HUGETLB) &#123;</span><br><span class="line">        <span class="comment">// 使用大内存页</span></span><br><span class="line">        <span class="comment">// ... some code omitted ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flags &amp;= ~(MAP_EXECUTABLE | MAP_DENYWRITE);</span><br><span class="line"></span><br><span class="line">    retval = vm_mmap_pgoff(file, addr, len, prot, flags, pgoff);</span><br><span class="line">    <span class="keyword">if</span> (file)</span><br><span class="line">        fput(file);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>vm_mmap_pgoff</code> 是一个 wrapper，来构建临界区代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">vm_mmap_pgoff</span><span class="params">(struct file *file, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">unsigned</span> <span class="keyword">long</span> prot,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flag, <span class="keyword">unsigned</span> <span class="keyword">long</span> pgoff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">current</span>-&gt;<span class="title">mm</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> populate;</span><br><span class="line"></span><br><span class="line">    ret = security_mmap_file(file, prot, flag);</span><br><span class="line">    <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">        down_write(&amp;mm-&gt;mmap_sem);</span><br><span class="line">        <span class="comment">// 临界区</span></span><br><span class="line">        ret = do_mmap_pgoff(file, addr, len, prot, flag, pgoff,</span><br><span class="line">                    &amp;populate);</span><br><span class="line">        up_write(&amp;mm-&gt;mmap_sem);</span><br><span class="line">        <span class="keyword">if</span> (populate)</span><br><span class="line">            mm_populate(ret, populate);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>do_mmap_pgoff</code> 基于 flags 进行了大量的检查工作，确保 mmap 得到可靠的映射结果。其核心的逻辑又是分别依赖于函数 <code>get_unmapped_area</code> 和 <code>mmap_region</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">do_mmap_pgoff</span><span class="params">(struct file *file, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">unsigned</span> <span class="keyword">long</span> prot,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">unsigned</span> <span class="keyword">long</span> flags, <span class="keyword">unsigned</span> <span class="keyword">long</span> pgoff,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">unsigned</span> <span class="keyword">long</span> *populate)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> * <span class="title">mm</span> = <span class="title">current</span>-&gt;<span class="title">mm</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">    <span class="keyword">vm_flags_t</span> vm_flags;</span><br><span class="line"></span><br><span class="line">    *populate = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; MAP_FIXED))</span><br><span class="line">        <span class="comment">// 低于 vm addr 硬下限，改成一个可用的最小地址</span></span><br><span class="line">        addr = round_hint_to_min(addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 地址对齐</span></span><br><span class="line">    len = PAGE_ALIGN(len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规避地址溢出的问题 </span></span><br><span class="line">    <span class="keyword">if</span> ((pgoff + (len &gt;&gt; PAGE_SHIFT)) &lt; pgoff)</span><br><span class="line">        <span class="keyword">return</span> -EOVERFLOW;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 达到系统参数 mmap 映射数上限?</span></span><br><span class="line">    <span class="keyword">if</span> (mm-&gt;map_count &gt; sysctl_max_map_count)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取一个未被映射的地址</span></span><br><span class="line">    addr = get_unmapped_area(file, addr, len, pgoff, flags);</span><br><span class="line">    <span class="comment">// 地址对齐</span></span><br><span class="line">    <span class="keyword">if</span> (addr &amp; ~PAGE_MASK)</span><br><span class="line">        <span class="keyword">return</span> addr;</span><br><span class="line"></span><br><span class="line">    vm_flags = calc_vm_prot_bits(prot) | calc_vm_flag_bits(flags) |</span><br><span class="line">            mm-&gt;def_flags | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MLOCK 相关操作，如果置位，可以保持映射的物理内存块不会被移出内存</span></span><br><span class="line"></span><br><span class="line">    inode = file ? file_inode(file) : <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (flags &amp; MAP_TYPE) &#123;</span><br><span class="line">        <span class="keyword">case</span> MAP_SHARED:    <span class="comment">// 共享标志，此时对文件内容的修改对其它任务可见</span></span><br><span class="line">            <span class="keyword">if</span> ((prot&amp;PROT_WRITE) &amp;&amp; !(file-&gt;f_mode&amp;FMODE_WRITE))</span><br><span class="line">                <span class="keyword">return</span> -EACCES;</span><br><span class="line">            <span class="keyword">if</span> (IS_APPEND(inode) &amp;&amp; (file-&gt;f_mode &amp; FMODE_WRITE))</span><br><span class="line">                <span class="keyword">return</span> -EACCES;</span><br><span class="line">            <span class="comment">// 确保此文件未被其它任务锁定</span></span><br><span class="line">            <span class="keyword">if</span> (locks_verify_locked(inode))</span><br><span class="line">                <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">            vm_flags |= VM_SHARED | VM_MAYSHARE;</span><br><span class="line">            <span class="keyword">if</span> (!(file-&gt;f_mode &amp; FMODE_WRITE))</span><br><span class="line">                vm_flags &amp;= ~(VM_MAYWRITE | VM_SHARED);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* fall through */</span></span><br><span class="line">        <span class="keyword">case</span> MAP_PRIVATE:</span><br><span class="line">            <span class="keyword">if</span> (!(file-&gt;f_mode &amp; FMODE_READ))</span><br><span class="line">                <span class="keyword">return</span> -EACCES;</span><br><span class="line">            <span class="keyword">if</span> (file-&gt;f_path.mnt-&gt;mnt_flags &amp; MNT_NOEXEC) &#123;</span><br><span class="line">                <span class="keyword">if</span> (vm_flags &amp; VM_EXEC)</span><br><span class="line">                    <span class="keyword">return</span> -EPERM;</span><br><span class="line">                vm_flags &amp;= ~VM_MAYEXEC;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!file-&gt;f_op || !file-&gt;f_op-&gt;mmap)</span><br><span class="line">                <span class="keyword">return</span> -ENODEV;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (flags &amp; MAP_TYPE) &#123;</span><br><span class="line">        <span class="keyword">case</span> MAP_SHARED:    <span class="comment">// 共享标志，此时对这段内存内容的修改对其它任务可见</span></span><br><span class="line">            <span class="comment">// 因此不能有偏移量</span></span><br><span class="line">            pgoff = <span class="number">0</span>;</span><br><span class="line">            vm_flags |= VM_SHARED | VM_MAYSHARE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MAP_PRIVATE:</span><br><span class="line">            pgoff = addr &gt;&gt; PAGE_SHIFT;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr = mmap_region(file, addr, len, vm_flags, pgoff);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>get_unmapped_area</code> 负责从虚拟地址空间中寻找一块合适的空间用于映射。根据是否指定 addr，是否做文件映射，分别又走向不同的逻辑分支。具体实现不再细数。函数的执行结果，就是得到可用的起始地址信息。</p>
<p><code>mmap_region</code> 做的是维护一个新的 vma 数据结构。根据实际场景，会涉及到释放冲突的 mmap 区域，合并直接衔接的 mmap 区块，更新映射文件的信息等。最终会将新的 vma 添加到 <code>mm_struct</code> 维护的红黑树及链表中。额外的，还有一些统计的工作，以及内存超卖等的策略实施。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">mmap_region</span><span class="params">(struct file *file, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">vm_flags_t</span> vm_flags, <span class="keyword">unsigned</span> <span class="keyword">long</span> pgoff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">current</span>-&gt;<span class="title">mm</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>, *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="keyword">int</span> correct_wcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">rb_link</span>, *<span class="title">rb_parent</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> charged = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =  <span class="title">file</span> ? <span class="title">file_inode</span>(<span class="title">file</span>) :</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    error = -ENOMEM;</span><br><span class="line">    <span class="comment">/* 如果新的 mmap 区域早已经被映射，则释放掉老的映射 */</span></span><br><span class="line">munmap_back:</span><br><span class="line">    <span class="keyword">if</span> (find_vma_links(mm, addr, addr + len, &amp;prev, &amp;rb_link, &amp;rb_parent)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (do_munmap(mm, addr, len))</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> munmap_back;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 确认物理内存是否足够用于支撑虚拟内存</span></span><br><span class="line"><span class="comment">     * 根据不同的 overcommit (内存超卖) 策略会有不同的结论。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (accountable_mapping(file, vm_flags)) &#123;</span><br><span class="line">        charged = len &gt;&gt; PAGE_SHIFT;</span><br><span class="line">        <span class="keyword">if</span> (security_vm_enough_memory_mm(mm, charged))</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        vm_flags |= VM_ACCOUNT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果新的映射区域能与老的映射区域相连，则合并两个映射区域*/</span></span><br><span class="line">    vma = vma_merge(mm, prev, addr, addr + len, vm_flags, <span class="literal">NULL</span>, file, pgoff, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (vma)    <span class="comment">// 如果能合并，则跳到 out 处</span></span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为 vma 结构申请一块内存</span></span><br><span class="line">    vma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!vma) &#123;</span><br><span class="line">        error = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> unacct_error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vma-&gt;vm_mm = mm;</span><br><span class="line">    vma-&gt;vm_start = addr;</span><br><span class="line">    vma-&gt;vm_end = addr + len;</span><br><span class="line">    vma-&gt;vm_flags = vm_flags;</span><br><span class="line">    vma-&gt;vm_page_prot = vm_get_page_prot(vm_flags);</span><br><span class="line">    vma-&gt;vm_pgoff = pgoff;</span><br><span class="line">    INIT_LIST_HEAD(&amp;vma-&gt;anon_vma_chain);</span><br><span class="line"></span><br><span class="line">    error = -EINVAL;    <span class="comment">/* when rejecting VM_GROWSDOWN|VM_GROWSUP */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果做文件映射，需要额外地维护文件的结构，声明其与一块 mmap 区域关联 */</span></span><br><span class="line">    <span class="keyword">if</span> (file) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vm_flags &amp; (VM_GROWSDOWN|VM_GROWSUP))</span><br><span class="line">            <span class="keyword">goto</span> free_vma;</span><br><span class="line">        <span class="keyword">if</span> (vm_flags &amp; VM_DENYWRITE) &#123;</span><br><span class="line">            error = deny_write_access(file);</span><br><span class="line">            <span class="keyword">if</span> (error)</span><br><span class="line">                <span class="keyword">goto</span> free_vma;</span><br><span class="line">            correct_wcount = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vma-&gt;vm_file = get_file(file);</span><br><span class="line">        error = file-&gt;f_op-&gt;mmap(file, vma);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> unmap_and_free_vma;</span><br><span class="line">        WARN_ON_ONCE(addr != vma-&gt;vm_start);</span><br><span class="line"></span><br><span class="line">        addr = vma-&gt;vm_start;</span><br><span class="line">        pgoff = vma-&gt;vm_pgoff;</span><br><span class="line">        vm_flags = vma-&gt;vm_flags;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vm_flags &amp; VM_SHARED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(vm_flags &amp; (VM_GROWSDOWN|VM_GROWSUP)))</span><br><span class="line">            <span class="keyword">goto</span> free_vma;</span><br><span class="line">        error = shmem_zero_setup(vma);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> free_vma;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新的 vma 结构维护到 mm 红黑树及链表上</span></span><br><span class="line">    vma_link(mm, vma, prev, rb_link, rb_parent);</span><br><span class="line">    file = vma-&gt;vm_file;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Once vma denies write, undo our temporary denial count */</span></span><br><span class="line">    <span class="keyword">if</span> (correct_wcount)</span><br><span class="line">        atomic_inc(&amp;inode-&gt;i_writecount);</span><br><span class="line">out:</span><br><span class="line">    perf_event_mmap(vma);</span><br><span class="line"></span><br><span class="line">    vm_stat_account(mm, vm_flags, file, len &gt;&gt; PAGE_SHIFT);</span><br><span class="line">    <span class="keyword">if</span> (vm_flags &amp; VM_LOCKED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!((vm_flags &amp; VM_SPECIAL) || is_vm_hugetlb_page(vma) ||</span><br><span class="line">                    vma == get_gate_vma(current-&gt;mm)))</span><br><span class="line">            mm-&gt;locked_vm += (len &gt;&gt; PAGE_SHIFT);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            vma-&gt;vm_flags &amp;= ~VM_LOCKED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file)</span><br><span class="line">        uprobe_mmap(vma);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此为止，基本上一个新的 mmap 区域的申请就完成了。不过，由于内核内存管理模块将缺页等操作提取并后置，这里都没有看到操作物理内存，只有逻辑上的为申请的虚拟内存划分区域，记录状态。不过，这恰恰也是内核高效的一个体现。如果申请虚拟内存直接跟物理内存挂钩，首先是两类内存逻辑上的耦合，其次是过度浪费（申请和使用通常是割裂的，再就是有时是申请了但不会进行使用），再次就是效率了。所以，很多时候写惯了 C 代码，用 malloc 大量申请内存，却看到系统的可用内存几乎没有变化，就是这个道理；另外 Java 堆的申请也类似于这种，如果申请了 2GB 的 Java 堆，一般来说从内核来看，是申请了 2 GB 大小的 anon mmap 区域，初始是不会与物理内存挂钩，等到 GC 发生时，会发现即使清理了垃圾，系统可用内存还是没有增加（这是 2GB 都处于 JVM 管理之下了，虽然从虚拟机看来已经清理出了内存，但系统并不会意识到这一点）</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>关于虚拟内存，还有相当多的内容等待揭开。比如文件映射中如何保证内存中的文件与磁盘中的文件的高效同步；不同策略下内存超卖的表现；缺页场景下虚拟内存与物理内存的映射…</p>
<p>浅尝，后续有时间再继续翻看。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="https://DorMOUSE-None.github.io">Utop</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="https://DorMOUSE-None.github.io/2019-07-17-understand-Kernel-13/">https://DorMOUSE-None.github.io/2019-07-17-understand-Kernel-13/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span>
      
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/Linux/">Linux</a>
            
              <a href="/tags/Kernel/">Kernel</a>
            
              <a href="/tags/vm/">vm</a>
            
              <a href="/tags/mmap/">mmap</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
    
      <a class="next" href="/2019-07-06-JNI_PROBLEM/">
        <span class="next-text nav-default">JNI 引发的堆外内存泄露</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:dormousenone@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/DorMOUSE-None" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    
    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2018 - 
    
    2019

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Utop</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  <script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'https://DorMOUSE-None.github.io/2019-07-17-understand-Kernel-13/';
        this.page.identifier = '2019-07-17-understand-Kernel-13/';
        this.page.title = '理解 Linux Kernel (13) - 虚拟内存';
    };
    (function() {
    var d = document, s = d.createElement('script');

    s.src = '//utop-blog.disqus.com/embed.js';

    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();  
  </script>

  

  



    
  



  
  





  
    <script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  

  
    <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.9.0"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->

  </body>
</html>
