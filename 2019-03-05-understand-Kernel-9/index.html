<!DOCTYPE html>
<html lang="zh-cn">
  <head><meta name="generator" content="Hexo 3.8.0">
    
<!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

<meta name="theme-color" content="#f8f5ec">
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="理解 Linux Kernel (9) - IO Multiplexing">




  <meta name="keywords" content="Linux, Kernel, IO Model, Utop's Blog">










  <link rel="alternate" href="/atom.xml" title="Utop's Blog">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.9.0">



<link rel="canonical" href="https://DorMOUSE-None.github.io/2019-03-05-understand-Kernel-9/">



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css">




  <link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css">



<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.9.0">


<link href="https://fonts.googleapis.com/css?family=Noto+Sans+SC" rel="stylesheet">


<link href="https://fonts.googleapis.com/css?family=Noto+Serif+SC:400,700" rel="stylesheet">


<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">



  


<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-92258941-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-92258941-1');
</script>


  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>





  <script src="//cdn1.lncld.net/static/js/3.1.1/av-min.js"></script>
  <script id="leancloud">
    AV.init({
      appId: "2IQmE2X540kOtTtNPDzsNh3e-9Nh9j0Va",
      appKey: "Vk01nlYJoGnfxJ4HCPUqW7p2"
    });
  </script>




<script>
  window.config = {"title":"Utop's Blog","subtitle":null,"description":null,"author":"Utop","language":"zh-cn","timezone":"Asia/Shanghai","url":"https://DorMOUSE-None.github.io","root":"/","permalink":":title/","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":true,"auto_detect":false,"line_number":true,"tab_replace":null,"first_line_number":"always1"},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":0,"pagination_dir":"page","theme":"even","deploy":{"type":"git","repo":"https://github.com/DorMOUSE-None/DorMOUSE-None.github.io.git","branch":"master","name":"DorMOUSE-None","email":"17816873960@163.com"},"ignore":[],"keywords":null,"index_generator":{"per_page":10,"order_by":"-date","path":""},"math":{"engine":"mathjax","mathjax":{"src":"//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML","config":{"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}}}},"archive_generator":{"per_page":0,"yearly":true,"monthly":true,"daily":false},"sitemap":{"path":"sitemap.xml"},"feed":{"type":"atom","limit":20,"hub":"","content":true,"content_limit":140,"content_limit_delim":"","path":"atom.xml"},"category_generator":{"per_page":0},"tag_generator":{"per_page":0},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true,"modifyAnchors":"","autolink":true},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true},"since":2018,"favicon":"/favicon.ico","rss":"default","menu":{"Home":"/","Archives":"/archives/","Tags":"/tags","About":"/about"},"color":"Default","toc":true,"fancybox":true,"pjax":true,"copyright":{"enable":true,"license":"<a rel=\"license\" href=\"http://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\">知识共享署名-非商业性使用 4.0 国际许可协议</a>"},"reward":{"enable":false,"qrCode":{"wechat":null,"alipay":null}},"social":{"email":"dormousenone@gmail.com","stack-overflow":null,"twitter":null,"facebook":null,"linkedin":null,"google":null,"github":"https://github.com/DorMOUSE-None","weibo":null,"zhihu":null,"douban":null,"pocket":null,"tumblr":null,"instagram":null},"leancloud":{"app_id":"2IQmE2X540kOtTtNPDzsNh3e-9Nh9j0Va","app_key":"Vk01nlYJoGnfxJ4HCPUqW7p2"},"baidu_analytics":null,"baidu_verification":null,"google_analytics":"UA-92258941-1","google_verification":null,"disqus_shortname":"utop-blog","changyan":{"appid":null,"appkey":null},"livere_datauid":null,"mathjax":{"enable":true,"per_page":false,"cdn":"//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"version":"2.9.0"};
</script>

    <title> 理解 Linux Kernel (9) - IO Multiplexing - Utop's Blog </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="mobile-header-logo">
    <a href="/." class="logo">Utop's Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            标签
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            关于
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Utop's Blog</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              标签
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          理解 Linux Kernel (9) - IO Multiplexing
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-03-05
        </span>
        
        
        <div class="post-visits" data-url="/2019-03-05-understand-Kernel-9/" data-title="理解 Linux Kernel (9) - IO Multiplexing">
            阅读次数 0
          </div>
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#SELECT"><span class="toc-text">SELECT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EPOLL"><span class="toc-text">EPOLL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll-create"><span class="toc-text">epoll_create</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll-ctl"><span class="toc-text">epoll_ctl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll-wait"><span class="toc-text">epoll_wait</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Extra"><span class="toc-text">Extra</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-text">参考</span></a></li></ol>
    </div>
  </div>



    <div class="post-content">
      
        <p><a href="./2019-01-15-understand-Kernel-8/">前一篇</a>已经对 Linux 内核网络相关的内容进行了基础性的介绍。数据从到达网卡，到最终被用户进程获取，最少经过了三个进程/硬中断的配合：网络中断负责将网络接收到的数据读取到内存并添加到 softnet_data 队列，并设置软中断通知内核进程 ksoftirqd；内核进程 ksoftirqd 被调度并处于运行状态，处理位于 softnet_data 中的 <code>struct sock</code> 对象，将其逐级从网络接口层逐级提升到网络层、传输层…最终添加到接收队列 <code>sk_receive_queue</code> 中；用户进程通过 <code>read</code>、<code>recv</code>、<code>recvfrom</code> 等命令检查并获取 <code>sk_receive_queue</code> 中的数据。</p>
<p>整个流程从概述上可以很轻松地配合进行网络数据交互，但如果要监控多个网络套接字呢？处理流程将变得复杂。我们无法预知哪个套接字能优先接收到数据。因此，最直接的办法就是轮询，在用户程序硬编码，通过设置超时时间的方式尝试获取数据。当然，这个效率就相当低下了。每次试探都需要触发系统调用（要知道这代价可是相当大的），另外超时时间的设置也是一个硬性的阻塞式消耗。</p>
<p>那么，有没有解决方案呢？当然有。通过用户程序硬编码式的轮询显然是陷入性能瓶颈的根源。因此内核主动提供了轮询式的系统调用（<code>select</code>, <code>poll</code>, <code>epoll</code>）。通过将轮询逻辑下沉到内核态，系统调用就只会有一次，而且超时时间的设置也显得统一。本篇就要就 <code>select</code> 和 <code>epoll</code> 两类系统调用的实现进行探究。</p>
<a id="more"></a>
<h2 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h2><p><code>select</code> 是一种比较古老的系统调用方式，存在着许多的调用限制。当然，相对的也就比较容易理解。</p>
<p><code>select</code> 系统调用最初的逻辑就是对超时时间的相关操作，完成从用户数据段到内核数据段的数据拷贝工作，而使用 <code>copy_from_user</code> 的目的，虽然看似比较晦涩，不如大家在用户程序中普通调用的memcpy，但究其原因，是为了处理MMU相关的问题。将内核复制的数据timeval做一定的取整操作（因为硬件中断的精度可能达不到timeval所描述的粒度，故根据HZ做取整，恰好为时钟中断周期的整数倍）。调用 <code>core_sys_select</code> 进行真正的轮询操作（当然，好像也算不上真正的逻辑，还有一层核心的调用呢）。结束后的操作当然是准备更新timeval。因为进行轮询的结果有两种，一种是因为超时而结束 <code>core_sys_select</code> 函数调用；另一种是得到了一个或多个准备就绪的数据，才结束调用并返回。显然，因为第二种结果而更新timeval有着一定的实际意义——到底等待了多久。不过这里需要注意的是，不是所有的Linux系统都支持对timeval做更新。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_select</span><span class="params">(<span class="keyword">int</span> n, fd_set __user *inp, fd_set __user *outp,</span></span></span><br><span class="line"><span class="function"><span class="params">			fd_set __user *<span class="built_in">exp</span>, struct timeval __user *tvp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	s64 timeout = <span class="number">-1</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果设置了超时时间 */</span></span><br><span class="line">	<span class="keyword">if</span> (tvp) &#123;</span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(&amp;tv, tvp, <span class="keyword">sizeof</span>(tv)))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 计时器不能设置为负数 */</span></span><br><span class="line">		<span class="keyword">if</span> (tv.tv_sec &lt; <span class="number">0</span> || tv.tv_usec &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Cast to u64 to make GCC stop complaining */</span></span><br><span class="line">        <span class="comment">/* 对 timeout 做一定的处理，根据时钟周期对 usec 进行取整 */</span></span><br><span class="line">		<span class="keyword">if</span> ((u64)tv.tv_sec &gt;= (u64)MAX_INT64_SECONDS)</span><br><span class="line">			timeout = <span class="number">-1</span>;	<span class="comment">/* 无限等待 */</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			timeout = DIV_ROUND_UP(tv.tv_usec, USEC_PER_SEC/HZ);</span><br><span class="line">			timeout += tv.tv_sec * HZ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 核心的 select 实现逻辑 */</span></span><br><span class="line">	ret = core_sys_select(n, inp, outp, <span class="built_in">exp</span>, &amp;timeout);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果设置了超时时间 */</span></span><br><span class="line">	<span class="keyword">if</span> (tvp) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">rtv</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (current-&gt;personality &amp; STICKY_TIMEOUTS)</span><br><span class="line">			<span class="keyword">goto</span> sticky;</span><br><span class="line">		rtv.tv_usec = jiffies_to_usecs(do_div((*(u64*)&amp;timeout), HZ));</span><br><span class="line">		rtv.tv_sec = timeout;</span><br><span class="line">		<span class="keyword">if</span> (timeval_compare(&amp;rtv, &amp;tv) &gt;= <span class="number">0</span>)</span><br><span class="line">			rtv = tv;</span><br><span class="line">        <span class="comment">/* 内核数据-&gt;用户数据的拷贝，更新距离超时剩余的时间间隔 */</span></span><br><span class="line">		<span class="keyword">if</span> (copy_to_user(tvp, &amp;rtv, <span class="keyword">sizeof</span>(rtv))) &#123;</span><br><span class="line">sticky:</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 如果应用程序把timeval放在只读内存中，内核就无需特别的更新它</span></span><br><span class="line"><span class="comment">			 * If an application puts its timeval in read-only</span></span><br><span class="line"><span class="comment">			 * memory, we don't want the Linux-specific update to</span></span><br><span class="line"><span class="comment">			 * the timeval to cause a fault after the select has</span></span><br><span class="line"><span class="comment">			 * completed successfully. However, because we're not</span></span><br><span class="line"><span class="comment">			 * updating the timeval, we can't restart the system</span></span><br><span class="line"><span class="comment">			 * call.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (ret == -ERESTARTNOHAND)</span><br><span class="line">				ret = -EINTR;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>core_sys_select</code> 也没有太多核心操作，完全是在为三个位图——输入、输出、错误从用户数据段到内核数据段的拷贝工作，以及在结束 <code>do_select</code> 调用后的反向拷贝操作。不过，无论是 <code>sys_select</code> 还是 <code>core_sys_select</code> 都将各自需要完成的工作分割得非常清晰，一个完成timeval的处理工作，另一个完成位图的处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 内核数据-位图的准备，调用do_select完成核心的逻辑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">core_sys_select</span><span class="params">(<span class="keyword">int</span> n, fd_set __user *inp, fd_set __user *outp,</span></span></span><br><span class="line"><span class="function"><span class="params">			   fd_set __user *<span class="built_in">exp</span>, s64 *timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fd_set_bits fds;</span><br><span class="line">	<span class="keyword">void</span> *bits;</span><br><span class="line">	<span class="keyword">int</span> ret, max_fds;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> size;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span>;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 在栈中定义较小的数组，减少堆内存的占用，同时可以更快；</span></span><br><span class="line"><span class="comment">     * SELECT_STACK_ALLOC = 256</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">long</span> stack_fds[SELECT_STACK_ALLOC/<span class="keyword">sizeof</span>(<span class="keyword">long</span>)];</span><br><span class="line"></span><br><span class="line">	ret = -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out_nofds;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* max_fds can increase, so grab it once to avoid race */</span></span><br><span class="line">    <span class="comment">/* max_fds 可能同时在增加，所以提前获取一份固定的拷贝避免竞争 */</span></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">    <span class="comment">/* 获取当前任务的文件描述符表 */</span></span><br><span class="line">	fdt = files_fdtable(current-&gt;files);</span><br><span class="line">	max_fds = fdt-&gt;max_fds;</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">if</span> (n &gt; max_fds)</span><br><span class="line">		n = max_fds;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We need 6 bitmaps (in/out/ex for both incoming and outgoing),</span></span><br><span class="line"><span class="comment">	 * since we used fdset we need to allocate memory in units of</span></span><br><span class="line"><span class="comment">	 * long-words.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	size = FDS_BYTES(n);</span><br><span class="line">	bits = stack_fds;</span><br><span class="line">	<span class="keyword">if</span> (size &gt; <span class="keyword">sizeof</span>(stack_fds) / <span class="number">6</span>) &#123;</span><br><span class="line">		<span class="comment">/* Not enough space in on-stack array; must use kmalloc */</span></span><br><span class="line">        <span class="comment">/* 栈数组大小不足；使用 kmalloc 获取新的空间 */</span></span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		bits = kmalloc(<span class="number">6</span> * size, GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!bits)</span><br><span class="line">			<span class="keyword">goto</span> out_nofds;</span><br><span class="line">	&#125;</span><br><span class="line">	fds.in      = bits;</span><br><span class="line">	fds.out     = bits +   size;</span><br><span class="line">	fds.ex      = bits + <span class="number">2</span>*size;</span><br><span class="line">	fds.res_in  = bits + <span class="number">3</span>*size;</span><br><span class="line">	fds.res_out = bits + <span class="number">4</span>*size;</span><br><span class="line">	fds.res_ex  = bits + <span class="number">5</span>*size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 用户数据段的数据 inp、outp、exp 往内核数据段 fds.xxx 拷贝 */</span></span><br><span class="line">	<span class="keyword">if</span> ((ret = get_fd_set(n, inp, fds.in)) ||</span><br><span class="line">	    (ret = get_fd_set(n, outp, fds.out)) ||</span><br><span class="line">	    (ret = get_fd_set(n, <span class="built_in">exp</span>, fds.ex)))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">    <span class="comment">/* fds.res_xxx 作为 do_select 的执行结果，预置为0，表示每一位相应的fd都未准备就绪 */</span></span><br><span class="line">	zero_fd_set(n, fds.res_in);</span><br><span class="line">	zero_fd_set(n, fds.res_out);</span><br><span class="line">	zero_fd_set(n, fds.res_ex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 交由 do_select 完成真正核心的操作 */</span></span><br><span class="line">	ret = do_select(n, &amp;fds, timeout);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	<span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">		ret = -ERESTARTNOHAND;</span><br><span class="line">		<span class="keyword">if</span> (signal_pending(current))</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		ret = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将结果集拷贝回用户数据段的 inp、outp、exp 中 */</span></span><br><span class="line">	<span class="keyword">if</span> (set_fd_set(n, inp, fds.res_in) ||</span><br><span class="line">	    set_fd_set(n, outp, fds.res_out) ||</span><br><span class="line">	    set_fd_set(n, <span class="built_in">exp</span>, fds.res_ex))</span><br><span class="line">		ret = -EFAULT;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (bits != stack_fds)</span><br><span class="line">		kfree(bits);</span><br><span class="line">out_nofds:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>终于是核心的逻辑了，逐一地将当前任务挂到相应文件的等待队列上，并等待调用 <code>poll</code> 函数被唤醒</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_select</span><span class="params">(<span class="keyword">int</span> n, fd_set_bits *fds, s64 *timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">poll_wqueues</span> <span class="title">table</span>;</span></span><br><span class="line">	poll_table *wait;</span><br><span class="line">	<span class="keyword">int</span> retval, i;</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">    <span class="comment">/* 确认fds.xxx所需轮询的fd全部全部处于打开状态，同时返回最大的fd */</span></span><br><span class="line">	retval = max_select_fd(n, fds);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	n = retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 把当前任务放入自己的等待队列中 */</span></span><br><span class="line">	poll_initwait(&amp;table);</span><br><span class="line">	wait = &amp;table.pt;</span><br><span class="line">    <span class="comment">/* 如果超时时间为0，即无需等待 */</span></span><br><span class="line">	<span class="keyword">if</span> (!*timeout)</span><br><span class="line">		wait = <span class="literal">NULL</span>;</span><br><span class="line">	retval = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 无限循环 */</span></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> *rinp, *routp, *rexp, *inp, *outp, *<span class="built_in">exp</span>;</span><br><span class="line">		<span class="keyword">long</span> __timeout;</span><br><span class="line"></span><br><span class="line">		set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line"></span><br><span class="line">		inp = fds-&gt;in; outp = fds-&gt;out; <span class="built_in">exp</span> = fds-&gt;ex;</span><br><span class="line">		rinp = fds-&gt;res_in; routp = fds-&gt;res_out; rexp = fds-&gt;res_ex;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++rinp, ++routp, ++rexp) &#123;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> in, out, ex, all_bits, bit = <span class="number">1</span>, mask, j;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> res_in = <span class="number">0</span>, res_out = <span class="number">0</span>, res_ex = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">f_op</span> = <span class="title">NULL</span>;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">			in = *inp++; out = *outp++; ex = *<span class="built_in">exp</span>++;</span><br><span class="line">			all_bits = in | out | ex;</span><br><span class="line">			<span class="keyword">if</span> (all_bits == <span class="number">0</span>) &#123;</span><br><span class="line">				i += __NFDBITS;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 对 unsigned long 的每一位进行确认 */</span></span><br><span class="line">			<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; __NFDBITS; ++j, ++i, bit &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">int</span> fput_needed;</span><br><span class="line">                <span class="comment">/* 超过需检测的最大的文件描述符 */</span></span><br><span class="line">				<span class="keyword">if</span> (i &gt;= n)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">/* 该 fd 无需检测，直接下一个 */</span></span><br><span class="line">				<span class="keyword">if</span> (!(bit &amp; all_bits))</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">/* 获取相应的文件实例 */</span></span><br><span class="line">				file = fget_light(i, &amp;fput_needed);</span><br><span class="line">				<span class="keyword">if</span> (file) &#123;</span><br><span class="line">					f_op = file-&gt;f_op;</span><br><span class="line">					mask = DEFAULT_POLLMASK;</span><br><span class="line">                    <span class="comment">/* 对于套接字，调用的是sock_poll，在poll成功时将唤醒wait队列的任务（即把当前任务唤醒）*/</span></span><br><span class="line">					<span class="keyword">if</span> (f_op &amp;&amp; f_op-&gt;poll)</span><br><span class="line">						mask = (*f_op-&gt;poll)(file, retval ? <span class="literal">NULL</span> : wait);</span><br><span class="line">					fput_light(file, fput_needed);</span><br><span class="line">					<span class="keyword">if</span> ((mask &amp; POLLIN_SET) &amp;&amp; (in &amp; bit)) &#123;</span><br><span class="line">						res_in |= bit;</span><br><span class="line">						retval++;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> ((mask &amp; POLLOUT_SET) &amp;&amp; (out &amp; bit)) &#123;</span><br><span class="line">						res_out |= bit;</span><br><span class="line">						retval++;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> ((mask &amp; POLLEX_SET) &amp;&amp; (ex &amp; bit)) &#123;</span><br><span class="line">						res_ex |= bit;</span><br><span class="line">						retval++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">                <span class="comment">/* 主动让出CPU片，等待重新调度（提前设置了最高优先级PREEMPT_ACTIVE）*/</span></span><br><span class="line">				cond_resched();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (res_in)</span><br><span class="line">				*rinp = res_in;</span><br><span class="line">			<span class="keyword">if</span> (res_out)</span><br><span class="line">				*routp = res_out;</span><br><span class="line">			<span class="keyword">if</span> (res_ex)</span><br><span class="line">				*rexp = res_ex;</span><br><span class="line">		&#125;</span><br><span class="line">		wait = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">if</span> (retval || !*timeout || signal_pending(current))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span>(table.error) &#123;</span><br><span class="line">			retval = table.error;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (*timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">/* Wait indefinitely */</span></span><br><span class="line">			__timeout = MAX_SCHEDULE_TIMEOUT;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlikely(*timeout &gt;= (s64)MAX_SCHEDULE_TIMEOUT - <span class="number">1</span>)) &#123;</span><br><span class="line">			<span class="comment">/* Wait for longer than MAX_SCHEDULE_TIMEOUT. Do it in a loop */</span></span><br><span class="line">			__timeout = MAX_SCHEDULE_TIMEOUT - <span class="number">1</span>;</span><br><span class="line">			*timeout -= __timeout;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			__timeout = *timeout;</span><br><span class="line">			*timeout = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">/* 进入延时唤醒状态，待定预定的超时时间 */</span></span><br><span class="line">		__timeout = schedule_timeout(__timeout);</span><br><span class="line">		<span class="keyword">if</span> (*timeout &gt;= <span class="number">0</span>)</span><br><span class="line">			*timeout += __timeout;</span><br><span class="line">	&#125;</span><br><span class="line">	__set_current_state(TASK_RUNNING);</span><br><span class="line"></span><br><span class="line">	poll_freewait(&amp;table);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结来看，<code>select</code> 完全能够支持IO多路复用。至少比用户程序自行实现轮询优秀得多。但是，也存在着一些明显的缺陷：</p>
<ol>
<li>支持的文件描述符存在上限，默认是1024。</li>
<li>每次陷入内核态 <code>select</code> 函数之后，都需要按位遍历所有的文件描述符（无论该fd是否存在），max(fd)越大，开销越大。</li>
<li>每次调用 <code>select</code> 都需要将fd集合从用户态复制到内核态，max(fd)越大，开销越大。</li>
</ol>
<h2 id="EPOLL"><a href="#EPOLL" class="headerlink" title="EPOLL"></a>EPOLL</h2><p>简单地描述过 <code>select</code> 系统调用之后，我们着重来聊一聊 <code>epoll</code> 的实现。毕竟 <code>select</code> 和 <code>poll</code> 的复杂度是 $O(N)$，而 <code>epoll</code> 只是 $O(\log{N})$ （当然，这里对时间复杂度的比较维度不同，稍候细讲）。<code>epoll</code> 区别于传统I/O复用模型的最大特色在于：它将创建并维护一个 <code>eventpoll</code> 实例，并通过注册请 <code>epoll</code> 对新的文件描述符进行监听，这意味着数据从用户数据区到内核数据区的拷贝只有一次；相对的，传统方式在每次轮询时，都需要全量地将数据从用户数据区拷贝到内核数据区。 </p>
<h3 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a><code>epoll_create</code></h3><p><code>epoll_create</code> 负责创建一个新的 <code>eventpoll</code> 实例。这里的size并没有实际意义（由于历史原因而存在），传入的参数将被忽略。看源码总是件有意思的事，这个size被描述成了检查精神健全的标志…</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> error, fd = <span class="number">-1</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line"></span><br><span class="line">	DNPRINTK(<span class="number">3</span>, (KERN_INFO <span class="string">"[%p] eventpoll: sys_epoll_create(%d)\n"</span>,</span><br><span class="line">		     current, size));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 精神健全检测(size)；同时建立内部数据结构 struct eventpoll</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	error = -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;= <span class="number">0</span> || (error = ep_alloc(&amp;ep)) != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> error_return;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 创建一个新的文件描述符，文件数据结构和i节点</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	error = anon_inode_getfd(&amp;fd, &amp;inode, &amp;file, <span class="string">"[eventpoll]"</span>,</span><br><span class="line">				 &amp;eventpoll_fops, ep);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> error_free;</span><br><span class="line"></span><br><span class="line">	DNPRINTK(<span class="number">3</span>, (KERN_INFO <span class="string">"[%p] eventpoll: sys_epoll_create(%d) = %d\n"</span>,</span><br><span class="line">		     current, size, fd));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> fd;</span><br><span class="line"></span><br><span class="line">error_free:</span><br><span class="line">	ep_free(ep);</span><br><span class="line">error_return:</span><br><span class="line">	DNPRINTK(<span class="number">3</span>, (KERN_INFO <span class="string">"[%p] eventpoll: sys_epoll_create(%d) = %d\n"</span>,</span><br><span class="line">		     current, size, error));</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g0qi7lrtgzj31eu0u075i.jpg" alt="Epoll Create | Model"></p>
<h3 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a><code>epoll_ctl</code></h3><p><code>epoll_ctl</code> 顾名思义——<code>epoll</code>控制器，用于增加、修改、删除监听的事件。这里 <code>epfd</code> 用于找到 <code>eventpoll</code> 实例，<code>fd</code> 表示需要监听的文件描述符，<code>op</code> 区分增删改，<code>event</code> 表示监听的具体事件描述。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd,</span></span></span><br><span class="line"><span class="function"><span class="params">			      struct epoll_event __user *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>, *<span class="title">tfile</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epds</span>;</span></span><br><span class="line"></span><br><span class="line">	DNPRINTK(<span class="number">3</span>, (KERN_INFO <span class="string">"[%p] eventpoll: sys_epoll_ctl(%d, %d, %d, %p)\n"</span>,</span><br><span class="line">		     current, epfd, op, fd, event));</span><br><span class="line"></span><br><span class="line">	error = -EFAULT;</span><br><span class="line">    <span class="comment">/* 如果是增改操作，需要把事件描述拷贝到内核数据区; 删除操作不需要 */</span></span><br><span class="line">	<span class="keyword">if</span> (ep_op_has_event(op) &amp;&amp;</span><br><span class="line">	    copy_from_user(&amp;epds, event, <span class="keyword">sizeof</span>(struct epoll_event)))</span><br><span class="line">		<span class="keyword">goto</span> error_return;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Get the "struct file *" for the eventpoll file */</span></span><br><span class="line">	error = -EBADF;</span><br><span class="line">	file = fget(epfd);</span><br><span class="line">	<span class="keyword">if</span> (!file)</span><br><span class="line">		<span class="keyword">goto</span> error_return;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Get the "struct file *" for the target file */</span></span><br><span class="line">	tfile = fget(fd);</span><br><span class="line">	<span class="keyword">if</span> (!tfile)</span><br><span class="line">		<span class="keyword">goto</span> error_fput;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 需要监听的文件描述符必须支持文件操作 poll */</span></span><br><span class="line">	error = -EPERM;</span><br><span class="line">	<span class="keyword">if</span> (!tfile-&gt;f_op || !tfile-&gt;f_op-&gt;poll)</span><br><span class="line">		<span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 需要确保不能把epfd作为被监听的fd加入 */</span></span><br><span class="line">	error = -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (file == tfile || !is_file_epoll(file))</span><br><span class="line">		<span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 这里的文件描述符一定是指eventpoll实例对应的文件描述符</span></span><br><span class="line"><span class="comment">     * 因此直接从中拿私有数据--预定义的*eventpoll</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	ep = file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;ep-&gt;mtx);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 从RB树中查找已经维护起来的监听事件</span></span><br><span class="line"><span class="comment">     * 当然，必须先把这个RB树结构锁定，防止查找时结构改变</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	epi = ep_find(ep, tfile, fd);</span><br><span class="line"></span><br><span class="line">	error = -EINVAL;</span><br><span class="line">	<span class="keyword">switch</span> (op) &#123;</span><br><span class="line">	<span class="keyword">case</span> EPOLL_CTL_ADD:     <span class="comment">// 新增监听</span></span><br><span class="line">		<span class="keyword">if</span> (!epi) &#123;</span><br><span class="line">			epds.events |= POLLERR | POLLHUP;</span><br><span class="line"></span><br><span class="line">			error = ep_insert(ep, &amp;epds, tfile, fd);</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			error = -EEXIST;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> EPOLL_CTL_DEL:     <span class="comment">// 删除监听</span></span><br><span class="line">		<span class="keyword">if</span> (epi)</span><br><span class="line">			error = ep_remove(ep, epi);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			error = -ENOENT;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> EPOLL_CTL_MOD:     <span class="comment">// 修改监听</span></span><br><span class="line">		<span class="keyword">if</span> (epi) &#123;</span><br><span class="line">			epds.events |= POLLERR | POLLHUP;</span><br><span class="line">			error = ep_modify(ep, epi, &amp;epds);</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			error = -ENOENT;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	mutex_unlock(&amp;ep-&gt;mtx);</span><br><span class="line"></span><br><span class="line">error_tgt_fput:</span><br><span class="line">	fput(tfile);</span><br><span class="line">error_fput:</span><br><span class="line">	fput(file);</span><br><span class="line">error_return:</span><br><span class="line">	DNPRINTK(<span class="number">3</span>, (KERN_INFO <span class="string">"[%p] eventpoll: sys_epoll_ctl(%d, %d, %d, %p) = %d\n"</span>,</span><br><span class="line">		     current, epfd, op, fd, event, error));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的核心操作，就是往 <code>eventpoll</code> 实例中增删改监听的事件。以 <code>ep_insert</code> 为例，先看看怎么新增监听。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 实例化 epitem */</span></span><br><span class="line"><span class="keyword">if</span> (!(epi = kmem_cache_alloc(epi_cache, GFP_KERNEL)))</span><br><span class="line">    <span class="keyword">goto</span> error_return;</span><br><span class="line"><span class="comment">/* 对 epitem 实例进行初始化数据 */</span></span><br><span class="line">ep_rb_initnode(&amp;epi-&gt;rbn);</span><br><span class="line">INIT_LIST_HEAD(&amp;epi-&gt;rdllink);</span><br><span class="line">INIT_LIST_HEAD(&amp;epi-&gt;fllink);</span><br><span class="line">INIT_LIST_HEAD(&amp;epi-&gt;pwqlist);</span><br><span class="line">epi-&gt;ep = ep;</span><br><span class="line"><span class="comment">/* 构建struct epoll_filefd，作为rb_tree比较不同的key */</span></span><br><span class="line">ep_set_ffd(&amp;epi-&gt;ffd, tfile, fd);</span><br><span class="line">epi-&gt;event = *event;</span><br><span class="line">epi-&gt;nwait = <span class="number">0</span>;</span><br><span class="line">epi-&gt;next = EP_UNACTIVE_PTR;</span><br></pre></td></tr></table></figure>
<p>接下来要接触的就是一段比较烧脑的逻辑。</p>
<p><code>poll_table</code> 是在 VFS 实现中相当重要的一个数据结构，用来与<code>poll</code>配合（这里的<code>poll</code>是指文件操作中的，而不是<code>poll()</code>系统调用）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_struct</span> &#123;</span></span><br><span class="line">	poll_queue_proc _qproc;</span><br><span class="line">&#125; poll_table;</span><br></pre></td></tr></table></figure>
<p>其中<code>poll_queue_proc</code>是一个函数指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*poll_queue_proc)</span><span class="params">(struct file *, <span class="keyword">wait_queue_head_t</span> *, struct poll_table_struct *)</span></span>;</span><br></pre></td></tr></table></figure>
<p>为了让 <code>epitem</code> 更方便地追踪 <code>poll_queue_proc</code>，<code>epoll_ctl</code> 中使用了一个 <code>ep_pqueue</code> 的数据结构来包装 <code>poll_table</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 使用 queue 回调函数初始化 poll table */</span></span><br><span class="line">epq.epi = epi;</span><br><span class="line">init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);</span><br></pre></td></tr></table></figure>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g0qwphhnz0j30xa0o6aan.jpg" alt=""></p>
<p>之后就是把这个 <code>poll_table</code> 作为钩子方法挂载到被监控的文件上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">revents = tfile-&gt;f_op-&gt;poll(tfile, &amp;epq.pt);</span><br></pre></td></tr></table></figure>
<p>这里以 <code>tcp_poll</code> 为例，先看看这段逻辑怎么实现的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sock_poll</span><span class="params">(struct file *file, poll_table *wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">    <span class="comment">/* 获取 struct sock 内核套接字数据结构 */</span></span><br><span class="line">    sock = file-&gt;private_data;</span><br><span class="line">    <span class="keyword">return</span> sock-&gt;ops-&gt;poll(file, sock, wait);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">tcp_poll</span><span class="params">(struct file *file, struct socket *sock, poll_table *wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> mask;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = <span class="title">sock</span>-&gt;<span class="title">sk</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> = <span class="title">tcp_sk</span>(<span class="title">sk</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这里将调用 poll_table *wait 维护的回调函数</span></span><br><span class="line"><span class="comment">     * 将持有 eventpoll 实例的进程注册到 sk 的等待队列中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	poll_wait(file, sk-&gt;sk_sleep, wait);</span><br><span class="line">	<span class="keyword">if</span> (sk-&gt;sk_state == TCP_LISTEN)</span><br><span class="line">		<span class="keyword">return</span> inet_csk_listen_poll(sk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这里省略了部分逻辑，主要是负责处理 struct sock 接收到的事件</span></span><br><span class="line"><span class="comment">     * 处理成 mask 并返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">poll_wait</span><span class="params">(struct file * filp, <span class="keyword">wait_queue_head_t</span> * wait_address, poll_table *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &amp;&amp; wait_address)</span><br><span class="line">        p-&gt;qproc(filp, wait_address, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看看epoll定义的回调函数的实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ep_ptable_queue_proc</span><span class="params">(struct file *file, <span class="keyword">wait_queue_head_t</span> *whead,</span></span></span><br><span class="line"><span class="function"><span class="params">				 poll_table *pt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span> = <span class="title">ep_item_from_epqueue</span>(<span class="title">pt</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">eppoll_entry</span> *<span class="title">pwq</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (epi-&gt;nwait &gt;= <span class="number">0</span> &amp;&amp; (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) &#123;</span><br><span class="line">		init_waitqueue_func_entry(&amp;pwq-&gt;wait, ep_poll_callback);</span><br><span class="line">		pwq-&gt;whead = whead;</span><br><span class="line">		pwq-&gt;base = epi;</span><br><span class="line">        <span class="comment">/* 添加到 struct sock 等待队列队首 */</span></span><br><span class="line">		add_wait_queue(whead, &amp;pwq-&gt;wait);</span><br><span class="line">		list_add_tail(&amp;pwq-&gt;llink, &amp;epi-&gt;pwqlist);</span><br><span class="line">		epi-&gt;nwait++;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* We have to signal that an error occurred */</span></span><br><span class="line">		epi-&gt;nwait = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此为止，<code>ep_insert</code> 核心的逻辑已经介绍完毕。主要就是将当前的 <code>eventpoll</code> 实例注册到监听目标（文件描述符）的等待队列上，并注册<code>ep_poll_callback</code>作为回调函数。回调函数实现是怎样呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_poll_callback</span><span class="params">(<span class="keyword">wait_queue_t</span> *wait, <span class="keyword">unsigned</span> mode, <span class="keyword">int</span> sync, <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pwake = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="comment">/* 获取 wait 结构维护的 epitem 实例 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span> = <span class="title">ep_item_from_wait</span>(<span class="title">wait</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span> = <span class="title">epi</span>-&gt;<span class="title">ep</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... code omitted...</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 把当前的 epitem 实例添加到 eventpoll 实例的就绪队列中 </span></span><br><span class="line"><span class="comment">     * 这是显然的，毕竟此回调函数只有在fd准备就绪后被回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line"></span><br><span class="line">is_linked:</span><br><span class="line">    <span class="comment">/* 如果 wait 结构维护的进程处于Sleeping状态，则将其唤醒并加入任务就绪队列 */</span></span><br><span class="line">	<span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">		__wake_up_locked(&amp;ep-&gt;wq, TASK_UNINTERRUPTIBLE |</span><br><span class="line">				 TASK_INTERRUPTIBLE);</span><br><span class="line">	<span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">		pwake++;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">	spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We have to call this outside the lock */</span></span><br><span class="line">	<span class="keyword">if</span> (pwake)</span><br><span class="line">		ep_poll_safewake(&amp;psw, &amp;ep-&gt;poll_wait);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a><code>epoll_wait</code></h3><p>处理完所有的监听事件的维护，用户程序需要通过 <code>epoll_wait</code> 与 <code>eventpoll</code> 实例进行交互，并被告知所有正在监听中的事件是否发生。由于 <code>epoll_wait</code> 的整个逻辑基本上都是在进行错误检测，此处不表。我们只关注其中的核心逻辑，即调用的 <code>ep_poll</code> 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ep_poll</span><span class="params">(struct eventpoll *ep, struct epoll_event __user *events,</span></span></span><br><span class="line"><span class="function"><span class="params">		   <span class="keyword">int</span> maxevents, <span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res, eavail;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="keyword">long</span> jtimeout;</span><br><span class="line">	<span class="keyword">wait_queue_t</span> wait;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Calculate the timeout by checking for the "infinite" value ( -1 )</span></span><br><span class="line"><span class="comment">	 * and the overflow condition. The passed timeout is in milliseconds,</span></span><br><span class="line"><span class="comment">	 * that why (t * HZ) / 1000.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	jtimeout = (timeout &lt; <span class="number">0</span> || timeout &gt;= EP_MAX_MSTIMEO) ?</span><br><span class="line">		MAX_SCHEDULE_TIMEOUT : (timeout * HZ + <span class="number">999</span>) / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">	spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">	res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 如果 eventpoll 实例的就绪队列为空，表明有没任何监听的事件发生。</span></span><br><span class="line"><span class="comment">     * 主动让进程陷入Sleeping状态，知道被 ep_poll_callback() 唤醒</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (list_empty(&amp;ep-&gt;rdllist)) &#123;</span><br><span class="line">		init_waitqueue_entry(&amp;wait, current);</span><br><span class="line">		wait.flags |= WQ_FLAG_EXCLUSIVE;</span><br><span class="line">		__add_wait_queue(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * We don't want to sleep if the ep_poll_callback() sends us</span></span><br><span class="line"><span class="comment">			 * a wakeup in between. That's why we set the task state</span></span><br><span class="line"><span class="comment">			 * to TASK_INTERRUPTIBLE before doing the checks.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">			<span class="keyword">if</span> (!list_empty(&amp;ep-&gt;rdllist) || !jtimeout)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">				res = -EINTR;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line">            <span class="comment">/* 主动陷入Sleeping状态 */</span></span><br><span class="line">			jtimeout = schedule_timeout(jtimeout);</span><br><span class="line">			spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">		&#125;</span><br><span class="line">		__remove_wait_queue(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line"></span><br><span class="line">		set_current_state(TASK_RUNNING);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Is it worth to try to dig for events ? */</span></span><br><span class="line">	eavail = !list_empty(&amp;ep-&gt;rdllist);</span><br><span class="line"></span><br><span class="line">	spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 将监听到的事件拷贝到用户空间。如果没有事件就绪且还没超时，就再抱着</span></span><br><span class="line"><span class="comment">     * 希望试一次。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!res &amp;&amp; eavail &amp;&amp;</span><br><span class="line">	    !(res = ep_send_events(ep, events, maxevents)) &amp;&amp; jtimeout)</span><br><span class="line">		<span class="keyword">goto</span> retry;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>这部分的数据结构配合着一些胶水代码比较难以理解，最好配合着类图看看（个人使用，不一定适合各位）</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1g0rmx65dzhj324y0t8di4.jpg" alt=""></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>Linux Kernel 2.6.24</li>
<li><a href="https://idndx.com/2014/09/01/the-implementation-of-epoll-1/" target="_blank" rel="noopener">The Implementation of epoll(1)</a></li>
<li><a href="https://idndx.com/2014/09/02/the-implementation-of-epoll-2/" target="_blank" rel="noopener">The Implementation of epoll(2)</a></li>
<li><a href="https://idndx.com/2014/09/22/the-implementation-of-epoll-3/" target="_blank" rel="noopener">The Implementation of epoll(3)</a></li>
<li><a href="https://idndx.com/2015/07/08/the-implementation-of-epoll-4/" target="_blank" rel="noopener">The Implementation of epoll(4)</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>
</li>
</ol>

      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="https://DorMOUSE-None.github.io">Utop</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="https://DorMOUSE-None.github.io/2019-03-05-understand-Kernel-9/">https://DorMOUSE-None.github.io/2019-03-05-understand-Kernel-9/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span>
      
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/Linux/">Linux</a>
            
              <a href="/tags/Kernel/">Kernel</a>
            
              <a href="/tags/IO-Model/">IO Model</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2019-03-19-JANUS/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">认证与授权·简述</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2019-02-27-Java-Fatal-API/">
        <span class="next-text nav-default">【Java】API 参数误定义的后果</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:dormousenone@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/DorMOUSE-None" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    
    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2018 - 
    
    2019

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Utop</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  <script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'https://DorMOUSE-None.github.io/2019-03-05-understand-Kernel-9/';
        this.page.identifier = '2019-03-05-understand-Kernel-9/';
        this.page.title = '理解 Linux Kernel (9) - IO Multiplexing';
    };
    (function() {
    var d = document, s = d.createElement('script');

    s.src = '//utop-blog.disqus.com/embed.js';

    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();  
  </script>

  

  



    
  



  
  





  
    <script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  

  
    <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.9.0"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->

  </body>
</html>
